' $Id: TuningDialogs.s2s,v 1.35 2016-05-15 21:04:07 devel Exp $
'
' This file contains dialog functions for the alert tuning script Tuning.s2s.
#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "UsreyGratings.s2s"
#include "UsreyDAQ.s2s"


const tunTypeNone$ := "None";
const tunTypeOrientation$ := "O";
const tunTypeContrast$ := "C";
const tunTypeSpatial$ := "S";
const tunTypeTemporal$ := "T";
const tunTypeArea$ := "A";
const tunTypeDonut$ := "H";  '(H)ole in stimulus
const tunTypeBerliner$ := "B";
const tunTypeBoxODonuts$ := "G";  '(G)rid of stimuli
const tunTypeXPos$ := "X";
const tunTypeXYPos$ := "Z";
const tunTypeDots$ := "D";
const tunTypeDisparity$ := "DX";
const tunTypeCRG$ := "R";
const tunTypeBlank$ := "BLANK";
const tunTypeGratingOnly$ := "GO";
const tunTypeDanish$ := "DN";
const tunTypeDSS$ := "DSS";
const tunTypeNullTest$ := "NULL";
const tunTypeLag$ := "LAG";
var tunType$:=tunTypeNone$;
var tunType1$:=tunTypeNone$;  'for first of two tuning curves, if Box O' Donuts, or for non-CRG curve in CRG scenarios
var tunType2$:=tunTypeNone$;  'for second of two tuning curves, if Box O' Donuts
var tunDualTuningType%;  'Determines whether, on dual tuning, both (0), Master (1), or Slave (2) screen varies.
var tunUseFile%;        ' Overall variables so we don't have to check 7 different ones in the main file.
var tunTuningFile$;     ' Location of tuning file
var tunUseFile1%;        ' for first of two tuning curves, if Box o' Donuts
var tunTuningFile1$;
var tunUseFile2%;        ' for second of two tuning curves, if Box o' Donuts
var tunTuningFile2$;

const tunContextDAQ$ := "DAQ";
const tunContextConfig$ := "Config";
var tunContext$ := tunContextConfig$;

const tundlgXHairButton% := 8;
const tundlgOrientationButton% := 9;
const tundlgContrastButton% := 10;
const tundlgSpatialButton% := 11;
const tundlgTemporalButton% := 12;
const tundlgAreaButton% := 13;
const tundlgDonutButton% := 14;
const tundlgBerlinerButton% := 15;
const tundlgBoxODonutsButton% := 16;
const tundlgXPosButton% := 17;
const tundlgDotsButton% := 18;
const tundlgDisparityButton% := 19;
const tundlgCRGButton% := 20;
const tundlgSelectSEQFileButton% := 21;
const tundlgBlankButton% := 22;
const tundlgGratingOnlyButton% := 23;
const tundlgCRG2Button% := 24;  'This is for CRG on SECOND screen
const tundlgDanishButton% := 25;
const tundlgDSSButton% := 26;
const tundlgNullTestANDLagButton% := 27;
const tundlgSelectTuningFileButton% := 28;
const tundlgLagButton% := 29;
const tundlgOptogeneticsButton% := 30;

' A note about "steps". 
' The dialogs ask for a number of "steps". A step is a transition from one stimulus
' to another. Thus, if there are N steps, there are N+1 different stimuli.

' These are specific to the individual tuning curve types - orientation first
var tunOriNSteps%;		' # steps in orientation tuning curve
var tunOriNRepeats%;		' # repeats in ori tuning curve
var tunOriMinOrientation;	' min orientation
var tunOriMaxOrientation;	' max orientation
var tunOriProgression%;
var tunOriUseFile%;
var tunOriTuningFile$;

' Contrast next
var tunContrastNSteps%;			' # steps in contrast tuning curve
var tunContrastNRepeats%;		' # repeats in contrast tuning curve
var tunContrastMinContrast;		' min contrast
var tunContrastMaxContrast;		' max contrast
var tunContrastProgression%;
var tunContrastUseFile%;
var tunContrastTuningFile$;

' Spatial next
var tunSpatialNSteps%;			' # steps in spatial freq tuning curve
var tunSpatialNRepeats%;		' # repeats in spatial freq tuning curve
var tunSpatialMinSF;			' min SF
var tunSpatialMaxSF;			' max SF
var tunSpatialProgression%;
var tunSpatialUseFile%;
var tunSpatialTuningFile$;

' Temporal next
var tunTemporalNSteps%;			' # steps in temporal tuning curve
var tunTemporalNRepeats%;		' # repeats in temporal tuning curve
var tunTemporalMinTF;		' min TF
var tunTemporalMaxTF;		' max TF
var tunTemporalProgression%;
var tunTemporalUseFile%;
var tunTemporalTuningFile$;

' Area next
var tunAreaNSteps%;			' # steps in area tuning curve
var tunAreaNRepeats%;		' # repeats in area tuning curve
var tunAreaMinDiam;		' min diameter
var tunAreaMaxDiam;		' max diameter
var tunAreaProgression%;
var tunAreaUseFile%;
var tunAreaTuningFile$;

' X/XY Position next
var tunXPosNSteps%;			' # steps in X position tuning curve
var tunXPosNRepeats%;		' # repeats in X position tuning curve
var tunXPosMinXPos;		' min position
var tunXPosMaxXPos;		' max position
var tunXPosProgression%;
var tunXYPosNXSteps%;			' # steps in X position tuning curve
var tunXYPosNRepeats%;		' # repeats in X position tuning curve
var tunXYPosMinXPos;		' min position
var tunXYPosMaxXPos;		' max position
var tunXYPosProgression%;
var tunXYPosNYSteps%;			' # steps in Y position tuning curve
var tunXYPosMinYPos;		' min position
var tunXYPosMaxYPos;		' max position


' Donuts - use same vars as area. There is one additional var - the optimal value index.
var tunDonutOptimalIndex%:=0;		' step index where area stim stops growing and donut stim starts
var tunDonutOptimalDiam;
var tunDonutProgression%;
var tunDonutCoreOnSlave% := 0;

' Berliners - also use same variables as Area.  Use optimal value index from Donuts.  Add maximal value index
var tunDonutOptimalDiamPlusOne;
var tunBerlinerMaximalIndex%:=0;    ' index for "maximal" size
var tunBerlinerMaximalDiam;
var tunBerlinerNSteps%;
var tunBerlinerNRepeats% := 3;  'just putting in 3 repeats for now
var tunBerlinerProgression%;
var tunBerlinerCoreOnSlave% := 0;

' Box O' Donuts
'var tunUseHoleKluge%;               'will be set by tuning dialogs if we are putting a hole in the stimulus
var tunBoxODonutsCurrentCurve%:=0;  'note, will be 0 unless BoxODonuts is selected on the dialog
var tunCurve1Text$;                 'For the nifty boxes telling us what's been done!
var tunCurve2Text$;
var updateCurve1Text%;              'These is just a pointer that allows us to change the tunCurve1Text$ value on the fly
var updateCurve2Text%;
var tunCurve1SelectedType$;         'This prevents us from doubling up
var tunBoxODonutsProgression%;
var tunBoxODonutsNRepeats%;
var tunMasterFollowsCurve1%;


' Dots - this is a bit different - it's an orientation tuning curve, 
' but the other parameters aren't quite general grating parameters, so do them here, too
var tunDotsNSteps%;		' # steps in orientation tuning curve
var tunDotsNRepeats%;		' # repeats in ori tuning curve
var tunDotsMinOrientation;	' min orientation
var tunDotsMaxOrientation;	' max orientation
var tunDotsProgression%;
var tunDotsX;               ' X position, deg
var tunDotsY;               ' Y position, deg
var tunDotsDiameter;        ' deg
var tunDotsSpeed;           ' deg/sec
var tunDotsDensity;         ' dots/deg^2
var tunDotsSize%;           ' pixels
var tunDotsBGR%;            ' Background color, red level
var tunDotsBGG%;            ' Background color, green level
var tunDotsBGB%;            ' Background color, blue level
var tunDotsFGR%;            ' Dot color, red level
var tunDotsFGG%;            ' Dot color, green level
var tunDotsFGB%;            ' Dot color, blue level


' Disparity - this runs a Disparity tuning curve on either the slave or master screen
var tunDisparityOnMaster%;      ' if 1, Disparity is on master, if 0, Disparity is on slave.
var tunDisparityProgression%;   ' if 1, progression is random
var tunDisparityLinear%;        ' if 1, tuning curve is linear, 0 log
var tunDisparityNSteps%;
var tunDisparityNRepeats%;
var tunDisparityCenterXPos;
var tunDisparityMaxXPos;
var tunDisparityMinXPos;


' Contrast Reversing Gratings
var tunCRGCurrentCurve%:=0;     ' note, will be 0 unless CRG is selected on the dialog
var tunCRGNRepeats%;            ' number of repeats of the CRG sequence, note there will be one repeat for each level in the non-CRG tuning curve
                                    ' thus if this is 3 and the tuning curve has 5 values and there are 10 sequences this is 150 stimuli
var tunCRGFramesPerFlip%;       ' number of frames for each contrast reverse in the sequence
var tunCRGProgression%;         ' if 1, progression is random
var tunCRGOnSlave%;             ' if 1, CRG is on slave screen, using slave here so "master" is at top of list box with this variable as an index
var tunCRGSeqFile$;             ' full path of sequence file
var tunCRGSeqFile2$;            ' full path of secondary sequence file, if used
var tunCRGNSeq1%;               ' will hold the number of sequences in the sequence file, not saved to registry
var tunCRGNSeq2%;               ' will hold the number of sequences in the sequence file, not saved to registry
var tunCRGNFlips1%;             ' number of flips per sequence in file 1 (note that nFlips is a bit of a misnomer...it's really the number of frame-blocks)
var tunCRGNFlips2%;             ' number of flips per sequence in file 2
var tunCRGSecsPerSeq:=0;        ' length of a sequence in seconds, to be compared to stim duration in tuning curve, not saved to registry


' Danishes
var tunDanishNSteps%;           ' # steps in outer diameter tuning curve
var tunDanishNRepeats%;         ' # repeats in outer diameter tuning curve
var tunDanishMinOuterDiameter;  ' min outer diameter
var tunDanishMaxOuterDiameter;  ' max outer diameter
var tunDanishProgression%;      ' if 1, progression is random
var tunDanishIncludeBlank%;     ' if 1, include "blank" (that is, zero-size donut) in tuning curve


'Dynamic Surround Suppression
var tunDSSNTrials%;             ' # of trials (one trial is made of N periods)
var tunDSSNPeriods%;            ' # of flash + blank periods
var tunDSSNBlanks%;             ' # of blank periods, the remainder are flashes
var tunDSSNFlashesPerReward%;   ' # of flashes per each reward
var tunDSSCurrPeriod%;          ' counts current period
var tunDSSFlashesUntilReward%;  ' how many flashes until we get a reward?
var tunDSSFlashOrBlank%[1000];  'is current "flash" a flash or a blank?
var tunDSSDuration;             'how long is each flash, will take from "fixation duration"
var tunDSSIsOn%;                'keep track of current state
var tunNextDSSTime;             'when is the next flip?



'Null Test
var tunNullTestNSteps%;         ' # steps in null test tuning curve
var tunNullTestNRepeats%;       ' # repeats in null test tuning curve
var tunNullTestMinPhase;        ' minimum phase
var tunNullTestMaxPhase;        ' maximum phase
var tunNullTestTF;              ' temporal frequency of the contrast reversal
var tunNullTestProgression%;    ' if 1, progression is random
var tunNullTestStepFunc%;
var tunNullTestUseFile%;
var tunNullTestTuningFile$;


'Lag
var tunLagNSteps%;			' # steps in temporal tuning curve
var tunLagNRepeats%;		' # repeats in temporal tuning curve
var tunLagMinLagFrames%;    ' min Lag, frames
var tunLagMaxLagFrames%;	' max Lag, frames
var tunLagMinLagFrames;     ' min Lag, frames, float for using GRPP
var tunLagMaxLagFrames;	    ' max Lag, frames, float for using GRPP
var tunLagMinLagMS;         ' min Lag, ms, for display
var tunLagMaxLagMS;         ' max lag, ms, for display
var tunLagProgression%;
var tunLagUseFile%;
var tunLagTuningFile$;
var tunLagFrames1$;
var tunLagFrames2$;
var tunLagMasterIsLagged%;


' Optogenetics variables
var tunPreStimOptoTime;
var tunPostStimOptoTime;
var tunOptoStaysOn%;
var tunOptoVoltageOut;
var tunOptoStartState%;  'essentially an index, 0 = off first, 1 = on first (those are logical), 2 = random
var tunOptoState% := 0;  'current opto state, will toggle, can set here in dialog box
var dontToggleOpto% := 0;  'by default, toggle opto on every block
'var tunRecOptoBox% := 0;      'record the output from the opto box?
var tunOptoNPulses%;
var tunPulsedOptoOnset;
var tunPulsedOptoWidth;
var tunPulsedOptoIPI;
var tunPulsedOptoOnsetClockSteps%;
var tunPulsedOptoOffsetClockSteps%;
var tunPulsedOptoWidthClockSteps%;
var tunPulsedOptoIPIClockSteps%;
var tunDoOpto%;                     ' New, 1 if doing optogenetics
'var tunRecStimulator% := 0;   'record the stimulator?
var tunOptoUsePulse% := 0;  'Are we using a "pulsing stimulation"?
var tunLaserDiode% := 0;  'Are we recording the output of the laser using a photodiode?
var tunInterBlockTime := 0;        ' New, time between blocks, important for opto

' Strings that hold grating parameters
var tunGratingParams$;
var tunGratingParamsSlave$;

' Crosshair display variables
var tunUseXHairs%;                'Do we use crosshairs?
var tunXHairInnerRadiusOffset;    'Inner diameter of inner grid ring
var tunXHairMiddleRadiusOffset;   'Outer diameter of inner grid ring/Inner diameter of outer grid ring
var tunXHairOuterRadiusOffset;    'Outer diameter of outer grid ring
var tunXHairNumGridDivisions%;    'Number of divisions in the grid rings
var tunXHairTicInnerOffset;       'Inner extent of 0/90/180/270 ticks
var tunXHairTicOuterOffset;       'Outer extent of 0/90/180/270 ticks
var tunMaximalDiam;
var tunSlaveMaximalDiam;

var tunAlwaysLooking% := 1; ' If set eye signals ignored - subject presumed to be looking always. TESTING ONLY.

var tunFixationDuration := 2.0;	' Time required to hold fixation for reward (stim ON) - this is the stimulus duration
var tunUseMaintainMode% := 1;  ' If 1, maintain fixation point on screen through stimuli, if zero, force "restart" on each stimulus
var tunMaintainFixation := 2.0;	' Time required to hold fixation for reward (stim OFF)
var tunAcquisitionTime := 1.0;		' Time allowed to acquire fixation
var tunStimulusOnsetDelay := 0;     ' Time of stimulus onset delay following acquisition 
var tunBackgroundColor$ := "gray";	' background color for stim
var tunAcqFailTime := 2.0;			' Wait time after acquisition failure
var tunHoldFailTime := 2.0;			' Wait time after failure to hold fixation (not on the first time after acquisition)
var tunMaintainFailTime := 2.0;	' Wait time after breaking fixation during maintain phase
'var tunTimeOutTime := 2.0;			' Wait time after failure to hold fixation (first time after acquisition)
var tunStdInterTrialTime := 2.0;    'Standard intertrial time
var tunDoRivalry% := 0;          ' If checked, run for the rivalry rig
var tunDoF12% := 1;                 ' compute f1 and f2. 
var tunDoTuningHist% := 1;          'do tuning histograms?
var tunSetStationary% := 0;         'do stationary?
var tunXHairText$;                  'holds whether crosshairs are on or off
var updateXHairText%;             'Gets the item number of a DlgText object for update
var TunCurveMArg$:="";            'holds type of tuning curve on Master
var TunCurveSArg$:="";            'holds type of tuning curve on slave
var TunCurveS2Arg$:="";           'holds second type of tuning curve on slave, for Box O' Donuts
var tunButtonCollect%;            'Collect button data for rivalry?
var tunUseLagDialog%;             'will be 1 if we are using the lag dialog
var tunUseConstantLag%;           '0 = no constant lag, 1 = constant lag on master, 2 = constant lag on slave
var tunConstantLagFrames%;
var tunConstantLagMS$;

' These will be set by the tuning curve choice
var tunNAdvances%;		' Number of times stim will advance during one repeat
var tunNRepeats%;		' Number of repeats

' This vector will hold the actual values to step through. Some are log steps, some are not. 
' The Indices array is the order to step through the values with: tunValues[tunValuesIndices%[0]], tunValues[tunValuesIndices%[1]], ...
' djs Make a constant tunMaxTrials to set the max number of trials. Arrays etc should be declared with this const. See below and
' tunF1Sum, tunF2Sum. 
const tunMaxTrials% := 1000;
var tunValues[tunMaxTrials%];
var tun1Values[tunMaxTrials%];
var tun2Values[tunMaxTrials%];
var tunValuesIndices%[tunMaxTrials%]; 
var tun1ValuesIndices%[tunMaxTrials%]; 
var tun2ValuesIndices%[tunMaxTrials%]; 
var tunNValues%;
var tun1NValues%;
var tun2NValues%;
var tunValuesStringified$;
var tun1ValuesStringified$;     'For Box O' Donuts
var tun2ValuesStringified$;


' Wavemarks and continuous ports are specified elsewhere
var tunNWavemarks% := 0;
var tunWavemarkPorts%[16];
var tunNContinuous% := 0;
var tunContinuousPorts%[16];

' Hold sum of F1 values. Each channel (up to 16) has values saved according to the index of the tuning value
' Rely on the fact that arrays are initialized with 0s in Spike2. 
var tunF1Sum[16][tunMaxTrials%];  'see, this isn't really a sum, it's a matrix that holds all the values
var tunF2Sum[16][tunMaxTrials%];
var tunF0ActualSum[16][tunMaxTrials%];  'these are really sums
var tunF1ActualSum[16][tunMaxTrials%];  
var tunF2ActualSum[16][tunMaxTrials%];
var tunF0Count%[16][tunMaxTrials%];  'use these to allow us to calculate averages instead of putting every single value on the plot
var tunF1Count%[16][tunMaxTrials%]; 
var tunF2Count%[16][tunMaxTrials%];
var tunTF;              ' Will need to use this during FFT analysis. Use at your own risk....


'------------ Read/write tuning curve parameters to the registry ------------

proc GetTuningCurveOrientationParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";
    tunOriNSteps% := GetIntRegistryValue%(key$, "NSteps", tunOriNSteps%);
    tunOriNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunOriNRepeats%);
    tunOriMinOrientation := GetFloatRegistryValue(key$, "MinOrientation", tunOriMinOrientation);
    tunOriMaxOrientation := GetFloatRegistryValue(key$, "MaxOrientation", tunOriMaxOrientation);
    tunOriProgression% := GetIntRegistryValue%(key$, "Progression", tunOriProgression%);
    tunOriUseFile% := GetIntRegistryValue%(key$, "UseFile", tunOriUseFile%);
    tunOriTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunOriTuningFile$);
end;

proc SaveTuningCurveOrientationParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";
    SetIntRegistryValue(key$, "NSteps", tunOriNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunOriNRepeats%);
    SetFloatRegistryValue(key$, "MinOrientation", tunOriMinOrientation);
    SetFloatRegistryValue(key$, "MaxOrientation", tunOriMaxOrientation);
    SetIntRegistryValue(key$, "Progression", tunOriProgression%);
    SetIntRegistryValue(key$, "UseFile", tunOriUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunOriTuningFile$);
end;

proc GetTuningCurveContrastParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";
    
    tunContrastNSteps% := GetIntRegistryValue%(key$, "NSteps", tunContrastNSteps%);
    tunContrastNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunContrastNRepeats%);
    tunContrastMinContrast := GetFloatRegistryValue(key$, "MinContrast", tunContrastMinContrast);
    tunContrastMaxContrast := GetFloatRegistryValue(key$, "MaxContrast", tunContrastMaxContrast);
    tunContrastProgression% := GetIntRegistryValue%(key$, "Progression", tunContrastProgression%);
    tunContrastUseFile% := GetIntRegistryValue%(key$, "UseFile", tunContrastUseFile%);
    tunContrastTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunContrastTuningFile$);
end;

proc SaveTuningCurveContrastParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";
    SetIntRegistryValue(key$, "NSteps", tunContrastNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunContrastNRepeats%);
    SetFloatRegistryValue(key$, "MinContrast", tunContrastMinContrast);
    SetFloatRegistryValue(key$, "MaxContrast", tunContrastMaxContrast);
    SetIntRegistryValue(key$, "Progression", tunContrastProgression%);
    SetIntRegistryValue(key$, "UseFile", tunContrastUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunContrastTuningFile$);
end;

proc GetTuningCurveSpatialParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";
    
    tunSpatialNSteps% := GetIntRegistryValue%(key$, "NSteps", tunSpatialNSteps%);
    tunSpatialNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunSpatialNRepeats%);
    tunSpatialMinSF := GetFloatRegistryValue(key$, "MinSF", tunSpatialMinSF);
    tunSpatialMaxSF := GetFloatRegistryValue(key$, "MaxSF", tunSpatialMaxSF);
    tunSpatialProgression% := GetIntRegistryValue%(key$, "Progression", tunSpatialProgression%);
    tunSpatialUseFile% := GetIntRegistryValue%(key$, "UseFile", tunSpatialUseFile%);
    tunSpatialTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunSpatialTuningFile$);
end;

proc SaveTuningCurveSpatialParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";
    
    SetIntRegistryValue(key$, "NSteps", tunSpatialNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunSpatialNRepeats%);
    SetFloatRegistryValue(key$, "MinSF", tunSpatialMinSF);
    SetFloatRegistryValue(key$, "MaxSF", tunSpatialMaxSF);
    SetIntRegistryValue(key$, "Progression", tunSpatialProgression%);
    SetIntRegistryValue(key$, "UseFile", tunSpatialUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunSpatialTuningFile$);
end;

proc GetTuningCurveTemporalParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";
    
    tunTemporalNSteps% := GetIntRegistryValue%(key$, "NSteps", tunTemporalNSteps%);
    tunTemporalNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunTemporalNRepeats%);
    tunTemporalMinTF := GetFloatRegistryValue(key$, "MinTF", tunTemporalMinTF);
    tunTemporalMaxTF := GetFloatRegistryValue(key$, "MaxTF", tunTemporalMaxTF);
    tunTemporalProgression% := GetIntRegistryValue%(key$, "Progression", tunTemporalProgression%);
    tunTemporalUseFile% := GetIntRegistryValue%(key$, "UseFile", tunTemporalUseFile%);
    tunTemporalTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunTemporalTuningFile$);
end;

proc SaveTuningCurveTemporalParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";

    SetIntRegistryValue(key$, "NSteps", tunTemporalNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunTemporalNRepeats%);
    SetFloatRegistryValue(key$, "MinTF", tunTemporalMinTF);
    SetFloatRegistryValue(key$, "MaxTF", tunTemporalMaxTF);
    SetIntRegistryValue(key$, "Progression", tunTemporalProgression%);
    SetIntRegistryValue(key$, "UseFile", tunTemporalUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunTemporalTuningFile$);
end;


proc GetTuningCurveXPosParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XPos";
    
    tunXPosNSteps% := GetIntRegistryValue%(key$, "NSteps", tunXPosNSteps%);
    tunXPosNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunXPosNRepeats%);
    tunXPosMinXPos := GetFloatRegistryValue(key$, "MinXPos", tunXPosMinXPos);
    tunXPosMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunXPosMaxXPos);
    tunXPosProgression% := GetIntRegistryValue%(key$, "Progression", tunXPosProgression%);
end;

proc SaveTuningCurveXPosParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XPos";

    SetIntRegistryValue(key$, "NSteps", tunXPosNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunXPosNRepeats%);
    SetFloatRegistryValue(key$, "MinXPos", tunXPosMinXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunXPosMaxXPos);
    SetIntRegistryValue(key$, "Progression", tunXPosProgression%);
end;


proc GetTuningCurveXYPosParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XYPos";
    
    tunXYPosNXSteps% := GetIntRegistryValue%(key$, "NXSteps", tunXYPosNXSteps%);
    tunXYPosNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunXYPosNRepeats%);
    tunXYPosMinXPos := GetFloatRegistryValue(key$, "MinXPos", tunXYPosMinXPos);
    tunXYPosMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunXYPosMaxXPos);
    tunXYPosProgression% := GetIntRegistryValue%(key$, "Progression", tunXYPosProgression%);
    tunXYPosNYSteps% := GetIntRegistryValue%(key$, "NYSteps", tunXYPosNYSteps%);
    tunXYPosMinYPos := GetFloatRegistryValue(key$, "MinYPos", tunXYPosMinYPos);
    tunXYPosMaxYPos := GetFloatRegistryValue(key$, "MaxYPos", tunXYPosMaxYPos);
end;

proc SaveTuningCurveXYPosParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XYPos";

    SetIntRegistryValue(key$, "NXSteps", tunXYPosNXSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunXYPosNRepeats%);
    SetFloatRegistryValue(key$, "MinXPos", tunXYPosMinXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunXYPosMaxXPos);
    SetIntRegistryValue(key$, "Progression", tunXYPosProgression%);
    SetIntRegistryValue(key$, "NYSteps", tunXYPosNYSteps%);
    SetFloatRegistryValue(key$, "MinYPos", tunXYPosMinYPos);
    SetFloatRegistryValue(key$, "MaxYPos", tunXYPosMaxYPos);
end;


proc GetTuningCurveDisparityParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Disparity";
    
    tunDisparityNSteps% := GetIntRegistryValue%(key$, "NSteps", tunDisparityNSteps%);
    tunDisparityNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunDisparityNRepeats%);
    tunDisparityCenterXPos := GetFloatRegistryValue(key$, "CenterXPos", tunDisparityCenterXPos);
    tunDisparityMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunDisparityMaxXPos);
    tunDisparityProgression% := GetIntRegistryValue%(key$, "Progression", tunDisparityProgression%);
    tunDisparityLinear% := GetIntRegistryValue%(key$, "Linear", tunDisparityLinear%);
    tunDisparityOnMaster% := GetIntRegistryValue%(key$, "Master", tunDisparityOnMaster%);
    
end;

proc SaveTuningCurveDisparityParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Disparity";
    
    SetIntRegistryValue(key$, "NSteps", tunDisparityNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunDisparityNRepeats%);
    SetFloatRegistryValue(key$, "CenterXPos", tunDisparityCenterXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunDisparityMaxXPos);
    SetIntRegistryValue(key$, "Progression", tunDisparityProgression%);
    SetIntRegistryValue(key$, "Linear", tunDisparityLinear%);
    SetIntRegistryValue(key$, "Master", tunDisparityOnMaster%);
    
end;


proc GetTuningCurveAreaParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

    tunAreaNSteps% := GetIntRegistryValue%(key$, "NSteps", tunAreaNSteps%);
    tunAreaNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunAreaNRepeats%);
    tunAreaMinDiam := GetFloatRegistryValue(key$, "MinDiam", tunAreaMinDiam);
    tunAreaMaxDiam := GetFloatRegistryValue(key$, "MaxDiam", tunAreaMaxDiam);
    tunAreaProgression% := GetIntRegistryValue%(key$, "Progression", tunAreaProgression%);
    tunAreaUseFile% := GetIntRegistryValue%(key$, "UseFile", tunAreaUseFile%);
    tunAreaTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunAreaTuningFile$);
    tunDonutOptimalIndex% := GetIntRegistryValue%(key$, "OptimalIndex", tunDonutOptimalIndex%);
    tunDonutProgression% := GetIntRegistryValue%(key$, "DonutProgression", tunDonutProgression%);
    tunDonutCoreOnSlave% := GetIntRegistryValue%(key$, "DonutCoreOnSlave", tunDonutCoreOnSlave%);
    tunBerlinerMaximalIndex% := GetIntRegistryValue%(key$, "MaximalIndexBerliner", tunBerlinerMaximalIndex%);
    tunBerlinerMaximalDiam := GetFloatRegistryValue(key$, "MaximalDiamBerliner", tunBerlinerMaximalDiam);
    tunBerlinerNSteps% := GetIntRegistryValue%(key$, "NStepsBerliner", tunBerlinerNSteps%);
    tunBerlinerNRepeats% := GetIntRegistryValue%(key$, "NRepeatsDiamBerliner", tunBerlinerNRepeats%);
    tunBerlinerProgression% := GetIntRegistryValue%(key$, "BerlinerProgression", tunBerlinerProgression%);
    tunBerlinerCoreOnSlave% := GetIntRegistryValue%(key$, "BerlinerCoreOnSlave", tunBerlinerCoreOnSlave%);
    tunMasterFollowsCurve1% := GetIntRegistryValue%(key$, "MasterFollowsCurve1", tunMasterFollowsCurve1%); 
    tunBoxODonutsProgression% := GetIntRegistryValue%(key$, "BoxODonutsProgression", tunBoxODonutsProgression%);
    tunBoxODonutsNRepeats% := GetIntRegistryValue%(key$, "BoxODonutsNRepeats", tunBoxODonutsNRepeats%);
end;

proc SaveTuningCurveAreaParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

    SetIntRegistryValue(key$, "NSteps", tunAreaNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunAreaNRepeats%);
    SetFloatRegistryValue(key$, "MinDiam", tunAreaMinDiam);
    SetFloatRegistryValue(key$, "MaxDiam", tunAreaMaxDiam);
    SetIntRegistryValue(key$, "Progression", tunAreaProgression%);
    SetIntRegistryValue(key$, "UseFile", tunAreaUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunAreaTuningFile$);
    SetIntRegistryValue(key$, "OptimalIndex", tunDonutOptimalIndex%);
    SetIntRegistryValue(key$, "DonutProgression", tunDonutProgression%);
    SetIntRegistryValue(key$, "DonutCoreOnSlave", tunDonutCoreOnSlave%);
    SetIntRegistryValue(key$, "MaximalIndexBerliner", tunBerlinerMaximalIndex%);
    SetFloatRegistryValue(key$, "MaximalDiamBerliner", tunBerlinerMaximalDiam);
    SetIntRegistryValue(key$, "NStepsBerliner", tunBerlinerNSteps%);
    SetIntRegistryValue(key$, "NRepeatsDiamBerliner", tunBerlinerNRepeats%);
    SetIntRegistryValue(key$, "BerlinerProgression", tunBerlinerProgression%);
    SetIntRegistryValue(key$, "MasterFollowsCurve1", tunMasterFollowsCurve1%);
    SetIntRegistryValue(key$, "BoxODonutsProgression", tunBoxODonutsProgression%);
    SetIntRegistryValue(key$, "BerlinerCoreOnSlave", tunBerlinerCoreOnSlave%);
    SetIntRegistryValue(key$, "BoxODonutsNRepeats", tunBoxODonutsNRepeats%);
end;

proc GetTuningCurveDotsParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Dots";
    tunDotsNSteps% := GetIntRegistryValue%(key$, "NSteps", tunDotsNSteps%);
    tunDotsNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunDotsNRepeats%);
    tunDotsMinOrientation := GetFloatRegistryValue(key$, "MinOrientation", tunDotsMinOrientation);
    tunDotsMaxOrientation := GetFloatRegistryValue(key$, "MaxOrientation", tunDotsMaxOrientation);
    tunDotsX := GetFloatRegistryValue(key$, "X", tunDotsX);
    tunDotsY := GetFloatRegistryValue(key$, "Y", tunDotsY);
    tunDotsDiameter := GetFloatRegistryValue(key$, "Diameter", tunDotsDiameter);
    tunDotsSpeed := GetFloatRegistryValue(key$, "Speed", tunDotsSpeed);
    tunDotsDensity := GetFloatRegistryValue(key$, "Density", tunDotsDensity);
    tunDotsSize% := GetIntRegistryValue%(key$, "Size", tunDotsSize%);
    tunDotsProgression% := GetIntRegistryValue%(key$, "Progression", tunDotsProgression%);
    tunDotsBGR% := GetIntRegistryValue%(key$, "BGR", tunDotsBGR%);
    tunDotsBGG% := GetIntRegistryValue%(key$, "BGG", tunDotsBGG%);
    tunDotsBGB% := GetIntRegistryValue%(key$, "BGB", tunDotsBGB%);
    tunDotsFGR% := GetIntRegistryValue%(key$, "FGR", tunDotsFGR%);
    tunDotsFGG% := GetIntRegistryValue%(key$, "FGG", tunDotsFGG%);
    tunDotsFGB% := GetIntRegistryValue%(key$, "FGB", tunDotsFGB%);
end;

proc SaveTuningCurveDotsParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Dots";
    SetIntRegistryValue(key$, "NSteps", tunDotsNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunDotsNRepeats%);
    SetFloatRegistryValue(key$, "MinOrientation", tunDotsMinOrientation);
    SetFloatRegistryValue(key$, "MaxOrientation", tunDotsMaxOrientation);
    SetFloatRegistryValue(key$, "X", tunDotsX);
    SetFloatRegistryValue(key$, "Y", tunDotsY);
    SetFloatRegistryValue(key$, "Diameter", tunDotsDiameter);
    SetFloatRegistryValue(key$, "Speed", tunDotsSpeed);
    SetFloatRegistryValue(key$, "Density", tunDotsDensity);
    SetIntRegistryValue(key$, "Size", tunDotsSize%);
    SetIntRegistryValue(key$, "Progression", tunDotsProgression%);
    SetIntRegistryValue(key$, "BGR", tunDotsBGR%);
    SetIntRegistryValue(key$, "BGG", tunDotsBGG%);
    SetIntRegistryValue(key$, "BGB", tunDotsBGB%);
    SetIntRegistryValue(key$, "FGR", tunDotsFGR%);
    SetIntRegistryValue(key$, "FGG", tunDotsFGG%);
    SetIntRegistryValue(key$, "FGB", tunDotsFGB%);
end;


proc GetTuningCurveCRGParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\CRG";
    tunCRGNRepeats% := GetIntRegistryValue%(key$, "CRGNRepeats", tunCRGNRepeats%);
    tunCRGFramesPerFlip% := GetIntRegistryValue%(key$, "CRGFramesPerTurn", tunCRGFramesPerFlip%);
    tunCRGProgression% := GetIntRegistryValue%(key$, "CRGProgression", tunCRGProgression%);
    tunCRGOnSlave% := GetIntRegistryValue%(key$, "CRGOnSlave", tunCRGOnSlave%);
    tunCRGSeqFile$ := GetStringRegistryValue$(key$, "CRGSeqFile", tunCRGSeqFile$);
end;


proc SaveTuningCurveCRGParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\CRG";
    SetIntRegistryValue(key$, "CRGNRepeats", tunCRGNRepeats%);
    SetIntRegistryValue(key$, "CRGFramesPerTurn", tunCRGFramesPerFlip%);
    SetIntRegistryValue(key$, "CRGProgression", tunCRGProgression%);
    SetIntRegistryValue(key$, "CRGOnSlave", tunCRGOnSlave%);
    SetStringRegistryValue(key$, "CRGSeqFile", tunCRGSeqFile$);
end;



proc GetTuningCurveDanishParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Danish";
    tunDanishNSteps% := GetIntRegistryValue%(key$, "DanishNSteps", tunDanishNSteps%);
    tunDanishNRepeats% := GetIntRegistryValue%(key$, "DanishNRepeats", tunDanishNRepeats%);
    tunDanishMinOuterDiameter := GetFloatRegistryValue(key$, "DanishMinOuterDiameter", tunDanishMinOuterDiameter);
    tunDanishMaxOuterDiameter := GetFloatRegistryValue(key$, "DanishMaxOuterDiameter", tunDanishMaxOuterDiameter);
    tunDanishProgression% := GetIntRegistryValue%(key$, "DanishProgression", tunDanishProgression%);
    tunDanishIncludeBlank% := GetIntRegistryValue%(key$, "DanishIncludeBlank", tunDanishIncludeBlank%);
end;


proc SaveTuningCurveDanishParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Danish";
    SetIntRegistryValue(key$, "DanishNSteps", tunDanishNSteps%);
    SetIntRegistryValue(key$, "DanishNRepeats", tunDanishNRepeats%);
    SetFloatRegistryValue(key$, "DanishMinOuterDiameter", tunDanishMinOuterDiameter);
    SetFloatRegistryValue(key$, "DanishMaxOuterDiameter", tunDanishMaxOuterDiameter);
    SetIntRegistryValue(key$, "DanishProgression", tunDanishProgression%);
    SetIntRegistryValue(key$, "DanishIncludeBlank", tunDanishIncludeBlank%);
end;


proc GetTuningCurveDSSParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\DSS";
    tunDSSNPeriods% := GetIntRegistryValue%(key$, "DSSNPeriods", tunDSSNPeriods%);
    tunDSSNBlanks% := GetIntRegistryValue%(key$, "DSSNBlanks", tunDSSNBlanks%);
    tunDSSNFlashesPerReward% := GetIntRegistryValue%(key$, "DSSNFlashesPerReward", tunDSSNFlashesPerReward%);
    tunDSSNTrials% := GetIntRegistryValue%(key$, "DSSNTrials", tunDSSNTrials%);
end;


proc SaveTuningCurveDSSParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\DSS";
    SetIntRegistryValue(key$, "DSSNPeriods", tunDSSNPeriods%);
    SetIntRegistryValue(key$, "DSSNBlanks", tunDSSNBlanks%);
    SetIntRegistryValue(key$, "DSSNFlashesPerReward", tunDSSNFlashesPerReward%);
    SetIntRegistryValue(key$, "DSSNTrials", tunDSSNTrials%);
end;


proc GetTuningCurveNullTestParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\NullTest";
    
    tunNullTestNSteps% := GetIntRegistryValue%(key$, "NSteps", tunNullTestNSteps%);
    tunNullTestNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunNullTestNRepeats%);
    tunNullTestProgression% := GetIntRegistryValue%(key$, "Progression", tunNullTestProgression%);
    tunNullTestStepFunc% := GetIntRegistryValue%(key$, "StepFunc", tunNullTestStepFunc%);
    tunNullTestMinPhase := GetFloatRegistryValue(key$, "MinPhase", tunNullTestMinPhase);
    tunNullTestMaxPhase := GetFloatRegistryValue(key$, "MaxPhase", tunNullTestMaxPhase);
    tunNullTestTF := GetFloatRegistryValue(key$, "TransitionFreq", tunNullTestTF);
    tunNullTestUseFile% := GetIntRegistryValue%(key$, "UseFile", tunNullTestUseFile%);
    tunNullTestTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunNullTestTuningFile$);
end;

proc SaveTuningCurveNullTestParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\NullTest";

    SetIntRegistryValue(key$, "NSteps", tunNullTestNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunNullTestNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunNullTestProgression%);
    SetIntRegistryValue(key$, "StepFunc", tunNullTestStepFunc%);
    SetFloatRegistryValue(key$, "MinPhase", tunNullTestMinPhase);
    SetFloatRegistryValue(key$, "MaxPhase", tunNullTestMaxPhase);
    SetFloatRegistryValue(key$, "TransitionFreq", tunNullTestTF);
    SetIntRegistryValue(key$, "UseFile", tunNullTestUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunNullTestTuningFile$);
end;

proc GetTuningCurveLagParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Lag";
    
    tunLagNSteps% := GetIntRegistryValue%(key$, "NSteps", tunLagNSteps%);
    tunLagNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunLagNRepeats%);
    tunLagMinLagFrames% := GetIntRegistryValue%(key$, "MinLag", tunLagMinLagFrames%);
    tunLagMaxLagFrames% := GetIntRegistryValue%(key$, "MaxLag", tunLagMaxLagFrames%);
    tunLagProgression% := GetIntRegistryValue%(key$, "Progression", tunLagProgression%);
    tunLagUseFile% := GetIntRegistryValue%(key$, "UseFile", tunLagUseFile%);
    tunLagTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunLagTuningFile$);
    tunLagMasterIsLagged% := GetIntRegistryValue%(key$, "MasterIsLagged", tunLagMasterIsLagged%);
end;

proc SaveTuningCurveLagParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Lag";
    SetIntRegistryValue(key$, "NSteps", tunLagNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunLagNRepeats%);
    SetIntRegistryValue(key$, "MinLag", tunLagMinLagFrames%);
    SetIntRegistryValue(key$, "MaxLag", tunLagMaxLagFrames%);
    SetIntRegistryValue(key$, "Progression", tunLagProgression%);
    SetIntRegistryValue(key$, "UseFile", tunLagUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunLagTuningFile$);
    SetIntRegistryValue(key$, "MasterIsLagged", tunLagMasterIsLagged%);
end;


proc GetTunOptoParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Opto";
    
    tunPreStimOptoTime := GetFloatRegistryValue(key$, "PreStimOptoTime", tunPreStimOptoTime);
    tunPostStimOptoTime := GetFloatRegistryValue(key$, "PostStimOptoTime", tunPostStimOptoTime);
    tunOptoStaysOn% := GetIntRegistryValue%(key$, "OptoStaysOn", tunOptoStaysOn%);
    tunOptoVoltageOut := GetFloatRegistryValue(key$, "OptoVoltageOut", tunOptoVoltageOut);
    tunOptoStartState% := GetIntRegistryValue%(key$, "OptoStartState", tunOptoStartState%);
    tunOptoUsePulse% := GetIntRegistryValue%(key$, "OptoUsePulse", tunOptoUsePulse%);
    tunLaserDiode% := GetIntRegistryValue%(key$, "LaserDiode", tunLaserDiode%);
    tunOptoNPulses% := GetIntRegistryValue%(key$, "OptoNPulses", tunOptoNPulses%);
    tunPulsedOptoOnset := GetFloatRegistryValue(key$, "PulsedOptoOnset", tunPulsedOptoOnset);
    tunPulsedOptoWidth := GetFloatRegistryValue(key$, "PulsedOptoWidth", tunPulsedOptoWidth);
    tunPulsedOptoIPI := GetFloatRegistryValue(key$, "PulsedOptoIPI", tunPulsedOptoIPI);
    tunInterBlockTime := GetFloatRegistryValue(key$, "InterBlockTime", tunInterBlockTime);
    
    
    'tunRecOptoBox% := GetIntRegistryValue%(key$, "RecOptoBox", tunRecOptoBox%);
    'tunRecStimulator% := GetIntRegistryValue%(key$, "RecStimulator", tunRecStimulator%);

end;

proc SaveTunOptoParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Opto";
    SetFloatRegistryValue(key$, "PreStimOptoTime", tunPreStimOptoTime);
    SetFloatRegistryValue(key$, "PostStimOptoTime", tunPostStimOptoTime);
    SetIntRegistryValue(key$, "OptoStaysOn", tunOptoStaysOn%);
    SetFloatRegistryValue(key$, "OptoVoltageOut", tunOptoVoltageOut);
    SetIntRegistryValue(key$, "OptoStartState", tunOptoStartState%);
    SetIntRegistryValue(key$, "OptoUsePulse", tunOptoUsePulse%);
    SetIntRegistryValue(key$, "LaserDiode", tunLaserDiode%);
    SetIntRegistryValue(key$, "OptoNPulses", tunOptoNPulses%);
    SetFloatRegistryValue(key$, "PulsedOptoOnset", tunPulsedOptoOnset);
    SetFloatRegistryValue(key$, "PulsedOptoWidth", tunPulsedOptoWidth);
    SetFloatRegistryValue(key$, "PulsedOptoIPI", tunPulsedOptoIPI);
    SetFloatRegistryValue(key$, "InterBlockTime", tunInterBlockTime);
    
    'SetIntRegistryValue(key$, "RecOptoBox", tunRecOptoBox%);
    'SetIntRegistryValue(key$, "RecStimulator", tunRecStimulator%);
end;






'------------ END Read/write tuning curve parameters to the registry ------------


func TuningCurveOrientationDialog%()
	var iReturn%;
	var i%;
	GetTuningCurveOrientationParameters();
	DlgCreate("Run Orientation Tuning Curve");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min Orientation (deg)", 0, 360);
	DlgReal(4, "Max Orientation (deg)", 0, 360);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);
    
	i% := DlgShow(tunOriNSteps%, tunOriNRepeats%, tunOriMinOrientation, tunOriMaxOrientation, tunOriProgression%, tunOriUseFile%, tunOriTuningFile$);

	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveOrientationParameters();
		PrintLog("TuningCurveOrientationDialog - user hit OK\n");
		tunType$ := tunTypeOrientation$;
        tunUseFile% := tunOriUseFile%;
        tunTuningFile$ := tunOriTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeOrientation$;
            tunUseFile1% := tunOriUseFile%;
            tunTuningFile1$ := tunOriTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is ORIENTATION";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgOrientationButton%);  'So we don't pick orientation again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeOrientation$;
            tunUseFile2% := tunOriUseFile%;
            tunTuningFile2$ := tunOriTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is ORIENTATION";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgOrientationButton%);  'So we don't pick orientation again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeOrientation$;
            if DlgValue(5) = 0 then 'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is ORIENTATION";
            else
                tunCurve1Text$ := "Tuning Curve on Master is ORIENTATION";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		PrintLog("TuningCurveOrientationDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    PrintLog("Return value is %d\n", iReturn%);
	return iReturn%;
end;



func TuningCurveContrastDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveContrastParameters();
	DlgCreate("Contrast Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min Contrast (%)", 0.1, 100);
	DlgReal(4, "Max Contrast (%)", 0.1, 100);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);

	i% := DlgShow(tunContrastNSteps%, tunContrastNRepeats%, tunContrastMinContrast, tunContrastMaxContrast, tunContrastProgression%, tunContrastUseFile%, tunContrastTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveContrastParameters();
'		PrintLog("TuningCurveContrastDialog - user hit OK\n");
		tunType$ := tunTypeContrast$;
        tunUseFile% := tunContrastUseFile%;
        tunTuningFile$ := tunContrastTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeContrast$;
            tunUseFile1% := tunContrastUseFile%;
            tunTuningFile1$ := tunContrastTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is CONTRAST";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgContrastButton%);  'So we don't pick contrast again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeContrast$;
            tunUseFile2% := tunContrastUseFile%;
            tunTuningFile2$ := tunContrastTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is CONTRAST";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgContrastButton%);  'So we don't pick contrast again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeContrast$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is CONTRAST";
            else
                tunCurve1Text$ := "Tuning Curve on Master is CONTRAST";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveContrastDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveSpatialDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveSpatialParameters();
	DlgCreate("Spatial Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min SF", .01, 100);
	DlgReal(4, "Max SF", .01, 100);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);

	i% := DlgShow(tunSpatialNSteps%, tunSpatialNRepeats%, tunSpatialMinSF, tunSpatialMaxSF, tunSpatialProgression%, tunSpatialUseFile%, tunSpatialTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveSpatialParameters();
'		PrintLog("TuningCurveSpatialDialog - user hit OK\n");
		tunType$ := tunTypeSpatial$;
        tunUseFile% := tunSpatialUseFile%;
        tunTuningFile$ := tunSpatialTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeSpatial$;
            tunUseFile1% := tunSpatialUseFile%;
            tunTuningFile1$ := tunSpatialTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is SPATIAL FREQ";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgSpatialButton%);  'So we don't pick spatial frequency again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeSpatial$;
            tunUseFile2% := tunSpatialUseFile%;
            tunTuningFile2$ := tunSpatialTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is SPATIAL FREQ";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgSpatialButton%);  'So we don't pick spatial frequency again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeSpatial$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is SPATIAL FREQ";
            else
                tunCurve1Text$ := "Tuning Curve on Master is SPATIAL FREQ";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveSpatialDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveTemporalDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveTemporalParameters();
	DlgCreate("Temporal Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min TF", 0, 100);
	DlgReal(4, "Max TF", 0, 100);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);

	i% := DlgShow(tunTemporalNSteps%, tunTemporalNRepeats%, tunTemporalMinTF, tunTemporalMaxTF, tunTemporalProgression%, tunTemporalUseFile%, tunTemporalTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveTemporalParameters();
'		PrintLog("TuningCurveTemporalDialog - user hit OK\n");
		tunType$ := tunTypeTemporal$;
        tunUseFile% := tunTemporalUseFile%;
        tunTuningFile$ := tunTemporalTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeTemporal$;
            tunUseFile1% := tunTemporalUseFile%;
            tunTuningFile1$ := tunTemporalTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is TEMPORAL FREQ";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgTemporalButton%);  'So we don't pick temporal frequency again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeTemporal$;
            tunUseFile2% := tunTemporalUseFile%;
            tunTuningFile2$ := tunTemporalTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is TEMPORAL FREQ";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgTemporalButton%);  'So we don't pick temporal frequency again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeTemporal$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is TEMPORAL FREQ";
            else
                tunCurve1Text$ := "Tuning Curve on Master is TEMPORAL FREQ";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveTemporalDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveAreaDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveAreaParameters();
	DlgCreate("Area Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	'DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);
    
    
	i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%, tunAreaUseFile%, tunAreaTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTuningCurveAreaParameters();
'		PrintLog("TuningCurveAreaDialog - user hit OK\n");
		tunType$ := tunTypeArea$;
        tunUseFile% := tunAreaUseFile%;
        tunTuningFile$ := tunAreaTuningFile$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeArea$;
            tunUseFile1% := tunAreaUseFile%;
            tunTuningFile1$ := tunAreaTuningFile$;
            tunCurve1Text$ := "Tuning Curve 1 is AREA";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgAreaButton%);  'So we don't pick area again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeArea$;
            tunUseFile2% := tunAreaUseFile%;
            tunTuningFile2$ := tunAreaTuningFile$;
            tunCurve2Text$ := "Tuning Curve 2 is AREA";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgAreaButton%);  'So we don't pick area again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeArea$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is AREA";
            else
                tunCurve1Text$ := "Tuning Curve on Master is AREA";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;


func TuningCurveXPosDialog%()
	var iReturn% := 0;
	var i%;
    
    'This function is now complicated because fixstim has XY tuning while dualstim only has X tuning
    'Because XY tuning is a superset of X tuning there does not seem to be much reason to have a separate
    'button, so that means this button needs to change between XY tuning and X tuning depending on the
    'context.  But that's doable.
    if DlgValue(11) = 1 or tunBoxODonutsCurrentCurve% = 1 or tunCRGCurrentCurve% = 1 then  'if it's a dualstim scenario, use X position
        
        GetTuningCurveXPosParameters();
        DlgCreate("XPos Tuning Curve Parameters");
        DlgInteger(1, "Number of Steps", 1, 100);
        'DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgReal(3, "Min X Position", -14, 14);
        DlgReal(4, "Max X Position", -14, 14);
        'DlgCheck(5, "Random Progression");
        if tunBoxODonutsCurrentCurve% = 0 then
            DlgInteger(2, "Number of Repeats", 1, 1000);
            DlgCheck(5, "Random Progression");
        else
            DlgInteger(2, "----------------", 1, 1);
            DlgCheck(5, "----------------");
        endif;

        
        i% := DlgShow(tunXPosNSteps%, tunXPosNRepeats%, tunXPosMinXPos, tunXPosMaxXPos, tunXPosProgression%);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        
        if i% = 1 then
            SaveTuningCurveXPosParameters();
            '		PrintLog("TuningCurveAreaDialog - user hit OK\n");
            tunType$ := tunTypeXPos$;
            
            'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
            'Oh, and update tuning types we are going to use.
            docase
            case tunBoxODonutsCurrentCurve% = 1 then
                tunType1$ := tunTypeXPos$;
                tunCurve1Text$ := "Tuning Curve 1 is X POSITION";
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                tunBoxODonutsCurrentCurve% := 2;  'update current curve 
                DlgEnable(0,-tundlgXPosButton%);  'So we don't pick X position again
            case tunBoxODonutsCurrentCurve% = 2 then
                tunType2$ := tunTypeXPos$;
                tunCurve2Text$ := "Tuning Curve 2 is X POSITION";
                DlgValue$(updateCurve2Text%, tunCurve2Text$);
                tunBoxODonutsCurrentCurve% := 3;  'update current curve 
                DlgEnable(0,-tundlgXPosButton%);  'So we don't pick X position again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            case tunCRGCurrentCurve% = 1 then
                tunCRGCurrentCurve% := 2;
                tunType1$ := tunTypeXPos$;
                if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                    tunCurve1Text$ := "Tuning Curve on Slave is X POSITION";
                else
                    tunCurve1Text$ := "Tuning Curve on Master is X POSITION";
                endif;
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            endcase;
            
            
            if tunContext$ = tunContextDAQ$ then
                ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
                iReturn% := 1;
            else
                iReturn% := 1;
            endif;
        endif;
    else 'if it's a fixstim scenario, use XY position
        
        GetTuningCurveXYPosParameters();
        DlgCreate("XYPos Tuning Curve Parameters");
        DlgInteger(1, "Number of Repeats", 1, 1000);
        DlgInteger(2, "Number of X Steps", 0, 100);
        DlgReal(3, "Min X Position", -14, 14);
        DlgReal(4, "Max X Position", -14, 14);
        DlgInteger(5, "Number of Y Steps", 0, 100);
        DlgReal(6, "Min Y Position", -14, 14);
        DlgReal(7, "Max Y Position", -14, 14);
        DlgCheck(8, "Random Progression");
        
        DlgAllow(0xffff, 0, TuningCurveXYPosDialogChanged%);
        
        i% := DlgShow(tunXYPosNRepeats%, tunXYPosNXSteps%, tunXYPosMinXPos, tunXYPosMaxXPos, tunXYPosNYSteps%, tunXYPosMinYPos, tunXYPosMaxYPos, tunXYPosProgression%);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        
        if i% = 1 then
            SaveTuningCurveXYPosParameters();
            '		PrintLog("TuningCurveAreaDialog - user hit OK\n");
            tunType$ := tunTypeXYPos$;
               
            
            if tunContext$ = tunContextDAQ$ then
                ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
                iReturn% := 1;
            else
                iReturn% := 1;
            endif;
        endif;
    endif;    
        
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;



func TuningCurveXYPosDialogChanged%(item%) 
    if DlgValue(2) = 0 then  'If no X variation
        DlgEnable(0,4); 'disable X Max
    else
        DlgEnable(1,4); 'enable X Max
    endif
    if DlgValue(5) = 0 then  'If no Y variation
        DlgEnable(0,7); 'disable Y Max
    else
        DlgEnable(1,7); 'enable Y Max
    endif
    return 1;
end





func TuningCurveDisparityDialog%()
    'This is closely related to XPos
	var iReturn% := 0;
	var i%;
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    
    'get parameters for Disparity tuning curve
    GetTuningCurveDisparityParameters();
    
    'get current x position, will allow update without going to grating parameters
    param$ := GetGratingParameters$("Stimulus");  'for XPos, get grating parameters from master stimulus, will reset master/slave accordingly 
	ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    tunDisparityCenterXPos := x;
    
	DlgCreate("Disparity Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps (one way)", 1, 100);
	DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Center X Position", -14, 14);
	DlgReal(4, "Max X Position (will mirror)", -14, 14);
    DlgCheck(5, "Slave Screen Is Stationary");
    DlgCheck(6, "No function - only linear for now");
    'DlgCheck(6, "Linear progression (unchecked is log)");
    DlgCheck(7, "Random Progression");
    
    
	i% := DlgShow(tunDisparityNSteps%, tunDisparityNRepeats%, tunDisparityCenterXPos, tunDisparityMaxXPos, tunDisparityOnMaster%, tunDisparityLinear%, tunDisparityProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTuningCurveDisparityParameters();
        'and reset the x position for master AND slave gratings
        x := tunDisparityCenterXPos;
        param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
        SaveGratingParameters("Stimulus", param$);  'this saves master
        TunMasterValsToSlave%();  'this copies master values over to slave
		
        tunType$ := tunTypeDisparity$;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;






' This function is initially called with a "0" input, which forces the 1-5 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
func TuningCurveDonutDialogChanged%(item%)
    if item% = 0 then
        DlgEnable(0, 1, 2, 3, 4);
    endif    
    return 1;
end

func TuningCurveDonutDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    var mylist$[2];
    mylist$[0] := "Master";
    mylist$[1] := "Slave";

    
	GetTuningCurveAreaParameters();
    
    ' Before we proceed, we must generate a list of choices for the optimal diameter. 
    ' Note that there are nsteps+1 values. 
    
    GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, result[], indices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
    sValues$ := GetRealArrayAsStringSep$(result[0:tunAreaNSteps%+1], indices%[0:tunAreaNSteps%+1], "|");
    
	DlgCreate("Donut Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgList(6, "Optimal diameter", sValues$);
    DlgList(7, "Core is on:", mylist$[]);
    DlgButton(151, "Master Grating", TunDlgGratingMaster%);
    DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
    DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
    DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
    DlgAllow(0xffff, 0, TuningCurveDonutDialogChanged%);
	i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunDonutProgression%, tunDonutOptimalIndex%, tunDonutCoreOnSlave%);
    tunDonutOptimalDiam := result[tunDonutOptimalIndex%];
    
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    tunMaximalDiam := result[tunDonutOptimalIndex%];
    tunSlaveMaximalDiam := tunAreaMaxDiam;
	if i% = 1 then
		SaveTuningCurveAreaParameters();
		tunType$ := tunTypeDonut$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;

' This function is initially called with a "0" input, which forces the 1, 3, 4 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
func TuningCurveBerlinerDialogChanged%(item%)    
    if item% = 0 then
        DlgEnable(0, 1, 3, 4);
    endif   
    return 1;
end

func TuningCurveBerlinerDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    var mylist$[2];
    mylist$[0] := "Master";
    mylist$[1] := "Slave";

    
	GetTuningCurveAreaParameters();
    
    ' Before we proceed, we must generate a list of choices for the optimal diameter. These are based on the most recent run of Area tuning
    ' Note that there are nsteps+1 values. 

    GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, result[], indices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
    sValues$ := GetRealArrayAsStringSep$(result[0:tunAreaNSteps%+1], indices%[0:tunAreaNSteps%+1], "|");
    
    'We want the default maximal value to be the largest value available when we open the dialog
    'so set tunBerlinerMaximalIndex% appropriately
    tunBerlinerMaximalIndex% := tunAreaNSteps%;
    
    'Define tunBerlinerNSteps%, because we are no longer doing a tuning curve.
    tunBerlinerNSteps% := 6;
    
	DlgCreate("Berliner Tuning Curve Parameters");
	'DlgInteger(1, "Number of Steps", 2, 100);
    DlgInteger(1, "Number of Stimuli", 1, 100);
	DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgList(6, "Optimal diameter", sValues$);
    DlgList(7, "Maximal diameter", sValues$);
    DlgList(8, "Core is on:", mylist$[]);
    DlgButton(151, "Master Grating", TunDlgGratingMaster%);
    DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
    DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
    DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
    DlgAllow(0xffff, 0, TuningCurveBerlinerDialogChanged%);
	'i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%, tunDonutOptimalIndex%, tunBerlinerMaximalIndex%);
    i% := DlgShow(tunBerlinerNSteps%, tunBerlinerNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunBerlinerProgression%, tunDonutOptimalIndex%, tunBerlinerMaximalIndex%, tunBerlinerCoreOnSlave%);
    
    tunMaximalDiam := tunAreaMaxDiam;
    tunSlaveMaximalDiam := result[tunBerlinerMaximalIndex%];
    ' Don't let the user screw this up by selecting incompatible values
    if tunBerlinerMaximalIndex% > tunDonutOptimalIndex%+1 then
        tunDonutOptimalDiam := result[tunDonutOptimalIndex%];
        tunDonutOptimalDiamPlusOne := result[tunDonutOptimalIndex%+1];
        tunBerlinerMaximalDiam := result[tunBerlinerMaximalIndex%];
    else
        i% := 0;  'Treat this as a "cancel"
        if tunBerlinerMaximalIndex% > tunDonutOptimalIndex% then
            message("Oops!|The maximal index was only one value greater than the optimal index!\nThis would result in 'near facilitation' and 'far suppression'\nstimuli being identical!\n\nI know you didn't want that, so try again!");
        else
            message("Oops!|The maximal index was not greater than the optimal index!\n\nI know you didn't want that, so try again!");
        endif;
    endif;
    
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveAreaParameters();
		tunType$ := tunTypeBerliner$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;




' This function is initially called with a "0" input, no function decided yet
' Second tuning curve and OK should be disabled until first curve/second curve
' are selected
' There are now TWO different callback for BoxODonuts depending on whether there is a second screen or not - this is the second screen version
func TuningCurveBoxODonutsDialogChanged%(item%)    
    'This re-enables any disabled buttons if the Box O' Donuts dialog is cancelled
    if item% = 0 then
        DlgEnable(1,-tundlgOrientationButton%);
        DlgEnable(1,-tundlgContrastButton%);
        DlgEnable(1,-tundlgSpatialButton%);
        DlgEnable(1,-tundlgTemporalButton%);
        DlgEnable(1,-tundlgAreaButton%);
        DlgEnable(1,-tundlgXPosButton%);

        
    endif;  
    if tunBoxODonutsCurrentCurve% = 3 then
        DlgEnable(1,-1);  'enable "OK" if both curves have been selected
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    return 1;
end


' This function is initially called with a "0" input, no function decided yet
' Second tuning curve and OK should be disabled until first curve/second curve
' are selected
' There are now TWO different callback for BoxODonuts depending on whether there is a second screen or not - this is the one screen version
func TuningCurveBoxODonutsDialogChanged2%(item%)    
    'This re-enables any disabled buttons if the Box O' Donuts dialog is cancelled
    if item% = 0 then
        DlgEnable(1,-tundlgOrientationButton%);
        DlgEnable(1,-tundlgContrastButton%);
        DlgEnable(1,-tundlgSpatialButton%);
        DlgEnable(1,-tundlgTemporalButton%);
        DlgEnable(1,-tundlgAreaButton%);
        DlgEnable(1,-tundlgXPosButton%);
        DlgEnable(0,3);  'Disable master follows curve 1 checkbox
        DlgEnable(0,-151);  'Disable all two-screen buttons
        DlgEnable(0,-152);
        DlgEnable(0,-153);
        DlgEnable(0,-154);
        
    endif;  
    if tunBoxODonutsCurrentCurve% = 3 then
        DlgEnable(1,-1);  'enable "OK" if both curves have been selected
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    return 1;
end



func TuningCurveBoxODonutsDialog%()
    var sValues$;
    var i%;
    var iReturn%;
    
    GetTuningCurveAreaParameters();   'parameters are still carried in "area", may not be ideal but ought to work 
    
    tunBoxODonutsCurrentCurve% := 1;  'this will be 0 unless we select this tuning curve
    
    tunCurve1Text$ := "Tuning Curve 1 is unselected";
    tunCurve2Text$ := "Tuning Curve 2 is unselected";
    
    
    DlgCreate("Box O' Donuts Parameters");
    
    DlgInteger(1,"Number of repeats",1,100,20);
    DlgCheck(2, "Random Progression", 2, 2);
    DlgCheck(3, "Master Follows Curve 1", 2, 3);
    
    if tunUseLagDialog% = 0 then  'do not show lag tuning for single-vsg
        DlgGroup("Select Two Tuning Curve Types", 1, 4, 47, 6); 
    else
        DlgGroup("Select Two Tuning Curve Types", 1, 4, 59, 6); 
    endif;
    
    updateCurve1Text% := DlgText(tunCurve1Text$, 14, 5, 30);  'this is to keep track of selected tuning curve 1
    updateCurve2Text% := DlgText(tunCurve2Text$, 14, 6, 30);  'this is to keep track of selected tuning curve 2
    DlgButton(tundlgOrientationButton%, " Orientation  ", TuningCurveOrientationDialog%, 2, 8); 'Note that labels for Orientation-Area are superceded 
	DlgButton(tundlgContrastButton%, "     Contrast     ", TuningCurveContrastDialog%, 18, 8);  'by TuningCurveScriptDialogChanged% even upon opening 
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 9);           'the dialog (i.e. whatever label is here is unused)
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 18, 9);
	DlgButton(tundlgAreaButton%, "Area", TuningCurveAreaDialog%, 36, 8);
    DlgButton(tundlgXPosButton%, "X Position", TuningCurveXPosDialog%, 36, 9);
    if tunUseLagDialog% = 1 then  'only show lag tuning for dual-vsg
        DlgButton(tundlgLagButton%, "Lag", TuningCurveNullTestANDLagDialog%, 50, 8);
    endif;
    
    
    
    DlgButton(151, "Master Grating", TunDlgGratingMaster%);
    DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
    DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
    DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
    if DlgValue(10) = 1 then
        DlgAllow(0xffff, 0, TuningCurveBoxODonutsDialogChanged%);
    else
        DlgAllow(0xffff, 0, TuningCurveBoxODonutsDialogChanged2%);
    endif;
    
    
    i% := DlgShow(tunBoxODonutsNRepeats%,tunBoxODonutsProgression%,tunMasterFollowsCurve1%);
    
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	
    tunBoxODonutsCurrentCurve% := 0;  'reset this, we don't need it once this dialog box is closed and it messes up stuff if we want to pick a different tuning curve    
    if i% = 1 then
		SaveTuningCurveAreaParameters();
		tunType$ := tunTypeBoxODonuts$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;   
    
end



func TuningCurveDotsDialog%()
	var iReturn%;
	var i%;
	GetTuningCurveDotsParameters();
	DlgCreate("Run Dots Tuning Curve");
    
    DlgGroup("Tuning Curve Parameters", 1, 1, 47, 6);
	DlgInteger(1, "Number of Steps", 1, 100, 0, 2);
	DlgInteger(2, "Number of Repeats", 1, 10, 0, 3);
	DlgReal(3, "Min Orientation (deg)", 0, 360, 0, 4);
	DlgReal(4, "Max Orientation (deg)", 0, 360, 0, 5);
	DlgCheck(5, "Random Progression", 0, 6);
    
    DlgGroup("Dot Parameters", 1, 7, 47, 7);
    DlgReal(6, "X Position (deg):",  -40, 40, 0, 8);
    DlgReal(7, "Y Position (deg):", -40, 40, 0, 9);
    DlgReal(8, "Diameter (deg):", .1, 30, 0, 10);
    DlgReal(9, "Speed (deg/sec):", 0, 100, 0, 11);
    DlgReal(10, "Density (dots/deg^2):", 0, 200, 0 ,12);
    DlgInteger(11, "Dot Size (pixels):", 0, 50, 0, 13);
    
    DlgGroup("Color", 1, 14, 47, 7);
    DlgInteger(12, "BG Color Red Value:", 0, 255, 0, 15);
    DlgInteger(13, "BG Color Green Value:", 0, 255, 0, 16);
    DlgInteger(14, "BG Color Blue Value:", 0, 255, 0, 17);
    DlgInteger(15, "Dot Color Red Value:", 0, 255, 0, 18);
    DlgInteger(16, "Dot Color Green Value:", 0, 255, 0, 19);
    DlgInteger(17, "Dot Color Blue Value:", 0, 255, 0, 20);

    
    
    'DlgList(12, "Color:", ColorVectorList$[]);  Color, BG color?  
    
    
	i% := DlgShow(tunDotsNSteps%, tunDotsNRepeats%, tunDotsMinOrientation, tunDotsMaxOrientation, tunDotsProgression%, tunDotsX, tunDotsY,
    tunDotsDiameter, tunDotsSpeed, tunDotsDensity, tunDotsSize%, tunDotsBGR%, tunDotsBGG%, tunDotsBGB%, tunDotsFGR%, tunDotsFGG%, tunDotsFGB%);

	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveDotsParameters();
		PrintLog("TuningCurveDotsDialog - user hit OK\n");
		tunType$ := tunTypeDots$;
                
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		PrintLog("TuningCurveDotsDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    PrintLog("Return value is %d\n", iReturn%);
	return iReturn%;
end;




' This function is initially called with a "0" input, no function decided yet
' Second tuning curve and OK should be disabled until first curve/second curve
' are selected
func TuningCurveCRGDialogChanged%(item%)    
    'This re-enables the master/slave listbox if CRG dialog is cancelled (actually not needed)
    'if item% = 0 then
        'DlgEnable(1,5); 
    'endif;  
    if item% = 5 then
        if DlgValue(5) = 0 then
            DlgValue$(updateCurve2Text%,"Contrast Reversing Grating on MASTER");
        else
            DlgValue$(updateCurve2Text%,"Contrast Reversing Grating on SLAVE");
        endif;
    endif;
    if tunCRGCurrentCurve% = 2 then
        DlgEnable(1,-1);  'enable "OK" if curve has been selected
        DlgEnable(0,5);   'and disable the master/slave listbox - can't change this once you've picked a curve
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    return 1;
end


func TuningCurveCRGDialog%()
    'Just copied over Box O Donuts for now
    var sValues$;
    var i%;
    var iReturn%;
    var tunCurveText$;
    var tunCurveCRGText$;
    
    var mylist$[2];
    mylist$[0] := "Master";
    mylist$[1] := "Slave";
    
    GetTuningCurveCRGParameters();    
    
    tunCRGCurrentCurve% := 1;  'this will be 0 unless we select this tuning curve
    
    tunCurveText$ := "Tuning Curve is unselected";
    if tunCRGOnSlave% = 0 then
        tunCurveCRGText$ := "Contrast Reversing Grating on MASTER";
    else
        tunCurveCRGText$ := "Contrast Reversing Grating on SLAVE";
    endif;
    
    
    DlgCreate("Contrast Reversing Grating Parameters");
    
    DlgInteger(1,"# of repeats per CRG sequence",1,100,30,1);
    DlgInteger(2,"# of frames per turn",1,1000,30,2);
    DlgCheck(3, "Random Progression", 2, 3);
    DlgButton(tundlgSelectSEQFileButton%,   "Select Sequence File", SelectSEQFile%,49,3);
    DlgString(4,40,255,"",50,2);  'for visual confirmation of selected seq file
    
    

    DlgGroup("CRG Screen and Tuning Curve Type", 1, 4, 64, 7); 
    DlgList(5, "CRG is on:", mylist$[], 2, 3);
    updateCurve2Text% := DlgText(tunCurveCRGText$, 9, 6, 50);  'this keeps track of which screen holds CRG, 1/2 label got swapped, just rolling with it
    updateCurve1Text% := DlgText(tunCurveText$, 9, 7, 50);  'this is to keep track of selected tuning curve 
    DlgButton(tundlgBlankButton%, "     Blank     ", TuningCurveCRGBlank%, 2, 8);  'for blank screen
    DlgButton(tundlgGratingOnlyButton%, "  Grating Only  ", TuningCurveCRGGratingOnly%, 18, 8);  'for single grating
    DlgButton(tundlgCRG2Button%, "Secondary CRG", TuningCurveCRG2%, 36, 8);  'for secondary CRG
    
    DlgButton(tundlgOrientationButton%, " Orientation  ", TuningCurveOrientationDialog%, 2, 9); 'Note that labels for Orientation-Area are superceded 
	DlgButton(tundlgContrastButton%, "     Contrast     ", TuningCurveContrastDialog%, 18, 9);  'by TuningCurveScriptDialogChanged% even upon opening 
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 10);           'the dialog (i.e. whatever label is here is unused)
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 18, 10);
	DlgButton(tundlgAreaButton%, "         Area         ", TuningCurveAreaDialog%, 36, 9);
    DlgButton(tundlgXPosButton%, "     X Position     ", TuningCurveXPosDialog%, 36, 10);
    DlgButton(tundlgLagButton%, "   Lag   ", TuningCurveNullTestANDLagDialog%, 55, 8);
    
    DlgButton(151, "Master Grating", TunDlgGratingMaster%);
    DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
    DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
    DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
    DlgAllow(0xffff, 0, TuningCurveCRGDialogChanged%);
    
    i% := DlgShow(tunCRGNRepeats%,tunCRGFramesPerFlip%,tunCRGProgression%,tunCRGSeqFile$,tunCRGOnSlave%);
    
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	
    tunCRGCurrentCurve% := 0;  'reset this, we don't need it once this dialog box is closed and it messes up stuff if we want to pick a different tuning curve    
    if i% = 1 then
		SaveTuningCurveCRGParameters();
		tunType$ := tunTypeCRG$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;   
    
end





func TuningCurveCRGBlank%()
'This function is ONLY called from the CRG dialog box, calling from anywhere else would make no sense, don't do it.
    tunCRGCurrentCurve% := 2;
    tunType1$ := tunTypeBlank$;
    if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
        tunCurve1Text$ := "Slave will be BLANK";
    else
        tunCurve1Text$ := "Master will be BLANK";
    endif;
    DlgValue$(updateCurve1Text%, tunCurve1Text$);
    TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    return 1;
end





func TuningCurveCRGGratingOnly%()
'This function is ONLY called from the CRG dialog box, calling from anywhere else would make no sense, don't do it.
    tunCRGCurrentCurve% := 2;
    tunType1$ := tunTypeGratingOnly$;
    if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
        tunCurve1Text$ := "Slave will have STATIC GRATING";
    else
        tunCurve1Text$ := "Master will have STATIC GRATING";
    endif;
    DlgValue$(updateCurve1Text%, tunCurve1Text$);
    TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    'set some contrast values...I think we can get away without committing these to the registry
    'Actually, I'm just going to hard code this in Tuning's CreateSampleConfiguration, should work fine
    'tunContrastNSteps% := 1;
    'tunContrastMinContrast := 0;
    'tunContrastMaxContrast := 100;
    return 1;
end




func TuningCurveCRG2%()
'This function is ONLY called from the CRG dialog box, calling from anywhere else would make no sense, don't do it.
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a secondary CRG sequence file");  'Find a sequence file
    tunCRGSeqFile2$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it 
    
    
    if fh0% > 0  then 'success in opening file 
        tunCRGCurrentCurve% := 2;
        tunType1$ := tunTypeCRG$;
    
        if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
            tunCurve1Text$ := "Slave will have SECONDARY CRG";
        else
            tunCurve1Text$ := "Master will have SECONDARY CRG";
        endif;
        DlgValue$(updateCurve1Text%, tunCurve1Text$);
        TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    endif
    
    return 1;
end





' This function is initially called with a "0" input, which forces the 1, 3, 4 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
'func TuningCurveDanishDialogChanged%(item%)    
    'if item% = 0 then
    '    DlgEnable(0, 1, 3, 4);
    'endif   
    'return 1;
'end

func TuningCurveDanishDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    
	GetTuningCurveDanishParameters();
    
    
	DlgCreate("Danish Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 100);
    'DlgInteger(1, "Number of Stimuli", 1, 100);
	DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Min Outer Diameter", 0.1, 100);
	DlgReal(4, "Max Outer Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgCheck(6, "Include Blank");
    DlgButton(151, "Core Grating", TunDlgGratingCore%);
    DlgButton(152, "Donut Grating", TunDlgGratingDonut%);
    DlgButton(153, "Core Vals -> Donut", TunCoreValsToDonut%);
    DlgButton(154, "Donut Vals -> Core", TunDonutValsToCore%);
    'DlgAllow(0xffff, 0, TuningCurveDanishDialogChanged%);
	
    i% := DlgShow(tunDanishNSteps%, tunDanishNRepeats%, tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter, tunDanishProgression%, tunDanishIncludeBlank%);
    
    'for now, no dummy-proofing


	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveDanishParameters();
		tunType$ := tunTypeDanish$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;



' This function is initially called with a "0" input, which forces the 1, 3, 4 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
'func TuningCurveDSSDialogChanged%(item%)    
'    if item% = 0 then
'        DlgEnable(0, 1, 3, 4);
'    endif   
'    return 1;
'end

func TuningCurveDSSDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    
	GetTuningCurveDSSParameters();
    
    ' Before we proceed, we must generate a list of choices for the optimal diameter. These are based on the most recent run of Area tuning
    ' Note that there are nsteps+1 values. 
    
    'GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, result[], indices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
    'sValues$ := GetRealArrayAsStringSep$(result[0:tunAreaNSteps%+1], indices%[0:tunAreaNSteps%+1], "|");
    
    'We want the default maximal value to be the largest value available when we open the dialog
    'so set tunBerlinerMaximalIndex% appropriately
    'tunBerlinerMaximalIndex% := tunAreaNSteps%;
    
    'Define tunBerlinerNSteps%, because we are no longer doing a tuning curve.
    'tunBerlinerNSteps% := 6;
    
	DlgCreate("DSS Parameters");
    DlgInteger(1, "Number of Trials", 1, 1000);
	DlgInteger(2, "Number of Surround Flashes/Blanks", 1, 1000);
	DlgInteger(3, "Number of 'Blank' Flashes", 0, 500);
	DlgInteger(4, "Number of Flashes per Reward",  1, 100);
    DlgButton(151, "Core Grating", TunDlgGratingMaster%);
    DlgButton(152, "Donut Grating", TunDlgGratingDonut%);
    DlgButton(153, "Core Vals -> Donut", TunCoreValsToDonut%);
    DlgButton(154, "Donut Vals -> Core", TunDonutValsToCore%);
    'DlgAllow(0xffff, 0, TuningCurveDSSDialogChanged%);
	'i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%, tunDonutOptimalIndex%, tunBerlinerMaximalIndex%);
    i% := DlgShow(tunDSSNTrials%,tunDSSNPeriods%, tunDSSNBlanks%, tunDSSNFlashesPerReward%);
    
  
    ' Can't allow too many blanks
    if tunDSSNBlanks%*10 > tunDSSNPeriods% then
        i% := 0;  'Treat this as a "cancel"
        message("Oops!|A maximum of 1/10 of stimuli can be flashes\nTry again!");
    endif;
    
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveDSSParameters();
		tunType$ := tunTypeDSS$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;



func TuningCurveNullTestANDLagDialog%()
    var iReturn% := 0;
    var i%;
    
    if tunUseLagDialog% = 0 then   'DlgValue(11) = 0 then  'run null test dialog
        
        GetTuningCurveNullTestParameters();
        DlgCreate("Null Test Tuning Curve Parameters");
        DlgInteger(1, "Number of Steps", 2, 99);
        DlgInteger(2, "Number of Repeats", 1, 30);
        DlgReal(3, "Start Phase", 0, 360);
        DlgReal(4, "End Phase", 0, 360);
        DlgReal(5, "Transition Frequency (Hz)", 0.1,100);
        DlgCheck(6, "Random Progression");
        DlgCheck(7, "Step Function in Time");
        DlgCheck(8, "Use File For Tuning Values");
        DlgString(9,40,255,"",3);  'for visual confirmation of selected seq file
        DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFileNullTest%, 2, 10);
        DlgAllow(0xffff, 0, TuningCurveNullTestDialogChanged%);
        
        i% := DlgShow(tunNullTestNSteps%, tunNullTestNRepeats%, tunNullTestMinPhase, tunNullTestMaxPhase, tunNullTestTF, tunNullTestProgression%, tunNullTestStepFunc%, tunNullTestUseFile%, tunNullTestTuningFile$);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        ' 
        ' djs 2/4/2011
        ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
        ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
        ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
        ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
        ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
        ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
        ' before things proceed. 
        'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
        if i% = 1 then
            SaveTuningCurveNullTestParameters();
            '		PrintLog("TuningCurveAreaDialog - user hit OK\n");
            tunType$ := tunTypeNullTest$;
            tunUseFile% := tunNullTestUseFile%;
            tunTuningFile$ := tunNullTestTuningFile$;
            
            'Reset dialog OK button text on Select dialog, and note which experiment to run
            'DlgValue$(-1,"Run Null Test");
            'TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
            'TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            
            if tunContext$ = tunContextDAQ$ then
                ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
                iReturn% := 1;
            else
                iReturn% := 1;
            endif;
        endif;
        if i% = 0 then
            '		PrintLog("TuningCurveNullTestDialog - user hit Cancel\n");
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
            'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
            'DlgValue$(-1,"Select Expt.");
            'TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
            'TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
        endif;
        
        return iReturn%;
        
    else 'run Lag tuning dialog
        
        var checkint;  'checking to make sure the number of frames will work
        
        GetTuningCurveLagParameters();
        DlgCreate("Lag Tuning Curve Parameters",0,0,62);
        DlgInteger(1, "Number of Steps", 1, 100,30,1);
        'DlgInteger(2, "Number of Repeats", 1, 10);
        DlgInteger(3, "Min Lag (frames)", 0, 1000,30,3);
        DlgInteger(4, "Max Lag (frames)", 0, 1000,30,4);
        'DlgCheck(5, "Random Progression");
        DlgCheck(6, "Use File For Tuning Values");
        DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
        DlgString(8,11,255,"",50,3);  DlgText("(ms)",45,3);
        DlgString(9,11,255,"",50,4);  DlgText("(ms)",45,4);
        DlgCheck(10,"Master Screen is Lagged",29,5);
        DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
        if tunBoxODonutsCurrentCurve% = 0 then
            DlgInteger(2, "Number of Repeats", 1, 1000,30,2);
            DlgCheck(5, "Random Progression");
        else
            DlgInteger(2, "----------------", 1, 1,30,2);
            DlgCheck(5, "----------------");
        endif;
        DlgAllow(0xffff, 0, TuningCurveLagDialogChanged%);
        
        i% := DlgShow(tunLagNSteps%, tunLagNRepeats%, tunLagMinLagFrames%, tunLagMaxLagFrames%, tunLagProgression%, tunLagUseFile%, tunLagTuningFile$, tunLagFrames1$, tunLagFrames2$,tunLagMasterIsLagged%);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
        ' djs 2/4/2011
        ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
        ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
        ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
        ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
        ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
        ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
        ' before things proceed. 
        
        'First things first, check the lag to make sure it will work
        if i% = 1 then
            tunLagMinLagFrames := tunLagMinLagFrames%;  'prepare for non-integer math
            tunLagMaxLagFrames := tunLagMaxLagFrames%;
            checkint := frac((tunLagMaxLagFrames-tunLagMinLagFrames)/tunLagNSteps%);
            'if lag will not work, note this and return as if canceled
            if checkint <> 0 then     
                message("The given number of steps will not create integer frame counts!  Try again!");
                i% := 0;
            endif;
        endif;
        
        if i% = 1 then
            SaveTuningCurveLagParameters();
            '		PrintLog("TuningCurveLagDialog - user hit OK\n");
            tunType$ := tunTypeLag$;
            tunUseFile% := tunLagUseFile%;
            tunTuningFile$ := tunLagTuningFile$;
            
            'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
            docase
            case tunBoxODonutsCurrentCurve% = 1 then
                tunType1$ := tunTypeLag$;
                tunUseFile1% := tunLagUseFile%;
                tunTuningFile1$ := tunLagTuningFile$;
                tunCurve1Text$ := "Tuning Curve 1 is LAG";
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                tunBoxODonutsCurrentCurve% := 2;  'update current curve 
                DlgEnable(0,-tundlgLagButton%);  'So we don't pick lag again
            case tunBoxODonutsCurrentCurve% = 2 then
                tunType2$ := tunTypeLag$;
                tunUseFile2% := tunLagUseFile%;
                tunTuningFile2$ := tunLagTuningFile$;
                tunCurve2Text$ := "Tuning Curve 2 is LAG";
                DlgValue$(updateCurve2Text%, tunCurve2Text$);
                tunBoxODonutsCurrentCurve% := 3;  'update current curve 
                DlgEnable(0,-tundlgLagButton%);  'So we don't pick lag again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            case tunCRGCurrentCurve% = 1 then
                tunCRGCurrentCurve% := 2;
                tunType1$ := tunTypeLag$;
                if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                    tunCurve1Text$ := "Tuning Curve on Slave is LAG";
                else
                    tunCurve1Text$ := "Tuning Curve on Master is LAG";
                endif;
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            endcase;
            
            
            if tunContext$ = tunContextDAQ$ then
                ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
                iReturn% := 1;
            else
                iReturn% := 1;
            endif;
        endif;
        if i% = 0 then
            '		PrintLog("TuningCurveLagDialog - user hit Cancel\n");
            tunType$ := tunTypeNone$;
            if tunContext$ = tunContextDAQ$ then
                iReturn% := 1;
            else
                iReturn% := 2;
            endif;
        endif;
        
        return iReturn%;
    endif;
    
        
end;


func TuningCurveLagDialogChanged%(item%)
    'This single dialog changed function can be used for ALL the tuning dialogs that allow file-based tuning curves
    '(at least currently) because they all have the same structure and therefore the same dialog positions to allow/disallow
    DlgValue$(8,Str$(DlgValue(3)*1000/dataScreenHz));  'just set the text values of the frame to millisecond conversion every time
    DlgValue$(9,Str$(DlgValue(4)*1000/dataScreenHz));
    DlgEnable(0,8);  'Always disable millisecond conversion, we can't type here to get frame values
    DlgEnable(0,9); 
    if DlgValue(6) = 0 then  'If we are not using a tuning file
        DlgEnable(0,7);  'disable the string box with the text file name (button still works)
        DlgEnable(1,1);  'enable nSteps, min, and max
        DlgEnable(1,3);
        DlgEnable(1,4);
    endif;
    if DlgValue(6) = 1 then
        DlgEnable(1,7);  'enable the string box with the text file name
        DlgEnable(0,1);  'disable nSteps, min, and max
        DlgEnable(0,3);
        DlgEnable(0,4);
    endif;
    return 1;
end


func TuningCurveNullTestDialogChanged%(item%)
    'The Null Test dialog has extra entries below, moving the tested checkbox to position 8 and the DlgString to 9
    if DlgValue(8) = 0 then  'If we are not using a tuning file
        DlgEnable(0,9);  'disable the string box with the text file name (button still works)
        DlgEnable(1,1);  'enable nSteps, min, and max
        DlgEnable(1,3);
        DlgEnable(1,4);
    endif;
    if DlgValue(8) = 1 then
        DlgEnable(1,9);  'enable the string box with the text file name
        DlgEnable(0,1);  'disable nSteps, min, and max
        DlgEnable(0,3);
        DlgEnable(0,4);
    endif;
    return 1;
end


func SelectTuningFileNullTest%()
    'This generic function ought to work for any of the dialogs where we allow the selection of a tuning file
    'This is the same as the regular file, but the string dialog entry is in a different location for the null test.
    'It would have been really cool to have this function take an argument, but I tried that and it automatically ran
    'the function without the button being pressed as soon as the parent dialog was open, so that's a no-go.

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a tuning file");  'Find a tuning file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(9,direc$);  'Place filename into dialog item 9 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;


func TunDlgGratingMaster%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Stimulus");
    i% := GratingParametersDialogMaster%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("Stimulus", tunGratingParams$);
        SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end



func TunDlgGratingSlave%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("SlaveStimulus");
    i% := GratingParametersDialogSlave%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("SlaveStimulus", tunGratingParams$);
        SaveGratingParameters("StatSlaveStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end


func TunDlgGratingCore%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Stimulus");
    i% := GratingParametersDialogCore%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("Stimulus", tunGratingParams$);
        SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end


func TunDlgGratingDonut%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Distractor1");
    i% := GratingParametersDialogDonut%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("Distractor1", tunGratingParams$);
        'SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end


func GratingParametersDialogMaster%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    
	var i% := 15;  'That's right, 15, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 15 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 10);
        DlgReal(9, "Temporal Freq:", 0, 10);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern:", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgButton(15, "Copy from Slave", TunCopySlaveVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
        Convert180(phase);
        
    wend;
      
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif
    return i%;
end;

func GratingParametersDialogSlave%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    
	var i% := 15;  'That's right, 15, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 15 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 10);
        DlgReal(9, "Temporal Freq:", 0, 10);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern:", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgButton(15, "Copy From Master", TunCopyMasterVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
        Convert180(phase);
        
    wend;
    
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif;
    return i%;
end;


func GratingParametersDialogCore%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    
	var i% := 15;  'That's right, 15, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 15 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 10);
        DlgReal(9, "Temporal Freq:", 0, 10);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern:", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgButton(15, "Copy from Donut!", TunCopyDonutVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
        Convert180(phase);
        
    wend;
      
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters, not using static but easier to just leave it in
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif
    return i%;
end;



func GratingParametersDialogDonut%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    
	var i% := 15;  'That's right, 15, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 15 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 10);
        DlgReal(9, "Temporal Freq:", 0, 10);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern:", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgButton(15, "Copy From Core", TunCopyCoreVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
        Convert180(phase);
        
    wend;
    
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters, not using static but easier to just leave it in
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif;
    return i%;
end;



func TunCopySlaveVals%(&param$)

    param$ := GetGratingParameters$("SlaveStimulus");

    return 1;
end



func TunCopyMasterVals%(&param$)

    param$ := GetGratingParameters$("Stimulus");

    return 1;
end


func TunCopyDonutVals%(&param$)
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    'Simply using "Distractor1" rather than making a separate "Donut" grating, can change if it's a problem
    param$ := GetGratingParameters$("Distractor1");
    ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    w := iw;  'set grating width to make a core that fits inside the donut, of zero inner diameter
    h := ih;
    iw := 0;
    ih := 0;
    param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);


    return 1;
end

func TunCopyCoreVals%(&param$)
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;    
    
    param$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    iw := w;  'set grating width to make a donut that surrounds the core, of arbitrary width
    ih := h;
    w := iw+1;
    h := ih+1;
    param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);

    return 1;
end


func TunMasterValsToSlave%()
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("Stimulus");
    SaveGratingParameters("SlaveStimulus", tempParams$);
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
    SaveGratingParameters("StatSlaveStimulus", tempParams$);
    
    return 1;
end


func TunSlaveValsToMaster%()
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("SlaveStimulus");
    SaveGratingParameters("Stimulus", tempParams$);
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
    SaveGratingParameters("StatStimulus", tempParams$);
    
    return 1;
end


func TunCoreValsToDonut%()
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    iw := w;  'set grating width to make a donut that surrounds the core, of arbitrary width
    ih := h;
    w := iw+1;
    h := ih+1;
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    SaveGratingParameters("Distractor1", tempParams$);
    
    return 1;
end


func TunDonutValsToCore%()
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("Distractor1");
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    w := iw;  'set grating width to make a core that fits inside the donut, of zero inner diameter
    h := ih;
    iw := 0;
    ih := 0;
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    SaveGratingParameters("Stimulus", tempParams$);
    
    return 1;
end


func TuningXHairDialog%()
    DlgCreate("Crosshair/Grid");
    DlgCheck(1, "Use crosshair grid");
    DlgReal(2, "Grid inner radius offset", 0, 100);
    DlgReal(3, "Grid mid radius offset", 0, 100);
    DlgReal(4, "Grid outer radius offset", 0, 100);
    DlgInteger(5, "Number of divisions in grid", 2, 128);
    DlgReal(6, "XHair inner offset", -1, 100);
    DlgReal(7, "XHair outer offset", -1, 100);
    DlgAllow(0xffff, 0, TuningXHairDialogChanged%);
    DlgShow(tunUseXHairs%, tunXHairInnerRadiusOffset, tunXHairMiddleRadiusOffset, tunXHairOuterRadiusOffset, tunXHairNumGridDivisions%, tunXHairTicInnerOffset, tunXHairTicOuterOffset);
    return 1;
end


func TuningXHairDialogChanged%(item%)
    docase 
    case item% = 0 then
        DlgEnable(tunUseXHairs%, 2, 3, 4, 5, 6, 7);
    case item% = 1 then
        DlgEnable(DlgValue(1), 2, 3, 4, 5, 6, 7);
    endcase
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve main dialog START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




proc GetTuningCurveScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
	tunFixationDuration := GetFloatRegistryValue(key$, "FixationDuration", tunFixationDuration);
    tunUseMaintainMode% := GetIntRegistryValue%(key$, "UseMaintainMode", tunUseMaintainMode%);
	tunMaintainFixation := GetFloatRegistryValue(key$, "MaintainFixation", tunMaintainFixation);
    tunAcquisitionTime := GetFloatRegistryValue(key$, "AcquisitionTime", tunAcquisitionTime);
    tunStimulusOnsetDelay := GetFloatRegistryValue(key$, "StimulusOnsetDelay", tunStimulusOnsetDelay);
    tunAcqFailTime := GetFloatRegistryValue(key$, "AcqFailTime", tunAcqFailTime);
    tunHoldFailTime := GetFloatRegistryValue(key$, "HoldFailTime", tunHoldFailTime);
    tunMaintainFailTime := GetFloatRegistryValue(key$, "MaintainFailTime", tunMaintainFailTime);
    tunStdInterTrialTime := GetFloatRegistryValue(key$, "StdInterTrialTime", tunStdInterTrialTime);
    tunBackgroundColor$ := GetStringRegistryValue$(key$, "BackgroundColor", tunBackgroundColor$);
    tunDoRivalry% := GetIntRegistryValue%(key$, "DoRivalry", tunDoRivalry%);
    tunDualTuningType% := GetIntRegistryValue%(key$, "DualTuningType", tunDualTuningType%);
    tunUseXHairs% := GetIntRegistryValue%(key$, "UseXHairs", tunUseXHairs%);
    tunXHairInnerRadiusOffset := GetFloatRegistryValue(key$, "XHairInnerRadiusOffset", tunXHairInnerRadiusOffset);
    tunXHairMiddleRadiusOffset := GetFloatRegistryValue(key$, "XHairMiddleRadiusOffset", tunXHairMiddleRadiusOffset);
    tunXHairOuterRadiusOffset := GetFloatRegistryValue(key$, "XHairOuterRadiusOffset", tunXHairOuterRadiusOffset);
    tunXHairTicInnerOffset := GetFloatRegistryValue(key$, "XHairTicInnerOffset", tunXHairTicInnerOffset);
    tunXHairTicOuterOffset := GetFloatRegistryValue(key$, "XHairTicOuterOffset", tunXHairTicOuterOffset);
    tunXHairNumGridDivisions% := GetIntRegistryValue%(key$, "XHairNumGridDivisions", tunXHairNumGridDivisions%);
    tunButtonCollect% := GetIntRegistryValue%(key$, "ButtonCollect", tunButtonCollect%);
    tunDoTuningHist% := GetIntRegistryValue%(key$, "DoTuningHist", tunDoTuningHist%);
    tunUseConstantLag% := GetIntRegistryValue%(key$, "UseConstantLag", tunUseConstantLag%);
    tunConstantLagFrames% := GetIntRegistryValue%(key$, "ConstantLagFrames", tunConstantLagFrames%);
end;

proc SaveTuningCurveScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
	SetFloatRegistryValue(key$, "FixationDuration", tunFixationDuration);
    SetIntRegistryValue(key$, "UseMaintainMode", tunUseMaintainMode%);
	SetFloatRegistryValue(key$, "MaintainFixation", tunMaintainFixation);
    SetFloatRegistryValue(key$, "AcquisitionTime", tunAcquisitionTime);
    SetFloatRegistryValue(key$, "StimulusOnsetDelay", tunStimulusOnsetDelay);
    SetFloatRegistryValue(key$, "AcqFailTime", tunAcqFailTime);
    SetFloatRegistryValue(key$, "HoldFailTime", tunHoldFailTime);
    SetFloatRegistryValue(key$, "MaintainFailTime", tunMaintainFailTime);
    SetFloatRegistryValue(key$, "StdInterTrialTime", tunStdInterTrialTime);
    SetStringRegistryValue(key$, "BackgroundColor", tunBackgroundColor$);
    SetIntRegistryValue(key$, "DoRivalry", tunDoRivalry%);
    SetIntRegistryValue(key$, "DualTuningType", tunDualTuningType%);
    SetIntRegistryValue(key$, "UseXHairs", tunUseXHairs%);
    SetFloatRegistryValue(key$, "XHairInnerRadiusOffset", tunXHairInnerRadiusOffset);
    SetFloatRegistryValue(key$, "XHairMiddleRadiusOffset", tunXHairMiddleRadiusOffset);
    SetFloatRegistryValue(key$, "XHairOuterRadiusOffset", tunXHairOuterRadiusOffset);
    SetFloatRegistryValue(key$, "XHairTicInnerOffset", tunXHairTicInnerOffset);
    SetFloatRegistryValue(key$, "XHairTicOuterOffset", tunXHairTicOuterOffset);
    SetIntRegistryValue(key$, "XHairNumGridDivisions", tunXHairNumGridDivisions%);
    SetIntRegistryValue(key$, "ButtonCollect", tunButtonCollect%);
    SetIntRegistryValue(key$, "DoTuningHist", tunDoTuningHist%);

    PrintLog("Saved DoRivalry=%d\n", tunDoRivalry%);
end;


' TuningCurveScriptDialog
' This dialog uses two global variables, tunContext$ and tunType$. 
' Set tunContext$ = tunContextConfig$ to run in the config scripts. The dialog 
' and its children (TuningCurveOrientationDialog, etc) will behave as expected, 
' allowing the user to set parameters and saving them in the registry. Set 
' tunContext$ = tunContextDAQ$ to run in a DAQ script. In this context you 
' must check the return value of the dialog and (possibly) the value of 
' tunType$. If the user hits Cancel in the main dialog, the return value is 0. 
' If the user selects a subdialog and hits OK, the return value will be 1 and 
' the value of tunType$ will be one of (tunTypeOrientation$, tunTypeContrast$, 
' tunTypeSpatial$, tunTypeTemporal$). Here, proceed directly to DAQ. If the 
' user Hits Cancel from the subdialog, then they return to the main dialog. If 
' they hit OK from the main dialog, then the return value is 1, but 
' tunType$ = tunTypeNone$. 


func TuningCurveScriptDialog%()
	var i%;
	var iReturn%;
    var tempParam$;
    var tempPhase;
    var boxOK% := 1;  'do the stimulus/crosshairs boxes overlap?
	GetTuningCurveScriptParameters();
    GetTunOptoParameters();  'We must get these or the user has to open the opto dialog every time.
	var bcl$[3];
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
    var ibcl%:=0;
    var constantLag$[3];
    constantLag$[0] := "No Constant Lag";
    constantLag$[1] := "Lag On Master";
    constantLag$[2] := "Lag On Slave";
    var dualType$[3];
    dualType$[0] := "Dual Tuning";
    dualType$[1] := "Master only";
    dualType$[2] := "Slave only";
    var maintainList$[5];
    maintainList$[0] := "Nothing";
    maintainList$[1] := "FixOnly";  
    maintainList$[2] := "Fix+Rwd";
    maintainList$[3] := "Core+Fix";
    maintainList$[4] := "C+F+Rwd";
    'these are for the addition of the stationary function to the standard tuning curves
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    var tempParams$;
        
    
	for i%:=0 to 2 do
		if tunBackgroundColor$ = bcl$[i%] then
			ibcl% := i%;
		endif
	next;
    
    docase 
    case tunUseXHairs% = 0 then
        tunXHairText$ := "Crosshairs are OFF";
    case tunUseXHairs% = 1 then
        tunXHairText$ := "Crosshairs are ON";
    endcase
    
    'Updated dialog box - more efficient use of space, neater
    DlgCreate("Tuning Curve Parameters", 0, 0, 0, 0, -1, 1, 1);  'center dialog relative to screen and not to application window to eliminate cutting off the bottom of the dialog!
	DlgGroup("Common Parameters", 1, 1, 52, 10);
	DlgReal(1, "Acquire Fixation time(s):", 1, 1000, 40, 2);
    DlgReal(2, "Acquire Fixation penalty(s):", .01, 10, 40, 3);
    DlgReal(3, "Stimulus onset delay(s):", 0, 10, 40, 4);
	DlgReal(4, "Stimulus duration(s):", .1, 60, 40, 5);
    DlgReal(5, "During-Stim fixation break penalty(s):", .01, 10, 40, 6);
    DlgReal(6, "Intertrial interval(s):", .01, 10, 40, 7);
	DlgReal(7, "Maintain fixation after stim(s):", .1, 10, 40, 8);
	DlgReal(8, "Maintain fixation after stim penalty(s):", .01, 10, 40, 9);
	DlgList(9, "Background color:", bcl$, 3, 34, 10);
    if JuicerType% = 1 then
        DlgInteger(10, "Juicer open dur. (ms):", 1, 2000, 40, 11);
    else  'JuicerResult should only be 2, other values should not allow access to dialog box
        DlgInteger(10, "Num. juicer pulses:", 1, 20, 40, 11);
    endif;   
    'juicer duration / n repeats dialog here?  Have to write values to DAQ parameters if changed, disable if not correct for juicer? 
    DlgGroup("Dual VSG Options", 1, 12, 52, 4);
    DlgCheck(11, "Use Dual VSG", 2, 13);
    'DlgCheck(12, "Select to turn off card sync", 25, 13);
    DlgInteger(18, 2, 0, 50, 20, 13); DlgText("<-(Frames) Constant Lag (ms)->",22,13); DlgString(19,5,255,"",48,13);
    DlgList(17, "Use Constant Lag?", constantLag$, 3, 25, 14); 
    DlgList(12, "Dual Tuning Configuration:", dualType$, 3, 25, 15);
    
    'DlgCheck(13, "Maintain Fixpt between trials", 2, 14);  'change this to a list
    DlgList(13, 11, maintainList$, 5, 3, 16); DlgText("Maintain what btwn trls", 15, 16);
    DlgCheck(14, "Stationary",2,17);
    DlgCheck(15, "Make Histograms", 35,16);
    DlgCheck(16, "Use Rivalry Button", 35,17);
    DlgButton(tundlgXHairButton%, " Crosshairs  ", UpdateTuningXHairDialog%, 1, 18);
    updateXHairText% := DlgText(tunXHairText$, 15, 18);
    
    DlgCheck(20,"Opto On",2,19);
    DlgButton(tundlgOptogeneticsButton%, "Optogenetics Parameters", TunOptoDialog%, 18, 19);    
    
    
	DlgGroup("Individual Tuning Curve Types", 1, 20, 52, 6);
	DlgButton(tundlgOrientationButton%, " Orientation  ", TuningCurveOrientationDialog%, 2, 21); 'Note that labels for Orientation-Area are superceded 
	DlgButton(tundlgContrastButton%, "     Contrast     ", TuningCurveContrastDialog%, 18, 21);  'by TuningCurveScriptDialogChanged% even upon opening 
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 22);           'the dialog (i.e. whatever label is here is unused)
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 18, 22);
	DlgButton(tundlgAreaButton%, "         Area         ", TuningCurveAreaDialog%, 36, 21);
    DlgButton(tundlgXPosButton%, "     X Position     ", TuningCurveXPosDialog%, 36, 22);
	DlgButton(tundlgDonutButton%, "   Donuts!   ", TuningCurveDonutDialog%, 2, 23);
    DlgButton(tundlgBerlinerButton%, "    Berliners!    ", TuningCurveBerlinerDialog%, 18, 23);
    DlgButton(tundlgBoxODonutsButton%, " Box O' Donuts ", TuningCurveBoxODonutsDialog%, 36, 23);
    DlgButton(tundlgDotsButton%, "     Dots!     ", TuningCurveDotsDialog%, 2, 24);
    DlgButton(tundlgCRGButton%,"      CRaGs      ",TuningCurveCRGDialog%, 18, 24);
    DlgButton(tundlgDisparityButton%, "      Disparity      ", TuningCurveDisparityDialog%, 36, 24);
    DlgButton(tundlgDanishButton%, "  Danishes!  ", TuningCurveDanishDialog%, 2, 25);
    DlgButton(tundlgDSSButton%,"        DSS        ",TuningCurveDSSDialog%, 18, 25);
    DlgButton(tundlgNullTestANDLagButton%,"      Null Test     ",TuningCurveNullTestANDLagDialog%, 36, 25);
    DlgAllow(0xffff, 0, TuningCurveScriptDialogChanged%);
	
    if JuicerType% = 1 then
        i%:=DlgShow(tunAcquisitionTime, tunAcqFailTime, tunStimulusOnsetDelay, tunFixationDuration, tunHoldFailTime, 
        tunStdInterTrialTime, tunMaintainFixation, tunMaintainFailTime,
        ibcl%, JuiceRewardMS%, tunDoRivalry%,  
        tunDualTuningType%, tunUseMaintainMode%, tunSetStationary%, tunDoTuningHist%, tunButtonCollect%,
        tunUseConstantLag%,tunConstantLagFrames%,tunConstantLagMS$,tunDoOpto%);
    else
        i%:=DlgShow(tunAcquisitionTime, tunAcqFailTime, tunStimulusOnsetDelay, tunFixationDuration, tunHoldFailTime, 
        tunStdInterTrialTime, tunMaintainFixation, tunMaintainFailTime, 
        ibcl%, JuicePerReward%, tunDoRivalry%,  
        tunDualTuningType%, tunUseMaintainMode%, tunSetStationary%, tunDoTuningHist%, tunButtonCollect%,
        tunUseConstantLag%,tunConstantLagFrames%,tunConstantLagMS$,tunDoOpto%);
    endif;
    
    
    ' djs 4-1-09
    ' Spike2 v6 change. DlgShow will return the button number when a button on the dialog is hit and the corresponding
    ' function returns 0. In this case those buttons open the various tuning type sub dialogs (orientation, area, etc). 
    ' In the last version, DlgShow would return the same value that the subdialog's function returned, and the code here
    ' was set up to behave accordingly. When the user hits the Cancel button in the subdialog everything still remains
    ' the same. 
    
    ' djs 2-4-2011
    ' Spike2v6 bug (see TuningDialogs.s2s) workaround requires that the tuning type dialogs return something > 0. 
    ' That will mean that closing any of those dialogs will not cause the main dialog (this one) to close automatically. 
    ' When it did close automatically the return value from DlgShow above was the same as the button that caused
    ' the close. Now, that button is NOT causing the close, so the return value is going to be 1 (not the button number). 
    ' In addition, the return value from this function needs to change because we now assume that the user will have
    ' to hit OK on this dialog to start the experiment. Thus, make sure that the return value from this function is 1
    ' when user hits OK and 0 when user hits Cancel. Also, do not save script parameters when user hits Cancel.
    
    'PrintLog("Tuning Curve Parameters Dialog - return from DlgShow is %d\n", i%);
    '	if i%=tundlgOrientationButton% or i%=tundlgContrastButton% or i%=tundlgSpatialButton% or i%=tundlgTemporalButton% or i%=tundlgAreaButton% then
    if i% = 1 then
		tunBackgroundColor$ := bcl$[ibcl%];
		SaveTuningCurveScriptParameters();
        SaveDAQParameters();  'Now saving DAQ parameters because juicer variables can change
        tunDSSDuration := tunFixationDuration;  'just setting this no matter what, not much reason to put in an IF
		if tunContext$ = tunContextDAQ$ then 
            iReturn% := 1;
		else iReturn% := 1;
		endif;
        
        'do not allow incorrect maintain mode - 2&3 are only legal for danishes
        if tunUseMaintainMode% > 2 and tunType$ <> tunTypeDanish$ and tunType$ <> tunTypeDSS$ then
            tunUseMaintainMode% := tunUseMaintainMode%-2;
            message("You cannot maintain core unless this is a Danish/DSS scenario, only maintaining fixation point!");
        endif;
        'furthermore...
        if tunUseMaintainMode% > 2 and tunType$ = tunTypeDanish$ then
            message("Maintain core is currently BROKEN for Danishes.  Sorry, not maintaining core.");
            tunUseMaintainMode% := tunUseMaintainMode%-2;
        endif;
        
        'check to make sure that the box for the crosshairs and stimuli do not overlap
        'this would work if it only got the maximum value of the size of the stimuli
        if tunUseXHairs% = 1 and (tunType$ = tunTypeBerliner$ or tunType$ = tunTypeDonut$) then
            tempParam$ := GetGratingParameters$("Stimulus");
            boxOK% := CheckXHairStimulusBox(tempParam$,tunXHairOuterRadiusOffset,tunMaximalDiam);
            if boxOK% = 0 then
                boxOK% := Query("The stimulus will overlap the crosshairs!","Continue","Quit");
            endif;           
            if boxOK% = 1 then
                tempParam$ := GetGratingParameters$("SlaveStimulus");
                boxOK% := CheckXHairStimulusBox(tempParam$,tunXHairOuterRadiusOffset,tunSlaveMaximalDiam);
                if boxOK% = 0 then
                    boxOK% := Query("The slave stimulus will overlap the crosshairs!","Continue","Quit");
                endif;
            endif;
            if boxOK% = 0 then
                iReturn% := 0;  'quit if user requested quit
            endif;
        endif;  
        
        'check to see if tunSetStationary is set for the "standard" tuning curves
        if tunSetStationary% = 1 then
            'Check for one of the five "standard" tuning curves that are not temporal - obviously stationary does not work with temporal tuning curves
            if (tunType$ = tunTypeOrientation$ or tunType$ = tunTypeContrast$ or tunType$ = tunTypeSpatial$ or tunType$ = tunTypeArea$ or tunType$ = tunTypeXYPos$ or tunType$ = tunTypeBoxODonuts$) and tunDoRivalry% = 0 then
                tempParams$ := GetGratingParameters$("Stimulus");
                ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
                tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
                SaveGratingParameters("StatStimulus", tempParams$);
            else
                if tunDoRivalry% = 1 then
                    message("The Stationary option is not defined for Dual VSG.  If you wish to change this, \nsee your local programmer.  Quitting.");
                else
                    message("The Stationary option is not defined for tuning type '" + tunType$ + "'.  If you wish to change this, \nsee your local programmer.  Quitting.");
                endif;
                iReturn% := 0;
            endif;
        endif
        
        'just make sure we don't have trouble with constant lag if there is no dual tuning - may not be needed but still...
        if tunDoRivalry% = 0 then
            tunUseConstantLag% := 0;
        endif;
        
        
	endif;
	if i% = 0 then
		'PrintLog("Tuning Curve Parameters dialog - user hit Cancel, tunType=" + tunType$ + "\n");
		if tunContext$ = tunContextDAQ$ then 
			if tunType$ <> tunTypeNone$ then 
				iReturn% := 0;
				'SaveTuningCurveScriptParameters();
			else iReturn% := 0;
		 	endif;
		else
			iReturn% := 2;		' The calling/main dialog would close if we returned 0
		endif;
	endif;
	return iReturn%;
end;



func TuningCurveScriptDialogChanged%(item%) 
    DlgValue$(19,Str$(DlgValue(18)*1000/dataScreenHz));  'just set the text values of the frame to millisecond conversion every time
    DlgEnable(0,19);  'Always disable millisecond conversion, we can't type here to get frame values
    if DlgValue(11) = 0 then  'If single VSG, do not allow Donuts or Berliners or disparity or CRG
        'DlgEnable(0,-tundlgDonutButton%,-tundlgBerlinerButton%,-tundlgBoxODonutsButton%,-tundlgCRGButton%,-tundlgDisparityButton%); 'old version
        DlgEnable(0,-tundlgDonutButton%,-tundlgBerlinerButton%,-tundlgCRGButton%,-tundlgDisparityButton%);  'allow boxOdonuts for single screen now
        'Also disable card synch functions, dual tuning listbox
        DlgEnable(0,12); 'dual tuning listbox
        DlgEnable(0,17); 'constant lag listbox
        DlgEnable(0,18); 'constant lag frames box
        'But do allow Dots, Danish, DSS, Null Test
        DlgEnable(1,-tundlgDotsButton%);
        DlgEnable(1,-tundlgDanishButton%);
        DlgEnable(1,-tundlgDSSButton%);
        'DlgEnable(1,-tundlgNullTestANDLagButton%);  'this is now NullTest/Lag, don't enable/disable
        'Also, change labels on buttons to reflect the monocular aspect of not using dual VSG
        DlgValue$(-tundlgOrientationButton%, " Orientation  ");
        DlgValue$(-tundlgContrastButton%, "     Contrast     ");
        DlgValue$(-tundlgSpatialButton%, "Spatial Freq");
        DlgValue$(-tundlgTemporalButton%, "Temporal Freq");
        DlgValue$(-tundlgAreaButton%, "Area");
        DlgValue$(-tundlgXPosButton%, "XY Position");
        DlgValue$(-tundlgNullTestANDLagButton%, "      Null Test     ");
        tunUseLagDialog% := 0;
    endif;
    if DlgValue(11) = 1 then  'If dual VSG, allow donuts and Berliners and disparity and CRG
        'DlgEnable(1,-tundlgDonutButton%,-tundlgBerlinerButton%,-tundlgBoxODonutsButton%,-tundlgCRGButton%,-tundlgDisparityButton%);  'old version
        DlgEnable(1,-tundlgDonutButton%,-tundlgBerlinerButton%,-tundlgCRGButton%,-tundlgDisparityButton%);  'allow boxOdonuts for single screen now
        'Also allow turning off card synch, dual tuning listbox
        DlgEnable(1,12);  'dual tuning listbox
        DlgEnable(1,17); 'constant lag listbox
        DlgEnable(1,18); 'constant lag frames box
        'But don't allow Dots, Danish, DSS, Null test
        DlgEnable(0,-tundlgDotsButton%);
        DlgEnable(0,-tundlgDanishButton%);
        DlgEnable(0,-tundlgDSSButton%);
        'DlgEnable(0,-tundlgNullTestANDLagButton%);  'this is now NullTest/Lag, don't enable/disable
        'Also, change labels on buttons to reflect the binocular aspect of using dual VSG
        docase 
        case DlgValue(12) = 0 then
            DlgValue$(-tundlgOrientationButton%, " D Orientation ");
            DlgValue$(-tundlgContrastButton%, "    D Contrast    ");
            DlgValue$(-tundlgSpatialButton%, "D Spatial Freq");
            DlgValue$(-tundlgTemporalButton%, "D Temporal Freq");
            DlgValue$(-tundlgAreaButton%, "D Area");
            DlgValue$(-tundlgXPosButton%, "D X Position");
            DlgValue$(-tundlgNullTestANDLagButton%, "        Lag        ");
        case DlgValue(12) = 1 then
            DlgValue$(-tundlgOrientationButton%, " M Orientation ");
            DlgValue$(-tundlgContrastButton%, "    M Contrast    ");
            DlgValue$(-tundlgSpatialButton%, "M Spatial Freq");
            DlgValue$(-tundlgTemporalButton%, "M Temporal Freq");
            DlgValue$(-tundlgAreaButton%, "M Area");
            DlgValue$(-tundlgXPosButton%, "M X Position");
            DlgValue$(-tundlgNullTestANDLagButton%, "        Lag        ");
        case DlgValue(12) = 2 then
            DlgValue$(-tundlgOrientationButton%, " S Orientation ");
            DlgValue$(-tundlgContrastButton%, "    S Contrast    ");
            DlgValue$(-tundlgSpatialButton%, "S Spatial Freq");
            DlgValue$(-tundlgTemporalButton%, "S Temporal Freq");
            DlgValue$(-tundlgAreaButton%, "S Area");
            DlgValue$(-tundlgXPosButton%, "S X Position");
            DlgValue$(-tundlgNullTestANDLagButton%, "        Lag        ");
        endcase;
        tunUseLagDialog% := 1;
    endif;
    if DlgValue(13) = 0 then 'disable maintain mode timing if not using maintain mode
        DlgEnable(0,7);
        DlgEnable(0,8);
    endif;
    if DlgValue(13) = 1 then 'enable maintain mode timing if using maintain mode
        DlgEnable(1,7);
        DlgEnable(1,8);
    endif;
    return 1;
end




func TunOptoDialog%()
	var iReturn% := 1;
	var i%;
    var labels$[4];
    var stimdur;
    var tempNPulses%;
    var tempCount%;
    stimdur := dlgvalue(4);  'get stimulus duration value from calling (main) dialog, limit opto period based on this
    
    labels$[0] := "Opto Off First";
    labels$[1] := "Opto On First";
    labels$[2] := "Random First";
    labels$[3] := "Opto On All Blocks";
	GetTunOptoParameters();
	DlgCreate("Optogenetics Parameters");
    DlgGroup("Common Parameters", 1, 1, 38, 5);
    DlgReal(1, "Opto Voltage Out (V)",0.0002,5,20,2); '.0002 is the minimum value that will give any change at all (to 1 in a 15-bit range) on the DAC
    DlgList(2, "Order of blocks",labels$,4,20,3);
    DlgReal(3, "InterBlock Time(s):", 0, 100, 20, 4);  'new, allow really long stimuli
    DlgCheck(4, "Use pulsing opto",2,5);
    DlgCheck(5, "Record Laser Diode",2,6);
    DlgGroup("Wrap-Around Opto", 1, 7, 38, 4);
    DlgReal(6, "PreStimulus Opto On (s)",0,10,20,8);
    DlgReal(7, "PostStimulus Opto On (s)",0,10,20,9);
    DlgCheck(8, "Keep Opto on between stims",2,10);
    DlgGroup("Pulsing Opto", 1, 11, 38, 5);
    DlgInteger(9, "Opto # Pulses ",0,1000,20,12);
    DlgReal(10, "Opto Period Onset (s)",0,stimdur,20,13);
    DlgReal(11, "Opto Pulse Width (s)",0,stimdur,20,14);
    DlgReal(12, "Opto Interpulse Interval (s)",0,100,20,15);
    
    'DlgCheck(6, "Record control box voltage");
    'DlgCheck(7, "Record stimulator");
    
    DlgAllow(0xffff, 0, TunOptoDialogChanged%);    
    
	'i% := DlgShow(tunPreStimOptoTime,tunPostStimOptoTime,tunOptoStaysOn%,tunOptoVoltageOut,tunOptoStartState%);',tunRecOptoBox%,tunRecStimulator%);
	'changing order with bigger dialog - note that with addition of the dialogChanged function the above will not be terribly relevant ever again
    i% := DlgShow(tunOptoVoltageOut,tunOptoStartState%,tunInterBlockTime,tunOptoUsePulse%,tunLaserDiode%,tunPreStimOptoTime,tunPostStimOptoTime,tunOptoStaysOn%,tunOptoNPulses%,tunPulsedOptoOnset,tunPulsedOptoWidth,tunPulsedOptoIPI);
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTunOptoParameters();
        docase
        case tunOptoStartState% = 3 then
            dontToggleOpto% := 1;
            tunOptoState% := 1;
        case tunOptoStartState% = 2 then
            tunOptoState% := round(Rand());
        else
            tunOptoState% := tunOptoStartState%;
        endcase;
        'printlog("Opto start state is %d\n",tunOptoState%);  'yep, works
        
        'do temporary calculation to make sure all pulses will occur during the stimulus
        'unfortunately we will have to do this AGAIN once the script starts because the user could change the stimulus duration after the opto parameters
        'fortunately, the calculation is the same and it all worked on the first try
        if tunOptoUsePulse% = 1 then
            stimdur := stimdur - tunPulsedOptoOnset;  'duration of stimulus after onset delay
            stimdur := stimdur - tunPulsedOptoWidth;  'duration of stimulus after first opto pulse
            if stimdur < 0 then  'if first pulse will extend beyond stimulus duration
                tunOptoNPulses% := 0;  'turn off opto by using no pulses
                'tell user to try again
                Message("The first opto pulse will extend beyond the stimulus!  There will be no pulses!  Please try again!");
            else
                tempNPulses% := tunOptoNPulses% - 1;  'how many more pulses are left?
                tempCount% := 1;  'temporary successful pulse count
                while tempNPulses% > 0 do
                    stimdur := stimdur - tunPulsedOptoWidth - tunPulsedOptoIPI;  'subtract duration of one more pulse+IPI
                    if stimdur < 0 then  'if this pulse will extend beyond stimulus duration
                        Message("Due to stimulus length, only " + Str$(tempCount%) + " pulses can be completed!  You may try again!");
                        tunOptoNPulses% := tempCount%;  'only use this many pulses if user does not recalculate
                        tempNPulses% := 0;  'break while
                    else  'if this pulse is OK
                        tempCount% += 1;  'increment temporary successful pulse count
                    endif;
                    tempNPulses% -= 1;  'decrement temporary pulse count remaining
                wend
                
            endif;
            
        endif;
        
        
        
	endif;
    
	return iReturn%;
end;



' This function is initially called with a "0" input
func TunOptoDialogChanged%(item%) 
    DlgEnable(0,5);  'Just straight up disable the laser diode recording
    if DlgValue(4) = 1 then
        DlgEnable(1,9);  'enable pulsing dialog values 
        DlgEnable(1,10);
        DlgEnable(1,11);
        DlgEnable(1,12);
        DlgEnable(0,6);  'disable wrap-around dialog values 
        DlgEnable(0,7);
        DlgEnable(0,8);
    else
        DlgEnable(0,9);  'disable pulsing dialog values 
        DlgEnable(0,10);
        DlgEnable(0,11);
        DlgEnable(0,12);
        DlgEnable(1,6);  'enable wrap-around dialog values 
        DlgEnable(1,7);
        DlgEnable(1,8);
    endif;
    
    return 1;
end






func UpdateTuningXHairDialog%()
    
    'Run the tuning crosshairs dialog  
    TuningXHairDialog%();  
    
    'When done with the tuning crosshairs dialog, update tunXHairText$ and update the main dialog
    docase 
    case tunUseXHairs% = 0 then
        tunXHairText$ := "Crosshairs are OFF";
    case tunUseXHairs% = 1 then
        tunXHairText$ := "Crosshairs are ON";
    endcase
    
    DlgValue$(updateXHairText%, tunXHairText$);
    
    return 1;
end


'----- Check to make sure the stimulus and crosshair rectangles do not overlap
Func CheckXHairStimulusBox(gr$,maxRadius,maxDiam);
    var x;
    var y;
    var w;
    var h;
    var iw;
    var ih;
    var contrast%;
    var sf;
    var tf;
    var ori;
    var phase;
    var cv$;
    var pattern$;
    var aperture$;
    var xencroach;
    var yencroach;
    
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    xencroach := Abs(x) - w/2;
    yencroach := Abs(y) - h/2;
    if maxDiam > 0 then
        xencroach := Abs(x) - maxDiam/2;
        yencroach := Abs(y) - maxDiam/2;
    endif;
    if xencroach < maxRadius and yencroach < maxRadius then
        return 0;  'rectangles will overlap
    else
        return 1;  'rectangles will not overlap
    endif;
       
end



func SelectSEQFile%()

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a CRG sequence file");  'Find a sequence file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(4,direc$);  'Place filename into dialog item 4 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;



func SelectTuningFile%()
    'This generic function ought to work for any of the dialogs where we allow the selection of a tuning file

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a tuning file");  'Find a tuning file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(7,direc$);  'Place filename into dialog item 7 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;


func TuningCurveGenericDialogChanged%(item%)
    'This single dialog changed function can be used for ALL the tuning dialogs that allow file-based tuning curves
    '(at least currently) because they all have the same structure and therefore the same dialog positions to allow/disallow
    if DlgValue(6) = 0 then  'If we are not using a tuning file
        DlgEnable(0,7);  'disable the string box with the text file name (button still works)
        DlgEnable(1,1);  'enable nSteps, min, and max
        DlgEnable(1,3);
        DlgEnable(1,4);
    endif;
    if DlgValue(6) = 1 then
        DlgEnable(1,7);  'enable the string box with the text file name
        DlgEnable(0,1);  'disable nSteps, min, and max
        DlgEnable(0,3);
        DlgEnable(0,4);
    endif;
    return 1;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve main dialog END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
