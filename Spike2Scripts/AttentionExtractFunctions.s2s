#include "ExtractionUtilities.s2s"

' Initialization and state saving vars
var attxIsInitialized% := 0;
var attxOutputHandle := -1;
var attxTLast := -1;

' saved state vars
var attxITrial% := 0;
var attxICueType% := 0;
const cuetypeTowards% := 1;
const cuetypeAway% := 2;
var attxIChangeType% := 0;
const changetypeUpper% := 4;
const changetypeLower% := 8;
var attxIUpDown% := 0;
const updownUp% := 16;
const updownDown% := 32;
var attxIResponse% := 0;
const responseNone% := 0;
const responseCorrect% := 1;
const responseIncorrect% := -1;
var attxFCueTime := -1;
var attxFStimTime := -1;
var attxFChangeTime := -1;
var attxFRxTime := -1;

' state related vars and consts
const attxstateStart% := 1;
const attxstateFixPt% := 2;
const attxstateStim% := 3;
const attxstateChange% := 4;
const attxstateAbort% := 5;
const attxstateError% := 6;
const attxstateDone% := 7;
var attxIState% := attxstateStart%;

' Counters
var attxNTrials := 0;
var attxNTrialsCompleted := 0;
var attxNTrialsCorrect := 0;
var attxNTrialsTowards := 0;
var attxNTrialsAway := 0;
var attxNTrialsTowardsCorrect := 0;
var attxNTrialsAwayCorrect := 0;
var attxNTrialsCatch := 0;
var attxNTrialsCatchCorrect := 0;
const MaxTrials% := 1000;
var attxRxTimeTowards[MaxTrials%];
var attxRxTimeAway[MaxTrials%];
var attxRxTimeCatch[MaxTrials%];


' Initialization function. Should be called once with a handle to an output file, already opened. 
' Running totals will be printed on log output. 

proc AttentionExtractInit(hOutput)
    attxIsInitialized% := 1;
    attxOutputHandle := hOutput;
    attxTLast := -1;
    return;
end


func AttentionExtract%(tEnd)
    var status% := 0;
    var tFound := -1;
    var sFound$;
    var sIgnore$ := "0Jqs";
    var tTrigger;

    tFound := NextKeyOrText(attxTLast, sFound$, sIgnore$);
    while tFound >= 0 and (tEnd < 0 or (tEnd > 0 and tFound <= tEnd)) and attxIState% <> attxstateError% do
'    while tFound >= 0 and attxIState% <> attxstateError% do

        docase
        case attxIState% = attxstateStart% then
            attxIState% := attxstateFixPt%;
            attxFCueTime := GetTriggerTimeFor(sFound$, tFound);
            attxITrial% += 1;
            docase
            case sFound$ = "F" then
                attxICueType% := cuetypeTowards%;
            case sFound$ = "G" then
                attxICueType% := cuetypeAway%;
            else
                ' Error
                attxIState% := attxstateError%;
            endcase
        case attxIState% = attxstateFixPt% then
            docase
            case sFound$ = "S" then
                attxFStimTime := GetTriggerTimeFor(sFound$, tFound);
                attxIState% := attxstateStim%;
            case sFound$ = "X" then
                attxIState% := attxstateAbort%;
            else
                'TODO ERROR
                attxIState% := attxstateError%;
            endcase
        case attxIState% = attxstateStim% then
            docase
            case sFound$ = "C" then
                attxIChangeType% := changetypeUpper%;
                attxIUpDown% := updownUp%;
                attxIState% := attxstateChange%;
                attxFChangeTime := GetTriggerTimeFor(sFound$, tFound);
            case sFound$ = "D" then
                attxIChangeType% := changetypeLower%;
                attxIUpDown% := updownUp%;
                attxIState% := attxstateChange%;
                attxFChangeTime := GetTriggerTimeFor(sFound$, tFound);
            case sFound$ = "c" then
                attxIChangeType% := changetypeUpper%;
                attxIUpDown% := updownDown%;
                attxIState% := attxstateChange%;
                attxFChangeTime := GetTriggerTimeFor(sFound$, tFound);
            case sFound$ = "d" then
                attxIChangeType% := changetypeLower%;
                attxIUpDown% := updownDown%;
                attxIState% := attxstateChange%;
                attxFChangeTime := GetTriggerTimeFor(sFound$, tFound);
            case sFound$ = "X" then
                attxIState% := attxstateAbort%;
            else
                'TODO ERROR
                attxIState% := attxstateError%;
            endcase
        case attxIState% = attxstateChange% then
            docase
            case sFound$ = "+" then
                attxIResponse% := responseCorrect%;
                attxIState% := attxstateDone%;
                attxFRxTime := tFound - attxFChangeTime;
            case sFound$ = "-" then
                attxIResponse% := responseIncorrect%;
                attxIState% := attxstateDone%;
                attxFRxTime := tFound - attxFChangeTime;
            case sFound$ = "X" then
                attxIState% := attxstateAbort%;
            else
                'TODO ERROR
                attxIState% := attxstateError%;
            endcase
        else
            'TODO this shouldn't happen!
            attxIState% := attxstateError%;
        endcase

        ' If we are in one of these states: attxstateDone%, attxstateAbort%, attxstateError%, we flush the state
        ' and transition to attxstateStart%.
        
        if attxIState% = attxstateAbort% or attxIState% = attxstateError% or attxIState% = attxstateDone% then
            FlushState();
            attxIState% := attxstateStart%;
        endif
        
        attxTLast := tFound;
        tFound := NextKeyOrText(attxTLast, sFound$, sIgnore$);
    wend

    PrintResults();
    
    return status%;
end


' Get M/N as a percentage, returned as a string in %4.1%% format, e.g 12.4%
' If N is zero, then return -----. 
func PctStr$(N, M)
    var s$ := "@@.@%";
    if N>0 then
        s$ := Print$("%4.1f%%", 100.0*M/N);
    endif
    return s$;
end

' Print current results to log window

proc PrintResults()
    var mean, std;
    PrintLog("\n==============================================================================\n\n");
    PrintLog("# Trials       : %5d\n", attxNTrials);
    PrintLog("# Completed (%): %5d (%s)     Cue         #  %%correct   rxtime\n", attxNTrialsCompleted, PctStr$(attxNTrials, attxNTrialsCompleted));

    mean := 0;
    std := 0;
    if attxNTrialsTowards > 1 then
        ArrSum(attxRxTimeTowards[0:attxNTrialsTowards-1], mean, std);
    endif
    PrintLog("                                   Towards   %3d     %s    %.3f +- %.3f s\n", attxNTrialsTowards, PctStr$(attxNTrialsTowards, attxNTrialsTowardsCorrect), mean, std);

    mean := 0;
    std := 0;
    if attxNTrialsAway > 1 then
        ArrSum(attxRxTimeAway[0:attxNTrialsAway-1], mean, std);
    endif
    PrintLog("                                   Away      %3d     %s    %.3f +- %.3f s\n", attxNTrialsAway, PctStr$(attxNTrialsAway, attxNTrialsAwayCorrect), mean , std);

    mean := 0;
    std := 0;
    if attxNTrialsCatch > 1 then
        ArrSum(attxRxTimeCatch[0:attxNTrialsCatch-1], mean, std);
    endif
    PrintLog("                                   Catch     %3d     %s    %.3f +- %.3f s\n", attxNTrialsCatch, PctStr$(attxNTrialsCatch, attxNTrialsCatchCorrect), mean , std);
    
    return;
end

proc FlushState()
    var s$;
    var isum% := 0;
    
    ' Update tallies and counts.....
    attxNTrials += 1;
    if attxIResponse% <> responseNone% then
        isum% := attxICueType% + attxIChangeType%;
        attxNTrialsCompleted += 1;
        if attxIResponse% = responseCorrect% then
            attxNTrialsCorrect += 1;
        endif
        docase
        case isum% = 5 then
            attxRxTimeTowards[attxNTrialsTowards] := attxFRxTime;
            attxNTrialsTowards += 1;
            if attxIResponse% = responseCorrect% then
                attxNTrialsTowardsCorrect += 1;
            endif
        case isum% = 10 then
            attxRxTimeAway[attxNTrialsAway] := attxFRxTime;
            attxNTrialsAway += 1;
            if attxIResponse% = responseCorrect% then
                attxNTrialsAwayCorrect += 1;
            endif
        case isum% = 9 or isum% = 6 then
            attxRxTimeCatch[attxNTrialsCatch] := attxFRxTime;
            attxNTrialsCatch += 1;
            if attxIResponse% = responseCorrect% then
                attxNTrialsCatchCorrect += 1;
            endif
        else
            ' should not happen!
            PrintLog("Error: isum has value %d!\n", isum%);
        endcase
    endif

    
    ' Dump this trial to the log and output file if it exists.
    s$ := Print$("%d\t%d\t%.3f\t%.3f\t%d\t%d\t%.3f\t%d\t%.3f\n", attxITrial%, attxICueType%, attxFCueTime, attxFStimTime, attxIChangeType%, attxIUpDown%, attxFChangeTime, attxIResponse%, attxFRxTime);
    View(LogHandle()).Print(s$);
    if attxOutputHandle >= 0 then
        View(attxOutputHandle).Print(s$);
    endif
    attxICueType% := 0;
    attxFCueTime := -1;
    attxFStimTime := -1;
    attxIChangeType% := 0;
    attxIUpDown% := 0;
    attxFChangeTime := -1;
    attxIResponse% := 0;
    attxFRxTime := -1;
    return;
end


func StateString$(state%)
    var s$;
    docase
    case attxIState% = attxstateStart% then
        s$ := "START";
    case attxIState% = attxstateFixPt% then
        s$ := "FIXPT";
    case attxIState% = attxstateStim% then
        s$ := "STIM";
    case attxIState% = attxstateChange% then
        s$ := "CHANGE";
    case attxIState% = attxstateAbort% then
        s$ := "ABORT";
    else
        s$ := "UNKNOWN";
    endcase
    return s$;
end


func GetTriggerTimeFor(key$, tKey)
    var tFound := -99;
    docase
    case key$ = "F" or key$ = "G" then
        tFound := NextTriggerTransition(5, tKey, 0);
    case key$ = "S" then
        tFound := NextTriggerTransition(6, tKey, 0);
    case key$ = "C" or key$ = "D" or key$ = "c" or key$ = "d" then
        tFound := NextTriggerTransition(7, tKey, 0);
    else
        tFound := -2;
    endcase
    return tFound;
end