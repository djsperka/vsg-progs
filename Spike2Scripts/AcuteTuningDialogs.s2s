' $Id: AcuteTuningDialogs.s2s,v 1.16 2015-08-03 17:50:56 devel Exp $
'
' This file contains dialog functions for the alert tuning script Tuning.s2s.
#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "UsreyGratings.s2s"

var TuningCurveScriptDialogAllowOK%;  'allows OK to button to work on main dialog - see AcuteTuning.pls

var tunStimulusDuration := 3;      ' New, time for each stimulus to last, replaces tunFixationDuration
var tunInterTrialTime := 1;        ' Time between stimuli 
var tunInterBlockTime := 0;        ' New, time between blocks, important for opto
'var tunBackgroundColor$ := "gray";	' background color for stim
var tunBackgroundGrayLevel% := 128; ' Background gray level
var tunDoOpto%;                     ' New, 1 if doing optogenetics
var tunDoF12% := 1;                 ' compute f1 and f2. 
var tunMSeqLocation$ := "D:\\work\\AlertRig\\stim\\MSequenceTerms";  'location of M-Seq file
var tunRecStimulator% := 0;   'record the stimulator?

' These will be set by the tuning curve choice
var tunNAdvances%;		' Number of times stim will advance during one repeat
var tunNRepeats%;		' Number of repeats
var tunUseFile%;        ' Overall variables so we don't have to check 7 different ones in the main file.
var tunTuningFile$;     ' Location of tuning file

'const tundlgXHairButton% := 8;
const tundlgOrientationButton% := 9;
const tundlgContrastButton% := 10;
const tundlgSpatialButton% := 11;
const tundlgTemporalButton% := 12;
const tundlgAreaButton% := 13;
const tundlgGratingParametersButton% := 14;
const tundlgDriftingBarButton% := 15;
const tundlgNullTestButton% := 16;
const tundlgCRGMButton% := 17;
const tundlgOptogeneticsButton% := 18;
const tundlgIDButton% := 19;
const tundlgSelectTuningFileButton% := 20;


const tunTypeNone$ := "None";
const tunTypeOrientation$ := "O";
const tunTypeContrast$ := "C";
const tunTypeSpatial$ := "S";
const tunTypeTemporal$ := "T";
const tunTypeArea$ := "A";
const tunTypeDriftingBar$ := "G";
const tunTypeNullTest$ := "P";  'This is P for counterPhase reversal, I guess
const tunTypeCRG$ := "R"; 'cRg, I guess
const tunTypeID$ := "I";    ' inner diameter tuning
'const tunTypeDonut$ := "H";
'const tunTypeBerliner$ := "B";
var tunType$:=tunTypeNone$;

const tunContextDAQ$ := "DAQ";
const tunContextConfig$ := "Config";
var tunContext$ := tunContextConfig$;

' A note about "steps". 
' The dialogs ask for a number of "steps". A step is a transition from one stimulus
' to another. Thus, if there are N steps, there are N+1 different stimuli.

' These are specific to the individual tuning curve types - orientation first
var tunOriNSteps%;		' # steps in orientation tuning curve
var tunOriNRepeats%;		' # repeats in ori tuning curve
var tunOriMinOrientation;	' min orientation
var tunOriMaxOrientation;	' max orientation
var tunOriProgression%;
var tunOriUseFile%;
var tunOriTuningFile$;

' Contrast next
var tunContrastNSteps%;			' # steps in contrast tuning curve
var tunContrastNRepeats%;		' # repeats in contrast tuning curve
var tunContrastMinContrast;		' min contrast
var tunContrastMaxContrast;		' max contrast
var tunContrastProgression%;
var tunContrastUseFile%;
var tunContrastTuningFile$;

' Spatial next
var tunSpatialNSteps%;			' # steps in spatial freq tuning curve
var tunSpatialNRepeats%;		' # repeats in spatial freq tuning curve
var tunSpatialMinSF;			' min SF
var tunSpatialMaxSF;			' max SF
var tunSpatialProgression%;
var tunSpatialUseFile%;
var tunSpatialTuningFile$;

' Temporal next
var tunTemporalNSteps%;			' # steps in temporal tuning curve
var tunTemporalNRepeats%;		' # repeats in temporal tuning curve
var tunTemporalMinTF;		' min TF
var tunTemporalMaxTF;		' max TF
var tunTemporalProgression%;
var tunTemporalUseFile%;
var tunTemporalTuningFile$;

' Area next
var tunAreaNSteps%;			' # steps in area tuning curve
var tunAreaNRepeats%;		' # repeats in area tuning curve
var tunAreaMinDiam;		' min diameter
var tunAreaMaxDiam;		' max diameter
var tunAreaProgression%;
var tunAreaUseFile%;
var tunAreaTuningFile$;

' InnerDiameter next
var tunIDNSteps%;			' # steps in area tuning curve
var tunIDNRepeats%;		' # repeats in area tuning curve
var tunIDMinDiam;		' min diameter
var tunIDMaxDiam;		' max diameter
var tunIDProgression%;
var tunIDUseFile%;
var tunIDTuningFile$;

' Null Test next
var tunNullTestNSteps%;			' # steps in area tuning curve
var tunNullTestNRepeats%;		' # repeats in area tuning curve
var tunNullTestMinPhase;		' min phase
var tunNullTestMaxPhase;		' max phase
var tunNullTestProgression%;
var tunNullTestTF;              ' Transition frequency
var tunNullTestStepFunc%;        ' If 1, use a step function in time, if 0, use smooth sine function in time
var tunNullTestUseFile%;
var tunNullTestTuningFile$;

' These are specific to the individual tuning curve types - drifting bar
var tunBarNSteps%;		' # steps in drifting bar tuning curve
var tunBarNRepeats%;		' # repeats in drifting bar tuning curve
var tunBarMinOrientation;	' min drifting bar orientation
var tunBarMaxOrientation;	' max drifting bar orientation
var tunBarProgression%;
var tunBarForegroundGrayLevel%; ' Foreground gray level for bar
var tunBarWidth;
var tunBarHeight;
var tunBarSpeed;


' Contrast next
var tunCRGMNSteps%;			' # steps in contrast tuning curve
var tunCRGMNRepeats%;		' # repeats in contrast tuning curve
var tunCRGMMinContrast;		' min contrast
var tunCRGMMaxContrast;		' max contrast
var tunCRGMProgression%;
var tunCRGMFramesPerTurn%;  ' how many frames per each term in the CRG?
var tunCRGMFirstTerm%;      ' what term to start with?
const tunCRGMNumTerms% := 32767;  'this is correct
var tunCRGMBalanced%;       ' if 1, balance presentation


' Optogenetics variables
var tunPreStimOptoTime;
var tunPostStimOptoTime;
var tunOptoStaysOn%;
var tunOptoVoltageOut;
var tunOptoStartState%;  'essentially an index, 0 = off first, 1 = on first (those are logical), 2 = random
var tunOptoState% := 0;  'current opto state, will toggle, can set here in dialog box
'var tunRecOptoBox% := 0;      'record the output from the opto box?
'var tunRecStimulator% := 0;   'record the stimulator?

' Strings that hold grating parameters
var tunGratingParams$;






proc GetTuningCurveScriptParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
    tunStimulusDuration := GetFloatRegistryValue(key$, "StimulusDuration", tunStimulusDuration);  'new
    tunInterTrialTime := GetFloatRegistryValue(key$, "InterTrialTime", tunInterTrialTime);  'new
    tunInterBlockTime := GetFloatRegistryValue(key$, "InterBlockTime", tunInterBlockTime);
    'tunBackgroundColor$ := GetStringRegistryValue$(key$, "BackgroundColor", tunBackgroundColor$);
    tunBackgroundGrayLevel% := GetIntRegistryValue%(key$, "BackgroundGrayLevel", tunBackgroundGrayLevel%);
    tunDoOpto% := GetIntRegistryValue%(key$, "DoOpto", tunDoOpto%);
    tunRecStimulator% := GetIntRegistryValue%(key$, "RecStimulator", tunRecStimulator%);
end;

proc SaveTuningCurveScriptParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
    SetFloatRegistryValue(key$, "StimulusDuration", tunStimulusDuration);
    SetFloatRegistryValue(key$, "InterTrialTime", tunInterTrialTime);
    SetFloatRegistryValue(key$, "InterBlockTime", tunInterBlockTime);
    'SetStringRegistryValue(key$, "BackgroundColor", tunBackgroundColor$);
    SetIntRegistryValue(key$, "BackgroundGrayLevel", tunBackgroundGrayLevel%);
    SetIntRegistryValue(key$, "DoOpto", tunDoOpto%);
    SetIntRegistryValue(key$, "RecStimulator", tunRecStimulator%);
end;


' TuningCurveScriptDialog
' This dialog uses two global variables, tunContext$ and tunType$. 
' Set tunContext$ = tunContextConfig$ to run in the config scripts. The dialog 
' and its children (TuningCurveOrientationDialog, etc) will behave as expected, 
' allowing the user to set parameters and saving them in the registry. Set 
' tunContext$ = tunContextDAQ$ to run in a DAQ script. In this context you 
' must check the return value of the dialog and (possibly) the value of 
' tunType$. If the user hits Cancel in the main dialog, the return value is 0. 
' If the user selects a subdialog and hits OK, the return value will be 1 and 
' the value of tunType$ will be one of (tunTypeOrientation$, tunTypeContrast$, 
' tunTypeSpatial$, tunTypeTemporal$). Here, proceed directly to DAQ. If the 
' user Hits Cancel from the subdialog, then they return to the main dialog. If 
' they hit OK from the main dialog, then the return value is 1, but 
' tunType$ = tunTypeNone$. 


func TuningCurveScriptDialog%()
	var i%;
	var iReturn%;
    var tempParam$;
    var tempPhase;
    var boxOK% := 1;  'do the stimulus/crosshairs boxes overlap?
    
    TuningCurveScriptDialogAllowOK% := 0;  'Disable OK button to start, force selection of experiment
    
	GetTuningCurveScriptParameters();
    GetTunOptoParameters();  'We must get these or the user has to open the opto dialog every time.
'	var bcl$[3];
'	var ibcl%:=0;
'	bcl$[0] := "gray";
'	bcl$[1] := "black";
'	bcl$[2] := "white";
'	for i%:=0 to 2 do
'		if tunBackgroundColor$ = bcl$[i%] then
'			ibcl% := i%;
'		endif
'	next;
    

	DlgCreate("Tuning Curve Parameters", 50, 10, 40);
    DlgButton(0,"         Quit         ");
    DlgButton(1,"     Select Expt.     ");        
	DlgGroup("Common Parameters", 1, 1, 38, 6);
	DlgReal(1, "Stimulus Duration(s):", .1, 100, 20, 2);  'new, allow really long stimuli
    DlgReal(2, "InterTrial Time(s):", .1, 100, 20, 3);  'new, allow really long stimuli
	DlgReal(3, "InterBlock Time(s):", 0, 100, 20, 4);  'new, allow really long stimuli
    DlgInteger(4, "Background Gray Level (0-255):", 0, 255, 20, 5);  'new, allow all grays
    DlgCheck(5, "Record Stimulator?", 2,6);
	'DlgList(3, "Background color:", bcl$, 3, 20, 4);  'updated as new dialog number
    
    DlgGroup("Grating Parameters", 1, 7, 38, 2);
    DlgButton(tundlgGratingParametersButton%, "Grating Parameters", TunDlgGratingMaster%, 2, 8);
    
    DlgGroup("Optogenetics", 1, 9, 38, 3);
    DlgCheck(6,"Opto On",2,10);
    DlgButton(tundlgOptogeneticsButton%, "Optogenetics Parameters", TunOptoDialog%, 2, 11);
    
    DlgGroup("Individual Tuning Curve Types", 1, 12, 38, 8);
	DlgButton(tundlgOrientationButton%, "Orientation", TuningCurveOrientationDialog%, 2, 13);
	DlgButton(tundlgContrastButton%, "Contrast", TuningCurveContrastDialog%, 2, 14);
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 15);
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 2, 16);
	DlgButton(tundlgAreaButton%, "Area", TuningCurveAreaDialog%, 2, 17);
    DlgButton(tundlgNullTestButton%, "Null Test", TuningCurveNullTestDialog%, 2, 18);
	DlgButton(tundlgIDButton%, "InnerDiam", TuningCurveIDDialog%, 2, 19);
    
    
    DlgGroup("Non-Grating Stimuli", 1, 20, 38, 3);
    DlgButton(tundlgDriftingBarButton%, "Drifting Bars", TuningCurveDriftingBarDialog%, 2, 21);
    DlgButton(tundlgCRGMButton%, "CRGs", TuningCurveCRGMDialog%, 2, 22);
    
    DlgAllow(0xffff, 0, TuningCurveScriptDialogChanged%);
    
    'i%:=DlgShow(tunStimulusDuration, tunInterTrialTime, ibcl%);  'new, for reduced dialog
    i%:=DlgShow(tunStimulusDuration, tunInterTrialTime, tunInterBlockTime, tunBackgroundGrayLevel%, tunRecStimulator%, tunDoOpto%);  'now using background gray level
    
    ' djs 4-1-09
    ' Spike2 v6 change. DlgShow will return the button number when a button on the dialog is hit and the corresponding
    ' function returns 0. In this case those buttons open the various tuning type sub dialogs (orientation, area, etc). 
    ' In the last version, DlgShow would return the same value that the subdialog's function returned, and the code here
    ' was set up to behave accordingly. When the user hits the Cancel button in the subdialog everything still remains
    ' the same. 
    
    ' djs 2-4-2011
    ' Spike2v6 bug (see TuningDialogs.s2s) workaround requires that the tuning type dialogs return something > 0. 
    ' That will mean that closing any of those dialogs will not cause the main dialog (this one) to close automatically. 
    ' When it did close automatically the return value from DlgShow above was the same as the button that caused
    ' the close. Now, that button is NOT causing the close, so the return value is going to be 1 (not the button number). 
    ' In addition, the return value from this function needs to change because we now assume that the user will have
    ' to hit OK on this dialog to start the experiment. Thus, make sure that the return value from this function is 1
    ' when user hits OK and 0 when user hits Cancel. Also, do not save script parameters when user hits Cancel.
    
    'PrintLog("Tuning Curve Parameters Dialog - return from DlgShow is %d\n", i%);
    '	if i%=tundlgOrientationButton% or i%=tundlgContrastButton% or i%=tundlgSpatialButton% or i%=tundlgTemporalButton% or i%=tundlgAreaButton% then
    if i% = 1 then
        
        if tunDoOpto% = 0 then  'it will be useful to make sure that tunOptoState% is 0 if we're not at all doin Opto
            tunOptoState% := 0;
        endif;
        
        if tunCRGMFirstTerm% > tunCRGMNumTerms% - 100 - (tunStimulusDuration*dataScreenHz) then
            Message("Error!  Duration was changed and CRG first term is not legal!  Quitting!");
            i% := 0;
        else
            SaveTuningCurveScriptParameters();
            if tunContext$ = tunContextDAQ$ then 
                iReturn% := 1;
            else iReturn% := 1;
            endif;
        endif;
        
	endif;
	if i% = 0 then
		'PrintLog("Tuning Curve Parameters dialog - user hit Cancel, tunType=" + tunType$ + "\n");
		if tunContext$ = tunContextDAQ$ then 
			if tunType$ <> tunTypeNone$ then 
				iReturn% := 0;
				'SaveTuningCurveScriptParameters();
			else iReturn% := 0;
		 	endif;
		else
			iReturn% := 2;		' The calling/main dialog would close if we returned 0
		endif;
	endif;
	return iReturn%;
end;


' This function is initially called with a "0" input
func TuningCurveScriptDialogChanged%(item%) 
    'This disables the "OK" button (though it will have different labels) until an experiment is selected
    if TuningCurveScriptDialogAllowOK% = 1 then
        DlgEnable(1,-1);  'enable "OK" 
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    return 1;
end






proc GetTuningCurveOrientationParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";
    tunOriNSteps% := GetIntRegistryValue%(key$, "NSteps", tunOriNSteps%);
    tunOriNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunOriNRepeats%);
    tunOriProgression% := GetIntRegistryValue%(key$, "Progression", tunOriProgression%);
    tunOriMinOrientation := GetFloatRegistryValue(key$, "MinOrientation", tunOriMinOrientation);
    tunOriMaxOrientation := GetFloatRegistryValue(key$, "MaxOrientation", tunOriMaxOrientation);
    tunOriUseFile% := GetIntRegistryValue%(key$, "UseFile", tunOriUseFile%);
    tunOriTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunOriTuningFile$);
end;

proc SaveTuningCurveOrientationParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";
    SetIntRegistryValue(key$, "NSteps", tunOriNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunOriNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunOriProgression%);
    SetFloatRegistryValue(key$, "MinOrientation", tunOriMinOrientation);
    SetFloatRegistryValue(key$, "MaxOrientation", tunOriMaxOrientation);
    SetIntRegistryValue(key$, "UseFile", tunOriUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunOriTuningFile$);
end;

proc GetTuningCurveContrastParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";
    
    tunContrastNSteps% := GetIntRegistryValue%(key$, "NSteps", tunContrastNSteps%);
    tunContrastNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunContrastNRepeats%);
    tunContrastProgression% := GetIntRegistryValue%(key$, "Progression", tunContrastProgression%);
    tunContrastMinContrast := GetFloatRegistryValue(key$, "MinContrast", tunContrastMinContrast);
    tunContrastMaxContrast := GetFloatRegistryValue(key$, "MaxContrast", tunContrastMaxContrast);
    tunContrastUseFile% := GetIntRegistryValue%(key$, "UseFile", tunContrastUseFile%);
    tunContrastTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunContrastTuningFile$);
end;

proc SaveTuningCurveContrastParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";
    SetIntRegistryValue(key$, "NSteps", tunContrastNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunContrastNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunContrastProgression%);
    SetFloatRegistryValue(key$, "MinContrast", tunContrastMinContrast);
    SetFloatRegistryValue(key$, "MaxContrast", tunContrastMaxContrast);
    SetIntRegistryValue(key$, "UseFile", tunContrastUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunContrastTuningFile$);
end;

proc GetTuningCurveSpatialParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";
    
    tunSpatialNSteps% := GetIntRegistryValue%(key$, "NSteps", tunSpatialNSteps%);
    tunSpatialNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunSpatialNRepeats%);
    tunSpatialProgression% := GetIntRegistryValue%(key$, "Progression", tunSpatialProgression%);
    tunSpatialMinSF := GetFloatRegistryValue(key$, "MinSF", tunSpatialMinSF);
    tunSpatialMaxSF := GetFloatRegistryValue(key$, "MaxSF", tunSpatialMaxSF);
    tunSpatialUseFile% := GetIntRegistryValue%(key$, "UseFile", tunSpatialUseFile%);
    tunSpatialTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunSpatialTuningFile$);
end;

proc SaveTuningCurveSpatialParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";
    
    SetIntRegistryValue(key$, "NSteps", tunSpatialNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunSpatialNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunSpatialProgression%);
    SetFloatRegistryValue(key$, "MinSF", tunSpatialMinSF);
    SetFloatRegistryValue(key$, "MaxSF", tunSpatialMaxSF);
    SetIntRegistryValue(key$, "UseFile", tunSpatialUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunSpatialTuningFile$);
end;

proc GetTuningCurveTemporalParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";
    
    tunTemporalNSteps% := GetIntRegistryValue%(key$, "NSteps", tunTemporalNSteps%);
    tunTemporalNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunTemporalNRepeats%);
    tunTemporalProgression% := GetIntRegistryValue%(key$, "Progression", tunTemporalProgression%);
    tunTemporalMinTF := GetFloatRegistryValue(key$, "MinTF", tunTemporalMinTF);
    tunTemporalMaxTF := GetFloatRegistryValue(key$, "MaxTF", tunTemporalMaxTF);
    tunTemporalUseFile% := GetIntRegistryValue%(key$, "UseFile", tunTemporalUseFile%);
    tunTemporalTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunTemporalTuningFile$);
end;

proc SaveTuningCurveTemporalParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";

    SetIntRegistryValue(key$, "NSteps", tunTemporalNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunTemporalNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunTemporalProgression%);
    SetFloatRegistryValue(key$, "MinTF", tunTemporalMinTF);
    SetFloatRegistryValue(key$, "MaxTF", tunTemporalMaxTF);
    SetIntRegistryValue(key$, "UseFile", tunTemporalUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunTemporalTuningFile$);
end;

proc GetTuningCurveAreaParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

    tunAreaNSteps% := GetIntRegistryValue%(key$, "NSteps", tunAreaNSteps%);
    tunAreaNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunAreaNRepeats%);
    tunAreaProgression% := GetIntRegistryValue%(key$, "Progression", tunAreaProgression%);
    tunAreaMinDiam := GetFloatRegistryValue(key$, "MinDiam", tunAreaMinDiam);
    tunAreaMaxDiam := GetFloatRegistryValue(key$, "MaxDiam", tunAreaMaxDiam);
    tunAreaUseFile% := GetIntRegistryValue%(key$, "UseFile", tunAreaUseFile%);
    tunAreaTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunAreaTuningFile$);
end;

proc SaveTuningCurveAreaParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

    SetIntRegistryValue(key$, "NSteps", tunAreaNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunAreaNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunAreaProgression%);
    SetFloatRegistryValue(key$, "MinDiam", tunAreaMinDiam);
    SetFloatRegistryValue(key$, "MaxDiam", tunAreaMaxDiam);
    SetIntRegistryValue(key$, "UseFile", tunAreaUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunAreaTuningFile$);
end;


proc GetTuningCurveIDParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\ID";

    tunIDNSteps% := GetIntRegistryValue%(key$, "NSteps", tunIDNSteps%);
    tunIDNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunIDNRepeats%);
    tunIDProgression% := GetIntRegistryValue%(key$, "Progression", tunIDProgression%);
    tunIDMinDiam := GetFloatRegistryValue(key$, "MinDiam", tunIDMinDiam);
    tunIDMaxDiam := GetFloatRegistryValue(key$, "MaxDiam", tunIDMaxDiam);
    tunIDUseFile% := GetIntRegistryValue%(key$, "UseFile", tunIDUseFile%);
    tunIDTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunIDTuningFile$);
end;

proc SaveTuningCurveIDParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\ID";

    SetIntRegistryValue(key$, "NSteps", tunIDNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunIDNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunIDProgression%);
    SetFloatRegistryValue(key$, "MinDiam", tunIDMinDiam);
    SetFloatRegistryValue(key$, "MaxDiam", tunIDMaxDiam);
    SetIntRegistryValue(key$, "UseFile", tunIDUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunIDTuningFile$);
end;


proc GetTuningCurveNullTestParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\NullTest";
    
    tunNullTestNSteps% := GetIntRegistryValue%(key$, "NSteps", tunNullTestNSteps%);
    tunNullTestNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunNullTestNRepeats%);
    tunNullTestProgression% := GetIntRegistryValue%(key$, "Progression", tunNullTestProgression%);
    tunNullTestStepFunc% := GetIntRegistryValue%(key$, "StepFunc", tunNullTestStepFunc%);
    tunNullTestMinPhase := GetFloatRegistryValue(key$, "MinPhase", tunNullTestMinPhase);
    tunNullTestMaxPhase := GetFloatRegistryValue(key$, "MaxPhase", tunNullTestMaxPhase);
    tunNullTestTF := GetFloatRegistryValue(key$, "TransitionFreq", tunNullTestTF);
    tunNullTestUseFile% := GetIntRegistryValue%(key$, "UseFile", tunNullTestUseFile%);
    tunNullTestTuningFile$ := GetStringRegistryValue$(key$, "TuningFile", tunNullTestTuningFile$);
end;

proc SaveTuningCurveNullTestParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\NullTest";

    SetIntRegistryValue(key$, "NSteps", tunNullTestNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunNullTestNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunNullTestProgression%);
    SetIntRegistryValue(key$, "StepFunc", tunNullTestStepFunc%);
    SetFloatRegistryValue(key$, "MinPhase", tunNullTestMinPhase);
    SetFloatRegistryValue(key$, "MaxPhase", tunNullTestMaxPhase);
    SetFloatRegistryValue(key$, "TransitionFreq", tunNullTestTF);
    SetIntRegistryValue(key$, "UseFile", tunNullTestUseFile%);
    SetStringRegistryValue(key$, "TuningFile", tunNullTestTuningFile$);
end;


proc GetTuningCurveDriftingBarParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\DriftingBar";
    tunBarNSteps% := GetIntRegistryValue%(key$, "NSteps", tunBarNSteps%);
    tunBarNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunBarNRepeats%);
    tunBarProgression% := GetIntRegistryValue%(key$, "Progression", tunBarProgression%);
    tunBarMinOrientation := GetFloatRegistryValue(key$, "MinOrientation", tunBarMinOrientation);
    tunBarMaxOrientation := GetFloatRegistryValue(key$, "MaxOrientation", tunBarMaxOrientation);
    tunBarForegroundGrayLevel% := GetIntRegistryValue%(key$, "ForegroundGrayLevel", tunBarForegroundGrayLevel%);
    tunBarWidth := GetFloatRegistryValue(key$, "Width", tunBarWidth);
    tunBarHeight := GetFloatRegistryValue(key$, "Height", tunBarHeight);
    tunBarSpeed := GetFloatRegistryValue(key$, "Speed", tunBarSpeed);
end;

proc SaveTuningCurveDriftingBarParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\DriftingBar";
    SetIntRegistryValue(key$, "NSteps", tunBarNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunBarNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunBarProgression%);
    SetFloatRegistryValue(key$, "MinOrientation", tunBarMinOrientation);
    SetFloatRegistryValue(key$, "MaxOrientation", tunBarMaxOrientation);
    SetIntRegistryValue(key$, "ForegroundGrayLevel", tunBarForegroundGrayLevel%);
    SetFloatRegistryValue(key$, "Width", tunBarWidth);
    SetFloatRegistryValue(key$, "Height", tunBarHeight);
    SetFloatRegistryValue(key$, "Speed", tunBarSpeed);
end;


proc GetTuningCurveCRGMParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\CRGM";
    
    tunCRGMNSteps% := GetIntRegistryValue%(key$, "NSteps", tunCRGMNSteps%);
    tunCRGMNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunCRGMNRepeats%);
    tunCRGMProgression% := GetIntRegistryValue%(key$, "Progression", tunCRGMProgression%);
    tunCRGMMinContrast := GetFloatRegistryValue(key$, "MinContrast", tunCRGMMinContrast);
    tunCRGMMaxContrast := GetFloatRegistryValue(key$, "MaxContrast", tunCRGMMaxContrast);
    tunCRGMFramesPerTurn% := GetIntRegistryValue%(key$, "FramesPerTurn", tunCRGMFramesPerTurn%);
    tunCRGMBalanced% := GetIntRegistryValue%(key$, "Balanced", tunCRGMBalanced%);
end;

proc SaveTuningCurveCRGMParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\CRGM";
    SetIntRegistryValue(key$, "NSteps", tunCRGMNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunCRGMNRepeats%);
    SetIntRegistryValue(key$, "Progression", tunCRGMProgression%);
    SetFloatRegistryValue(key$, "MinContrast", tunCRGMMinContrast);
    SetFloatRegistryValue(key$, "MaxContrast", tunCRGMMaxContrast);
    SetIntRegistryValue(key$, "FramesPerTurn", tunCRGMFramesPerTurn%);
    SetIntRegistryValue(key$, "Balanced", tunCRGMBalanced%);
end;

proc GetTunOptoParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Opto";
    
    tunPreStimOptoTime := GetFloatRegistryValue(key$, "PreStimOptoTime", tunPreStimOptoTime);
    tunPostStimOptoTime := GetFloatRegistryValue(key$, "PostStimOptoTime", tunPostStimOptoTime);
    tunOptoStaysOn% := GetIntRegistryValue%(key$, "OptoStaysOn", tunOptoStaysOn%);
    tunOptoVoltageOut := GetFloatRegistryValue(key$, "OptoVoltageOut", tunOptoVoltageOut);
    tunOptoStartState% := GetIntRegistryValue%(key$, "OptoStartState", tunOptoStartState%);
    'tunRecOptoBox% := GetIntRegistryValue%(key$, "RecOptoBox", tunRecOptoBox%);
    'tunRecStimulator% := GetIntRegistryValue%(key$, "RecStimulator", tunRecStimulator%);

end;

proc SaveTunOptoParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Opto";
    SetFloatRegistryValue(key$, "PreStimOptoTime", tunPreStimOptoTime);
    SetFloatRegistryValue(key$, "PostStimOptoTime", tunPostStimOptoTime);
    SetIntRegistryValue(key$, "OptoStaysOn", tunOptoStaysOn%);
    SetFloatRegistryValue(key$, "OptoVoltageOut", tunOptoVoltageOut);
    SetIntRegistryValue(key$, "OptoStartState", tunOptoStartState%);
    'SetIntRegistryValue(key$, "RecOptoBox", tunRecOptoBox%);
    'SetIntRegistryValue(key$, "RecStimulator", tunRecStimulator%);
end;


func TuningCurveOrientationDialog%()
	var iReturn%;
	var i%;
	GetTuningCurveOrientationParameters();
	DlgCreate("Run Orientation Tuning Curve");
	DlgInteger(1, "Number of Steps", 2, 99);  'note that 100 steps breaks something - no time to track it down right now JJ
	DlgInteger(2, "Number of Repeats", 1, 30);
	DlgReal(3, "Min Orientation (deg)", 0, 360);
	DlgReal(4, "Max Orientation (deg)", 0, 360);
	DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);
    
	i% := DlgShow(tunOriNSteps%, tunOriNRepeats%, tunOriMinOrientation, tunOriMaxOrientation, tunOriProgression%, tunOriUseFile%, tunOriTuningFile$);

	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveOrientationParameters();
		PrintLog("TuningCurveOrientationDialog - user hit OK\n");
		tunType$ := tunTypeOrientation$;
        tunUseFile% := tunOriUseFile%;
        tunTuningFile$ := tunOriTuningFile$;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run Orientation");
        TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
        TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		PrintLog("TuningCurveOrientationDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
        'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
        DlgValue$(-1,"Select Expt.");
        TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
        TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
	endif;
    PrintLog("Return value is %d\n", iReturn%);
	return iReturn%;
end;



func TuningCurveContrastDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveContrastParameters();
	DlgCreate("Contrast Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 99);
	DlgInteger(2, "Number of Repeats", 1, 500);
	DlgReal(3, "Min Contrast (%)", 0.1, 100);
	DlgReal(4, "Max Contrast (%)", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);
    
	i% := DlgShow(tunContrastNSteps%, tunContrastNRepeats%, tunContrastMinContrast, tunContrastMaxContrast, tunContrastProgression%, tunContrastUseFile%, tunContrastTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveContrastParameters();
'		PrintLog("TuningCurveContrastDialog - user hit OK\n");
		tunType$ := tunTypeContrast$;
        tunUseFile% := tunContrastUseFile%;
        tunTuningFile$ := tunContrastTuningFile$;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run Contrast");
        TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
        TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveContrastDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
        'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
        DlgValue$(-1,"Select Expt.");
        TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
        TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
	endif;

	return iReturn%;
end;

func TuningCurveSpatialDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveSpatialParameters();
	DlgCreate("Spatial Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 99);
	DlgInteger(2, "Number of Repeats", 1, 30);
	DlgReal(3, "Min SF", .01, 100);
	DlgReal(4, "Max SF", .01, 100);
	DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);
    
	i% := DlgShow(tunSpatialNSteps%, tunSpatialNRepeats%, tunSpatialMinSF, tunSpatialMaxSF, tunSpatialProgression%, tunSpatialUseFile%, tunSpatialTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveSpatialParameters();
'		PrintLog("TuningCurveSpatialDialog - user hit OK\n");
		tunType$ := tunTypeSpatial$;
        tunUseFile% := tunSpatialUseFile%;
        tunTuningFile$ := tunSpatialTuningFile$;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run Spatial");
        TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
        TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveSpatialDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
        'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
        DlgValue$(-1,"Select Expt.");
        TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
        TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
	endif;

	return iReturn%;
end;

func TuningCurveTemporalDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveTemporalParameters();
	DlgCreate("Temporal Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 99);
	DlgInteger(2, "Number of Repeats", 1, 30);
	DlgReal(3, "Min TF", 0, 100);
	DlgReal(4, "Max TF", 0, 100);
	DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);
    
	i% := DlgShow(tunTemporalNSteps%, tunTemporalNRepeats%, tunTemporalMinTF, tunTemporalMaxTF, tunTemporalProgression%, tunTemporalUseFile%, tunTemporalTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveTemporalParameters();
'		PrintLog("TuningCurveTemporalDialog - user hit OK\n");
		tunType$ := tunTypeTemporal$;
        tunUseFile% := tunTemporalUseFile%;
        tunTuningFile$ := tunTemporalTuningFile$;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run Temporal");
        TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
        TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveTemporalDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
        'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
        DlgValue$(-1,"Select Expt.");
        TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
        TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
	endif;

	return iReturn%;
end;

func TuningCurveAreaDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveAreaParameters();
	DlgCreate("Area Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 99);
	DlgInteger(2, "Number of Repeats", 1, 100);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);
    
	i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%, tunAreaUseFile%, tunAreaTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTuningCurveAreaParameters();
'		PrintLog("TuningCurveAreaDialog - user hit OK\n");
		tunType$ := tunTypeArea$;
        tunUseFile% := tunAreaUseFile%;
        tunTuningFile$ := tunAreaTuningFile$;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run Area");
        TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
        TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
        'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
        DlgValue$(-1,"Select Expt.");
        TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
        TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
	endif;
    
	return iReturn%;
end;

func TuningCurveIDDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveIDParameters();
	DlgCreate("ID Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 99);
	DlgInteger(2, "Number of Repeats", 1, 30);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgCheck(6, "Use File For Tuning Values");
    DlgString(7,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFile%, 2, 8);
    DlgAllow(0xffff, 0, TuningCurveGenericDialogChanged%);
    
	i% := DlgShow(tunIDNSteps%, tunIDNRepeats%, tunIDMinDiam, tunIDMaxDiam, tunIDProgression%, tunIDUseFile%, tunIDTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTuningCurveIDParameters();
'		PrintLog("TuningCurveAreaDialog - user hit OK\n");
		tunType$ := tunTypeID$;
        tunUseFile% := tunIDUseFile%;
        tunTuningFile$ := tunIDTuningFile$;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run InnerDiam");
        TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
        TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
        'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
        DlgValue$(-1,"Select Expt.");
        TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
        TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
	endif;
    
	return iReturn%;
end;




func TuningCurveNullTestDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveNullTestParameters();
	DlgCreate("Null Test Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 99);
	DlgInteger(2, "Number of Repeats", 1, 30);
	DlgReal(3, "Start Phase", 0, 360);
	DlgReal(4, "End Phase", 0, 360);
    DlgReal(5, "Transition Frequency (Hz)", 0.1,100);
	DlgCheck(6, "Random Progression");
    DlgCheck(7, "Step Function in Time");
    DlgCheck(8, "Use File For Tuning Values");
    DlgString(9,40,255,"",3);  'for visual confirmation of selected seq file
    DlgButton(tundlgSelectTuningFileButton%, " Select Tuning File ", SelectTuningFileNullTest%, 2, 10);
    DlgAllow(0xffff, 0, TuningCurveNullTestDialogChanged%);
    
	i% := DlgShow(tunNullTestNSteps%, tunNullTestNRepeats%, tunNullTestMinPhase, tunNullTestMaxPhase, tunNullTestTF, tunNullTestProgression%, tunNullTestStepFunc%, tunNullTestUseFile%, tunNullTestTuningFile$);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTuningCurveNullTestParameters();
'		PrintLog("TuningCurveAreaDialog - user hit OK\n");
		tunType$ := tunTypeNullTest$;
        tunUseFile% := tunNullTestUseFile%;
        tunTuningFile$ := tunNullTestTuningFile$;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run Null Test");
        TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
        TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveNullTestDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
        'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
        DlgValue$(-1,"Select Expt.");
        TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
        TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
	endif;
    
	return iReturn%;
end;




func TuningCurveDriftingBarDialog%()
	var iReturn%;
	var i%;
	GetTuningCurveDriftingBarParameters();
	DlgCreate("Run Drifting Bar Tuning Curve");
    DlgGroup("Tuning Curve Parameters", 1, 1, 38, 5);
	DlgInteger(1, "Number of Steps", 2, 99, 20, 2);  'note that 100 steps breaks something - no time to track it down right now JJ
	DlgInteger(2, "Number of Repeats", 1, 30, 20, 3);
	DlgReal(3, "Min Orientation (deg)", 0, 360, 20, 4);
	DlgReal(4, "Max Orientation (deg)", 0, 360, 20, 5);
    DlgGroup("Bar Parameters", 1, 7, 38, 5);
    DlgReal(5, "Bar Width (deg)", 0.01, 1000, 20, 8);  'Values over max width allowed by ViSaGe will be truncated w/ no ill effects
	DlgReal(6, "Bar Height (deg)", 0.01, 50, 20, 9);   'For most screen distances, 50 degs should be across the entire screen anyway...could certainly restrict further 
    DlgReal(7, "Bar Speed (deg/s)", 0.001, 30, 20, 10); 
    DlgInteger(8, "Bar Gray Level (0-255):", 0, 255, 20, 11);  'new, allow all grays
	DlgCheck(9, "Random Progression", 2, 13);
	i% := DlgShow(tunBarNSteps%, tunBarNRepeats%, tunBarMinOrientation, tunBarMaxOrientation, tunBarWidth, tunBarHeight, tunBarSpeed, tunBarForegroundGrayLevel%, tunBarProgression%);

	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveDriftingBarParameters();
		PrintLog("TuningCurveDriftingBarDialog - user hit OK\n");
		tunType$ := tunTypeDriftingBar$;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run Drifting Bar");
        TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
        TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		PrintLog("TuningCurveDriftingBarDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
        'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
        DlgValue$(-1,"Select Expt.");
        TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
        TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
	endif;
    PrintLog("Return value is %d\n", iReturn%);
	return iReturn%;
end;


func TuningCurveCRGMDialog%()
	var iReturn% := 0;
	var i%;
    var tempdur;
    var lastStartTerm%;
	GetTuningCurveCRGMParameters();
    
    'M-Seq doesn't wrap, so we have to set an end point
    tempdur := DlgValue(1);  'this gets the currently-set duration of the stimulus in seconds
    lastStartTerm% := tunCRGMNumTerms% - 100 - (tempdur*dataScreenHz);  'don't start the M-Seq beyond this point - there's a buffer
                                                                        'assumes one frame per turn, unbalanced
    
    'set value of starting term in M sequence to ~random, allow user to change in dialog if they want
    tunCRGMFirstTerm% := Ceil(Rand(tunCRGMNumTerms%-99,99));  'will give value between 100 and tunCRGMNumTerms%, inclusive
    
	DlgCreate("CRG M-Seq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 99);
	DlgInteger(2, "Number of Repeats", 1, 300);  'henry changed here from 30 to 300
	DlgReal(3, "Min Contrast (%)", 0.1, 100);
	DlgReal(4, "Max Contrast (%)", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgInteger(6, "Frames per turn", 1, 1000);
    DlgInteger(7, "MSeq Starting Point", 100, lastStartTerm%);  'maximum start term calculated above
    DlgCheck(8, "Balanced");

	i% := DlgShow(tunCRGMNSteps%, tunCRGMNRepeats%, tunCRGMMinContrast, tunCRGMMaxContrast, tunCRGMProgression%, tunCRGMFramesPerTurn%, tunCRGMFirstTerm%, tunCRGMBalanced%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveCRGMParameters();
		tunType$ := tunTypeCRG$;
        
        'Reset dialog OK button text on Select dialog, and note which experiment to run
        DlgValue$(-1,"Run CRGs");
        TuningCurveScriptDialogAllowOK% := 1;  'Prepare to enable OK button
        TuningCurveScriptDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
        'Reset dialog OK button text on Select dialog, and note we need to pick an expt.
        DlgValue$(-1,"Select Expt.");
        TuningCurveScriptDialogAllowOK% := 0;  'Prepare to disable OK button
        TuningCurveScriptDialogChanged%(-1);  'Disables "OK" button, -1 is sham input
	endif;

	return iReturn%;
end;

func TunDlgGratingMaster%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Stimulus");
    i% := GratingParametersDialog2%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("Stimulus", tunGratingParams$);
        'SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end



'func TunDlgGratingSlave%()
'    
'    var x, y, w, h, sf, tf, ori, phase;
'    var contrast%;
'    var param$, cv$, pattern$, aperture$;
'    var label$;
'    var i%;
'    var tunGratingParamsStat$;
'    
'    tunGratingParams$ := GetGratingParameters$("SlaveStimulus");
'    i% := GratingParametersDialogSlave%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
'    if i% = 1 then
'        SaveGratingParameters("SlaveStimulus", tunGratingParams$);
'        SaveGratingParameters("StatSlaveStimulus", tunGratingParamsStat$);
'    endif
'    
'    return 1;
'end
'

func TunOptoDialog%()
	var iReturn% := 1;
	var i%;
    var labels$[3];
    labels$[0] := "Opto Off First";
    labels$[1] := "Opto On First";
    labels$[2] := "Random First";
	GetTunOptoParameters();
	DlgCreate("Optogenetics Parameters");
    
    DlgReal(1, "PreStimulus Opto On (s)",0,10);
    DlgReal(2, "PostStimulus Opto On (s)",0,10);
    DlgCheck(3, "Keep Opto on between stims");
    DlgReal(4, "Opto Voltage Out (V)",0.0002,5); '.0002 is the minimum value that will give any change at all (to 1 in a 15-bit range) on the DAC
    DlgList(5, "Order of blocks",labels$,3);
    'DlgCheck(6, "Record control box voltage");
    'DlgCheck(7, "Record stimulator");

	i% := DlgShow(tunPreStimOptoTime,tunPostStimOptoTime,tunOptoStaysOn%,tunOptoVoltageOut,tunOptoStartState%);',tunRecOptoBox%,tunRecStimulator%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTunOptoParameters();
        if tunOptoStartState% = 2 then
            tunOptoState% := round(Rand());
        else
            tunOptoState% := tunOptoStartState%;
        endif;
        'printlog("Opto start state is %d\n",tunOptoState%);  'yep, works
	endif;
    
	return iReturn%;
end;



func GratingParametersDialog2%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
'func GratingParametersDialog2%()    
	var i% := 13;  'That's right, 13
    var tempPhase;
    var firstRun := 1;
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 13 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 100);
        DlgReal(4, "Outer Height:", .1, 100);
        DlgReal(5, "Inner Width:", 0, 100);
        DlgReal(6, "Inner Height:", 0, 100);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 10);
        DlgReal(9, "Temporal Freq:", 0, 32);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern:", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        'DlgButton(13, "Copy from Slave", TunCopySlaveVals%(param$));
        if firstRun = 0 then  'prevent phase from being overwritten the first time the function is called
            phase := tempPhase;
        endif;
        firstRun := 0;      
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
        Convert180(phase);
        
        
    wend;
      
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
		' save parameters
        param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
		'param$ := Print$("%.1f,%.1f,%.1f,%.1f,%d,%.2f,%.2f,%.1f,%s,%s,%s", x, y, w, h, contrast%, sf, tf, ori, cv$, pattern$, aperture$);
        'statparam$ := EncodeGratingParameters$(x, y, w, h, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
        'statparam$ := Print$("%.1f,%.1f,%.1f,%.1f,%d,%.2f,0.00,%.1f,%s,%s,%s", x, y, w, h, contrast%, sf, ori, cv$, pattern$, aperture$); 'hardcoded zero TF
    endif
    return i%;
end;


func SelectTuningFile%()
    'This generic function ought to work for any of the dialogs where we allow the selection of a tuning file

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a tuning file");  'Find a tuning file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(7,direc$);  'Place filename into dialog item 7 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;

func SelectTuningFileNullTest%()
    'This generic function ought to work for any of the dialogs where we allow the selection of a tuning file
    'This is the same as the regular file, but the string dialog entry is in a different location for the null test.
    'It would have been really cool to have this function take an argument, but I tried that and it automatically ran
    'the function without the button being pressed as soon as the parent dialog was open, so that's a no-go.

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a tuning file");  'Find a tuning file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(9,direc$);  'Place filename into dialog item 9 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;


func TuningCurveGenericDialogChanged%(item%)
    'This single dialog changed function can be used for almost ALL the acute tuning dialogs that allow file-based tuning curves
    '(at least currently) because they all have the same structure and therefore the same dialog positions to allow/disallow
    if DlgValue(6) = 0 then  'If we are not using a tuning file
        DlgEnable(0,7);  'disable the string box with the text file name (button still works)
        DlgEnable(1,1);  'enable nSteps, min, and max
        DlgEnable(1,3);
        DlgEnable(1,4);
    endif;
    if DlgValue(6) = 1 then
        DlgEnable(1,7);  'enable the string box with the text file name
        DlgEnable(0,1);  'disable nSteps, min, and max
        DlgEnable(0,3);
        DlgEnable(0,4);
    endif;
    return 1;
end


func TuningCurveNullTestDialogChanged%(item%)
    'The Null Test dialog has extra entries below, moving the tested checkbox to position 8 and the DlgString to 9
    if DlgValue(8) = 0 then  'If we are not using a tuning file
        DlgEnable(0,9);  'disable the string box with the text file name (button still works)
        DlgEnable(1,1);  'enable nSteps, min, and max
        DlgEnable(1,3);
        DlgEnable(1,4);
    endif;
    if DlgValue(8) = 1 then
        DlgEnable(1,9);  'enable the string box with the text file name
        DlgEnable(0,1);  'disable nSteps, min, and max
        DlgEnable(0,3);
        DlgEnable(0,4);
    endif;
    return 1;
end


'
'func GratingParametersDialogSlave%(label$, &param$, &statparam$, &x, &y, &w, &h, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
'    
'	var i% := 13;  'That's right, 13
'    var tempPhase;
'    var firstRun := 1;
'    
'	var ColorVectorList$[5];
'	var cvl$[5];
'	var icvl% := 0;
'    var icvlS% := 0;
'	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
'	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
'	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
'	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
'	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
'    
'	var PatternList$[2];
'	var pl$[2];
'	var ipl% := 0;
'    var iplS% := 0;
'	PatternList$[0]:="Sine";	pl$[0]:="s";
'	PatternList$[1]:="Square";	pl$[1]:="q";
'    
'	var ApertureList$[2];
'	var al$[2];
'	var ial% := 0;
'    var ialS% := 0;
'	ApertureList$[0]:="Ellipse";	al$[0]:="e";
'	ApertureList$[1]:="Rectangle";	al$[1]:="r";
'    
'    while i% = 13 do
'        
'        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
'        if Len(param$)>0 then
'            if ParseGratingParameters%(param$, x, y, w, h, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
'                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
'                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
'                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
'            endif
'        endif
'        
'        DlgCreate("Grating parameters: " + label$, 25, 11);
'        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
'        DlgReal(1, "X:", -40, 40);
'        DlgReal(2, "Y:", -40, 40);
'        DlgReal(3, "Width:", .1, 30);
'        DlgReal(4, "Height:", .1, 30);
'        DlgInteger(5, "Contrast(%):", -100, 100);
'        DlgReal(6, "Spatial Freq:", .1, 10);
'        DlgReal(7, "Temporal Freq:", 0, 10);
'        DlgReal(8, "Orientation (degrees):", -360, 360);
'        DlgReal(9, "Initial Phase (deg, 0 = white at center)", 0, 360);
'        DlgList(10, "Color:", ColorVectorList$[]);
'        DlgList(11, "Pattern:", PatternList$[]);
'        DlgList(12, "Aperture:", ApertureList$[]);
'        DlgButton(13, "Copy From Master", TunCopyMasterVals%(param$));
'        if firstRun = 0 then  'prevent phase from being overwritten the first time the function is called
'            phase := tempPhase;
'        endif;
'        firstRun := 0;
'        
'        i% := DlgShow(x, y, w, h, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
'        Convert180(phase);
'        
'    wend;
'    
'	if i%=1 then
'		cv$ := cvl$[icvl%];
'		pattern$ := pl$[ipl%];
'		aperture$ := al$[ial%];
'		' save parameters
'		param$ := EncodeGratingParameters$(x, y, w, h, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
'		'param$ := Print$("%.1f,%.1f,%.1f,%.1f,%d,%.2f,%.2f,%.1f,%s,%s,%s", x, y, w, h, contrast%, sf, tf, ori, cv$, pattern$, aperture$);
'        statparam$ := EncodeGratingParameters$(x, y, w, h, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
'        'statparam$ := Print$("%.1f,%.1f,%.1f,%.1f,%d,%.2f,0.00,%.1f,%s,%s,%s", x, y, w, h, contrast%, sf, ori, cv$, pattern$, aperture$); 'hardcoded zero TF
'    endif
'    return i%;
'end;
'
'
'
'func TunCopySlaveVals%(&param$)
'
'    param$ := GetGratingParameters$("SlaveStimulus");
'
'    return 1;
'end
'
'
'
'func TunCopyMasterVals%(&param$)
'
'    param$ := GetGratingParameters$("Stimulus");
'
'    return 1;
'end
'
'
'func TunMasterValsToSlave%()
'    
'    var x, y, w, h;
'    var contrast%;
'    var sf, tf, ori, phase;
'    var cv$, pattern$, aperture$;
'    
'    var tempParams$;
'    
'    tempParams$ := GetGratingParameters$("Stimulus");
'    SaveGratingParameters("SlaveStimulus", tempParams$);
'    ParseGratingParameters%(tempParams$, x, y, w, h, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
'    tempParams$ := EncodeGratingParameters$(x, y, w, h, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
'    SaveGratingParameters("StatSlaveStimulus", tempParams$);
'    
'    return 1;
'end
'
'
'func TunSlaveValsToMaster%()
'    
'    var x, y, w, h;
'    var contrast%;
'    var sf, tf, ori, phase;
'    var cv$, pattern$, aperture$;
'    
'    var tempParams$;
'    
'    tempParams$ := GetGratingParameters$("SlaveStimulus");
'    SaveGratingParameters("Stimulus", tempParams$);
'    ParseGratingParameters%(tempParams$, x, y, w, h, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
'    tempParams$ := EncodeGratingParameters$(x, y, w, h, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
'    SaveGratingParameters("StatStimulus", tempParams$);
'    
'    return 1;
'end






'func TuningXHairDialog%()
'    DlgCreate("Crosshair/Grid");
'    DlgCheck(1, "Use crosshair grid");
'    DlgReal(2, "Grid inner radius offset", 0, 100);
'    DlgReal(3, "Grid mid radius offset", 0, 100);
'    DlgReal(4, "Grid outer radius offset", 0, 100);
'    DlgInteger(5, "Number of divisions in grid", 2, 128);
'    DlgReal(6, "XHair inner offset", -1, 100);
'    DlgReal(7, "XHair outer offset", -1, 100);
'    DlgAllow(0xffff, 0, TuningXHairDialogChanged%);
'    DlgShow(tunUseXHairs%, tunXHairInnerRadiusOffset, tunXHairMiddleRadiusOffset, tunXHairOuterRadiusOffset, tunXHairNumGridDivisions%, tunXHairTicInnerOffset, tunXHairTicOuterOffset);
'    return 1;
'end
'
'
'func TuningXHairDialogChanged%(item%)
'    docase 
'    case item% = 0 then
'        DlgEnable(tunUseXHairs%, 2, 3, 4, 5, 6, 7);
'    case item% = 1 then
'        DlgEnable(DlgValue(1), 2, 3, 4, 5, 6, 7);
'    endcase
'    return 1;
'end