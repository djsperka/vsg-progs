' $Id: AcuteTuning.s2s,v 1.10 2012-01-27 17:55:07 jeff Exp $
const tunCVSID$ := "$Id: AcuteTuning.s2s,v 1.10 2012-01-27 17:55:07 jeff Exp $";


#include "../../Spike2Util/ChannelUtilities.s2s"
#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "AcuteTuningDialogs.s2s"
#include "UsreyGratings.s2s"
#include "UsreyDAQ.s2s"


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var tunStimulusDuration := 3;      ' New, time for each stimulus to last, replaces tunFixationDuration
var tunInterTrialTime := 1;        ' New, time between stimuli 
'var tunBackgroundColor$ := "gray";	' background color for stim
var tunBackgroundGrayLevel% := 128; ' Background gray level
var tunDoF12% := 1;                 ' compute f1 and f2. 

' These will be set by the tuning curve choice
var tunNAdvances%;		' Number of times stim will advance during one repeat
var tunNRepeats%;		' Number of repeats

' This vector will hold the actual values to step through. Some are log steps, some are not. 
' The Indices array is the order to step through the values with: tunValues[tunValuesIndices%[0]], tunValues[tunValuesIndices%[1]], ...
' djs Make a constant tunMaxTrials to set the max number of trials. Arrays etc should be declared with this const. See below and
' tunF1Sum, tunF2Sum. 
const tunMaxTrials% := 1000;
var tunValues[tunMaxTrials%];
var tunValuesIndices%[tunMaxTrials%]; 
var tunNValues%;
var tunValuesStringified$;


'const tundlgXHairButton% := 8;
const tundlgOrientationButton% := 9;
const tundlgContrastButton% := 10;
const tundlgSpatialButton% := 11;
const tundlgTemporalButton% := 12;
const tundlgAreaButton% := 13;
const tundlgGratingParametersButton% := 14;
const tundlgDriftingBarButton% := 15;


' Wavemarks and continuous ports are specified elsewhere
var tunNWavemarks% := 0;
var tunWavemarkPorts%[16];
var tunNContinuous% := 0;
var tunContinuousPorts%[16];

' Hold sum of F1 values. Each channel (up to 16) has values saved according to the index of the tuning value
' Rely on the fact that arrays are initialized with 0s in Spike2. 
var tunF1Sum[16][tunMaxTrials%];
var tunF2Sum[16][tunMaxTrials%];
var tunTF;              ' Will need to use this during FFT analysis. Use at your own risk....

' djs 10-19-11 trigger hack for Visage trigger bug.
var tunTriggerHack% := 1;




proc GetTuningCurveScriptParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
    tunStimulusDuration := GetFloatRegistryValue(key$, "StimulusDuration", tunStimulusDuration);  'new
    tunInterTrialTime := GetFloatRegistryValue(key$, "InterTrialTime", tunInterTrialTime);  'new
    'tunBackgroundColor$ := GetStringRegistryValue$(key$, "BackgroundColor", tunBackgroundColor$);
    tunBackgroundGrayLevel% := GetIntRegistryValue%(key$, "BackgroundGrayLevel", tunBackgroundGrayLevel%);
end;

proc SaveTuningCurveScriptParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
    SetFloatRegistryValue(key$, "StimulusDuration", tunStimulusDuration);
    SetFloatRegistryValue(key$, "InterTrialTime", tunInterTrialTime);
    'SetStringRegistryValue(key$, "BackgroundColor", tunBackgroundColor$);
    SetIntRegistryValue(key$, "BackgroundGrayLevel", tunBackgroundGrayLevel%);
end;


' TuningCurveScriptDialog
' This dialog uses two global variables, tunContext$ and tunType$. 
' Set tunContext$ = tunContextConfig$ to run in the config scripts. The dialog 
' and its children (TuningCurveOrientationDialog, etc) will behave as expected, 
' allowing the user to set parameters and saving them in the registry. Set 
' tunContext$ = tunContextDAQ$ to run in a DAQ script. In this context you 
' must check the return value of the dialog and (possibly) the value of 
' tunType$. If the user hits Cancel in the main dialog, the return value is 0. 
' If the user selects a subdialog and hits OK, the return value will be 1 and 
' the value of tunType$ will be one of (tunTypeOrientation$, tunTypeContrast$, 
' tunTypeSpatial$, tunTypeTemporal$). Here, proceed directly to DAQ. If the 
' user Hits Cancel from the subdialog, then they return to the main dialog. If 
' they hit OK from the main dialog, then the return value is 1, but 
' tunType$ = tunTypeNone$. 


func TuningCurveScriptDialog%()
	var i%;
	var iReturn%;
    var tempParam$;
    var tempPhase;
    var boxOK% := 1;  'do the stimulus/crosshairs boxes overlap?
	GetTuningCurveScriptParameters();
'	var bcl$[3];
'	var ibcl%:=0;
'	bcl$[0] := "gray";
'	bcl$[1] := "black";
'	bcl$[2] := "white";
'	for i%:=0 to 2 do
'		if tunBackgroundColor$ = bcl$[i%] then
'			ibcl% := i%;
'		endif
'	next;
    

	DlgCreate("Tuning Curve Parameters", 50, 10);
	DlgGroup("Common Parameters", 1, 1, 38, 4);
	DlgReal(1, "Stimulus Duration(s):", .1, 100, 20, 2);  'new, allow really long stimuli
    DlgReal(2, "InterTrial Time(s):", .1, 100, 20, 3);  'new, allow really long stimuli
	'DlgList(3, "Background color:", bcl$, 3, 20, 4);  'updated as new dialog number
    DlgInteger(3, "Background Gray Level (0-255):", 0, 255, 20, 4);  'new, allow all grays
	DlgGroup("Individual Tuning Curve Types", 1, 6, 38, 6);
	DlgButton(tundlgOrientationButton%, "Orientation", TuningCurveOrientationDialog%, 2, 7);
	DlgButton(tundlgContrastButton%, "Contrast", TuningCurveContrastDialog%, 2, 8);
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 9);
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 2, 10);
	DlgButton(tundlgAreaButton%, "Area", TuningCurveAreaDialog%, 2, 11);
    DlgGroup("Grating Parameters", 1, 12, 38, 2);
    DlgButton(tundlgGratingParametersButton%, "Grating Parameters", TunDlgGratingMaster%, 2, 13);
    DlgGroup("Non-Grating Stimuli", 1, 14, 38, 2);
    DlgButton(tundlgDriftingBarButton%, "Drifting Bars", TuningCurveDriftingBarDialog%, 2, 15);
    
    'i%:=DlgShow(tunStimulusDuration, tunInterTrialTime, ibcl%);  'new, for reduced dialog
    i%:=DlgShow(tunStimulusDuration, tunInterTrialTime, tunBackgroundGrayLevel%);  'now using background gray level
    
    ' djs 4-1-09
    ' Spike2 v6 change. DlgShow will return the button number when a button on the dialog is hit and the corresponding
    ' function returns 0. In this case those buttons open the various tuning type sub dialogs (orientation, area, etc). 
    ' In the last version, DlgShow would return the same value that the subdialog's function returned, and the code here
    ' was set up to behave accordingly. When the user hits the Cancel button in the subdialog everything still remains
    ' the same. 
    
    ' djs 2-4-2011
    ' Spike2v6 bug (see TuningDialogs.s2s) workaround requires that the tuning type dialogs return something > 0. 
    ' That will mean that closing any of those dialogs will not cause the main dialog (this one) to close automatically. 
    ' When it did close automatically the return value from DlgShow above was the same as the button that caused
    ' the close. Now, that button is NOT causing the close, so the return value is going to be 1 (not the button number). 
    ' In addition, the return value from this function needs to change because we now assume that the user will have
    ' to hit OK on this dialog to start the experiment. Thus, make sure that the return value from this function is 1
    ' when user hits OK and 0 when user hits Cancel. Also, do not save script parameters when user hits Cancel.
    
    'PrintLog("Tuning Curve Parameters Dialog - return from DlgShow is %d\n", i%);
    '	if i%=tundlgOrientationButton% or i%=tundlgContrastButton% or i%=tundlgSpatialButton% or i%=tundlgTemporalButton% or i%=tundlgAreaButton% then
    if i% = 1 then
		'tunBackgroundColor$ := bcl$[ibcl%];
		SaveTuningCurveScriptParameters();
		if tunContext$ = tunContextDAQ$ then 
            iReturn% := 1;
		else iReturn% := 1;
		endif;
        
	endif;
	if i% = 0 then
		'PrintLog("Tuning Curve Parameters dialog - user hit Cancel, tunType=" + tunType$ + "\n");
		if tunContext$ = tunContextDAQ$ then 
			if tunType$ <> tunTypeNone$ then 
				iReturn% := 0;
				'SaveTuningCurveScriptParameters();
			else iReturn% := 0;
		 	endif;
		else
			iReturn% := 2;		' The calling/main dialog would close if we returned 0
		endif;
	endif;
	return iReturn%;
end;




' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;

' xy windows for plotting (TuningWindow) and PSTH. 
var TuningWindow%[16];	' one for each wavemark channel
var PSTHWindow%[16];    ' used for f1 and f2. Will be made invisible when in use. 

' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Init logging
LogInit(1);

' run parameters script....
tunContext$ := tunContextDAQ$;
tunType$ := tunTypeNone$;

GetTuningCurveScriptParameters();
iScript% := TuningCurveScriptDialog%();
if iScript% = 1 then
	if tunType$ = tunTypeNone$ then
		LogInfo("No tuning type selected, exit gracefully\n");
		Halt;
	else
		'LogInfo("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ. DoRivalry = " + str$(tunDoRivalry%));
        LogInfo("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ.");
	endif;
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' When TF curve, don't do f1 and f2. 
if tunType$ = tunTypeTemporal$ then
    tunDoF12% := 0;
endif


' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 21;
YChannel% := 22;
StimChannel% := 25;
ReadyChannel% := 27;            ' Look for ready signal on port 2 (same as fixpt). 
FrameChannel% := 19;

' Fetch electrode information. 
tunNWavemarks% := GetWavemarkPorts%(tunWavemarkPorts%[]);
tunNContinuous% := GetContinuousPorts%(tunContinuousPorts%[]);

CreateSampleConfiguration();


' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
'	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
'	ToolbarSet(6,"Exp Parameters",AttentionScriptDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 
var tStimSequence := -1;    ' time that stim sequence started; followed by pulses on frame channels
var tInterTrialTime := 0;	' Time spent waiting between trials (i.e. after screen is blank, but before fix point is presented)
var tRise, tFall;

' Constants for states
const stateStartTrial%:=0;		' Start trial state
const stateWaitForStimOn%:=3;		' Wait for stimulus return trigger (on)
const stateWaitForStimOff%:=4;		' Wait for stimulus return trigger (off)
const stateStimulusPlaying%:=5;     ' New, wait for tNow to exceed stimulus duration
const stateMaintainFixation%:=8;	' Maintaining fixation (stim off period)
const stateInterTrialInterval%:=9;	' time out after failed trial
const stateVSGWait%:=10;		' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForStimTrigger% := 14; ' Rising edge indicating start of stim sequence
const stateBarPlaying%:=15;

var iState% := stateVSGWait%;	' present state

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 

var pulseFound%;
var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
tic := View(DataWindow%).BinSize(ReadyChannel%);

func IdleProcessing%()
	var iStatus% := 1;	
	tNow := View(DataWindow%).MaxTime();
    
    ' First time through (tLast<0) just update tLast. Crosstalk on vsg dig outputs leads to erroneous
    ' triggers. Maybe this will help. 
    if tLast < 0 then
        tLast := 1;
        return 1;
    endif
    
    
	docase 
    case iState% = stateVSGWait% then
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        'if View(DataWindow%).FindPulseUp%(ReadyChannel%, -1, tRise, tFall) = 1 then
        pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
        if pulseFound% = 1 then
            LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
            Yield(1.0);
            tLastTrigger := tFall;
            ChangeStateTo(stateStartTrial%, tFall);
        else
            if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                tLastTrigger := tFall;
            endif;
        endif;

    case iState% = stateStartTrial% then

        ' Start trial. Put up stimulus.
        LogStatus("StartTrial", "Request stimulus");
        SampleText("T," + str$(GetPlotXCoord(nTrialsCompleted%)));
        SafeSampleKey("S");
        'iHoldCount% := 0;
        ChangeStateTo(stateWaitForStimTrigger%, tNow);
    

    case iState% = stateWaitForStimTrigger% then
        
        if tunTriggerHack% = 0 then
            if View(DataWindow%).FindRisingEdge%(StimChannel%, tLast, tTrigger) = 0 then
                ' Stimulus has begun
                LogStatus("WaitForStimTrigger", "Stim sequence started at " + str$(tTrigger));
                tStimOn := tTrigger;
                tStimSequence := tTrigger;      ' TODO remove tStimOn ref above - see stateWaitForStimOn
                tLastTrigger := tTrigger;
                'ChangeStateTo(stateHoldFixation%, tTrigger);
                if tunType$ = tunTypeDriftingBar$ then
                    ChangeStateTo(stateBarPlaying%, tTrigger);
                else
                    ChangeStateTo(stateStimulusPlaying%, tTrigger);
                endif;
            endif
        else
            if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then
                ' Stimulus has begun
                LogStatus("WaitForStimTrigger", "Stim sequence started at " + str$(tRise));
                tStimOn := tRise;
                tStimSequence := tRise;
                tLastTrigger := tRise;
                if tunType$ = tunTypeDriftingBar$ then
                    ChangeStateTo(stateBarPlaying%, tRise);
                else
                    ChangeStateTo(stateStimulusPlaying%, tRise);
                endif;
            endif
        endif
            
        
        
        
    case iState% = stateStimulusPlaying% then

        if tNow - tStateStart > tunStimulusDuration then
            
            ' turn off stimulus and advance it
            SampleText("+");
            LogStatus("StimulusPlaying", "Turn off and advance stimulus.");
            
            SafeSampleKey("X");            
                        
            Yield();
            
            ' Process spikes
            PlotSpikes(tStimOn, tNow, 1, GetPlotXCoord(nTrialsCompleted%), nTrialsCompleted%);
            
            ' Now wait until stim is off
            ChangeStateTo(stateWaitForStimOff%, tNow);
            
        endif
        
        
        
    case iState% = stateWaitForStimOff% then
        
        if tunTriggerHack% = 0 then
            if View(DataWindow%).FindFallingEdge%(StimChannel%, tLast, tTrigger) = 1 then
                ' Advance
                SafeSampleKey("a");

                tLastTrigger := tTrigger;
                ChangeStateTo(stateTrialCompleted%, tNow);
            endif
        else
            if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then
                ' Advance
                SafeSampleKey("a");

                tLastTrigger := tRise;
                ChangeStateTo(stateTrialCompleted%, tRise);
            endif
        endif
        
        
    case iState% = stateBarPlaying% then
        if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then
            
            'Note stimulus is off
            SampleText("+");
            LogStatus("BarPlaying", "Turn off and advance stimulus.");          
            
            SafeSampleKey("X");            
            
            Yield();
            
            ' Process spikes
            PlotSpikes(tStimOn, tNow, 1, GetPlotXCoord(nTrialsCompleted%), nTrialsCompleted%);
            
            'Advance
            SafeSampleKey("a");

            tLastTrigger := tRise;
            ChangeStateTo(stateTrialCompleted%, tRise);
        endif
        
    case iState% = stateTrialCompleted% then
        
        nTrialsCompleted% += 1;         ' this state must be exited this time through!!!
        printlog("number of trials completed is %d\n",nTrialsCompleted%);
        if nTrialsCompleted% = (tunNAdvances%+1)*tunNRepeats% then
            ' We're all done
            ChangeStateTo(stateDone%, tNow);
            Stop%();
            iStatus% := 0;
        else
            tInterTrialTime := tunInterTrialTime;
            ChangeStateTo(stateInterTrialInterval%, tNow);
        endif        

    case iState% = stateInterTrialInterval% then

        if tNow - tStateStart > tInterTrialTime then

            ChangeStateTo(stateStartTrial%, tNow);

        endif

    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;

	endcase;

	tLast := tNow;
	return iStatus%;
end;


func GetPlotXCoord(nTrials%)
    return tunValues[tunValuesIndices%[nTrials%]];
end;

proc PlotSpikes(t1, t2, vOnOff%, x, index%)
	var rate;
    var i%;
    var tSweep;
    var fftData[16];        ' size of this array should be same as number of bins!
    
	for i% := 0 to tunNWavemarks%-1 do
		rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
		if rate >= 0 then
			if vOnOff% = 1 then
				' this is signal
                'PrintLog("%d Count %f\n", i%, rate*(t2-t1));
				View(TuningWindow%[i%]).XYAddData(1, x, rate);    ' channel 1 is data; channel 2 is background
			endif
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	    endif 
        
        if tunDoF12% = 1 and vOnOff% = 1 then
            ' Process for each cycle of the stimulus. A single cycle of the stim takes 1/tf
			View(PSTHWindow%[i%]);
			Process(t1, t2, 1, 1);
			for tSweep := t1+1/tunTF to t2-1/tunTF step 1/tunTF do 
				Process(tSweep, tSweep+1/tunTF, 0, 1);
			next
			ArrConst(fftData[], View(PSTHWindow%[i%]).[]);
			ArrFFT(fftData[], 4); 
            View(TuningWindow%[i%]).XYAddData(2, x, fftData[1]);
            View(TuningWindow%[i%]).XYAddData(3, x, fftData[2]);
            tunF1Sum[i%][index%] += fftData[1];
            tunF2Sum[i%][index%] += fftData[2];
        endif
        
	next
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end





proc InitializeWindows()
    var i%;
    var WindowStep;
    var ch1%, ch2%;
    
    ' Get tf of stim
    tunTF := GetStimulusTF();
    
    ' Make spike2 use allof monitor 1
    View(App()).Window(0, 0, 100, 100, 1);
    
	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(0,48,50,95);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
    
	' open xy window to display tuning results    
    if tunNWavemarks% > 0 then
        WindowStep := 100/tunNWavemarks%;
    endif
    for i% := 0 to tunNWavemarks%-1 do
        TuningWindow%[i%] := FileNew(12);
        Window(50, i%*WindowStep, 100, (i%+1)*WindowStep);
        ChanTitle$(0, "Spikes/s");
        TuningCurveLabels(tunWavemarkPorts%[i%]);
        WindowVisible(1);
        
        ' Create psth window if f1 and f2 analysis needed
        if tunDoF12% = 1 then
            
            ch1% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f1
            XYColour(ch1%, 25);
            ch2% := View(TuningWindow%[i%]).XYSetChan(0);   ' used to plot f2
            XYColour(ch2%, 30);
            LogStatus("InitializeWindows", "Channel " + str$(i%+1) + " " + str$(ch1%) + " " + str$(ch2%));
            'PSTHWindow%[i%] := View(DataWindow%).SetPSTH(i%+1, 16, 1 /(tunTF*16), 0, 0, 3);
            PSTHWindow%[i%] := View(DataWindow%).SetPSTH(tunWavemarkPorts%[i%]+1, 16, 1 /(tunTF*16), 0, 0, 3);  'must use index to tWMP%[] now that channel #s correspond to port #s (+1)
            View(PSTHWindow%[i%]).WindowVisible(0);
        endif        
    next

end;

proc TuningCurveLabels(iport%)

    var s$;
    s$ := "Port " + str$(iport%);
	docase 
		case tunType$ = tunTypeContrast$ then

			WindowTitle$("Contrast Tuning - " + s$);
			XUnits$("Contrast (%)");
			ChanTitle$(1, "Chan 1");
			XRange(tunContrastMinContrast, tunContrastMaxContrast);

		case tunType$ = tunTypeOrientation$ then

			WindowTitle$("Orientation Tuning - " + s$);
			XUnits$("Orientation (degrees)");
			ChanTitle$(1, "Chan 1");
			XRange(tunOriMinOrientation, tunOriMaxOrientation);

		case tunType$ = tunTypeSpatial$ then

			WindowTitle$("Spatial Frequency Tuning - " + s$);
			XUnits$("Spatial Frequency");
			ChanTitle$(1, "Chan 1");
			XRange(tunSpatialMinSF, tunSpatialMaxSF);
	
		case tunType$ = tunTypeTemporal$ then

			WindowTitle$("Temporal Frequency Tuning - " + s$);
			XUnits$("Temporal Frequency");
			ChanTitle$(1, "Chan 1");
			XRange(tunTemporalMinTF, tunTemporalMaxTF);

		case tunType$ = tunTypeArea$ then

			WindowTitle$("Aperture Area Tuning - " + s$);
			XUnits$("Aperture Diameter");
			ChanTitle$(1, "Chan 1");
			XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
        case tunType$ = tunTypeDriftingBar$ then

			WindowTitle$("Drifting Bar Orientation Tuning - " + s$);
			XUnits$("Orientation (degrees)");
			ChanTitle$(1, "Chan 1");
            XRange(tunBarMinOrientation, tunBarMaxOrientation);
        
		else

			Message("TuningCurveLabels Error - unknown value for tunType$: " + tunType$);

	endcase;

end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;
	SampleClear(); 'Set standard sampling state
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    docase
        
    case tunType$ = tunTypeContrast$ then 
        SampleAutoName$(dataCellName$ + "_con_000");
        tunNAdvances% := tunContrastNSteps%;
        tunNRepeats% := tunContrastNRepeats%;
        GetRepeatedParameterProgression%(tunContrastNSteps%+1, tunContrastNRepeats%, tunValues[], tunValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, tunContrastProgression%);
        tunNValues% := (tunContrastNSteps%+1)*tunContrastNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeOrientation$ then 
        SampleAutoName$(dataCellName$ + "_ori_000");
        tunNAdvances% := tunOriNSteps%;
        tunNRepeats% := tunOriNRepeats%;
        GetRepeatedParameterProgression%(tunOriNSteps%+1, tunOriNRepeats%, tunValues[], tunValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, tunOriProgression%);
        tunNValues% := (tunOriNSteps%+1)*tunOriNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeSpatial$ then 
        SampleAutoName$(dataCellName$ + "_spa_000");
        tunNAdvances% := tunSpatialNSteps%;
        tunNRepeats% := tunSpatialNRepeats%;
        GetRepeatedParameterProgression%(tunSpatialNSteps%+1, tunSpatialNRepeats%, tunValues[], tunValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, tunSpatialProgression%);        
        tunNValues% := (tunSpatialNSteps%+1)*tunSpatialNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeTemporal$ then 
        SampleAutoName$(dataCellName$ + "_tem_000");
        tunNAdvances% := tunTemporalNSteps%;
        tunNRepeats% := tunTemporalNRepeats%;
        GetRepeatedParameterProgression%(tunTemporalNSteps%+1, tunTemporalNRepeats%, tunValues[], tunValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 1, tunTemporalProgression%);
        tunNValues% := (tunTemporalNSteps%+1)*tunTemporalNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeArea$ then 
        SampleAutoName$(dataCellName$ + "_area_000");
        tunNAdvances% := tunAreaNSteps%;
        tunNRepeats% := tunAreaNRepeats%;
        GetRepeatedParameterProgression%(tunAreaNSteps%+1, tunAreaNRepeats%, tunValues[], tunValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
        tunNValues% := (tunAreaNSteps%+1)*tunAreaNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeDriftingBar$ then 
        SampleAutoName$(dataCellName$ + "_bar_000");
        tunNAdvances% := tunBarNSteps%;
        tunNRepeats% := tunBarNRepeats%;
        GetRepeatedParameterProgression%(tunBarNSteps%+1, tunBarNRepeats%, tunValues[], tunValuesIndices%[], tunBarMinOrientation, tunBarMaxOrientation, 0, tunBarProgression%);
        tunNValues% := (tunBarNSteps%+1)*tunBarNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    else
        SampleAutoName$(dataCellName$ + "_tun_000");
    endcase;
    
    
    SampleAutoFile(1);
    
    ' Text marks make extraction easier
    SampleTextMark(200);
    
	'Channel recording definitions
	SampleEvent(StimChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
	SampleEvent(FrameChannel%, 0, 2, 3600);
	SampleComment$(FrameChannel%,"Frame");
	SampleTitle$(FrameChannel%,"Frame");
    
    ' Electrodes: wavemark/continuous
    ' 12/6/2010
    ' Wavemark channels will be channels # 1-N, waveform N+1 - N+1+M, where there are N wavemark channels
    ' and M waveform channels. 
    ' Changed!  To avoid confusion wavemarks now are place on channels (Port+1) and waveforms on channels (Port+8)
    for i% := 0 to tunNWavemarks%-1 do
		'SampleWaveMark(i% + 1, tunWavemarkPorts%[i%], 2000, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
		'SampleTitle$(i% + 1, "WMrk " + str$(tunWavemarkPorts%[i%])); 
        'Trying here to avoid collapsing channel numbers
        SampleWaveMark(tunWavemarkPorts%[i%]+1, tunWavemarkPorts%[i%], 2000, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
		SampleTitle$(tunWavemarkPorts%[i%]+1, "WMrk " + str$(tunWavemarkPorts%[i%]));
        if tunWavemarkPorts%[i%] > 6 then
            message("The rig should only be set up to collect data from Ports 0-6!  Quitting!");
            'This message comes up because of the non-collapsed (i.e. non-continuous) channel numbers.  There is a "hack" a few lines below
            'which sets the continuous waveforms to live on channels numbered 7 greater than the corresponding WaveMark channel.  We can get
            'away with this because the Thomas system which feeds into the CED has only 7 electrode channels which are fed to Ports 0-6 on
            'the CED.  As of now, the channels that can legally hold WaveMarks are channels 1-7 and the channels that can legally hold
            'continuous waveforms are channels 8-14.  Since channel 19 holds pulses, there isn't a lot more room to work under this scheme
            'before needing to reposition other channels anyway (this non-collapsed scheme would work up to a hard-coded 9 rather than 7 Ports).
            'So if you need to use Port 7/8, you'll need to change the hardcode here and for tunNContinuous% below to 8/9.  If you need
            'to go beyond Port 8, you'll have to either move some of the hardcoded pulse channels, or dump the non-collapsed numbering scheme. -jj
            halt();
        endif;
	next
    for i% := 0 to tunNContinuous%-1 do
        'SampleWaveform(tunNWavemarks% + i% + 1, tunContinuousPorts%[i%], 20000);
        'SampleTitle$(tunNWavemarks% + i% + 1, "Cont " + str$(tunContinuousPorts%[i%]));
        'Trying here to avoid collapsing channel numbers
        SampleWaveform(tunContinuousPorts%[i%]+8, tunContinuousPorts%[i%], 20000);  'this hack only works because wavemark chans are limited to channels 1-7
        SampleTitle$(tunContinuousPorts%[i%]+8, "Cont " + str$(tunContinuousPorts%[i%]));
    next
    
	SampleSequencer(script$ + "Tuning.pls");
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;

' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, j%, m%;
    
	' Disable idle process func
	ToolbarSet(0,"");

	' Tell stim app to shut down
	SafeSampleKey("Q");
	Yield(.1);
	SampleStop();

	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend

	' Write parameter file
	WriteParameterFile();

	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
'	TotalRewards% += nTrialsCompleted%;
	SaveDailyTotals();
    
    ' Figure out max F1 values
    if tunDoF12% = 1 then
        for i% := 0 to tunNWavemarks%-1 do
            m% := Max(tunF1Sum[i%][]);
            LogStatus("F1 Max", "Channel " + str$(i%+1) + " Port " + str$(tunWavemarkPorts%[i%]) + " max F1 at x=" + str$(tunValues[m%]));
        next
    endif    

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetAcuteDistanceToScreenMM$());
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	'Print("Background color           : %s\n", tunBackgroundColor$);
    Print("Background gray level      : %d\n", tunBackgroundGrayLevel%);

	' write stimulus parameters
	Print("\nStimulus\n");
	Print("-------------------\n\n");

	var Tstimstr$;
	var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
    var phase;
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    Print("Initial Phase (degrees)         : %f\n", phase);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);


	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");
    Print("Stimulus Duration (s)  : %f\n", tunStimulusDuration);
	Print("\nTuning parameters\n");
	Print("-------------------\n\n");
	docase 
		case tunType$ = tunTypeContrast$ then

			Print("Type:                  : Contrast\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");


		case tunType$ = tunTypeOrientation$ then

			Print("Type:                  : Orientation\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeSpatial$ then

			Print("Type:                  : Spatial Frequency\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");
	
		case tunType$ = tunTypeTemporal$ then

			Print("Type:                  : Temporal Frequency\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeArea$ then

			Print("Type:                  : Aperture Area\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
            Print("\n");
        
        case tunType$ = tunTypeDriftingBar$ then

			Print("Type:                  : DriftingBar\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunBarMinOrientation, tunBarMaxOrientation, tunBarNSteps%, tunBarNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		else

			Print("TuningCurve Error - unknown value for tunType$: %s\n", tunType$);

	endcase;

	' close parfile
	FileClose(0);

end;


' Gets the temporal freq of the current stimulus. 
' Make sure to call this only after all user dialogs have been completed (so you know that the stim parameters will not change)

func GetStimulusTF()
    var gr$;
    var x, y, w, h, sf, tf, ori, phase;
    var contrast%;
    var cv$, pattern$, aperture$;
	gr$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(gr$, x, y, w, h, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    LogStatus("GetStimulusTF", "TF=" + str$(tf));
    return tf;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var cmdLine$;
'	var FixationPoint$;
	var Extras$;
	var Tune$;
	var Stim$:="";
'	var SlaveStim$:="";
	var Values$;
'    var Dual$;
    var key$;
    var offsetFilename$;
    var i%;
    var ProgName$;
    var tunBGStr$;
    var tunFGStr$;
    var tunBarStr$;
'    var XHairArg$;
	
	SampleStart(0); 'Start sampling
	SafeSampleKey("0");
    
    'build background gray level string
    tunBGStr$ := "(" + Str$(tunBackgroundGrayLevel%) + "/" + Str$(tunBackgroundGrayLevel%) + "/" + Str$(tunBackgroundGrayLevel%) + ") ";
    
    Stim$ := " -s " + GetGratingParameters$("Stimulus");    
	Values$ := tunValuesStringified$;
    'Extras$ := " -b " + tunBackgroundColor$ + " -d " + GetAcuteDistanceToScreenMM$() + " -p 2 -v";
    Extras$ := " -b " + tunBGStr$ + " -d " + GetAcuteDistanceToScreenMM$() + " -p 2 -v";
    
    'By default, set ProgName$ to be FIXSTIM
    ProgName$ := "\\fixstim.exe ";    
    
	docase 
    case tunType$ = tunTypeContrast$ then
        
        'Tune$ := Dual$ + " -C " + Values$;
        Tune$ := " -C " + Values$;

    case tunType$ = tunTypeOrientation$ then

        'Tune$ := Dual$ + " -O " + Values$;
        Tune$ := " -O " + Values$;

    case tunType$ = tunTypeSpatial$ then

        'Tune$ := Dual$ + " -S " + Values$;
        Tune$ := " -S " + Values$;

    case tunType$ = tunTypeTemporal$ then

        'Tune$ := Dual$ + " -T " + Values$;
        Tune$ := " -T " + Values$;

    case tunType$ = tunTypeArea$ then
        
        'Tune$ := Dual$ + " -A " + Values$;
        Tune$ := " -A " + Values$;
        
    case tunType$ = tunTypeDriftingBar$ then
        
        'build foreground gray level string
        tunFGStr$ := "(" + Str$(tunBarForegroundGrayLevel%) + "/" + Str$(tunBarForegroundGrayLevel%) + "/" + Str$(tunBarForegroundGrayLevel%) + ")";
        'build drifting bar string
        tunBarStr$ := Str$(tunBarWidth) + "," + Str$(tunBarHeight) + "," + Str$(tunBarSpeed) + ",";
        
        Tune$ := " -G " + tunFGStr$ + "," + tunBarStr$ + "," + Values$;
        
    else

        Message("Error - unknown value for tunType$: " + tunType$);
        Halt;

	endcase;
	
    cmdLine$ := "cmd /k " + bin$ + ProgName$ + Extras$ + Stim$ + Tune$;
    
    ' Record initial text marks. The command line may need to be broken into pieces. 
    if tunTriggerHack% = 0 then
        SampleText("Tuning,3," + str$(Len(cmdLine$)));  'not clear what this should be, if anything.
    else
        SampleText("Tuning,4," + str$(Len(cmdLine$)));  'not clear what this should be, if anything.
    endif
    
    SampleText(tunCVSID$);
    for i% := 1 to Len(cmdLine$) step 100 do
        SampleText(Mid$(cmdLine$, i%, 100));
    next
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n");
    printlog("num advances is %d and num repeats is %d\n",tunNAdvances%,tunNRepeats%);
	StimHandle% := ProgRun(cmdLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(.1);
return 1;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLogProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a linear progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLinearProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (xmax -xmin)/nsteps%;
	for v := xmin to xmax+stepsize/2 step stepsize do
	'	PrintLog("Value=" + str$(v) + "\n");
		vec[i%] := v;
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
Func StringifyProgression$(n%, vec[], ind%[])
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
		s$ += str$(vec[ind%[i%]]);
	next
	return s$;
end;

