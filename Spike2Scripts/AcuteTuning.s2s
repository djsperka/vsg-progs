' $Id: AcuteTuning.s2s,v 1.41 2015-05-13 21:57:13 devel Exp $
const tunCVSID$ := "$Id: AcuteTuning.s2s,v 1.41 2015-05-13 21:57:13 devel Exp $";

'var TuningCurveScriptDialogAllowOK%;  'allows OK to button to work on main dialog

#include "../../Spike2Util/ChannelUtilities.s2s"
#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "AcuteTuningDialogs.s2s"
#include "UsreyGratings.s2s"
#include "UsreyDAQ.s2s"


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' replace vars herezzzzzzzzzzzzzzzz

' This vector will hold the actual values to step through. Some are log steps, some are not. 
' The Indices array is the order to step through the values with: tunValues[tunValuesIndices%[0]], tunValues[tunValuesIndices%[1]], ...
' djs Make a constant tunMaxTrials to set the max number of trials. Arrays etc should be declared with this const. See below and
' tunF1Sum, tunF2Sum. 
const tunMaxTrials% := 1000;
var tunValues[tunMaxTrials%];
var tunValuesIndices%[tunMaxTrials%]; 
var tunNValues%;
var tunValuesStringified$;
var nTriggersExpected%;     'only for tunTypeCRG$
var triggerCount%;




' Wavemarks and continuous ports are specified elsewhere
var tunNWavemarks% := 0;  'This is really the number of Wavemark CHANNELS, hence the number of 'trodes
var tunWavemarkPorts%[16];
var tunNContinuous% := 0;
var tunContinuousPorts%[16];


'Variables for creating rasters
var memChanRasterTriggers%;  'a memory channel that holds raster triggers
var memChanRasterTriggersOpto%;  'a memory channel that holds raster trigger for the opto state
var memChanBetterTextMark%;  'a memory channel that mimics the textmark channel, but with better temporal fidelity
var handlePSTH%[16];         'a list of PSTH handles
var stimCodes%[4];           'For the raster textmark channel; we'll only use index 0 but the textmark requires a 4-length vector
var rasterTotal;  'total duration for raster
var rasterPre := .2;  'Hard coded for now, will change if necessary
var rasterPost := 0;  'No post-stim for now, but this will facilitate a change in the future
var histBinWidth := 0.05;  'Just throwing out 50 ms as a number
var histBins%;
var myTitle$;
var myTitle2$;
var trodes[10];  'global, for creating rasters at the end
var vals[30];    'global, for creating rasters at the end
var handlePSTHend%[10];  'For creating rasters at the end

' Hold sum of F1 values. Each channel (up to 16) has values saved according to the index of the tuning value
' Rely on the fact that arrays are initialized with 0s in Spike2. 
var tunF1Sum[16][tunMaxTrials%];
var tunF2Sum[16][tunMaxTrials%];
var tunTF;              ' Will need to use this during FFT analysis. Use at your own risk....
var tunF1Cum[16];
var tunF2Cum[16];
var tunRateCum[16];

' djs 10-19-11 trigger hack for Visage trigger bug.
var tunTriggerHack% := 1;

var memorychannel% := 28;
var memorychannel2% := 29;
var memorychannelopto% := 45;  'avoiding textmarks
'var memorychannelvisible% := 0;  'unused...?



' replace hereZZZZZZZZZZZZZZZZZZZZZZZZZZ

' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;
var StimulatorChannel%;

' xy windows for plotting (TuningWindow) and PSTH. 
var TuningWindow%[16];	' one for each wavemark channel
var PSTHWindow%[16];    ' used for f1 and f2. Will be made invisible when in use. 

' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Init logging
LogInit(1);

' run parameters script....
tunContext$ := tunContextDAQ$;
tunType$ := tunTypeNone$;

GetTuningCurveScriptParameters();
iScript% := TuningCurveScriptDialog%();
if iScript% = 1 then
	if tunType$ = tunTypeNone$ then
		LogInfo("No tuning type selected, exit gracefully\n");
		Halt;
	else
		'LogInfo("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ. DoRivalry = " + str$(tunDoRivalry%));
        LogInfo("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ.");
	endif;
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' When TF curve or TF = 0, don't do f1 and f2. 
if tunType$ = tunTypeTemporal$ or GetTemporalFrequency() = 0 then
    tunDoF12% := 0;
endif


' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 21;
YChannel% := 22;
StimChannel% := 25;
ReadyChannel% := 27;            ' Look for ready signal on port 2 (same as fixpt). 
FrameChannel% := 19;
StimulatorChannel% := 18;

' Fetch electrode information. 
tunNWavemarks% := GetWavemarkPorts%(tunWavemarkPorts%[]);
tunNContinuous% := GetContinuousPorts%(tunContinuousPorts%[]);

CreateSampleConfiguration();


' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
'	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
'	ToolbarSet(6,"Exp Parameters",AttentionScriptDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 
var tStimSequence := -1;    ' time that stim sequence started; followed by pulses on frame channels
var tInterTrialTime := 0;	' Time spent waiting between trials (i.e. after screen is blank, but before fix point is presented)
var tRise, tFall;

' Constants for states
const stateStartTrial%:=0;		' Start trial state
const stateWaitForStimOn%:=3;		' Wait for stimulus return trigger (on)
const stateWaitForStimOff%:=4;		' Wait for stimulus return trigger (off)
const stateStimulusPlaying%:=5;     ' New, wait for tNow to exceed stimulus duration
const stateMaintainFixation%:=8;	' Maintaining fixation (stim off period)
const stateInterTrialInterval%:=9;	' time out after failed trial
const stateVSGWait%:=10;		' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForStimTrigger% := 14; ' Rising edge indicating start of stim sequence
const stateBarPlaying%:=15;
const stateWaitingForBarOff%:=16;
const stateCRGPlaying%:=17;
const stateWaitingForCRGOff%:=18;
const stateStartOpto%:=19;
const stateWaitOptoPrestim%:=20;
const stateCheckTurnOnOpto%:=21;
const stateCheckTurnOffOpto%:=22;
const stateTurnOffOpto%:=23;
const stateWaitOptoPoststim%:=24;


var iState% := stateVSGWait%;	' present state

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 

var stimOffTime;
var tOpt;
var pulseFound%;
var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
tic := View(DataWindow%).BinSize(ReadyChannel%);

func IdleProcessing%()
	var iStatus% := 1;	
	tNow := View(DataWindow%).MaxTime();
    
    ' First time through (tLast<0) just update tLast. Crosstalk on vsg dig outputs leads to erroneous
    ' triggers. Maybe this will help. 
    if tLast < 0 then
        tLast := 1;
        return 1;
    endif
    
    
	docase 
    case iState% = stateVSGWait% then
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        'if View(DataWindow%).FindPulseUp%(ReadyChannel%, -1, tRise, tFall) = 1 then
        pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
        if pulseFound% = 1 then
            LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
            Yield(1.0);
            tLastTrigger := tFall;
            ChangeStateTo(stateCheckTurnOnOpto%, tFall);
        else
            if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                tLastTrigger := tFall;
            endif;
        endif;
        
        
    case iState% = stateCheckTurnOnOpto% then
        docase
        case tunDoOpto% = 0 or tunOptoState% = 0 then 'if this is not an opto trial, just start it
            ChangeStateTo(stateStartTrial%, tNow);
            printlog("Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",tunDoOpto%,tunOptoState%,tNow);
        case tunOptoStaysOn% = 1 and (nTrialsCompleted% mod (tunNAdvances%+1)) <> 0 then 'this is for when we're keeping the opto on and it's mid block
            ChangeStateTo(stateStartTrial%, tNow);
            printlog("Opto is already on, OptoStaysOn = %d, TrialsComplete = %d, time = %f\n",tunOptoStaysOn%,(nTrialsCompleted% mod (tunNAdvances%+1)),tNow);
        else 'otherwise it is an opto trial and we need to turn opto on
            ChangeStateTo(stateStartOpto%, tNow);
            printlog("Turning Opto On at time = %f\n",tNow);
        endcase
        
        
    case iState% = stateStartOpto% then
        SafeSampleKey("O");  'turn on opto
        tOpt := View(DataWindow%).MaxTime();
        'printlog("OptoOn at %f\n",tOpt);
        SampleText("OptoOn",tOpt);
        ChangeStateTo(stateWaitOptoPrestim%, tNow);
        
        
    case iState% = stateWaitOptoPrestim% then
        if tNow > tStateStart + tunPreStimOptoTime then
            ChangeStateTo(stateStartTrial%, tNow);
        endif;
        

    case iState% = stateStartTrial% then

        ' Start trial. Put up stimulus.
        LogStatus("StartTrial", "Request stimulus");
        SampleText("T," + str$(GetPlotXCoord(nTrialsCompleted%)));
        SafeSampleKey("S");
        'iHoldCount% := 0;
        ChangeStateTo(stateWaitForStimTrigger%, tNow);
    

    case iState% = stateWaitForStimTrigger% then
        
                
        if tunTriggerHack% = 0 then
            if View(DataWindow%).FindRisingEdge%(StimChannel%, tLast, tTrigger) = 0 then
                ' Stimulus has begun
                LogStatus("WaitForStimTrigger", "Stim sequence started at " + str$(tTrigger));
                tStimOn := tTrigger;
                tStimSequence := tTrigger;      ' TODO remove tStimOn ref above - see stateWaitForStimOn
                tLastTrigger := tTrigger;
                'ChangeStateTo(stateHoldFixation%, tTrigger);
                docase
                case tunType$ = tunTypeCRG$ then
                    ChangeStateTo(stateCRGPlaying%, tRise);
                case tunType$ = tunTypeDriftingBar$ then
                    ChangeStateTo(stateBarPlaying%, tRise);
                else
                    ChangeStateTo(stateStimulusPlaying%, tRise);
                endcase;                
            endif
        else
            if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then
                ' Stimulus has begun
                LogStatus("WaitForStimTrigger", "Stim sequence started at " + str$(tRise));
                tStimOn := tRise;
                tStimSequence := tRise;
                tLastTrigger := tRise;
                docase
                case tunType$ = tunTypeCRG$ then
                    ChangeStateTo(stateCRGPlaying%, tRise);
                case tunType$ = tunTypeDriftingBar$ then
                    ChangeStateTo(stateBarPlaying%, tRise);
                else
                    ChangeStateTo(stateStimulusPlaying%, tRise);
                endcase;
            endif
        endif
        
        
    case iState% = stateStimulusPlaying% then

        if tNow - tStateStart > tunStimulusDuration then
            
            ' turn off stimulus and advance it
            SampleText("+");
            LogStatus("StimulusPlaying", "Turn off and advance stimulus.");
            
            SafeSampleKey("X");            
                        
            Yield();
            
            'Set stimCodes[0] to hold the index of the current stimulus
            stimCodes%[0] := tunValuesIndices%[nTrialsCompleted%]; 'nTrialsCompleted has not yet been incremented, so this is right
            'log stimulus start time in pseudotextmark channel and for raster triggering
            if tunOptoState% = 0 then
                view(DataWindow%).MemSetItem(memChanRasterTriggers%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
            else
                view(DataWindow%).MemSetItem(memChanRasterTriggersOpto%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
            endif;
            
            view(DataWindow%).MemSetItem(memChanBetterTextMark%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
            
            ' Process spikes
            PlotSpikes(tStimOn, tNow, tunOptoState%+1, nTrialsCompleted%);
            
            ' Now wait until stim is off
            ChangeStateTo(stateWaitForStimOff%, tNow);
            
        endif
        
        
        
    case iState% = stateWaitForStimOff% then
        
        if tunTriggerHack% = 0 then
            if View(DataWindow%).FindFallingEdge%(StimChannel%, tLast, tTrigger) = 1 then
                ' Advance
                SafeSampleKey("a");

                tLastTrigger := tTrigger;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
            endif
        else
            if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then
                ' Advance
                SafeSampleKey("a");

                tLastTrigger := tRise;
                ChangeStateTo(stateCheckTurnOffOpto%, tRise);
            endif
        endif
        
        
    case iState% = stateBarPlaying% then
        if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then 'find signal indicating bar is off screen
            
            'Note stimulus is off
            SampleText("+");
            LogStatus("BarPlaying", "Turn off and advance stimulus.");          
            
            SafeSampleKey("X");            
            
            Yield();
            
            ' Process spikes
            PlotSpikes(tStimOn, tNow, tunOptoState%+1, nTrialsCompleted%);
            
            'Advance
            'SafeSampleKey("a");

            tLastTrigger := tRise;
            'ChangeStateTo(stateTrialCompleted%, tRise);
            ChangeStateTo(stateWaitingForBarOff%, tRise);
        endif
        
    case iState% = stateWaitingForBarOff% then
        if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then 'find signal indicating bar stimulus has been turned off
            
            'Advance
            SafeSampleKey("a");
            
            tLastTrigger := tRise;
            ChangeStateTo(stateCheckTurnOffOpto%, tRise);
        endif;
        
        
   case iState% = stateCRGPlaying% then
        if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then 'find signal indicating bar is off screen
            
            triggerCount% += 1;
            tStateStart := tRise;  'reset time to find all triggers
            'printlog("Found trigger %d at %f\n",triggerCount%,tStateStart);
            
            if triggerCount% = nTriggersExpected% then
            
                'Note stimulus is off
                stimOffTime := tStateStart;
                SampleText("+",tStateStart);
                'Log time of offset only in pseudotextmark channel
                view(DataWindow%).MemSetItem(memChanBetterTextMark%,0,tStateStart,stimCodes%[],"+");
                LogStatus("CRGPlaying", "Turn off and advance stimulus.");          
            
                SafeSampleKey("X");            
            
                Yield();
                
                'Set stimCodes[0] to hold the index of the current stimulus
                stimCodes%[0] := tunValuesIndices%[nTrialsCompleted%]; 'nTrialsCompleted has not yet been incremented, so this is right
                'log stimulus start time in pseudotextmark channel and for raster triggering
                if tunOptoState% = 0 then
                    view(DataWindow%).MemSetItem(memChanRasterTriggers%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
                else
                    view(DataWindow%).MemSetItem(memChanRasterTriggersOpto%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));
                endif;
                
                view(DataWindow%).MemSetItem(memChanBetterTextMark%,0,tStimOn,stimCodes%[],Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));            
                
                ' Process spikes
                PlotSpikes(tStimOn, tNow, tunOptoState%+1, nTrialsCompleted%);

                tLastTrigger := tRise;
                'ChangeStateTo(stateTrialCompleted%, tRise);
                ChangeStateTo(stateWaitingForCRGOff%, tRise);
            endif;
            
        endif
        
    case iState% = stateWaitingForCRGOff% then
        if View(DataWindow%).FindPulseUp%(FrameChannel%, tStateStart, tRise, tFall) = 1 then 'find signal indicating bar stimulus has been turned off
            printlog("Maxtime is now %f, writing sample text\n",view(DataWindow%).maxtime());
            'Advance
            SafeSampleKey("a");
            triggerCount% := 0;
            
            tLastTrigger := tRise;
            ChangeStateTo(stateCheckTurnOffOpto%, tRise);
        endif;  
        
        
    case iState% = stateCheckTurnOffOpto% then
        nTrialsCompleted% += 1;  'trial is complete, change of count here makes logic easier 
        docase
        case tunDoOpto% = 0 or tunOptoState% = 0 then 'if this is not an opto trial, trial is complete
            ChangeStateTo(stateTrialCompleted%, tStateStart);
            printlog("Trial complete, Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",tunDoOpto%,tunOptoState%,tStateStart);
        case tunOptoStaysOn% = 1 and (nTrialsCompleted% mod (tunNAdvances%+1)) <> 0 then 'this is for when we're keeping the opto on and it's mid block
            ChangeStateTo(stateTrialCompleted%, tStateStart);
            printlog("Opto is staying on, OptoStaysOn = %d, TrialsComplete = %d, time = %f\n",tunOptoStaysOn%,(nTrialsCompleted% mod (tunNAdvances%+1)),tStateStart);
        else 'otherwise it is an opto trial and we need to turn opto off
            ChangeStateTo(stateWaitOptoPoststim%, tStateStart);
            printlog("Turning Opto Off at time = %f\n",tStateStart);
        endcase
        
        
        
    case iState% = stateWaitOptoPoststim% then
        if tNow > tStateStart + tunPostStimOptoTime then
            ChangeStateTo(stateTurnOffOpto%, tNow);
        endif;
        
        
    case iState% = stateTurnOffOpto% then
        SafeSampleKey("o");  'turn it off
        tOpt := View(DataWindow%).MaxTime();
        'printlog("OptoOff at %f\n",tOpt);
        SampleText("OptoOff",tOpt);
        ChangeStateTo(stateTrialCompleted%,tNow);        
        
        
    case iState% = stateTrialCompleted% then
        printlog("number of trials completed is %d\n",nTrialsCompleted%);
        docase
        case nTrialsCompleted% = (tunNAdvances%+1)*tunNRepeats% then
            ' We're all done
            ChangeStateTo(stateDone%, tNow);
            Stop%();
            iStatus% := 0;
        case (nTrialsCompleted% mod (tunNAdvances%+1)) = 0 then 'toggle tunOptoState at the end of a block, use interblock time
            if tunDoOpto% = 1 then
                tunOptoState% := 1-tunOptoState%;  'but only toggle if we're actually doing opto
            endif;
            tInterTrialTime := tunInterTrialTime + tunInterBlockTime;
            ChangeStateTo(stateInterTrialInterval%, tNow);
        else
            tInterTrialTime := tunInterTrialTime;
            ChangeStateTo(stateInterTrialInterval%, tNow);
        endcase        
        
        view(datawindow%).MemSave(memChanRasterTriggers%,memorychannel%,0,1);
        view(datawindow%).MemSave(memChanRasterTriggersOpto%,memorychannelopto%,0,1);
        view(datawindow%).MemSave(memChanBetterTextMark%,memorychannel2%,0,1);
        
            
        

    case iState% = stateInterTrialInterval% then

        if tNow - tStateStart > tInterTrialTime then

            ChangeStateTo(stateCheckTurnOnOpto%, tNow);

        endif

    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;

	endcase;

	tLast := tNow;
	return iStatus%;
end;


func GetPlotXCoord(nTrials%)
    return tunValues[tunValuesIndices%[nTrials%]];
end;


func GetPlotXIndex%(nTrials%)
    return tunValuesIndices%[nTrials%];
end;



proc PlotSpikes(t1, t2, vOnOff%, index%)
	var rate;
    var i%;
    var tSweep;
    var fftData[16];        ' size of this array should be same as number of bins! 
    var x;  'the x value to plot
    var xind%;  'the x value index
    'var index2%;
    
    'vOnOff% is a switch that allows us to plot (in this case) opto-on and opto-off with different colors
    
    x := GetPlotXCoord(index%);
    xind% := GetPlotXIndex%(index%);  'for keeping an average...may be difficult to implement
    
    'index2% := ArrFindFloat%(tunValues[],x);  'this is going to correspond to the index of the XYPlot that will be deleted/updated
    'actually, xind% should do this more easily.
    
	for i% := 0 to tunNWavemarks%-1 do
		rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
        'tunRateCum[i%] := tunRateCum[i%] + rate;  
        'if tunRateCum[i%] >= 0 then  
		if rate >= 0 then
            View(TuningWindow%[i%]).XYAddData(vOnOff%, x, rate);    ' channel 1 is opto-off; channel 2 is opto-on
			'if vOnOff% = 1 then
				' this is signal
                'PrintLog("%d Count %f\n", i%, rate*(t2-t1));
				'View(TuningWindow%[i%]).XYAddData(1, x, rate);    ' channel 1 is data; channel 2 is background
                'Grr.  Deleting data will make this hard.
                'View(TuningWindow%[i%]).XYSort(1,1);  'sort by x
                'View(TuningWindow%[i%]).XYDelete(1,index2%);  'delete the last entry for this value
                'View(TuningWindow%[i%]).XYAddData(1, x, tunRateCum[i%]/(index%+1));    ' channel 1 is data; channel 2 is background
			'endif
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	    endif 
        
        if vOnOff% = 1 then
            'update the raster even if there are no spikes on this trial
            view(handlePSTH%[i%]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggers%,rasterTotal,rasterPre,stimCodes%[0]);  'Update single-stim histogram        
            'And update the title, to indicate which stimulus it is
            view(handlePSTH%[i%]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[i%]+1) + myTitle2$ + Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));  'Rename single-stim histogram
        else
            'update the raster even if there are no spikes on this trial
            view(handlePSTH%[i%+8]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggersOpto%,rasterTotal,rasterPre,stimCodes%[0]);  'Update single-stim histogram        
            'And update the title, to indicate which stimulus it is
            view(handlePSTH%[i%+8]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[i%]+1) + " Opto On " + myTitle2$ + Str$(tunValues[tunValuesIndices%[nTrialsCompleted%]]));  'Rename single-stim histogram
        endif
        
            
        'do F1 if requested, F2 not currently done
        if tunDoF12% = 1 then
            ' Process for each cycle of the stimulus. A single cycle of the stim takes 1/tf
			View(PSTHWindow%[i%]);
			Process(t1, t2, 1, 1);
			for tSweep := t1+1/tunTF to t2-1/tunTF step 1/tunTF do 
				Process(tSweep, tSweep+1/tunTF, 0, 1);
			next
			ArrConst(fftData[], View(PSTHWindow%[i%]).[]);
			ArrFFT(fftData[], 4); 
            
            docase
            case vOnOff% = 1 then
                View(TuningWindow%[i%]).XYAddData(3, x, fftData[1]);
                tunF1Sum[i%][index%] += fftData[1];
            case vOnOff% = 2 then
                View(TuningWindow%[i%]).XYAddData(4, x, fftData[1]);  
                tunF1Sum[i%][index%] += fftData[1];
            endcase
            'tunF1Cum[i%] += fftdata[1];
            'tunF2Cum[i%] += fftdata[2];
            'View(TuningWindow%[i%]).XYSort(2,1);  'sort by x
            'View(TuningWindow%[i%]).XYSort(3,1);  'sort by x
            'View(TuningWindow%[i%]).XYDelete(2,index2%);  'delete the last entry for this value
            'View(TuningWindow%[i%]).XYDelete(3,index2%);  'delete the last entry for this value
            
            'View(TuningWindow%[i%]).XYAddData(3, x, fftData[2]);
            'View(TuningWindow%[i%]).XYAddData(2, x, tunF1Cum[i%]/(index%+1));
            'View(TuningWindow%[i%]).XYAddData(3, x, tunF2Cum[i%]/(index%+1));
            
            'tunF2Sum[i%][index%] += fftData[2];      
        endif
        
	next
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end





proc InitializeWindows()
    var i%;
    var WindowStep;
    var ch1%, ch2%;
    var tunL, tunR, histL, histR, histOptoL, histOptoR;
    
    'set tunL, etc.
    if tunDoOpto% = 0 then
        tunl := 50;
        tunr := 75;
        histL := 75;
        histR := 100;
    else
        tunl := 50;
        tunr := 66;
        histL := 66;
        histR := 83;
        histOptoL := 83;
        histOptoR := 100;
    endif;
    
    
    ' Get tf of stim
    tunTF := GetStimulusTF();
    
    ' Make spike2 use allof monitor 1
    View(App()).Window(0, 0, 100, 100, 1);
    
	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(0,48,50,95);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
    
    'Create textmark channel to hold onset times of stimuli
    memChanRasterTriggers% := MemChan(8, 25); 'Create textmarker channel for stimtype
    ChanTitle$(MemChanRasterTriggers%,"RasterTriggers"); 'give it a title, could be useful if channel is saved
    chanhide(MemChanRasterTriggers%); 'hide the memchan, don't need to see it.    
    'chanshow(MemChanRasterTriggers%);
    
    'Create textmark channel to hold onset times of stimuli
    memChanRasterTriggersOpto% := MemChan(8, 25); 'Create textmarker channel for stimtype
    ChanTitle$(MemChanRasterTriggersOpto%,"RasterTriggersOpto"); 'give it a title, could be useful if channel is saved
    chanhide(MemChanRasterTriggersOpto%); 'hide the memchan, don't need to see it.
    
    'Create textmark channel to hold onset times of stimuli
    memChanBetterTextMark% := MemChan(8, 25); 'Create textmarker channel for stimtype
    ChanTitle$(memChanBetterTextMark%,"PseudoTextMark"); 'give it a title, could be useful if channel is saved
    'chanhide(memChanBetterTextMark%); 'hide the memchan, don't need to see it.    
    chanshow(memChanBetterTextMark%);
    
    
	' open xy window to display tuning results    
    if tunNWavemarks% > 0 then
        WindowStep := 100/tunNWavemarks%;
    endif
    for i% := 0 to tunNWavemarks%-1 do
        TuningWindow%[i%] := FileNew(12);
        Window(tunL, i%*WindowStep, tunR, (i%+1)*WindowStep);
        ChanTitle$(0, "Spikes/s");
        TuningCurveLabels(tunWavemarkPorts%[i%]);
        WindowVisible(1);        
       
        
        'Create raster/PSTH result view for each electrode
        rasterTotal := rasterPre + rasterPost + tunStimulusDuration;  'calculate total raster time
        histBins% := rasterTotal/histBinWidth;  'and number of bins
        handlePSTH%[i%] := View(DataWindow%).SetPsth(tunWavemarkPorts%[i%]+1,histBins%,histBinWidth,rasterPre,memChanRasterTriggers%,3);  '3 makes rasters and scales to spikes per second
        View(handlePSTH%[i%]).windowtitle$("No Data");  'name gets changed later
        View(handlePSTH%[i%]).Window(histL, i%*WindowStep, histR, (i%+1)*WindowStep);  'size window as above, squeeze in
        View(handlePSTH%[i%]).WindowVisible(1);  'make window visible
        
        if tunDoOpto% = 1 then  'Create raster/PSTH result view for each electrode, opto-on
            handlePSTH%[i%+8] := View(DataWindow%).SetPsth(tunWavemarkPorts%[i%]+1,histBins%,histBinWidth,rasterPre,memChanRasterTriggersOpto%,3);  '3 makes rasters and scales to spikes per second
            View(handlePSTH%[i%+8]).windowtitle$("No Data");  'name gets changed later
            View(handlePSTH%[i%+8]).Window(histOptoL, i%*WindowStep, histOptoR, (i%+1)*WindowStep);  'size window as above, squeeze in
            View(handlePSTH%[i%+8]).WindowVisible(1);  'make window visible
        endif
        
        FrontView(DataWindow%);  'bring main window back to front to avoid view is not a time view shit
        
        ' Create psth window if f1 and f2 analysis needed
        if tunDoF12% = 1 then
            
            ch1% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f1
            View(TuningWindow%[i%]).XYColour(ch1%, 16);
            'ch2% := View(TuningWindow%[i%]).XYSetChan(0);   ' used to plot f2
            'View(TuningWindow%[i%]).XYColour(ch2%, 38);
            ch2% := View(TuningWindow%[i%]).XYSetChan(0);   ' appropriating this to plot f1 of opto-on
            View(TuningWindow%[i%]).XYColour(ch2%, 38);
            LogStatus("InitializeWindows", "Channel " + str$(i%+1) + " " + str$(ch1%) + " " + str$(ch2%));
            'PSTHWindow%[i%] := View(DataWindow%).SetPSTH(i%+1, 16, 1 /(tunTF*16), 0, 0, 3);
            PSTHWindow%[i%] := View(DataWindow%).SetPSTH(tunWavemarkPorts%[i%]+1, 16, 1 /(tunTF*16), 0, 0, 3);  'must use index to tWMP%[] now that channel #s correspond to port #s (+1)
            View(PSTHWindow%[i%]).WindowVisible(0);
        endif        
    next

end;

proc TuningCurveLabels(iport%)

    var s$;
    's$ := "Port " + str$(iport%);
    s$ := "Electrode " + str$(iport%);
	docase 
		case tunType$ = tunTypeContrast$ then
        
            myTitle$ := s$ + " - Contrast = ";
            myTitle2$ := " - Contrast = ";
			WindowTitle$("Contrast Tuning - " + s$);
			XUnits$("Contrast (%)");
			ChanTitle$(1, "Chan 1");
			XRange(tunContrastMinContrast, tunContrastMaxContrast);

		case tunType$ = tunTypeOrientation$ then
        
            myTitle$ := s$ + " - Orientation = ";
            myTitle2$ := " - Orientation = ";
			WindowTitle$("Orientation Tuning - " + s$);
			XUnits$("Orientation (degrees)");
			ChanTitle$(1, "Chan 1");
			XRange(tunOriMinOrientation, tunOriMaxOrientation);

		case tunType$ = tunTypeSpatial$ then
        
            myTitle$ := s$ + " - Spatial Freq = ";
            myTitle2$ := " - Spatial Freq = ";
			WindowTitle$("Spatial Frequency Tuning - " + s$);
			XUnits$("Spatial Frequency");
			ChanTitle$(1, "Chan 1");
			XRange(tunSpatialMinSF, tunSpatialMaxSF);
	
		case tunType$ = tunTypeTemporal$ then
        
            myTitle$ := s$ + " - Temporal Freq = ";
            myTitle2$ := " - Temporal Freq = ";
			WindowTitle$("Temporal Frequency Tuning - " + s$);
			XUnits$("Temporal Frequency");
			ChanTitle$(1, "Chan 1");
			XRange(tunTemporalMinTF, tunTemporalMaxTF);

		case tunType$ = tunTypeArea$ then
        
            myTitle$ := s$ + " - Area = ";
            myTitle2$ := " - Area = ";
			WindowTitle$("Aperture Area Tuning - " + s$);
			XUnits$("Aperture Diameter");
			ChanTitle$(1, "Chan 1");
			XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
		case tunType$ = tunTypeID$ then
        
            myTitle$ := s$ + " - ID = ";
            myTitle2$ := " - ID = ";
			WindowTitle$("Inner Diameter Tuning - " + s$);
			XUnits$("Inner Diameter");
			ChanTitle$(1, "Chan 1");
			XRange(tunIDMinDiam, tunIDMaxDiam);
        
        case tunType$ = tunTypeDriftingBar$ then
        
            myTitle$ := s$ + " - Bar Orientation = ";
            myTitle2$ := " - Bar Orientation = ";
			WindowTitle$("Drifting Bar Orientation Tuning - " + s$);
			XUnits$("Orientation (degrees)");
			ChanTitle$(1, "Chan 1");
            XRange(tunBarMinOrientation, tunBarMaxOrientation);
        
        case tunType$ = tunTypeNullTest$ then
        
            myTitle$ := s$ + " - Phase = ";
            myTitle2$ := " - Phase = ";
			WindowTitle$("Null Test Counterphase Tuning - " + s$);
			XUnits$("Phase (degrees)");
			ChanTitle$(1, "Chan 1");
            XRange(tunNullTestMinPhase, tunNullTestMaxPhase);
        
        case tunType$ = tunTypeCRG$ then
        
            myTitle$ := s$ + " - Contrast = ";
            myTitle2$ := " - Contrast = ";
			WindowTitle$("CRG Contrast Tuning - " + s$);
			XUnits$("Contrast (%)");
			ChanTitle$(1, "Chan 1");
            XRange(tunCRGMMinContrast, tunCRGMMaxContrast);
		else

			Message("TuningCurveLabels Error - unknown value for tunType$: " + tunType$);

	endcase;

end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;

	SampleClear(); 'Set standard sampling state
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    
    'read tuning file, if one is specified
    if tunUseFile% = 1 then
        var tunFileLen%;
        var eof%:=1;
        readsetup(",","	 ","","","	");  'Standard read setup
        FileOpen(tunTuningFile$,8,0);  'open specified file
        while eof% > 0 do
            eof% := read(tunValues[tunFileLen%]);  'read to end of file, must put each value on a new line to count number of stimuli in a block
            tunFileLen%+=1;  'increment tuning file length
        wend
        tunFileLen%-=1;  'decrement tuning file length because we increment when we find EOF.
        FileClose();  'close the file
    endif
    
    
    docase
        
    case tunType$ = tunTypeContrast$ then 
        SampleAutoName$(dataCellName$ + "_con_000");
        tunNRepeats% := tunContrastNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunContrastProgression%);
        else
            tunNAdvances% := tunContrastNSteps%;
            GetRepeatedParameterProgression%(tunContrastNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, tunContrastProgression%);
        endif;
        'tunNValues% := (tunContrastNSteps%+1)*tunContrastNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  'shorter, should work the same as above commented line, keeping old line for contrast only just in case...
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeOrientation$ then 
        SampleAutoName$(dataCellName$ + "_ori_000");
        tunNRepeats% := tunOriNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunOriProgression%);
        else
            tunNAdvances% := tunOriNSteps%;
            GetRepeatedParameterProgression%(tunOriNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, tunOriProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeSpatial$ then 
        SampleAutoName$(dataCellName$ + "_spa_000");
        tunNRepeats% := tunSpatialNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunSpatialProgression%);
        else
            tunNAdvances% := tunSpatialNSteps%;
            GetRepeatedParameterProgression%(tunSpatialNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, tunSpatialProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeTemporal$ then 
        SampleAutoName$(dataCellName$ + "_tem_000");
        tunNRepeats% := tunTemporalNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunTemporalProgression%);
        else
            tunNAdvances% := tunTemporalNSteps%;
            GetRepeatedParameterProgression%(tunTemporalNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 0, tunTemporalProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeArea$ then 
        SampleAutoName$(dataCellName$ + "_area_000");
        tunNRepeats% := tunAreaNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunAreaProgression%);
        else
            tunNAdvances% := tunAreaNSteps%;
            GetRepeatedParameterProgression%(tunAreaNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeID$ then 
        SampleAutoName$(dataCellName$ + "_id_000");
        tunNRepeats% := tunIDNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunIDProgression%);
        else
            tunNAdvances% := tunIDNSteps%;
            GetRepeatedParameterProgression%(tunIDNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunIDMinDiam, tunIDMaxDiam, 1, tunIDProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeDriftingBar$ then 
        SampleAutoName$(dataCellName$ + "_bar_000");
        tunNAdvances% := tunBarNSteps%;
        tunNRepeats% := tunBarNRepeats%*(1+tunDoOpto%);
        GetRepeatedParameterProgression%(tunBarNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunBarMinOrientation, tunBarMaxOrientation, 0, tunBarProgression%);
        tunNValues% := (tunBarNSteps%+1)*tunBarNRepeats%*(1+tunDoOpto%);
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeNullTest$ then 
        SampleAutoName$(dataCellName$ + "_nulltest_000");
        tunNRepeats% := tunNullTestNRepeats%*(1+tunDoOpto%);  'double number of blocks if doing optogenetics
        if tunUseFile% = 1 then
            tunNAdvances% := tunFileLen%-1;
            ShuffleAndExpand(tunFileLen%,tunNRepeats%,tunValuesIndices%[],tunNullTestProgression%);
        else
            tunNAdvances% := tunNullTestNSteps%;
            GetRepeatedParameterProgression%(tunNullTestNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunNullTestMinPhase, tunNullTestMaxPhase, 1, tunNullTestProgression%);
        endif;
        tunNValues% := (tunNAdvances%+1)*tunNRepeats%;  
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeCRG$ then 
        SampleAutoName$(dataCellName$ + "_crg_000");
        tunNAdvances% := tunCRGMNSteps%;
        tunNRepeats% := tunCRGMNRepeats%*(1+tunDoOpto%);
        GetRepeatedParameterProgression%(tunCRGMNSteps%+1, tunNRepeats%, tunValues[], tunValuesIndices%[], tunCRGMMinContrast, tunCRGMMaxContrast, 1, tunCRGMProgression%);
        tunNValues% := (tunCRGMNSteps%+1)*tunCRGMNRepeats%*(1+tunDoOpto%);
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    else
        SampleAutoName$(dataCellName$ + "_tun_000");
    endcase;
    
    printlog("values are %f\n",tunValues[]);
    printlog("Indices are %d\n",tunValuesIndices%[]);
    
    
    SampleAutoFile(1);
    
    ' Text marks make extraction easier
    SampleTextMark(200);
    
	'Channel recording definitions
	SampleEvent(StimChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
	SampleEvent(FrameChannel%, 0, 2, 3600);
	SampleComment$(FrameChannel%,"Frame");
	SampleTitle$(FrameChannel%,"Frame");
    
    
    ' Before assigning Electrode channels, check value of tunRecOptoBox% to make sure
    ' there are no channel conflicts; if Opto is being used, just block off ADC6
    ' Opto box efference copy will be on ADC6
    ' Note that this ability has been killed due to the fact that the opto box doesn't actually output
    ' the value under analog control.  We could split an efference copy but it seems useless.
    ' Not fully tested before being abandoned.
    'if tunRecOptoBox% > 0  and tunDoOpto% > 0 then  'obviously if we're not doing opto then we're not recording the opto box
    '    if tunNWavemarks% > 6 then
    '        message("Only 6 'trodes can be recorded with the opto box efference copy!  Reducing to 6!");
    '        tunNWaveMarks% := 6;
    '        tunNContinuous% := 6;
    '    endif
    'endif
    
    
    
    ' Electrodes: wavemark/continuous
    ' 12/6/2010
    ' Wavemark channels will be channels # 1-N, waveform N+1 - N+1+M, where there are N wavemark channels
    ' and M waveform channels. 
    ' Changed!  To avoid confusion wavemarks now are place on channels (Port+1) and waveforms on channels (Port+8)
    for i% := 0 to tunNWavemarks%-1 do
		'SampleWaveMark(i% + 1, tunWavemarkPorts%[i%], 2000, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
		'SampleTitle$(i% + 1, "WMrk " + str$(tunWavemarkPorts%[i%])); 
        'Trying here to avoid collapsing channel numbers
        SampleWaveMark(tunWavemarkPorts%[i%]+1, tunWavemarkPorts%[i%], 2000, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
		SampleTitle$(tunWavemarkPorts%[i%]+1, "WMrk " + str$(tunWavemarkPorts%[i%]));
        
        ' djs 7-29-2014 Hack to allow all 8 ports. See djs comments. 
' djs        if tunWavemarkPorts%[i%] > 6 then
        if tunWavemarkPorts%[i%] > 7 then
' djs            message("The rig should only be set up to collect data from Ports 0-6!  Quitting!");
            message("The rig should only be set up to collect data from Ports 0-7!  Quitting!");
            'This message comes up because of the non-collapsed (i.e. non-continuous) channel numbers.  There is a "hack" a few lines below
            'which sets the continuous waveforms to live on channels numbered 7 greater than the corresponding WaveMark channel.  We can get
            'away with this because the Thomas system which feeds into the CED has only 7 electrode channels which are fed to Ports 0-6 on
            'the CED.  As of now, the channels that can legally hold WaveMarks are channels 1-7 and the channels that can legally hold
            'continuous waveforms are channels 8-14.  Since channel 19 holds pulses, there isn't a lot more room to work under this scheme
            'before needing to reposition other channels anyway (this non-collapsed scheme would work up to a hard-coded 9 rather than 7 Ports).
            'So if you need to use Port 7/8, you'll need to change the hardcode here and for tunNContinuous% below to 8/9.  If you need
            'to go beyond Port 8, you'll have to either move some of the hardcoded pulse channels, or dump the non-collapsed numbering scheme. -jj
            halt();
        endif;
	next
    for i% := 0 to tunNContinuous%-1 do
        'SampleWaveform(tunNWavemarks% + i% + 1, tunContinuousPorts%[i%], 20000);
        'SampleTitle$(tunNWavemarks% + i% + 1, "Cont " + str$(tunContinuousPorts%[i%]));
        'Trying here to avoid collapsing channel numbers
'djs        SampleWaveform(tunContinuousPorts%[i%]+8, tunContinuousPorts%[i%], 20000);  'this hack only works because wavemark chans are limited to channels 1-7
'djs        SampleTitle$(tunContinuousPorts%[i%]+8, "Cont " + str$(tunContinuousPorts%[i%]));
        SampleWaveform(tunContinuousPorts%[i%]+9, tunContinuousPorts%[i%], 20000);  'this hack only works because wavemark chans are limited to channels 1-7
        SampleTitle$(tunContinuousPorts%[i%]+9, "Cont " + str$(tunContinuousPorts%[i%]));
    next
    
    
    'Set channel for Opto box efference copy, if needed - turned off because opto box won't output for the analog input
    'if tunRecOptoBox% > 0 then
    '    SampleWaveform(13, 5, 1000);  'there are a possible 7 'trodes in ADC0-ADC6; here 5 is port ADC5, 13 is channel: port 5 + 7 'trodes + 1 (because channel numbering starts at 1), 1kHz sampling should be fine
    '    SampleTitle$(13, "Opto voltage");
    'endif;
    
    'Set channel for stimulator efference copy, if needed, as an event input
    if tunRecStimulator% > 0 then
        SampleEvent(StimulatorChannel%,0,2,20);
        SampleTitle$(StimulatorChannel%, "Stimulator Copy");
    endif;
    
 
    
    
	SampleSequencer(script$ + "Tuning.pls");
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;

' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, j%, m%, mylen%;
    var fn$;
    var chanToExport%[30];
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    'turn off opto if it happens to be on
    SafeSampleKey("o");
    
    
	' Tell stim app to shut down
	SafeSampleKey("Q");
	Yield(.1);
	SampleStop();

	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend

	' Write parameter file
	WriteParameterFile();
    
    
    view(dataWindow%);
    MemSave(memChanRasterTriggers%,memorychannel%,0,1);  'final update of memory channel
    MemSave(memChanRasterTriggersOpto%,memorychannelopto%,0,1);  'final update of memory channel
    MemSave(memChanBetterTextMark%,memorychannel2%,0,1);  'final update of memory channel
    
    ExportChanList();
    chanToExport%[1] := 29;  'channels to export go in elements 1:...
    chanToExport%[2] := 30;
    for j% := 0 to tunNWavemarks%-1 do
        chanToExport%[j%+3]:=tunWavemarkPorts%[j%]+1;
    next;
    chanToExport%[0] := 2+j%;  'total number of channels goes in element 0
    ExportChanList(0,view(datawindow%).maxtime(),chanToExport%[]);
    
    ' Write matlab file
    fn$ := FileName$();  'get current file name
    mylen% := Len(fn$);
    fn$ := Left$(fn$,mylen%-4);
    fn$ := fn$ + ".mat";
    j% := view(datawindow%).FileSaveAs(fn$,100,0,"",0,"UseSName=0"); 'Do not overwrite the .mat file - should have a different name and if it doesn't that is a red flag

    
    
	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
'	TotalRewards% += nTrialsCompleted%;
	SaveDailyTotals();
    
    ' Figure out max F1 values
    if tunDoF12% = 1 then
        for i% := 0 to tunNWavemarks%-1 do
            m% := Max(tunF1Sum[i%][]);
            LogStatus("F1 Max", "Channel " + str$(i%+1) + " Port " + str$(tunWavemarkPorts%[i%]) + " max F1 at x=" + str$(tunValues[m%]));
        next
    endif    
    
    ' Plot rasters for each individual stimulus, for each electrode
    ' Caitlin sez "too many rasters"
    'for j% := 0 to tunNWavemarks%-1 do
    '    for i% := 0 to tunValuesIndices%[max(tunValuesIndices%[])] do
    '        handlePSTH%[i%] := View(DataWindow%).SetPsth(tunWavemarkPorts%[j%]+1,histBins%,histBinWidth,rasterPre,memChanRasterTriggers%,3);  '3 makes rasters and scales to spikes per second
    '        'not sure what the best sizing mech is, punting for now
    '        'View(handlePSTH%[i%]).Window(75, i%*WindowStep, 100, (i%+1)*WindowStep);  'size window as above, squeeze in
    '        View(handlePSTH%[i%]).WindowVisible(1);  'make window visible
    '        
    '        'create the raster
    '        view(handlePSTH%[i%]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggers%,rasterTotal,rasterPre,i%);  'Update single-stim histogram        
    '        'And update the title, to indicate which stimulus it is
    '        view(handlePSTH%[i%]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[j%]) + myTitle2$ + Str$(tunValues[i%]));  'Rename single-stim histogram
    '    next
    'next
    
    InvestigateRastersDialog%();
    
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetAcuteDistanceToScreenMM$());
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	'Print("Background color           : %s\n", tunBackgroundColor$);
    Print("Background gray level      : %d\n", tunBackgroundGrayLevel%);

	' write stimulus parameters
	Print("\nStimulus\n");
	Print("-------------------\n\n");

	var Tstimstr$;
    var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;	
	'var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
    var phase;
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
    i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	'i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    Print("Initial Phase (degrees)         : %f\n", phase);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);


	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");
    Print("Stimulus Duration (s)  : %f\n", tunStimulusDuration);
	Print("\nTuning parameters\n");
	Print("-------------------\n\n");
	docase 
		case tunType$ = tunTypeContrast$ then

			Print("Type:                  : Contrast\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");


		case tunType$ = tunTypeOrientation$ then

			Print("Type:                  : Orientation\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeSpatial$ then

			Print("Type:                  : Spatial Frequency\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");
	
		case tunType$ = tunTypeTemporal$ then

			Print("Type:                  : Temporal Frequency\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeArea$ then

			Print("Type:                  : Aperture Area\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
            Print("\n");
        
		case tunType$ = tunTypeID$ then

			Print("Type:                  : Inner Diameter\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunIDMinDiam, tunIDMaxDiam, tunIDNSteps%, tunIDNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
            Print("\n");
        
        case tunType$ = tunTypeDriftingBar$ then

			Print("Type:                  : DriftingBar\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunBarMinOrientation, tunBarMaxOrientation, tunBarNSteps%, tunBarNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");
        
        case tunType$ = tunTypeNullTest$ then

			Print("Type:                  : Null Test Counterphase Gratings\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunNullTestMinPhase, tunNullTestMaxPhase, tunNullTestNSteps%, tunNullTestNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
            Print("\n");
        
		else

			Print("TuningCurve Error - unknown value for tunType$: %s\n", tunType$);

	endcase;

	' close parfile
	FileClose(0);

end;


' Gets the temporal freq of the current stimulus. 
' Make sure to call this only after all user dialogs have been completed (so you know that the stim parameters will not change)

func GetStimulusTF()
    var gr$;
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var cv$, pattern$, aperture$;
    
    if tunType$ = tunTypeNullTest$ then 'get the temporal frequency of the counterphase shift, grating does not drift
        tf := tunNullTestTF;
    else  'get the temporal frequency of the grating
    	gr$ := GetGratingParameters$("Stimulus");
        ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    endif;
    
    LogStatus("GetStimulusTF", "TF=" + str$(tf));
    return tf;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var cmdLine$;
'	var FixationPoint$;
	var Extras$;
	var Tune$;
	var Stim$:="";
'	var SlaveStim$:="";
	var Values$;
'    var Dual$;
    var key$;
    var offsetFilename$;
    var i%;
    var ProgName$;
    var tunBGStr$;
    var tunFGStr$;
    var tunBarStr$;
    var tunCRGBal$;
    var tunCRGNumTerms%;
    var voltageInteger%;
'    var XHairArg$;
	
	SampleStart(0); 'Start sampling
	SafeSampleKey("0");
    
    if tunDoOpto% = 1 then
        'set sequencer variable 4 for opto voltage
        'Please note that the input for this has to be a 32-bit variable, not a 16-bit like
        'I sure thought I read.  Use vdac32% to get the right value.
        voltageInteger% := vdac32%(tunOptoVoltageOut, 1, 0);
        SampleSeqVar(4,voltageInteger%);
    endif;
    
    
    'build background gray level string
    tunBGStr$ := "(" + Str$(tunBackgroundGrayLevel%) + "/" + Str$(tunBackgroundGrayLevel%) + "/" + Str$(tunBackgroundGrayLevel%) + ") ";
    
    Stim$ := " -s " + GetGratingParameters$("Stimulus");    
	Values$ := tunValuesStringified$;
    'Extras$ := " -b " + tunBackgroundColor$ + " -d " + GetAcuteDistanceToScreenMM$() + " -p 2 -v";
    Extras$ := " -b " + tunBGStr$ + " -d " + GetAcuteDistanceToScreenMM$() + " -p 2 -v";
    
    'By default, set ProgName$ to be FIXSTIM
    ProgName$ := "\\fixstim.exe ";    
    
	docase 
    case tunType$ = tunTypeContrast$ then
        
        'Tune$ := Dual$ + " -C " + Values$;
        Tune$ := " -C " + Values$;

    case tunType$ = tunTypeOrientation$ then

        'Tune$ := Dual$ + " -O " + Values$;
        Tune$ := " -O " + Values$;

    case tunType$ = tunTypeSpatial$ then

        'Tune$ := Dual$ + " -S " + Values$;
        Tune$ := " -S " + Values$;

    case tunType$ = tunTypeTemporal$ then

        'Tune$ := Dual$ + " -T " + Values$;
        Tune$ := " -T " + Values$;

    case tunType$ = tunTypeArea$ then
        
        'Tune$ := Dual$ + " -A " + Values$;
        Tune$ := " -A " + Values$;
        
    case tunType$ = tunTypeID$ then
        
        'Tune$ := Dual$ + " -A " + Values$;
        Tune$ := " -I " + Values$;
        
    case tunType$ = tunTypeNullTest$ then
        if tunNullTestStepFunc% = 0 then
            Tune$ := " -P " + Str$(tunNullTestTF) + "," + Values$;
        else
            Tune$ := " -w -P " + Str$(tunNullTestTF) + "," + Values$;  'What new letter shall we use here?
        endif;
        
        
    case tunType$ = tunTypeDriftingBar$ then
        
        'build foreground gray level string
        tunFGStr$ := "(" + Str$(tunBarForegroundGrayLevel%) + "/" + Str$(tunBarForegroundGrayLevel%) + "/" + Str$(tunBarForegroundGrayLevel%) + ")";
        'build drifting bar string
        tunBarStr$ := Str$(tunBarWidth) + "," + Str$(tunBarHeight) + "," + Str$(tunBarSpeed) + ",";
        
        Tune$ := " -G " + tunFGStr$ + "," + tunBarStr$ + "," + Values$;
        
    case tunType$ = tunTypeCRG$ then
        
        if tunCRGMBalanced% = 1 then
            tunCRGBal$ := " -B ";
            tunCRGNumTerms% := (tunStimulusDuration/2)*(dataScreenHz/tunCRGMFramesPerTurn%);
            nTriggersExpected% := (tunStimulusDuration)*(dataScreenHz/tunCRGMFramesPerTurn%);
        else
            tunCRGBal$ := " -R ";
            tunCRGNumTerms% := tunStimulusDuration*(dataScreenHz/tunCRGMFramesPerTurn%);
            nTriggersExpected% := tunCRGNumTerms%;  'There is one trigger per frame change.  The first trigger is parsed as the stim on, so each trigger we count is an offset, there are as many offsets as turns
        endif;
            printlog("number of triggers expected is %d\n",nTriggersExpected%);
        
        Tune$ := " -F " + tunMSeqLocation$ + tunCRGBal$ + Str$(tunCRGMFramesPerTurn%) + "," + Str$(tunCRGMFirstTerm%) + "," + Str$(tunCRGNumTerms%) + "," + Values$;  'Values$ indicates the contrasts
        
    else

        Message("Error - unknown value for tunType$: " + tunType$);
        Halt;

	endcase;
	
    cmdLine$ := "cmd /k " + bin$ + ProgName$ + Extras$ + Stim$ + Tune$;
    PrintLog(cmdLine$+"\n");
    printlog("num advances is %d and num repeats is %d\n",tunNAdvances%,tunNRepeats%);
    ' Record initial text marks. The command line may need to be broken into pieces. 
    if tunTriggerHack% = 0 then
        SampleText("Tuning,3," + str$(Len(cmdLine$)));  'not clear what this should be, if anything.
    else
        SampleText("Tuning,4," + str$(Len(cmdLine$)));  'not clear what this should be, if anything.
    endif
    
    SampleText(tunCVSID$);
    for i% := 1 to Len(cmdLine$) step 100 do
        SampleText(Mid$(cmdLine$, i%, 100));
    next
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n");
    printlog("num advances is %d and num repeats is %d\n",tunNAdvances%,tunNRepeats%);
	StimHandle% := ProgRun(cmdLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(.1);
return 1;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLogProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a linear progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLinearProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (xmax -xmin)/nsteps%;
	for v := xmin to xmax+stepsize/2 step stepsize do
	'	PrintLog("Value=" + str$(v) + "\n");
		vec[i%] := v;
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
Func StringifyProgression$(n%, vec[], ind%[])
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
		s$ += str$(vec[ind%[i%]]);
	next
	return s$;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Allow investigation of rasters

func InvestigateRastersDialog%()
	var i%;
    var trodes$[10];
    'var trodes[10];  'make global
    var vals$[30];
    'var vals[30];    'make global
    var nTrodes%;
    var nVals%;
    var ind1%;
    var ind2%;
    var temp;
    
    ArrConst(trodes,-4341);  'arbitrary values that won't come up
    ArrConst(vals,-235124);
    
    'Fill out lists, get number of unique entries
    for i% := 0 to Len(trodes$[])-1 do
        temp := tunWavemarkPorts%[i%];
        if ArrFindFloat%(trodes,temp) = -1 then
            nTrodes% := nTrodes% + 1;
        endif;
        trodes$[i%] := Str$(tunWavemarkPorts%[i%]+1);
        trodes[i%] := temp;
    next;
    
    for i% := 0 to Len(vals$[])-1 do
        temp := tunValues[i%];
        if ArrFindFloat%(vals,temp) = -1 then
            nVals% := nVals% + 1;
        endif;
        vals$[i%] := Str$(tunValues[i%]);
        vals[i%] := temp;
    next;
    
	DlgCreate("Investigate Rasters", 50, 10);
	DlgList(1, "Electrode:", trodes$, nTrodes%, 20, 2);  'List of available electrodes
    DlgList(2, "Tuning Curve Value:", vals$, nVals%, 20, 3);  

	'DlgButton(1, "View Raster", InvestigateRasters%, 2, 5);
    DlgAllow(1023,0,InvestigateRasters%);
    
    i%:=DlgShow(ind1%,ind2%);  'we're not keeping any of these values
    
    return 1;
        
end;


func InvestigateRasters%(i%)
    var t%;
    var v%;
    var WindowStep;
    
    WindowStep := 100/tunNWavemarks%;
    t% := DlgValue(1);
    v% := DlgValue(2);
           
    'create the raster
    view(handlePSTH%[t%]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggers%,rasterTotal,rasterPre,v%);  'Update single-stim histogram        
    'And update the title, to indicate which stimulus it is
    view(handlePSTH%[t%]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[t%]+1) + myTitle2$ + Str$(tunValues[v%]));  'Rename single-stim histogram
    
    if tunDoOpto% = 1 then
        'create the raster
        view(handlePSTH%[t%+8]).process(0,view(-1).maxtime(),1,1,0,MemChanRasterTriggersOpto%,rasterTotal,rasterPre,v%);  'Update single-stim histogram        
        'And update the title, to indicate which stimulus it is
        view(handlePSTH%[t%+8]).windowtitle$("Electrode " + Str$(tunWavemarkPorts%[t%]+1) + " Opto On " + myTitle2$ + Str$(tunValues[v%]));  'Rename single-stim histogram
    endif;
    
    return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Just a quickie that grabs the current temporal frequency, useful for making sure
' F1/F2 calcs aren't done is TF = 0

func GetTemporalFrequency()
    var Tstimstr$;
    var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;	
    var i%;
    Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstiminnerw$, Tstiminnerh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
    printlog("OK, in GTF the TF is %s\n",Tstimtf$);
    return Val(Tstimtf$);
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' The vdac32% function converts a value in user DAC units into an integer value
'  (the result of the function) suitable for passing into a sequencer variable
'  for use in the DAC, ADDAC, RAMP and OFFSET sequencer instructions. It mimics
'  the vdac32() expression in the text sequence compiler.
'
' out     is the output value that you want to generate, in user DAC units.
' scale   is the user DAC units corresponding to one volt on the actual DAC
'         (or two volts for a ten-volt system). This is exactly the same as
'         the DACscale field used with the SET or SDAC directives.
' offset  is the user DAC units corresponding to zero volts output. This is
'         exactly the same as the DACOffset field in SET or SDAC.
'
' If you want to use this function to calculate the slope for a ramp, use
'  vdac32%(volts/sticks%(time)) for maximum accuracy.
'
func vdac32%(out, scale, offset)
var v32;                                ' Real variable for the calculation
out := out - offset;                    ' First compensate for offset
v32 := ((out * (6553.6 / scale)) * 65536.0);   ' Floating point result
var v32%;                               ' Integer value for the result
if v32 > 2147483647.0 then              ' 2147483647 is the largest positive
    v32% := 2147483647;                 '  integer value
else
    if v32 < -2147483647.0 then         ' -2147483648 is the lowest negative value
        v32% := -2147483647;            '  but we have to stay one above that
    else
        v32% := round(v32);             ' We can be sure this will not overflow
    endif;
endif;
return v32%;
end