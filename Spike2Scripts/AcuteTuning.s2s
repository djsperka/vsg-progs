' $Id: AcuteTuning.s2s,v 1.4 2010-04-23 23:41:06 devel Exp $
'
' AcuteTuning.s2s
'
' This is a replacement for the old acute rig tuning curve functions CreateParameterFile.s2s, 
' CreateSDL.s2s. 

#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/FileUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "../../Spike2Util/ChannelUtilities.s2s"
#include "UsreyGratings.s2s"

' tuning type-specific values
var tunFileLabel$ := "zzz";

' tuning daq parameters
var tunNChannels%;
var tunColorIndex%;
var tunColor$[4];

' Grating parameters
var tunGratingParams$;

' daq channels for triggers from vsg
var tunChanTrigger% := 11;
var tunChanVSGReady% := 12;

' prog handles
var tunHandleStim := -1;

' window handles
var tunWindowData%;


' Tuning curve types

const tuntypeOri%     := 101;
const tuntypeDom%     := 102;
const tuntypeSF%       := 103;
const tuntypeTF%       := 104;
const tuntypeArea%     := 105;
const tuntypeXY%       := 106;
var tuntypeSelected%   := tuntypeOri%;

' String vars whose values are specific to the expt type
var tunExptTypeFileLabel$;
var tunExptTypeLabel$;
var tunExptTypeArgs$;

' Colors
var tunBGColor$[3];
var tunBGColorIndex% := 0;
var tunBGColorCurrent$;

' Tuning curve parameters

var tunNRepeats% := 1;
var tunStimTime := 2;
var tunBlankTime := 2;
var tunNSteps% := 15;
var tunOriMin := 0;
var tunOriMax := 360;
var tunContrastMin := 1;
var tunContrastMax := 100;
var tunSFMin := 0.1;
var tunSFMax := 6;
var tunTFMin := 0.5;
var tunTFMax := 64;
var tunRandomProgression% := 0;

' tuned parameter arrays
const tunMaxParameters% := 500;
var tunParameterValues[tunMaxParameters%];
var tunParameterIndices%[tunMaxParameters%];


' Initializations

tunBGColor$[0] := "gray";
tunBGColor$[1] := "black";
tunBGColor$[2] := "white";

tunColor$[0] := "Black and white";
tunColor$[1] := "S cone isolating";
tunColor$[2] := "M cone isolating";
tunColor$[3] := "L cone isolating";

tunGratingParams$ := GetGratingParameters$("Stimulus");

' TODO: Resize window?
'View(App(0)).Window(0,0,75,95);




'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Script starts here

' Initialize logging
LogInit(1);


' Get experimental parameters. 
' tunFileLabel$ is set here! 
if AcuteTuningDialog%() = 0 then
    halt;
endif

' Sampling config
CreateSampleConfiguration();

' Prepare display windows, input channels, etc. 
InitializeWindows();


	
ToolbarSet(1,"Quit",Quit%);
ToolbarSet(2,"Sample start",Start%);
ToolbarSet(3,"Sample stop", Stop%);
ToolbarEnable(3,0);
Toolbar("Go",1234);

' Oh no! Make sure sampling has stopped!
if SampleStatus() <> -1 then
    LogWarn("AcuteTuning", "Toolbar exited and sampling status is " + str$(SampleStatus()) + ". Stopping sampling...");
    SampleStop();
    LogWarn("AcuteTuning", "Sampling stopped.");
endif


proc CreateSampleConfiguration()
    
    var i%;
    
	SampleClear(); 'Set standard sampling state
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 3);
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 1);
    SampleAutoName$(dataCellName$ + "_" + tunFileLabel$ + "_000");
	SampleAutoFile(1);

    'Channel recording definitions

    for i% := 1 to tunNChannels% do
        SampleWaveMark(i%, i%-1, 2000, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
        SampleTitle$(i%, "Trode " + Str$(i%-1));
    next

    SampleEvent(tunChanTrigger%, 1, 1, 1000); 
    SampleTitle$(tunChanTrigger%, "Terms");
    
   	SampleEvent(tunChanVSGReady%, 6, 2, 200); 'Trigger channel, level
	SampleComment$(tunChanVSGReady%, "VSG Rdy");
	SampleTitle$(tunChanVSGReady%, "VSG Rdy");
    
	SampleSequencer(script$ + "AcuteTuning.pls");
    SampleOptimise(2, 2, 2, 2, 50);  'Set optimise mode (do this last)
    SampleMode(1); 'Continuous sampling
    
end;


proc InitializeWindows()
    var i%;
    var AutoCorr%;
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
    
    tunWindowData% := FileNew(0,4);
    View(tunWindowData%).WindowVisible(1);
    View(tunWindowData%).Window(0,33,100,100);

    SaveParameterFile();
end

proc SaveParameterFile()
    var handle;
    var filename$;
    
    filename$ := ReplaceFileExtension$(-1, "par");
    handle := FileOpen(filename$, 8, 1);
    if handle <0 then 
        Message("Could not create parameter file " + filename$);
    else
        LogInfo("TODO : Writing parameters to file " + filename$);
        FileClose();
    endif
    
    return;
end


func AcuteTuningDialog%()
    var status%;
    
    LogWarn("AcuteTuningDialog()", "TODO: Get Acute Tuning Parameters");
    
    DlgCreate("Select Tuning Curve Type");
    DlgButton(101, "Orientation", TunDlgOrientation%, 1, 1);
    DlgButton(102, "Contrast", TunDlgContrast%, 1, 2);
    DlgButton(103, "Spatial Frequency", TunDlgSF%, 1, 3);
    DlgButton(104, "Temporal Frequency", TunDlgTF%, 1, 4);
    DlgButton(105, "Area", TunDlgArea%, 1, 5);
    DlgButton(106, "XY", TunDlgXY%, 1, 6);
    status% := DlgShow();    
    if status% <> 0 then
        tunBGColorCurrent$ := tunBGColor$[tunBGColorIndex%];
    endif
    
    LogWarn("AcuteTuningDialog()", "TODO: Save Acute Tuning Parameters");
    
    return status%;
end


func TunDlgOrientation%()
    var status%;
    var nParams%;
    DlgCreate("Orientation Tuning Parameters");
    DlgReal(1, "Stimulus time(s)", 0.1, 100.0);
    DlgReal(2, "Blank time(s)", 0.1, 100.0);
    DlgInteger(3, "Number of steps", 2, 100);
    DlgInteger(4, "Number of repeats", 1, 100);
    DlgReal(5, "Min Orientation", 0, 360);
    DlgReal(6, "Max Orientation", 0, 360);
    DlgCheck(7, "Random Progression?");
	DlgList(8, "Background color:", tunBGColor$);
    DlgButton(151, "Grating Properties", TunDlgOrientationGrating%);
    status% := DlgShow(tunStimTime, tunBlankTime, tunNSteps%, tunNRepeats%, tunOriMin, tunOriMax, tunRandomProgression%, tunBGColorIndex%);
    
    ' Check return value from DlgShow. If user hit OK, the return value is 1, but we must
    ' change it to 0 here.... that's so the calling dialog exits. 
    ' Before we return from here, though, we have all the info needed to put together the 
    ' command line for the tuning program. 
    
    docase
    case status% = 0 then 
        status% := 1;
    case status% = 1 then
        status% := 0;
        tunExptTypeFileLabel$ := "ori";
        tunExptTypeLabel$ := "Orientation";
        nParams% := (tunNSteps%+1)*tunNRepeats%;
        if GetRepeatedParameterProgression%(tunNSteps%+1, tunNRepeats%, tunParameterValues[0:nParams%], tunParameterIndices%[0:nParams%], tunOriMin, tunOriMax, 0, tunRandomProgression%) <> 0 then
            ' TODO: Make sure dialog limits values to this never happens!
            Message("Cannot get progression values for this expt!");
            halt;
        endif
        tunExptTypeArgs$ := " -O " + GetRealArrayAsString$(tunParameterValues[0:tunNSteps%+1], tunParameterIndices%[0:tunNSteps%+1]);
        PrintLog(tunExptTypeArgs$ + "\n");
    endcase
    
    return status%;
end



func TunDlgOrientationGrating%()
    
    var x, y, w, h, sf, tf, ori;
    var contrast%;
    var label$, param$, cv$, pattern$, aperture$;
    var i%;
    var disable%[11];
    var ndisable%;

    ' Disregard the return value from GratingParametersDialog and return 1 so the calling dialog does not exit. 
    ArrConst(disable%[], 0);
    ndisable% := 1;
    disable%[0] := 8;
    i% := GratingParametersDialog%(label$, tunGratingParams$, disable%[], ndisable%, x, y, w, h, contrast%, sf, tf, ori, cv$, pattern$, aperture$);
    LogInfo("TunDlg Orientation: grating label=>" + label$ + "<");
    LogInfo("TunDlg Orientation: params=>" + tunGratingParams$ + "<");
    return 1;
end



func TunDlgContrast%()
    var status%;
    DlgCreate("Contrast Tuning Parameters");
    DlgReal(1, "Stimulus time(s)", 0.1, 100.0);
    DlgReal(2, "Blank time(s)", 0.1, 100.0);
    DlgInteger(3, "Number of steps", 2, 100);
    DlgInteger(4, "Number of repeats", 1, 100);
    DlgReal(5, "Min Contrast%", 1, 100);
    DlgReal(6, "Max Contrast%", 1, 100);
    DlgCheck(7, "Random Progression?");
	DlgList(8, "Background color:", tunBGColor$);
    DlgButton(151, "Grating Properties", TunDlgContrastGrating%);
    status% := DlgShow(tunStimTime, tunBlankTime, tunNSteps%, tunNRepeats%, tunContrastMin, tunContrastMax, tunRandomProgression%, tunBGColorIndex%);
    
    ' Check return value from DlgShow. If user hit OK, the return value is 1, but we must
    ' change it to 0 here.... that's so the calling dialog exits. 
    ' Before we return from here, though, we have all the info needed to put together the 
    ' command line for the tuning program. 
    
    docase
    case status% = 0 then 
        status% := 1;
    case status% = 1 then
        status% := 0;
        tunExptTypeFileLabel$ := "dom";
        tunExptTypeLabel$ := "Contrast";
        if GetRepeatedParameterProgression%(tunNSteps%+1, tunNRepeats%, tunParameterValues[0:tunNSteps%+1], tunParameterIndices%[0:tunNSteps%+1], tunContrastMin, tunContrastMax, 1, tunRandomProgression%) <> 0 then
            ' TODO: Make sure dialog limits values to this never happens!
            Message("Cannot get progression values for this expt!");
            halt;
        endif
        tunExptTypeArgs$ := " -C " + GetRealArrayAsString$(tunParameterValues[0:tunNSteps%+1], tunParameterIndices%[0:tunNSteps%+1]);
        PrintLog(tunExptTypeArgs$ + "\n");
    endcase
    
    return status%;
end

func TunDlgContrastGrating%()
    
    var x, y, w, h, sf, tf, ori;
    var contrast%;
    var label$, param$, cv$, pattern$, aperture$;
    var i%;
    var disable%[11];
    var ndisable%;

    ' Disregard the return value from GratingParametersDialog and return 1 so the calling dialog does not exit. 
    ArrConst(disable%[], 0);
    ndisable% := 1;
    disable%[0] := 5;
    i% := GratingParametersDialog%(label$, param$, disable%[], ndisable%, x, y, w, h, contrast%, sf, tf, ori, cv$, pattern$, aperture$);
    return 1;
end


func TunDlgSF%()
    var status%;
    var nParams%;
    DlgCreate("Spatial Frequency Tuning Parameters");
    DlgReal(1, "Stimulus time(s)", 0.1, 100.0);
    DlgReal(2, "Blank time(s)", 0.1, 100.0);
    DlgInteger(3, "Number of steps", 2, 100);
    DlgInteger(4, "Number of repeats", 1, 100);
    DlgReal(5, "Min SF", .01, 100);
    DlgReal(6, "Max SF", .01, 100);
    DlgCheck(7, "Random Progression?");
	DlgList(8, "Background color:", tunBGColor$);
    DlgButton(151, "Grating Properties", TunDlgSFGrating%);
    status% := DlgShow(tunStimTime, tunBlankTime, tunNSteps%, tunNRepeats%, tunSFMin, tunSFMax, tunRandomProgression%, tunBGColorIndex%);
    
    ' Check return value from DlgShow. If user hit OK, the return value is 1, but we must
    ' change it to 0 here.... that's so the calling dialog exits. 
    ' Before we return from here, though, we have all the info needed to put together the 
    ' command line for the tuning program. 
    
    docase
    case status% = 0 then 
        status% := 1;
    case status% = 1 then
        status% := 0;
        tunExptTypeFileLabel$ := "sf";
        tunExptTypeLabel$ := "Spatial Frequency";
        nParams% := (tunNSteps%+1)*tunNRepeats%;
        if GetRepeatedParameterProgression%(tunNSteps%+1, tunNRepeats%, tunParameterValues[0:nParams%], tunParameterIndices%[0:nParams%], tunSFMin, tunSFMax, 1, tunRandomProgression%) <> 0 then
            ' TODO: Make sure dialog limits values to this never happens!
            Message("Cannot get progression values for this expt!");
            halt;
        endif
        tunExptTypeArgs$ := " -S " + GetRealArrayAsString$(tunParameterValues[0:tunNSteps%+1], tunParameterIndices%[0:tunNSteps%+1]);
        PrintLog(tunExptTypeArgs$ + "\n");
    endcase
    
    return status%;
end

func TunDlgSFGrating%()
    
    var x, y, w, h, sf, tf, ori;
    var contrast%;
    var label$, param$, cv$, pattern$, aperture$;
    var i%;
    var disable%[11];
    var ndisable%;

    ' Disregard the return value from GratingParametersDialog and return 1 so the calling dialog does not exit. 
    ArrConst(disable%[], 0);
    ndisable% := 1;
    disable%[0] := 6;
    i% := GratingParametersDialog%(label$, param$, disable%[], ndisable%, x, y, w, h, contrast%, sf, tf, ori, cv$, pattern$, aperture$);
    return 1;
end


func TunDlgTF%()
    var status%;
    var nParams%;
    DlgCreate("Temporal Frequency Tuning Parameters");
    DlgReal(1, "Stimulus time(s)", 0.1, 100.0);
    DlgReal(2, "Blank time(s)", 0.1, 100.0);
    DlgInteger(3, "Number of steps", 2, 100);
    DlgInteger(4, "Number of repeats", 1, 100);
    DlgReal(5, "Min TF", .01, 100);
    DlgReal(6, "Max TF", .01, 100);
    DlgCheck(7, "Random Progression?");
	DlgList(8, "Background color:", tunBGColor$);
    DlgButton(151, "Grating Properties", TunDlgTFGrating%);
    status% := DlgShow(tunStimTime, tunBlankTime, tunNSteps%, tunNRepeats%, tunTFMin, tunTFMax, tunRandomProgression%, tunBGColorIndex%);
    
    ' Check return value from DlgShow. If user hit OK, the return value is 1, but we must
    ' change it to 0 here.... that's so the calling dialog exits. 
    ' Before we return from here, though, we have all the info needed to put together the 
    ' command line for the tuning program. 
    
    docase
    case status% = 0 then 
        status% := 1;
    case status% = 1 then
        status% := 0;
        tunExptTypeFileLabel$ := "tf";
        tunExptTypeLabel$ := "Temporal Frequency";
        nParams% := (tunNSteps%+1)*tunNRepeats%;
        if GetRepeatedParameterProgression%(tunNSteps%+1, tunNRepeats%, tunParameterValues[0:nParams%], tunParameterIndices%[0:nParams%], tunTFMin, tunTFMax, 1, tunRandomProgression%) <> 0 then
            ' TODO: Make sure dialog limits values to this never happens!
            Message("Cannot get progression values for this expt!");
            halt;
        endif
        tunExptTypeArgs$ := " -T " + GetRealArrayAsString$(tunParameterValues[0:tunNSteps%+1], tunParameterIndices%[0:tunNSteps%+1]);
        PrintLog(tunExptTypeArgs$ + "\n");
    endcase
    
    return status%;
end

func TunDlgTFGrating%()
    
    var x, y, w, h, sf, tf, ori;
    var contrast%;
    var label$, param$, cv$, pattern$, aperture$;
    var i%;
    var disable%[11];
    var ndisable%;

    ' Disregard the return value from GratingParametersDialog and return 1 so the calling dialog does not exit. 
    ArrConst(disable%[], 0);
    ndisable% := 1;
    disable%[0] := 7;
    i% := GratingParametersDialog%(label$, param$, disable%[], ndisable%, x, y, w, h, contrast%, sf, tf, ori, cv$, pattern$, aperture$);
    return 1;
end


func TunDlgArea%()
    var status%;
    DlgCreate("Area Tuning Parameters");
    status% := DlgShow();
    PrintLog("TunDlgArea %d\n", status%);
    docase
    case status% = 0 then 
        status% := 1;
    case status% = 1 then
        status% := 0;
        tunExptTypeFileLabel$ := "area";
        tunExptTypeLabel$ := "Area";
    endcase
    return status%;
end

func TunDlgXY%()
    var status%;
    DlgCreate("XY Tuning Parameters");
    status% := DlgShow();
    PrintLog("TunDlgXY %d\n", status%);
    docase
    case status% = 0 then 
        status% := 1;
    case status% = 1 then
        status% := 0;
        tunExptTypeFileLabel$ := "xy";
        tunExptTypeLabel$ := "XY";
    endcase
    return status%;
end


' Quit is used to exit the script entirely. 
' If there are any VSG apps running they should be stopped now. 
' All VSG apps should be triggered off if possible - that allows for clean
' handling of the lock. 
' Could check if app is running, display error message. 

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Quit%()
'   TODO: Check for running vsg app.
    return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' Start is used to start sampling. Start must take things from post-dialog (i.e. all parameters can 
' be assumed to be expt-ready, but live, daq-related values (updated in Idle%() ) - tStateStart, 
' iState%, etc.) have only been initialized, not used.
' Start should start sampling, and immediately issue a SampleKey("0"); to lower all output lines. 
' THEN launch vsg application (so it sees the cleared triggers. 
' Finally, take care of the toolbar. 

func Start%()
    var cmd$;
    
    ' Start sampling
    SampleStart(0);
    View(tunWindowData%);    
    
    ' Send sample key. 
    SampleKey("0");
    
    ' Set idle here - before vsg launches so we cannot miss the ready signal. 
    ToolbarEnable(3,1); ' stop
    ToolbarEnable(2,0); ' start
    ToolbarEnable(1,0); ' quit
    ToolbarSet(0, "", Idle%);
    
    ' Build command line and launch vsg app.     
    cmd$ := GetBinDir$(1) + "meatuning.exe " + "-cvb " + tunBGColorCurrent$ + " -g " + tunGratingParams$ + " -t " + str$(tunStimTime) + " -d " + GetAcuteDistanceToScreenMM$() + tunExptTypeArgs$;
    LogInfo(cmd$);
    tunHandleStim := ProgRun("cmd /c " + cmd$);
    
    
    'wait 5 seconds for some spikes to come in, and then optimize the display for them.
    Yield(5);
    View(tunWindowData%).Optimise(-1, 0, MaxTime());
    return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' Stop must stop applications and sampling nicely. Adjust toolbar to wait for "quit", stop Idle%(). 
' Send SampleKey to kill the VSG app and wait for it to exit. 
' TODO: Can this be done with a timeout?
' VSG apps should return to gray screen, clear triggers, all off - at same time that lock is freed?

func Stop%()
    
    ' remove the idle process. 
    ToolbarSet(0, "");
    ToolbarEnable(1, 1);
    ToolbarEnable(3, 0);
    
    ' send the quit command before stopping sampling
    SampleKey("q");
    while ProgStatus(tunHandleStim) > 0 do
        Yield(1);
    wend
    SampleStop();
    
    ' clear screen/trigger, just in case
    'ProgRun(GetBinDir$(1) + "ClearTrigger");

    return 1;
end; 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var tNow;               ' Set on entering this func. For this invocation it is the latest time sampled. 
var tLast;              ' This is tNow from the last time Idle%() was called. 
var tStateStart := -1;  ' Start time of current state
var tStimStart := -1;   ' Time of stim ON trig
var tBlankStart := -1;  ' Time of blankON trig
var tBlankEnd := -1;    ' time of blankOFF trig
var iStimCounter% := 0;
var iBlankCounter% := 0;
var tTrigger := -1;
var vTrigger;
var tlastTrigger := -1;

' states
const stateStartup%             :=  1;
const stateVSGWait%             :=  2;
const stateVSGConfirm%          :=  3;
const stateStartTuning%         :=  4;
const stateNoStim%              :=  5;
const stateStimON%              :=  6;
const stateBlankON%             :=  7;
const stateDone%                := 99;
var iState% := stateStartup%;              ' This holds the current state
var iDummy% := 0;

func Idle%()
    var status% := 1;
    
	tNow := MaxTime();
    
    docase 
    case iState% = stateStartup% then
        
        LogStatus("stateStartup", "Starting up.");
        ChangeStateTo(stateVSGWait%, tNow);
        
    case iState% = stateVSGWait% then
        
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        tTrigger := NextTime(tunChanVSGReady%, tLast, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 0 then
            LogStatus("stateVSGWait", "Got leading edge of trigger.");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateVSGConfirm%, tTrigger);                
        endif;
            
    case iState% = stateVSGConfirm% then
            
        ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
        tTrigger := NextTime(tunChanVSGReady%, tLastTrigger, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 1 then                
            LogStatus("stateVSGConfirm", "Got trailing edge of trigger.");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateStartTuning%, tTrigger);
        endif;
            
    case iState% = stateStartTuning% then
        
        ' Issue sample key to start stim, then switch to looking for triggers
        LogStatus("stateStartTuning", "Starting stimulus.");
        Yield(1.0);
        SampleKey("s");
        ChangeStateTo(stateNoStim%, tNow);
        
    case iState% = stateNoStim% then
        
        ' Waiting for the first trig - which indicates the stim is on
        if FindEvent%(tunChanTrigger%, tStateStart, tStimStart) > 0 then
            ChangeStateTo(stateStimON%, tStimStart);
        endif
        
    case iState% = stateStimON% then
        
        ' Waiting for the second trig - which indicates the stim is off
        if FindEvent%(tunChanTrigger%, tStimStart, tBlankStart) > 0 then
            ' TODO process spikes
            LogInfo("TODO: Process spikes for STIM " + str$(iStimCounter%) + " " + str$(tStimStart) + "-" + str$(tBlankStart) + " " + str$(tunParameterValues[tunParameterIndices%[iStimCounter%]]) + "\n");
            iStimCounter% += 1;
            ChangeStateTo(stateBlankON%, tBlankStart);
        endif
        
    case iState% = stateBlankON% then
        
        ' Waiting for the third trig - which indicates the blank is off
        if FindEvent%(tunChanTrigger%, tBlankStart, tBlankEnd) > 0 then
            
            LogInfo("TODO: Process spikes for BLANK " + str$(iBlankCounter%) + " " + str$(tBlankStart) + "-" + str$(tBlankEnd) + "\n");
            iBlankCounter% += 1;            
            
            ' check whether all stim have been presented
            if iStimCounter% = (tunNSteps%+1) * tunNRepeats% then
                ChangeStateTo(stateDone%, tNow);
            else
                ChangeStateTo(stateNoStim%, tBlankEnd);
            endif
        endif
        
    case iState% = stateDone% then
        
        Stop%();
        status% := 1;
        
    else
        
        LogError("", "Unknown state " + str$(iState%));
        Stop%();
        status% := 0;
        
    endcase
    
    return status%;
end

proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;
