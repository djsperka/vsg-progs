' $Id: AttentionGoNoGoTemp.s2s,v 1.16 2013-05-30 17:33:31 jeff Exp $
'
#include "../../Spike2Util/UsreyUtil.s2s"
#include "AttentionExtractFunctions.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' 	Attention script dialog START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'	Vars that control the Attention script. 

var attNumberOfBlocks%;
var attTrialsPerBlock%;
var attEasyTrialsPerBlock%;
var attCatchTrialPercentage;  'this really could be an integer, but whatevs
var attUncatchTrialPercentage;
var attDoUncatch%;
var attNoGoTrialPercentage;  'ditto
var attBackgroundColor$;
var attBackgroundRed% := 0;
var attBackgroundGreen% := 0;
var attBackgroundBlue% := 0;
var attBackgroundFromRed% := 0;
var attBackgroundFromGreen% := 0;
var attBackgroundFromBlue% := 0;
var attBackgroundToRed% := 0;
var attBackgroundToGreen% := 0;
var attBackgroundToBlue% := 0;
var attAnswerPointDiameter := 0.05;
var attAnswerPointOffset := 5.0;
var attAnswerPointWindowRadius := 2.5;
var attContrastBase%;
var attMaxContChange;
var attMinContChange;
var attNContLevels%;
var attContrastList[20];        'max of 20 (10 up, 10 down) contrast levels
var attFixationTime;
'var attWhitePointTime;          ' xxxxx
var attFixationCueMinTime;      ' xxxxx
var attFixationCueMaxTime;      ' xxxxx
var attHazardMinTime;
var attHazardExpMeanTime;
var attHazardCutoffTime;
var attAcquisitionTime;
var attInterTrialTime;
var attInterTrialTime2;
var attTimeToAnswer;
var attAbortWaitTime;
var attMissPenalty;
var attFalseAlarmWaitTime;
var attFalseAlarmCheckWindow;
var attBlockAlternate%;
var attNoBlockRand%;  'if 1, don't do blocked randomization
var attTrainingContrastCheck%:=0;
var attTrainingContrastPct%:=0;
var attAnsWindowIsGrating%:=0;
var randBlockOrderVar%;     'this will be 0 or 1, and will determine whether we start attend-toward or attend-away
randBlockOrderVar% := round(rand(0.0)); 'just set it right now, may need 0.0 to properly seed random number generator

var attCustomGratingColorCheck%;
var attCustomGratingColorStimFrom%[3];
var attCustomGratingColorStimTo%[3];
var attCustomGratingColorDistractorFrom%[3];
var attCustomGratingColorDistractorTo%[3];

var attLollipopCheck%;
var attCueLinePct;
var attCircleDiameterDiff;
var attLollipopContrast%;
var attLollipopStickContrast%;
var attCueLineGap;

var Contrast$;

' Counter vars for attention script
var attCountAllTrials% := 0;
var attCountAllTrialsCorrect% := 0;
var attCountAllTrialsIncorrect% := 0;
var attCountAllTrialsAbort% := 0;
var attCountTowardTrials% := 0;
var attCountTowardTrialsCorrect% := 0;
var attCountTowardTrialsIncorrect% := 0;
var attCountTowardTrialsAbort% := 0;
var attCountAwayTrials% := 0;
var attCountAwayTrialsCorrect% := 0;
var attCountAwayTrialsIncorrect% := 0;
var attCountAwayTrialsAbort% := 0;
var attOnlyOneCatch% := 0;
var attOneCatchContrast% := 0;

' constants for dialog and check function - start with 10 because there are 9 dialog entries prior
' sure, it would be great if all the dialog numbers were done like this, but they ain't, and time is time
const attdlgTrainingContrastCheck% := 13;
const attdlgTrainingContrastPct% := 14;
const attdlgLollipopCheck% := 15;
const attdlgCueLinePct% := 16;
const attdlgCircleDiameterDiff% := 17;
const attdlgLollipopContrast% := 18;
const attdlgLollipopStickContrast% := 19;
const attdlgLollipopStickGap := 20;
'const attdlgUseAnsWindow% := 21;  'not used
const attdlgOnlyOneCatch% := 21;
const attdlgOneCatchContrast% := 22;
const attdlgDoUncatch% := 23;

' constants for timing dialog
const atttimingdlgFixationCueMinTime% := 2;
const atttimingdlgFixationCueMaxTime% := 3;
const atttimingdlgHazardMinTime% := 4;
const atttimingdlgHazardExpMeanTime% := 5;
const atttimingdlgHazardCutoffTime% := 6;

' constants for color dialog
var attdlgColorIndexGray% := 0;
var attdlgColorIndexBlack% := 1;
var attdlgColorIndexWhite% := 2;
var attdlgColorIndexCustom% := 3;
var attcolorsdlgBackgroundColor% := 1;
var attcolorsdlgBackgroundRed% := 2;
var attcolorsdlgBackgroundGreen% := 3;
var attcolorsdlgBackgroundBlue% := 4;
var attcolorsdlgCustomGratingColorCheck% := 5;
var attcolorsdlgCustomGratingColorStimFromRed% := 6;
var attcolorsdlgCustomGratingColorStimFromGreen% := 7;
var attcolorsdlgCustomGratingColorStimFromBlue% := 8;
var attcolorsdlgCustomGratingColorStimToRed% := 9;
var attcolorsdlgCustomGratingColorStimToGreen% := 10;
var attcolorsdlgCustomGratingColorStimToBlue% := 11;
var attcolorsdlgCustomGratingColorDistractorFromRed% := 12;
var attcolorsdlgCustomGratingColorDistractorFromGreen% := 13;
var attcolorsdlgCustomGratingColorDistractorFromBlue% := 14;
var attcolorsdlgCustomGratingColorDistractorToRed% := 15;
var attcolorsdlgCustomGratingColorDistractorToGreen% := 16;
var attcolorsdlgCustomGratingColorDistractorToBlue% := 17;

'variables for Henry's tuning curve version
const attMaxTrl% := 1000;
var attTrialOrder%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the test trials
var attTrialOrderTemp%[attMaxTrl%];  'helps in creating variable percentages of no-go trials
var attCatchTrialOrder%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the catch trials
var attTrial[attMaxTrl%];       'this variable is really only here because GetRepeatedParameterProgression wants to fill it; we will ignore it
var attCurrTrialIndex%;         'We'll need to keep track of the current trial index
var attContrastList%[attMaxTrl%];  'A list of which contrast is being used on each trial, filled by CreateContrastList
var attUpDownList%[attMaxTrl%];    '1 if using increase in contrast, -1 if using decrease on each trial, filled by CreateContrastList
var attValidList%[attMaxTrl%];     '1 if valid, 0 if catch trial, filled by CreateContrastList
var thisContrast%;                 'for sampletexty stuff
var FAIsResponse%;              'if 1, use "response abort", otherwise use regular abort
var expectedAnswer%;            'keeps track of expected answer, saves a bunch of redundant code

'we need to explicitly know the position of the gratings to place the answer windows on the gratings
var upX;
var upY;
var upW;
var upH;
var downX;
var downY;
var downW;
var downH;

proc GetAttentionScriptParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
	Profile(key$, "NumberOfBlocks", 1, attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", 1, attTrialsPerBlock%);
    Profile(key$, "EasyTrialsPerBlock", 1, attEasyTrialsPerBlock%);
    Profile(key$, "DoUncatch", 1, attDoUncatch%);
	Profile(key$, "CatchTrialPercentage", "0.0", stmp$);
    attCatchTrialPercentage := val(stmp$);
    Profile(key$, "NoGoTrialPercentage", "0.0", stmp$);
	attNoGoTrialPercentage := val(stmp$);
	Profile(key$, "BlockAlternate", 1, attBlockAlternate%);
    Profile(key$, "NoBlockRand", 1, attNoBlockRand%);
	Profile(key$, "TrainingContrastCheck", 0, attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", 0, attTrainingContrastPct%);
    Profile(key$, "OnlyOneCatch", 0, attOnlyOneCatch%);
    Profile(key$, "OneCatchContrast", 0, attOneCatchContrast%); 
	Profile(key$, "BackgroundColor", "gray", attBackgroundColor$);
    
    if InStr(attBackgroundColor$, "(") = 1 then
        if ParseColor%(attBackgroundColor$, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%) <> 0 then
            attBackgroundColor$ := "gray";
        endif
    endif
    
    Profile(key$, "ContrastBase", 50, attContrastBase%);
	'Profile(key$, "ContrastMax", 80, attMaxContChange);  ;now reals, have to do pull a string and convert
	'Profile(key$, "ContrastMin", 20, attMinContChange);
    Profile(key$, "NContrastLevels", 20, attNContLevels%);
    
    
    Profile(key$, "ContrastMax", "1", stmp$);
	attMaxContChange := val(stmp$);
    
    Profile(key$, "ContrastMin", "1", stmp$);
	attMinContChange := val(stmp$);
    
	Profile(key$, "AnswerPointDiameter", "0.5", stmp$);
	attAnswerPointDiameter := val(stmp$);
    
	Profile(key$, "AnswerPointOffset", "5.0", stmp$);
	attAnswerPointOffset := val(stmp$);
    
	Profile(key$, "AnswerPointWindowRadius", "2.0", stmp$);
	attAnswerPointWindowRadius := val(stmp$);
    
	Profile(key$, "FixationCueMinTime", "1.0", stmp$);
	attFixationCueMinTime := val(stmp$);
    
	Profile(key$, "FixationCueMaxTime", "1.0", stmp$);
	attFixationCueMaxTime := val(stmp$);
    
    '	Profile(key$, "WhitePointTime", "1.0", stmp$);
    '	attWhitePointTime := val(stmp$);
    
	Profile(key$, "HazardMinTime", "0.5", stmp$);
	attHazardMinTime := val(stmp$);
    
	Profile(key$, "HazardExpMeanTime", "1.0", stmp$);
	attHazardExpMeanTime := val(stmp$);
    
   	Profile(key$, "HazardCutoffTime", "5.0", stmp$);
	attHazardCutoffTime := val(stmp$);
    
	Profile(key$, "AcquisitionTime", "1.0", stmp$);
	attAcquisitionTime := val(stmp$);
    
	Profile(key$, "InterTrialTime", "1.0", stmp$);
	attInterTrialTime := val(stmp$);
    
	Profile(key$, "TimeToAnswer", "1.0", stmp$);
	attTimeToAnswer := val(stmp$);
    
	Profile(key$, "AbortWaitTime", "1.0", stmp$);
	attAbortWaitTime := val(stmp$);
    
    Profile(key$, "MissPenalty", "1.0", stmp$);
	attMissPenalty := val(stmp$);
    
    Profile(key$, "FalseAlarmWaitTime", "1.0", stmp$);
	attFalseAlarmWaitTime := val(stmp$);
    
    Profile(key$, "FalseAlarmCheckWindow", "1.0", stmp$);
	attFalseAlarmCheckWindow := val(stmp$);
    
    
    Profile(key$, "CustomGratingColorsCheck", 0, attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", 0, attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", 0, attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", 0, attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", 255, attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", 255, attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", 255, attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", 0, attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", 0, attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", 0, attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", 255, attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", 255, attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", 255, attCustomGratingColorDistractorTo%[2]);
    
	Profile(key$, "LollipopCheck", 0, attLollipopCheck%);
	Profile(key$, "CueLinePct", "100.0", stmp$);
    attCueLinePct := val(stmp$);
    Profile(key$, "CircleDiameterDiff", "0.1", stmp$);
    attCircleDiameterDiff := val(stmp$);
    Profile(key$, "LollipopContrast", 100, attLollipopContrast%);
    Profile(key$, "LollipopStickContrast", 100, attLollipopStickContrast%);
	Profile(key$, "CueLineGap", "0.5", stmp$);
    attCueLineGap := val(stmp$);
    
end;

proc SaveAttentionScriptParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
	Profile(key$, "NumberOfBlocks", attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", attTrialsPerBlock%);
    Profile(key$, "EasyTrialsPerBlock", attEasyTrialsPerBlock%);
    Profile(key$, "DoUncatch", attDoUncatch%);
	Profile(key$, "CatchTrialPercentage", str$(attCatchTrialPercentage));
    Profile(key$, "NoGoTrialPercentage", str$(attNoGoTrialPercentage));
	Profile(key$, "BlockAlternate", attBlockAlternate%);
    Profile(key$, "NoBlockRand", attNoBlockRand%);
	Profile(key$, "TrainingContrastCheck", attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", attTrainingContrastPct%);
    Profile(key$, "OnlyOneCatch", attOnlyOneCatch%);
    Profile(key$, "OneCatchContrast", attOneCatchContrast%);
	Profile(key$, "BackgroundColor", attBackgroundColor$);
	Profile(key$, "ContrastBase", attContrastBase%);
	Profile(key$, "ContrastMax", str$(attMaxContChange));
	Profile(key$, "ContrastMin", str$(attMinContChange));
    Profile(key$, "NContrastLevels", attNContLevels%);
	Profile(key$, "FixationCueMinTime", str$(attFixationCueMinTime));
	Profile(key$, "FixationCueMaxTime", str$(attFixationCueMaxTime));
    '	Profile(key$, "WhitePointTime", str$(attWhitePointTime));
	Profile(key$, "HazardMinTime", str$(attHazardMinTime));
	Profile(key$, "HazardExpMeanTime", str$(attHazardExpMeanTime));
    Profile(key$, "HazardCutoffTime", str$(attHazardCutoffTime));
	Profile(key$, "AcquisitionTime", str$(attAcquisitionTime));
	Profile(key$, "AbortWaitTime", str$(attAbortWaitTime));
    Profile(key$, "MissPenalty", str$(attMissPenalty));
    Profile(key$, "FalseAlarmWaitTime", str$(attFalseAlarmWaitTime));
    Profile(key$, "FalseAlarmCheckWindow", str$(attFalseAlarmCheckWindow));
	Profile(key$, "InterTrialTime", str$(attInterTrialTime));
	Profile(key$, "TimeToAnswer", str$(attTimeToAnswer));
	Profile(key$, "AnswerPointDiameter", str$(attAnswerPointDiameter));
	Profile(key$, "AnswerPointOffset", str$(attAnswerPointOffset));
	Profile(key$, "AnswerPointWindowRadius", str$(attAnswerPointWindowRadius));
    Profile(key$, "CustomGratingColorsCheck", attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", attCustomGratingColorDistractorTo%[2]);
    
	Profile(key$, "LollipopCheck", attLollipopCheck%);
	Profile(key$, "CueLinePct", str$(attCueLinePct));
    Profile(key$, "CircleDiameterDiff", str$(attCircleDiameterDiff));
    Profile(key$, "LollipopContrast", attLollipopContrast%);
    Profile(key$, "LollipopContrast", attLollipopContrast%);
    Profile(key$, "LollipopStickContrast", attLollipopStickContrast%);
	Profile(key$, "CueLineGap", str$(attCueLineGap));
    
end;

func AttentionScriptDialog%()
	var i%;
    var j%;
    var tempIndex%;
    var tempNBlocks%;
    var tempTotal;  'friggin integer math
    var tempWhoops;
    var threeints%[3];
    var twoints%[2];
    
    GetAttentionScriptParameters();
    
    'cheating on number of entries in dialog box
    threeints%[0] := attNumberOfBlocks%;
    threeints%[1] := attTrialsPerBlock%;
    threeints%[2] := attEasyTrialsPerBlock%;
    twoints%[0] := attBlockAlternate%;
    twoints%[1] := attNoBlockRand%;
    
	DlgCreate("Attention Training Parameters", 25, 10);
    DlgGroup("Blocks", 1, 1, 34, 9);
	DlgInteger(1, "Number of Blocks:", 1, 1000, 22, 2);
	DlgInteger(2, "Reg. Trials per block:", 1, 1000, 22, 3);
    DlgInteger(3, "Easy Trials per block:", 1, 1000, 22, 4);
	DlgReal(4, "Catch Trial pct (0-100)", 0, 100, 22, 5);
    DlgCheck(attdlgDoUncatch%, "Use 'Uncatch' trials at same %age", 2, 6);
    DlgReal(5, "No-Go Trial pct (0-100)", 0, 100, 22, 7);
	DlgCheck(6, "Alternate cue type by block", 2, 8);
    DlgCheck(7, "Do NOT randomize by block", 2, 9);
    
    'for this dialog group we have to use DlgText because CED justifies the text all the way left in DlgInteger, etc.
    DlgGroup("Contrast",36,1,34,10);
    DlgInteger(8, "", 0, 100, 56, 2);  DlgText("Base contrast (%)",37,2);
	DlgReal(9, "", 0, 10, 56, 3);  DlgText("Max dContrast (oct)",37,3);
	DlgReal(10, "", 0, 10, 56, 4);  DlgText("Min dContrast (oct)",37,4);
    DlgInteger(11, "", 1, 10, 56, 5);  DlgText("N contrast levels",37,5);
    'DlgCheck(attdlgUseAnsWindow%, "Answer window = grating",2,13);  'too many to use..., keeping it, but...
    DlgReal(12, "", 0, 10, 56, 6);  DlgText("Ans. window rad. (deg)",37,6);
	DlgCheck(attdlgTrainingContrastCheck%, "Training Contrast", 37, 7);
	DlgInteger(attdlgTrainingContrastPct%, "", 0, 100, 56, 8);  DlgText("Training Contrast(%)",37,8);
    DlgCheck(attdlgOnlyOneCatch%, "Use only one catch value", 37,9);
    DlgInteger(attdlgOneCatchContrast%,"",0,100,56,10);  DlgText("Single Catch Cont (%)",37,10);
    
    DlgButton(2, "Colors", ColorsDialog%, 1, 10);
    DlgButton(3, "Timing", TimingDialog%, 20, 10);
    DlgGroup("Lollipops", 1, 11, 68, 7);
    DlgCheck(attdlgLollipopCheck%, "Use lollipop cues", 2, 12);
    DlgReal(attdlgCueLinePct%, "Cue line %", 0, 100, 22, 13);
    DlgReal(attdlgCircleDiameterDiff%, "Circle diameter diff", 0, 10, 22, 14);
    DlgInteger(attdlgLollipopContrast%, "Lollipop contrast", 0, 100, 22, 15);
    DlgInteger(attdlgLollipopStickContrast%, "Stick contrast", 0, 100, 22, 16);
    DlgReal(attdlgLollipopStickGap, "Lollipop stick gap", 0, 10, 22, 17);
    DlgAllow(0, 0, AttentionScriptDialogChanged%);
	i%:=DlgShow(threeints%[], attCatchTrialPercentage, attNoGoTrialPercentage, 
    twoints%[], attContrastBase%, attMaxContChange, attMinContChange, attNContLevels%,
    attAnswerPointWindowRadius, attTrainingContrastCheck%, attTrainingContrastPct%, 
    attLollipopCheck%, attCueLinePct, attCircleDiameterDiff, 
    attLollipopContrast%, attLollipopStickContrast%, attCueLineGap, attOnlyOneCatch%, 
    attOneCatchContrast%, attDoUncatch%);
	if i% = 1 then
        '	attBackgroundColor$ := bcl$[ibcl%];
        'Cheating on number of entries in dialog box
        attNumberOfBlocks% := threeints%[0];
        attTrialsPerBlock% := threeints%[1];
        attEasyTrialsPerBlock% := threeints%[2];
        attBlockAlternate% := twoints%[0];
        attNoBlockRand% := twoints%[1];
        
        
        'If we are doing the Uncatch trials, set UncatchTrialPercentage to 2x CatchTrialPercentage
        'The logic here is:  case rand < catch, then catch; case rand < uncatch, then uncatch
        'When uncatch = catch, there will be no uncatch; when uncatch = 2x catch, there will be the
        'same number of each.
        if attDoUncatch% = 1 and attOnlyOneCatch% = 1 then
            attUncatchTrialPercentage := 2*attCatchTrialPercentage;
        else
            attUncatchTrialPercentage := attCatchTrialPercentage;
        endif;
        'sanity check
        if attUncatchTrialPercentage > 100 then
            message("Error: Catch Trials + Uncatch Trials > 100%!!!");
            Quit%();
        endif;
        
        
        
        'Secret hidden check, if answer point radius is 0 it will use the grating size
        if attAnswerPointWindowRadius = 0 then
            attAnsWindowIsGrating% := 1;
        else
            attAnsWindowIsGrating% := 0;
        endif;
        
        if attMinContChange > attMaxContChange then
            message("The maximum contrast change must be MORE than the minimum!  Swapping!");
            tempWhoops := attMinContChange;
            attMinContChange := attMaxContChange;
            attMaxContChange := tempWhoops;
        endif;
        
		SaveAttentionScriptParameters();
        
        'get contrast list
        if attNContLevels% > 1 then
            GetLogProgression(attContrastBase%*(pow(2,attMinContChange)),attContrastBase%*(pow(2,attMaxContChange)),attNContLevels%-1,attContrastList[0:attNContLevels%]);  'levels above base
            'GetLogProgression(attContrastBase%/(pow(2,attMaxContChange)),attContrastBase%/(pow(2,attMinContChange)),attNContLevels%-1,attContrastList[attNContLevels%:attNContLevels%]);  'levels below base, in *ascending* order
            Arrconst(attContrastList[attNContLevels%:attNContLevels%],attContrastBase%);  'for no-go, assign the second half of stimuli as identical to the base contrast
            round(attContrastList[]);  'we can only use integer values in the VSG call
        else
            'if only one value is requested, this will crash GetLogProgression, so just do it manually
            attContrastList[0] := attContrastBase%*(pow(2,attMaxContChange));
            'attContrastList[1] := attContrastBase%/(pow(2,attMaxContChange));
            attContrastList[1] := attContrastBase%;  'for go/no-go, use the base, not a down contrast
                        
            message("Note that only one contrast level was requested, using MAX as actual value!");
        endif;
        
        'get number of trials to run, which is hypothetical "max" number for both test trials and catch trials regardless of catch/test percentage
        tempTotal := attNumberOfBlocks%*attTrialsPerBlock%;  'total number of non-"easy" trials
        'tempNBlocks% := ceil(tempTotal/(attNContLevels%*2));  'total number of times we have to repeat the tuning curve to reach the total number of trials
        tempNBlocks% := ceil(tempTotal/(attNContLevels%));  'MAXIMUM number of times we have to repeat the tuning curve to reach the total number of trials, if 0 no-go trials
        
        printlog("number of contrast levels is %d and tempnblocks is %d\n",attNContLevels%,tempNBlocks%);
        
        'It's a bit tricky to try to push the idea of variable No-Go percentage (as opposed to 50%) into the GetRepeatedParameterProgression
        'schematic, but I think I've got a plan.
        'First step - create a list of contrasts as normal in a temporary variable, but only include "go" contrasts 
        if attNoBlockRand% = 0 then
            'get trial order, attTrialOrder%[] will hold indices into attContrastList[] for all trials
            'GetRepeatedParameterProgression%(attNContLevels%*2,tempNBlocks%,attTrial[],attTrialOrder%[],0,(attNContLevels%*2)-1,0,1);  'this has Go and No-go contrasts
            GetRepeatedParameterProgression%(attNContLevels%,tempNBlocks%,attTrial[],attTrialOrder%[],0,(attNContLevels%)-1,0,1);  'this has only Go contrasts
        else 'Henry sez just do true random
            'Rand(attTrialOrder%[0:attNContLevels%*2*tempNBlocks%],(attNContLevels%*2)); 'this has Go and No-go contrasts
            Rand(attTrialOrder%[0:attNContLevels%*tempNBlocks%],attNContLevels%);  'this has only the Go contrast
        endif;   

        'The below line will assign only GO trials as catch trials
        GetRepeatedParameterProgression%(attNContLevels%,tempNBlocks%,attTrial[],attCatchTrialOrder%[],0,attNContLevels%-1,0,1);
        
        
        ''Commented out - useful for testing the creation of the trial order
        'var Contrast$;
        'CreateContrastList(Contrast$,attContrastList%,attValidList%,attUpDownList%);
        'var specFileName$:="E:\\AttentionSpecFile.txt";
        'var specHandle%;
        'specHandle% := FileOpen(specFileName$, 8, 1);
        ''print to spec file
        'Print("%s",Contrast$);  'file should be everything starting from FixationArg$ on
        ''close spec file
        'FileClose(0);
        'printlog("Temp trial order list is %d\n",attTrialOrder%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("Contrast list is %d\n",attContrastList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("Valid list is %d\n",attValidList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("UpDown list is %d\n",attUpDownList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("contrasts are %d\n",attContrastList[]);
        'halt();
	endif;
	return i%;
end;


func ParseColor%(s$, &r%, &g%, &b%)
    var status% := -1;
    var n;
    ReadSetup("", "/(", "(", ")");
    n := ReadStr(s$, r%, g%, b%);
    ReadSetup();
    if n = 3 then
        status% := 0;
    endif
    return status%;
end

func EncodeColor$(r%, g%, b%)
    var s$;
    s$ := Print$("(%d/%d/%d)", r%, g%, b%);
    return s$;
end


' Called when items in attention script dialog change. WARNING: The item #s are coded as constants
' If format of dialog changes then those constants should be changed. 

func AttentionScriptDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = attdlgTrainingContrastCheck% then
        DlgEnable(DlgValue(attdlgTrainingContrastCheck%), attdlgTrainingContrastPct%);
    case item% = attdlgOnlyOneCatch% then
        DlgEnable(DlgValue(attdlgOnlyOneCatch%), attdlgOneCatchContrast%);
        DlgEnable(DlgValue(attdlgOnlyOneCatch%), attdlgDoUncatch%);
    case item% = attdlgLollipopCheck% then
        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgCircleDiameterDiff%);
        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgCueLinePct%);
        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgLollipopContrast%);
    case item% = 0 then
        DlgEnable(attOnlyOneCatch%, attdlgOneCatchContrast%);
        DlgEnable(attTrainingContrastCheck%, attdlgTrainingContrastPct%);
        DlgEnable(attLollipopCheck%, attdlgCircleDiameterDiff%);
        DlgEnable(attLollipopCheck%, attdlgCueLinePct%);
        DlgEnable(attLollipopCheck%, attdlgLollipopContrast%);
        DlgEnable(attOnlyOneCatch%, attdlgDoUncatch%);
    endcase
    return status%;
end


func TimingDialog%()
    var i%;
    
	DlgCreate("Attention timing", 25, 10);
	DlgReal(1, "Acquisition time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMinTime%, "Fixation cue min time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMaxTime%, "Fixation cue max time(s):", .01, 10);  'We will presumably lose the ability to have a variable stimulus onset time when the animation is implemented
	DlgReal(atttimingdlgHazardMinTime%, "Hazard min time(s):", 0, 10);
	DlgReal(atttimingdlgHazardExpMeanTime%, "Hazard exp mean time(s):", 0, 10);
	DlgReal(atttimingdlgHazardCutoffTime%, "Hazard cutoff time(s):", 0, 10);
	DlgReal(7, "Time to answer(s):", 0.01, 10.0);
	DlgReal(8, "Intertrial time(s):", .01, 10);
	DlgReal(9, "Abort wait time(s):", .01, 10);
    DlgReal(10, "False Alarm penalty time(s):", .01, 100);  'I'll let that be really really long
    DlgReal(11, "False Alarm check window(s): ", .01, 1);
    DlgReal(12, "Miss penalty time(s): ", 0, 100);
    
    DlgAllow(0, 0, TimingDialogChanged%);
	i%:=DlgShow(attAcquisitionTime, attFixationCueMinTime, attFixationCueMaxTime, 
    attHazardMinTime, attHazardExpMeanTime, attHazardCutoffTime, attTimeToAnswer, 
    attInterTrialTime, attAbortWaitTime,attFalseAlarmWaitTime,attFalseAlarmCheckWindow,attMissPenalty);
    if i% = 1 then
        if attAbortWaitTime < attFalseAlarmCheckWindow then
            message("False Alarm Check Window is longer than Abort Wait Time!");
            message("Reducing window to be equal to Abort Wait Time!");
            attFalseAlarmCheckWindow := attAbortWaitTime;
        endif;
    endif;
    return 1;
end


func TimingDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = atttimingdlgFixationCueMinTime% or item% = atttimingdlgFixationCueMaxTime% then
        ' max >= min
        if DlgValue(atttimingdlgFixationCueMinTime%) > DlgValue(atttimingdlgFixationCueMaxTime%) then
            status% := 0;
            Message("Fixation cue min time cannot be greater than max time!");
        endif
    case item% = atttimingdlgHazardMinTime% or item% = atttimingdlgHazardExpMeanTime% or item% = atttimingdlgHazardCutoffTime% then
        ' max >= min
        if DlgValue(atttimingdlgHazardMinTime%) > DlgValue(atttimingdlgHazardExpMeanTime%)  or DlgValue(atttimingdlgHazardExpMeanTime%) > DlgValue(atttimingdlgHazardCutoffTime%) then
            status% := 0;
            Message("Hazard min time <= Hazard mean time <= Hazard cutoff time");
        endif
    endcase
    return status%;
end


func ColorsDialog%()
	var i%;
	var bcl$[4];
	var ibcl%:=0;
	GetAttentionScriptParameters();
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
    bcl$[3] := "custom";
    if InStr(attBackgroundColor$, "(") = 1 then
        ibcl% := attdlgColorIndexCustom%;
    else
        ibcl% := 2;
        for i%:=0 to 2 do
            if attBackgroundColor$ = bcl$[i%] then
                ibcl% := i%;
            endif
        next;
    endif
    
	DlgCreate("Attention colors", 25, 10);
    DlgAllow(0, 0, ColorsDialogChanged%);
	DlgList(1, "Background color:", bcl$);
    DlgInteger(2, "Background red (0-255)", 0, 255);
    DlgInteger(3, "Background green (0-255)", 0, 255);
    DlgInteger(4, "Background blue (0-255)", 0, 255);
    DlgCheck(attcolorsdlgCustomGratingColorCheck%, "Custom grating colors");
    DlgGroup("Stimulus", 1, 6, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromRed%, "From Red (0-255)", 0, 255, 20, 7);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromGreen%, "From Green (0-255)", 0, 255, 20, 8);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromBlue%, "From Blue (0-255)", 0, 255, 20, 9);
    DlgInteger(attcolorsdlgCustomGratingColorStimToRed%, "To Red (0-255)", 0, 255, 20, 10);
    DlgInteger(attcolorsdlgCustomGratingColorStimToGreen%, "To Green (0-255)", 0, 255, 20, 11);
    DlgInteger(attcolorsdlgCustomGratingColorStimToBlue%, "To Blue (0-255)", 0, 255, 20, 12);
    DlgGroup("Distractor", 1, 13, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromRed%, "From Red (0-255)", 0, 255, 20, 14);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromGreen%, "From Green (0-255)", 0, 255, 20, 15);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromBlue%, "From Blue (0-255)", 0, 255, 20, 16);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToRed%, "To Red (0-255)", 0, 255, 20, 17);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToGreen%, "To Green (0-255)", 0, 255, 20, 18);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToBlue%, "To Blue (0-255)", 0, 255, 20, 19);
	i% := DlgShow(ibcl%, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%, 
    attCustomGratingColorCheck%, 
    attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2], 
    attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2], 
    attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2], 
    attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);
    
	' If user cancelled, reload params
	if i% = 1 then
        if ibcl% = attdlgColorIndexCustom% then
            attBackgroundColor$ := EncodeColor$(attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%);
        else
            attBackgroundColor$ := bcl$[ibcl%];
        endif
	endif
    
	return 1;
end;

func ColorsDialogChanged%(item%)
    var status% := 1;
    if item% = 0 or item% = attcolorsdlgBackgroundColor% then
        if DlgValue(attcolorsdlgBackgroundColor%) = 3 then
            DlgEnable(1, attcolorsdlgBackgroundRed%);
            DlgEnable(1, attcolorsdlgBackgroundGreen%);
            DlgEnable(1, attcolorsdlgBackgroundBlue%);
        else
            DlgEnable(0, attcolorsdlgBackgroundRed%);
            DlgEnable(0, attcolorsdlgBackgroundGreen%);
            DlgEnable(0, attcolorsdlgBackgroundBlue%);
        endif
    endif
    
    if item% = 0 or item% = attcolorsdlgCustomGratingColorCheck% then
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToBlue%);
    endif
    
    return status%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Attention script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''






' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameTriggerChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;

' tuning curves
var TuningWindow%[8];	' one for each channel. There'd better not be more than 8 channels! 
' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iFixationWindowChannel%;' channel number for fixation window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iAnswerWindowChannel1%;  'channel number for upper answer window display in xy window
var iAnswerWindowChannel2%;  'channel number for lower answer window display in XY window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Check for valid data file path
if Len(dataDataSet$) = 0 then
	Message("No data set is selected! Edit Data parameters...");
	' Might be nice to open the dialog here....
	halt;
endif



' run parameters script....
GetAttentionScriptParameters();
iScript% := AttentionScriptDialog%();
if iScript% = 1 then
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    'SampleAutoName$(dataCellName$ + "_atn_000");
    'SampleAutoFile(1);
else
	PrintLog("User cancel - exit gracefully\n");
	Halt;
endif;





' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 21;
YChannel% := 22;
FrameTriggerChannel% := 23;
FixationPointChannel% := 24;
StimChannel% := 25;
StimChangeChannel% := 26;
ReadyChannel% := 27;
CreateSampleConfiguration();


' Initialize extraction
'AttentionExtractInit%(-1, "");

' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' UpdateToolbarText - Print tallies of trials in toolbar
'

proc UpdateToolbarText()
    
	var s$;
	var allpct$ := "--";
	var towpct$ := "--";
    var awapct$ := "--";
    var num, den, pct;
    
    if (attCountAllTrials% > 0) then
        num := attCountAllTrialsCorrect%;
        den := attCountAllTrials%;
        pct := num/den*100;
		allpct$ := print$("%2.0f", pct);
	endif
	if (attCountTowardTrials% > 0) then
        num := attCountTowardTrialsCorrect%;
        den := attCountTowardTrials%;
        pct := num/den*100;
		towpct$ := print$("%2.0f", pct);
	endif
	if (attCountAwayTrials% > 0) then
        num := attCountAwayTrialsCorrect%;
        den := attCountAwayTrials%;
        pct := num/den*100;
		awapct$ := print$("%2.0f", pct);
	endif
	s$ := Print$("Tallies count/correct/incorrect/aborted (correct%%): ALL %d/%d/%d/%d (%s%%) TOWARD %d/%d/%d/%d (%s%%) AWAY %d/%d/%d/%d (%s%%)", 
    attCountAllTrials%, attCountAllTrialsCorrect%, attCountAllTrialsIncorrect%, attCountAllTrialsAbort%, allpct$,
    attCountTowardTrials%, attCountTowardTrialsCorrect%, attCountTowardTrialsIncorrect%, attCountTowardTrialsAbort%, towpct$,
    attCountAwayTrials%, attCountAwayTrialsCorrect%, attCountAwayTrialsIncorrect%, attCountAwayTrialsAbort%, awapct$);
    
	ToolbarText(s$);
    
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	UpdateToolbarText();
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    '	ToolbarSet(6,"Exp Parameters",%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);
    
end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Answer%(EyePosX, EyePosY)
    var ans% := 0;
    var ansptRadius;
    ansptRadius := Pow(attAnswerPointWindowRadius,2);
    docase
    case attAnsWindowIsGrating% = 1 then
        'Top response location
        if (Pow(EyePosX-upX,2) + Pow(EyePosY-(upY),2)) <= Pow(upW/2,2) then ans% := 1; endif  'just assuming upW = upH!
        'Bottom response location
        if (Pow(EyePosX-downX,2) + Pow(EyePosY-(downY),2)) <= Pow(downW/2,2) then ans% := -1; endif  'just assuming downW = downH!
    else
        'Top response location
        if (Pow(EyePosX-upX,2) + Pow(EyePosY-(upY),2)) <= ansptRadius then ans% := 1; endif
        'Bottom response location
        if (Pow(EyePosX-downX,2) + Pow(EyePosY-(downY),2)) <= ansptRadius then ans% := -1; endif
    endcase
    
    'old
	'if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-(FixationY+attAnswerPointOffset),2)) <= ansptRadius then ans% := 1; endif
	'if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-(FixationY-attAnswerPointOffset),2)) <= ansptRadius then ans% := -1; endif

	return ans%;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
    DefaultReward();
    'No sample text, just use 'R' from keyboard channel
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 

' Constants for states
const stateStartTrial%:=0;		        ' Start trial state
const stateWaitForFixPtOn%:=1;		    ' Waiting for fixation/cue point return trigger (on)
const stateHoldFixationToStimOn%:=2;		    ' Maintaining fixation with cue color point and lollipops up
const stateWaitForStimOn%:=3;		    ' Wait for stimulus return trigger (on)
const stateWaitForContrastChange%:=4;	' Wait for indication that contrast change has happened
const stateWaitForAcquisition%:=5;	    ' Waiting for subject to acquire fixation point
const stateHoldFixationToCC%:=6;		    ' Holding fixation point
const stateAbort%:=7;			        ' Failed trial state
const stateWaitForAnswer%:=8;			' waiting for answer
const stateAbortWait%:=9;	            ' time out after failed trial
const stateVSGWait%:=10;		        ' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		    ' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		    ' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForBlank%:=14;
const stateBlockCompleted%:=16;
const stateStartBlock%:=17;
const stateTrialCompletedWaitForBlank% := 18;
const stateTrialCompletedPause% := 19;
const stateWaitForWhitePointOn%:=20;    ' Waiting for fixation white point  This white point stuff is mostly or wholly excised
const stateWhitePointFixation%:=21;     ' white point up, remain fixation
const stateNoResponse% := 22;
const stateFalseAlarmWait% := 23;
const stateCheckFalseAlarm% := 24;
const stateMiss% := 25;
const stateCorrectRejection% := 26;
var iState% := stateVSGWait%;	' present state

const trialtypeAttendToward% := 100;
const trialtypeAttendAway% := 101;
var trialType%;
var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 
var nBlocksCompleted%:=0;
var iAnswer%;
var isStimDistractorOff% := 0;
var trialCatch%;
var trialContrastUpDown%;
var trialHazardFunctionTime;

func IdleProcessing%()
    'var getPreciseTiming := 1;
	var iStatus% := 1;	
    
    'while getPreciseTiming = 1 do 
    
    'getPreciseTiming := 0;  'don't get precise timing unless we ask to (if 0, return control to windows after each idle loop iteration)
    
    tNow := MaxTime();
    
    xEye := ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
    yEye := ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;
    
    ' Don't update display every time....
    if tNow-tLastUpdate > .005 then
        View(XYWindow%).XYAddData(1,xEye,yEye);
        tLastUpdate := tNow;
    endif
    
    
    docase 
    case iState% = stateVSGWait% then
        
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        tTrigger := NextTime(ReadyChannel%, tLast, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 0 then
            PrintLog("state stateVSGWait: Got leading edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateVSGWaitConfirm%, tTrigger);
        endif;
        
    case iState% = stateVSGWaitConfirm% then
        
        ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
        tTrigger := NextTime(ReadyChannel%, tLastTrigger, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 1 then
            PrintLog("state stateVSGWaitConfirm: Got trailing edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateStartBlock%, tTrigger);
        endif;
        
        
    case iState% = stateStartBlock% then
        
        PrepareBlock();
        ChangeStateTo(stateStartTrial%, tNow);
        
    case iState% = stateStartTrial% then
        
        ' Start trial. Put up fixation point.
        UpdateToolbarText();
        PrepareTrial();
        attCountAllTrials% += 1;
        'SafeSampleKey("W");
        docase
        case trialType% = trialtypeAttendToward% then
            'PrintLog("stateWhitePointFixation: Request cue F - AttendToward\n");
            PrintLog("Request cue F - AttendToward\n");
            SafeSampleKey("F");
            attCountTowardTrials% += 1;
        case trialType% = trialtypeAttendAway% then
            'PrintLog("stateWhitePointFixation: Request cue G - AttendAway\n");
            PrintLog("Request cue G - AttendAway\n");
            SafeSampleKey("G");
            attCountAwayTrials% += 1;
        else
            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
        endcase
        ChangeStateTo(stateWaitForFixPtOn%, tNow);
        
        
    case iState% = stateWaitForFixPtOn% then
        tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        if tTrigger > tLast then
            ' Fixation point is up
            PrintLog("stateWaitForFixPtOn: signal received. " + str$(tTrigger) + "\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateWaitForAcquisition%, tTrigger);
            if trialType% = trialtypeAttendToward% then
                SampleText("Fixation point on, Attend Toward",tTrigger);
            else
                SampleText("Fixation point on, Attend Away",tTrigger);
            endif;
            DrawStim(1);	' actually this draws the location of the fixpt.
        endif
        
        
    case iState% = stateWaitForAcquisition% then
        'getPreciseTiming := 1;
        ' Waiting for eye to fall inside of fixation window
        if Looking%(xEye, yEye) = 1 then
            PrintLog("stateWaitForAcquisition: eye in fixation window.\n");
            'ChangeStateTo(stateWhitePointFixation%, tNow);
            ChangeStateTo(stateHoldFixationToStimOn%, tNow);
            SampleText("Fixation Acquired",tNow);
            'getPreciseTiming := 0;
        else 
            if tNow - tStateStart > attAcquisitionTime then  'simple abort on failure to acquire
                PrintLog("stateWaitForAcquisition: failed.\n");
                ChangeStateTo(stateAbort%, tNow);
                'getPreciseTiming := 0;
            endif
        endif
        
        
    case iState% = stateHoldFixationToStimOn% then
        
        ' Eye must remain inside of fixation window
        docase
        case Looking%(xEye, yEye) = 1 then
            if tNow - tStateStart > attFixationTime then
                PrintLog("stateHoldFixationToStimOn: Success. Gratings up...\n");
                SafeSampleKey("S");
                ChangeStateTo(stateWaitForStimOn%, tNow);
            endif
        else 'go back to waiting for acquisition
            changeStateTo(stateWaitForAcquisition%, tNow);
        endcase
        
    case iState% = stateWaitForStimOn% then
        tTrigger := NextTime(StimChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        if tTrigger > tLast and vTrigger = 0 then
            ' gratings et al are up
            PrintLog("stateWaitForStimOn: stim is up.\n");
            tStimOn := tTrigger;
            tLastTrigger := tTrigger;
            ChangeStateTo(stateHoldFixationToCC%, tTrigger);
            SampleText("Stimulus on, Base contrast " + Str$(attContrastBase%) + ", hazard dur " + Str$(trialHazardFunctionTime),tTrigger);
        endif
        
        
    case iState% = stateAbort% then
        
        ' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
        ' fixpt off. 
        PrintLog("stateAbort: send X key.\n");
        SafeSampleKey("X");
        
        view(XYWindow%).XYColour(iAnswerWindowChannel1%,13);  'Force up answer window to blue
        view(XYWindow%).XYColour(iAnswerWindowChannel2%,13);  'Force down answer window to blue
        view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Force fixation window to blue
        
        ' tally up aborted trials, right now not distinguishing between response aborts and regular aborts
        attCountAllTrialsAbort% += 1;
        docase
        case trialType% = trialtypeAttendToward% then
            attCountTowardTrialsAbort% += 1;
        case trialType% = trialtypeAttendAway% then
            attCountAwayTrialsAbort% += 1;
        else 
            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
        endcase
        
        ' move on
        'ChangeStateTo(stateWaitForBlank%, tNow);
        ChangeStateTo(stateWaitForBlank%, tStateStart);  'don't update time, carry forward
        
    case iState% = stateWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        'if tTrigger > tLast and vTrigger = 1 then
        if tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            if FAIsResponse% = 1 then
                FAIsResponse% := 0;
                ChangeStateTo(stateFalseAlarmWait%, tTrigger);
                'advance on false alarm
                SafeSampleKey("a");  'this is the only place to get into stateFalseAlarmWait, so advance here is fine
            else                
                'ChangeStateTo(stateAbortWait%, tTrigger);
                ChangeStateTo(stateAbortWait%, tStateStart);  'don't update time, "credits" for time served
            endif;
            DrawStim(0);	' actually this draws the location of the fixpt.
        endif
        
    case iState% = stateAbortWait% then
        
        if tNow - tStateStart > attAbortWaitTime then
            PrintLog("stateAbortWait: time out is done.\n");
            ChangeStateTo(stateStartTrial%, tNow);
        endif
        
       
        
    case iState% = stateCheckFalseAlarm% then
        
        if tNow - tStateStart < attFalseAlarmCheckWindow then
            docase
            case Answer% (xEye, yEye) = 1 then 'answer in "attend toward" = "up" window
                PrintLog("stateCheckFalseAlarm: in attend toward response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText("Fixation broken, False Alarm in attend toward window, trial aborted");
            case Answer% (xEye, yEye) = -1 then 'answer in "attend away" = "down" window
                PrintLog("stateCheckFalseAlarm: in attend away response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText("Fixation broken, False Alarm in attend away window, trial aborted");    
            endcase;
        else 'credit the animal for time served on the abort if it's not a response
            PrintLog("stateCheckFalseAlarm: no response in window, aborting trial.\n");
            ChangeStateTo(stateAbort%, tNow-attFalseAlarmCheckWindow); 
            SampleText("Fixation broken, no response, trial aborted");
        endif;
        
         
    case iState% = stateFalseAlarmWait% then
        
        if tNow - tStateStart > attFalseAlarmWaitTime then
            PrintLog("stateFalseAlarmWait: time out is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
        endif        
        
        
    case iState% = stateHoldFixationToCC% then
        
        docase            
        case Looking%(xEye, yEye) = 0 then  'begin abort procedure, check to see if it's a FA
            docase
            case Answer% (xEye, yEye) = 1 then 'answer in "attend toward" = "up" window
                PrintLog("stateHoldFixationToCC: in attend toward response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText("Fixation broken, False Alarm in attend toward window, trial aborted");
            case Answer% (xEye, yEye) = -1 then 'answer in "attend away" = "down" window
                PrintLog("stateHoldFixationToCC: in attend away response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText("Fixation broken, False Alarm in attend away window, trial aborted");        
            'if Answer%(xEye, yEye) <> 0 then  'if it's in response window, quit while you're ahead
            '    PrintLog("stateHoldFixationToCC: in response window, aborting trial.\n");
            '    FAIsResponse% := 1;
            '    ChangeStateTo(stateAbort%,tNow);
            '    SampleText("Fixation broken, False Alarm, trial aborted");
            else  'keep checking
                ChangeStateTo(stateCheckFalseAlarm%, tNow);
            endcase;
            
        else 
            if (tNow - tStateStart) > (trialHazardFunctionTime) then
                ' turn off stimulus and advance it
                PrintLog("stateHoldFixationToCC: request contrast change\n");
                docase
                case trialType% = trialtypeAttendToward% then
                    if trialContrastUpDown% > 0 then
                        if trialCatch% = 0 then
                            SafeSampleKey("C");
                        else
                            SafeSampleKey("D");
                        endif
                    else
                        if trialCatch% = 0 then
                            SafeSampleKey("c");
                        else
                            SafeSampleKey("d");
                        endif
                    endif
                case trialType% = trialtypeAttendAway% then
                    if trialContrastUpDown% > 0 then
                        if trialCatch% = 0 then
                            SafeSampleKey("D");
                        else
                            SafeSampleKey("C");
                        endif
                    else
                        if trialCatch% = 0 then
                            SafeSampleKey("d");
                        else
                            SafeSampleKey("c");
                        endif
                    endif
                else
                    PrintLog("ERROR! Unknown blocktype!!!\n");
                endcase;
                
                ' Now wait until contrast change trigger is received
                ChangeStateTo(stateWaitForContrastChange%, tNow);
                
            endif
            
        endcase
        
    case iState% = stateWaitForContrastChange% then
        tTrigger := NextTime(StimChangeChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        docase
        case tTrigger > tLast and vTrigger = 0 then
            PrintLog("stateWaitForContrastChange: got it.\n");
            tLastTrigger := tTrigger;
            isStimDistractorOff% := 0;
            ChangeStateTo(stateWaitForAnswer%, tNow);
            docase
            case trialType% = trialtypeAttendToward% then
                if trialContrastUpDown% > 0 then
                    if trialCatch% = 0 then
                        view(XYWindow%).XYColour(iAnswerWindowChannel1%,16);  'Change up answer window to red
                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Toward",tTrigger);
                    else
                        view(XYWindow%).XYColour(iAnswerWindowChannel2%,16);  'Change down answer window to red
                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Toward (catch)",tTrigger);
                    endif
                else
                    view(XYWindow%).XYColour(iFixationWindowChannel%,16);  'Change fixation window to red
                    Sampletext("No Contrast Change",tTrigger);
                endif
            case trialType% = trialtypeAttendAway% then
                if trialContrastUpDown% > 0 then
                    if trialCatch% = 0 then
                        view(XYWindow%).XYColour(iAnswerWindowChannel2%,16);  'Change down answer window to red
                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Away",tTrigger);
                    else
                        view(XYWindow%).XYColour(iAnswerWindowChannel1%,16);  'Change up answer window to red
                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Away (catch)",tTrigger);
                    endif
                else
                    view(XYWindow%).XYColour(iFixationWindowChannel%,16);  'Change fixation window to red
                    Sampletext("No Contrast Change",tTrigger);
                endif
            else
                PrintLog("ERROR! Unknown blocktype!!!\n");
            endcase;
            
        case Looking%(xEye, yEye) = 0 then  'begin abort procedure, check to see if it is a FA
            docase
            case Answer% (xEye, yEye) = 1 then 'answer in "attend toward" = "up" window
                PrintLog("stateWaitForContrastChange: in attend toward response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText("Fixation broken, False Alarm in attend toward window, trial aborted");
            case Answer% (xEye, yEye) = -1 then 'answer in "attend away" = "down" window
                PrintLog("stateWaitForContrastChange: in attend away response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText("Fixation broken, False Alarm in attend away window, trial aborted");        
            'if Answer%(xEye, yEye) <> 0 then  'if it's in response window, quit while you're ahead
            '    PrintLog("stateHoldFixationToCC: in response window, aborting trial.\n");
            '    FAIsResponse% := 1;
            '    ChangeStateTo(stateAbort%,tNow);
            '    SampleText("Fixation broken, False Alarm, trial aborted");
            else  'keep checking
                ChangeStateTo(stateCheckFalseAlarm%, tNow);
            endcase;
            
        endcase;
        
    case iState% = stateWaitForAnswer% then
        'getPreciseTiming := 1;  'we need precise timing here, stay in while loop until we get eye movements we expect
        if tNow - tStateStart > attTimeToAnswer then  'no response in answer window
            if trialContrastUpDown% > 0 then 'GO trial, expected response
                SafeSampleKey("X");  'turn off animation
                PrintLog("stateWaitForAnswer: no response on go trial, miss\n");
                if trialType% = trialtypeAttendToward% then
                    SampleText("Miss, Attend Toward",tNow);
                else
                    SampleText("Miss, Attend Away",tNow);
                endif;
                ChangeStateTo(stateMiss%, tNow); 'go to miss penalty
                SafeSampleKey("a");
            else  'NO-GO trial, this is correct rejection
                SafeSampleKey("X");  'turn off animation
                PrintLog("stateWaitForAnswer: no response on no-go trial, correct rejection\n");
                if trialType% = trialtypeAttendToward% then
                    SampleText("Correct Rejection, Attend Toward",tNow);
                else
                    SampleText("Correct Rejection, Attend Away",tNow);
                endif;
                Reward%();
                ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
            endif;
        else  'we are still in the response window
            ' When fixation is first broken we turn off the stim and distractor. 
            ' That test is done separately from the test for an answer. Also set up 
            ' a var to tell us whether the stim has been turned off. 
            'Get rid of this so that stimulus stays on until time to answer is over
            'if isStimDistractorOff% = 0 then
            '    if Looking%(xEye, yEye) = 0 then
            '        SafeSampleKey("s");
            '        SampleText("Fixation broken during response window",tNow);
            '        PrintLog("stateWaitForAnswer: fix broken - turn off stim\n");
            '        isStimDistractorOff% := 1;
            '    endif
            'endif
            
            if Looking%(xEye, yEye) = 0 then
                iAnswer% := Answer%(xEye, yEye);
                if iAnswer% = 1 or iAnswer% = -1 then
                    ' Got an answer. Record marker for correct/incorrect answer
                    docase
                    case iAnswer% = expectedAnswer% then
                    'if trialContrastUpDown% = 1 then 'it's a GO trial
                        ' Hit                    
                        attCountAllTrialsCorrect% += 1;
                        attInterTrialTime2 := attInterTrialTime;
                        'SampleText("+");
                        docase
                        case trialType% = trialtypeAttendToward% and trialContrastUpDown% = 1 then
                            attCountTowardTrialsCorrect% += 1;
                            SampleText("Hit, Attend Toward, Contrast Up",tNow);
                        case trialType% = trialtypeAttendAway% and trialContrastUpDown% = 1 then
                            attCountAwayTrialsCorrect% += 1;
                            SampleText("Hit, Attend Away, Contrast Up",tNow);
                        else
                            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                        endcase
                        'getPreciseTiming := 0;
                        Reward%();
                        ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
                        SafeSampleKey("X");
                    case iAnswer% = -expectedAnswer% then
                    'if trialContrastUpDown% = 1 then 'it's a GO trial
                        ' Saccade to wrong grating                    
                        attCountAllTrialsIncorrect% += 1;
                        attInterTrialTime2 := attInterTrialTime + attMissPenalty;
                        'SampleText("+");
                        docase
                        case trialType% = trialtypeAttendToward% and trialContrastUpDown% = 1 then
                            attCountTowardTrialsIncorrect% += 1;
                            SampleText("Miss, Attend Toward, Moved To Wrong Grating, Contrast Up",tNow);
                        case trialType% = trialtypeAttendAway% and trialContrastUpDown% = 1 then
                            attCountAwayTrialsIncorrect% += 1;
                            SampleText("Miss, Attend Away, Moved To Wrong Grating, Contrast Up",tNow);
                        else
                            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                        endcase
                        'getPreciseTiming := 0;
                        ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
                        SafeSampleKey("X");
                    else  'it's a NO-GO trial, and we got an answer
                        'SampleText("-");
                        attCountAllTrialsIncorrect% += 1;
                        attInterTrialTime2 := attInterTrialTime + attMissPenalty;
                        docase
                        case trialType% = trialtypeAttendToward% and trialContrastUpDown% = 1 then
                            attCountTowardTrialsIncorrect% += 1;
                            SampleText("False Alarm, Attend Toward",tNow);
                        case trialType% = trialtypeAttendAway% and trialContrastUpDown% = 1 then
                            attCountAwayTrialsIncorrect% += 1;
                            SampleText("False Alarm, Attend Away",tNow);
                        else
                            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                        endcase
                        'getPreciseTiming := 0;
                        Yield(.01);    ' necessary so that the SampleText and SafeSampleKey below don't land on the same time (makes extraction difficult)
                        FAIsResponse% := 1;
                        ChangeStateTo(stateAbort%,tNow);
                        'SafeSampleKey("X");  'this is done in stateAbort%
                    endcase
                else  'not looking, but no answer
                    if trialContrastUpDown% < 0 then 'NO-GO trial, out of fixation window before end of response window is abort/FA
                        ChangeStateTo(stateCheckFalseAlarm%, tNow);  'either a false alarm or an abort, decide based on attFalseAlarmCheckWindow
                    endif
                    'if it's a GO trial, eye may not have reached answer window yet, just check for an answer next time around the idle loop
                endif
            endif
        endif
        
    case iState% = stateTrialCompletedWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        'if tTrigger > tLast and vTrigger = 1 then
        if tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateTrialCompleteWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            'advance
            SafeSampleKey("a");
            ChangeStateTo(stateTrialCompletedPause%, tTrigger);
            DrawStim(0);	' actually this draws the location of the fixpt.
        endif
        
'    case iState% = stateNoResponse% then
'        
'        ' we just wait for fix point off signal in this case. 
'        tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
'        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
'        'if tTrigger > tLast and vTrigger = 1 then
'        if tTrigger > tLast then
'            ' Fixation point is off
'            PrintLog("stateTrialNoResponse: Fix pt is off.\n");
'            tLastTrigger := tTrigger;
'            'advance
'            'SafeSampleKey("a");  'maybe don't advance
'            ChangeStateTo(stateTrialCompletedPause%, tTrigger);
'            DrawStim(0);	' actually this draws the location of the fixpt.
'        endif        
        
    case iState% = stateTrialCompletedPause% then
        
        if tNow - tStateStart > attInterTrialTime2 then
            
            PrintLog("stateTrialCompletedPause: inter-trial time is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
            
        endif
        
    case iState% = stateMiss% then
        
        if tNow - tStateStart > attMissPenalty then
            
            PrintLog("stateMiss: penalty time is done.\n");
            ChangeStateTo(stateTrialCompletedPause%, tNow);  'can't look for trigger in this case
            
        endif
        
        
    case iState% = stateTrialCompleted% then
        view(XYWindow%).XYColour(iAnswerWindowChannel1%,13);  'Force up answer window to blue
        view(XYWindow%).XYColour(iAnswerWindowChannel2%,13);  'Force down answer window to blue
        view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Force fixation window to blue
        PrintLog("Trial completed.\n");
        nTrialsCompleted% += 1;
        attCurrTrialIndex% += 1;
        if nTrialsCompleted% = attTrialsPerBlock%+attEasyTrialsPerBlock% then
            ChangeStateTo(stateBlockCompleted%, tNow);
        else
            ChangeStateTo(stateStartTrial%, tNow);
        endif
        
    case iState% = stateBlockCompleted% then
        
        PrintLog("Block completed.\n");
        nBlocksCompleted% := nBlocksCompleted% + 1;
        if nBlocksCompleted% = attNumberOfBlocks% then
            ChangeStateTo(stateDone%, tNow);
            Stop%();
            iStatus% := 0;
        else
            ChangeStateTo(stateStartBlock%, tNow);
        endif
        
    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;
        
    endcase;
    
    tLast := tNow;
    'wend;
    
	return iStatus%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareTrial()
    
	PrintLog("Prepare trial: ");
    
	if attBlockAlternate% = 0 then
		if (Rand(0.0) < 0.5) then
			trialType% := trialtypeAttendToward%;
			PrintLog("Trial type: attend-toward\n");
		else
			trialType% := trialtypeAttendAway%;
			PrintLog("Trial type: attend-away\n");
		endif
	else
		if trialType% = trialtypeAttendToward% then
			PrintLog("Trial type: attend-toward (for this entire block)\n");
		else
			PrintLog("Trial type: attend-away (for this entire block)\n");
		endif
	endif
    
    ' Fixation time is a random number between attFixationMinTime and attFixationMaxTime. 
    ' Notedy-note: the ability to assign this as a variable number is expected to go bye-bye when the animation is implemented
    attFixationTime := Rand(attFixationCueMaxTime - attFixationCueMinTime, attFixationCueMinTime);
    PrintLog("Fixation time " + str$(attFixationTime) + "\n");
	
    if nTrialsCompleted% < attEasyTrialsPerBlock% then  'it's an "easy" trial, give minimum hazard time
        
        'Set hazard time to minimum on "easy" trials
        trialHazardFunctionTime := attHazardMinTime;
        
    else  'do a regular trial, get random hazard time

        ' hazard function - compute time from fixation to contrast change. Make sure hazard time is not greater than cutoff time.
        trialHazardFunctionTime := RandExp(attHazardExpMeanTime, attHazardMinTime);
        if trialHazardFunctionTime > attHazardCutoffTime then
            trialHazardFunctionTime := attHazardCutoffTime;
        endif

    endif;
    
    'Determine if trial is catch trial
    trialCatch% := 1-attValidList%[attCurrTrialIndex%];
    if trialCatch% = 1 then
        PrintLog("CATCH\n");
    endif;
    
    'Determine if contrast is up or down
    trialContrastUpDown% := attUpDownList%[attCurrTrialIndex%];
    
    'Record actual contrast level on this trial
    thisContrast% := attContrastList%[attCurrTrialIndex%];
    
    'Calculate expected answer
    docase
    case trialType% = trialtypeAttendToward% then
        if trialContrastUpDown% > 0 then
            if trialCatch% = 0 then
                expectedAnswer% := 1;
            else
                expectedAnswer% := -1;
            endif
        else
            expectedAnswer% := 0;
        endif
    case trialType% = trialtypeAttendAway% then
        if trialContrastUpDown% > 0 then
            if trialCatch% = 0 then
                expectedAnswer% := -1;
            else
                expectedAnswer% := 1;
            endif
        else
            expectedAnswer% := 0;
        endif
    else
        PrintLog("ERROR! Unknown blocktype!!!\n");
    endcase;
    
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareBlock()
	PrintLog("Preparing block: ");
	' when blocksCompleted% is even, this is attend-toward
	' Modified: The above is done only when attBlockAlternate% is non zero. Otherwise its random trial-by-trial 
	' cue type. 
	if attBlockAlternate% <>0 then
		if ((nBlocksCompleted%+randBlockOrderVar%) mod 2) = 0 then
			trialType% := trialtypeAttendToward%;
			PrintLog("Attend-toward ");
		else
			trialType% := trialtypeAttendAway%;
			PrintLog("Attend-away ");
		endif
	else
		PrintLog("Attend-toward/away done on a trial-by-trial basis.");
	endif
	PrintLog("\n");
    'reset block-specific variables
	ntrialsCompleted% := 0;
	nTrialsStarted% := 0;
	nTrialsAborted% :=0;		' 
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
    Pause% :=1;
    ToolbarEnable(4,0);
    ToolbarEnable(5,1);
    return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
    Pause% :=0;
    ToolbarEnable(4,1);
    ToolbarEnable(5,0);
    return 1;
end





proc InitializeWindows()
    
	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(0,48,100,95);
	View(DataWindow%).WindowVisible(1);
    
	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
    
	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;
    
	'Create a new channel in the XY view to display the fixation window
	iFixationWindowChannel% := XYSetChan(0);
	XYColour(iFixationWindowChannel%,13);
	XYDrawMode(iFixationWindowChannel%,2,1);
	XYJoin(iFixationWindowChannel%,1);
	'Draw the fixation window
	XYAddData(iFixationWindowChannel%, FixWindowX[], FixWindowY[]);
        
    
    'get locations of stimuli so that answer windows overlap them
    ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"),upX,upY,upW,upH); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor1"),downX,downY,downW,downH);  
    
    'Create new channels in the XY view to display the answer windows
    'reuse FixationX, FixationY
    'First window
    for index% := 0 to 35 do
        'FixWindowX[index%] := FixationX + attAnswerPointWindowRadius * Cos(index% * twopi/36.0);
		'FixWindowY[index%] := FixationY + attAnswerPointOffset + attAnswerPointWindowRadius * Sin(index% * twopi/36.0);
        docase
        case attAnsWindowIsGrating% = 1 then
            FixWindowX[index%] := upX + (upW/2) * Cos(index% * twopi/36.0);
            FixWindowY[index%] := upY + (upH/2) * Sin(index% * twopi/36.0);
        else
            FixWindowX[index%] := upX + attAnswerPointWindowRadius * Cos(index% * twopi/36.0);
            FixWindowY[index%] := upY + attAnswerPointWindowRadius * Sin(index% * twopi/36.0);
        endcase
	next;
    iAnswerWindowChannel1% := XYSetChan(0);
    XYColour(iAnswerWindowChannel1%,13);
	XYDrawMode(iAnswerWindowChannel1%,2,1);
	XYJoin(iAnswerWindowChannel1%,1);
	'Draw the answer window
	XYAddData(iAnswerWindowChannel1%, FixWindowX[], FixWindowY[]);
    

'    'Second window
    for index% := 0 to 35 do
        docase
        case attAnsWindowIsGrating% = 1 then
            FixWindowX[index%] := downX + (downW/2) * Cos(index% * twopi/36.0);
            FixWindowY[index%] := downY + (downH/2) * Sin(index% * twopi/36.0);
        else    
            FixWindowX[index%] := downX + attAnswerPointWindowRadius * Cos(index% * twopi/36.0);
            FixWindowY[index%] := downY + attAnswerPointWindowRadius * Sin(index% * twopi/36.0);
        endcase
		'FixWindowY[index%] := FixationY - attAnswerPointOffset + attAnswerPointWindowRadius * Sin(index% * twopi/36.0);
	next;
    iAnswerWindowChannel2% := XYSetChan(0);
    XYColour(iAnswerWindowChannel2%,13);
	XYDrawMode(iAnswerWindowChannel2%,2,1);
	XYJoin(iAnswerWindowChannel2%,1);
	'Draw the answer window
	XYAddData(iAnswerWindowChannel2%, FixWindowX[], FixWindowY[]);
    
	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);
    
	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%,13);
	XYDrawMode(iMonitorChannel%,3,1);
	XYJoin(iMonitorChannel%,2);
	XYAddData(iMonitorChannel%,-9,-7);
	XYAddData(iMonitorChannel%,9,-7);
	XYAddData(iMonitorChannel%,9,7);
	XYAddData(iMonitorChannel%,-9,7);
    
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
    SampleClear(); 'Set standard sampling state
    '	SampleAutoFile(0); 'Enable automatic file naming
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    SampleAutoName$(dataCellName$ + "_atn_000");
    SampleAutoFile(1);
    
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
	'Channel recording definitions
	SampleEvent(FrameTriggerChannel%,0,2,3600); 'Trigger channel, level
	SampleComment$(FrameTriggerChannel%,"Frame");
	SampleTitle$(FrameTriggerChannel%,"Frame");
    
 	SampleEvent(FixationPointChannel%,1,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixation");
	SampleTitle$(FixationPointChannel%,"Fixation");
	
	SampleEvent(StimChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
	
	SampleEvent(StimChangeChannel%,4,2,3600); 'Trigger channel, level
	SampleComment$(StimChangeChannel%,"Stim Chg.");
	SampleTitle$(StimChangeChannel%,"Stim Chg.");
	
	SampleEvent(ReadyChannel%,6,2,3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
    ' Set up channels for sampling electrodes.
    CreateElectrodeSamplingConfiguration(1, 11);
	
	SampleWaveform(XChannel%,14,1000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%,15,1000);
	SampleTitle$(YChannel%,"Eye Y");
    
	SampleWaveform(NumberOfElectrodes%+10, 6, 1000);
	SampleTitle$(NumberOfElectrodes%+10, "PD");
    
	SampleTextMark(200);  'increase number of allowed characters, 1 is so stingy!
    
	SampleSequencer(script$ + "Attention.pls");
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;



' Get grating p[arameters from registry AlertRig\\(config)\\Gratings\\type$
func GetGratingParameters$(type$)
	var key$;
	var stmp$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\Gratings";
	Profile(key$, type$, "", stmp$);
	return stmp$;
end;

' Replace the color vector spec in a grating with the specified value
func ReplaceGratingColorVector$(gspec$, cvspec$)
    var s$;
    var i1%, i2%;
    var index%:=0;
    var i%;
    ' i1% and i2% are the index positions of the 8th and 9th commas
    PrintLog(gspec$ + "\n");
    for i% := 1 to 7 do
        index% := InStr(gspec$, ",", index%+1);
        PrintLog("%d index %d\n", i%, index%);
    next;
    i1% := InStr(gspec$, ",", index%+1);
    i2% := InStr(gspec$, ",", i1%+1);
    s$ := Mid$(gspec$, 1, i1%) + cvspec$ + Mid$(gspec$, i2%);
    PrintLog(s$ + "\n");
    return s$;
end


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, mylen%;
    var fn$;
    var chanToExport%[30];
    
	' Disable idle process func
	ToolbarSet(0,"");
    
	' Tell stim app to shut down
	SafeSampleKey("q");
	Yield(.1);
	SampleStop();
    
	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend
    
    View(DataWindow%);
    ExportChanList(); 
    chanToExport%[1] := 30;  'channels to export go in elements 1:...'30 is the textmark channel
    chanToExport%[2] := 31;  '31 is the keyboard channel
    for i% := 0 to NumWavemarkPorts% do
        chanToExport%[i%+3] := i%+1;  'wavemark channels are in order
    next;
    chanToExport%[0] := 2+i%;  'total number of channels goes in element 0
    ExportChanList(0,view(datawindow%).maxtime(),chanToExport%[]);
    
    'Code for putting other various channels into the Matlab extraction, Ben doesn't want them but they will be useful for other code    
    '    ExportChanList(0,maxtime(),XChannel%);  'Eye position channel, X
    '    ExportChanList(0,maxtime(),YChannel%);  'Eye position channel, Y
    'for i% := 0 to NumWavemarkPorts%-1 do
    '    ExportChanList(0,maxtime(),i%+1);  'Wavemark channel(s)
    'next;
    
    
    fn$ := FileName$();  'get current file name
    mylen% := Len(fn$);
    fn$ := Left$(fn$,mylen%-4);
    fn$ := fn$ + ".mat";
    FileSaveAs(fn$,100,0,"",0,"UseSName=0"); 'Do not overwrite the .mat file - should have a different name and if it doesn't that is a red flag    
    
    WriteParameterFile();
    
    ' update statistics
    'AttentionExtract%(-1, -1);
    
	'ProgRun(bin$ + "\\ClearTrigger",0);
    
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
	var Extras$;
	var Tune$;
	var Stim$:="";
	'var Contrast$;
    var ttemp;
    var stimSpec$;
    var distSpec$;
    var lolSpec$;
    var x;
    var i%;
    var specFileName$:="F:\\work\\AttentionSpecFile.txt";
    var specHandle%;
	
	SampleStart(0); 'Start sampling
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    ttemp := View(DataWindow%).MaxTime();
    Yield();
    tLast := View(DataWindow%).MaxTime();
    PrintLog("ttemp " + str$(ttemp) + " tlast " + str$(tLast) + "\n");
    
    stimSpec$ := GetGratingParameters$("Stimulus");
    distSpec$ := GetGratingParameters$("Distractor1");
    if attCustomGratingColorCheck% = 1 then
        var f$, t$;
        f$ := EncodeColor$(attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2]);
        stimSpec$ := ReplaceGratingColorVector$(stimSpec$, f$ + "-" + t$);
        f$ := EncodeColor$(attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);
        distSpec$ := ReplaceGratingColorVector$(distSpec$, f$ + "-" + t$);
    endif
    if attLollipopCheck% = 1 then
        lolSpec$ := " -L -c " + str$(attCircleDiameterDiff) + " -p " + str$(attLollipopContrast%) + " -l " + str$(attCueLinePct/100) + " -G " + str$(attCueLineGap) + " -P " + str$(attLollipopStickContrast%);
    else
        lolSpec$ := "";
    endif
    
	Stim$ := " -g " + distSpec$ + " -s " + stimSpec$;  
	'Contrast$ := " -t " + str$(round(attContrastBase%/pow(2,attMinContChange))) + "," + str$(attContrastBase%) + "," + str$(round(attContrastBase%*pow(2,attMaxContChange)));  'this will change once tuning curves are in, at least a bit
	CreateContrastList(Contrast$,attContrastList%,attValidList%,attUpDownList%);  'Fills Contrast$ with the big ol' list, plus some vars to make it easier on us all 
    'Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$() + " -A " + str$(attAnswerPointOffset) + " -D " + str$(attAnswerPointDiameter) + lolSpec$;  'answer points on
    Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$() + " -N " + lolSpec$;  'answer points off
    if attTrainingContrastCheck% = 1 then
        Extras$ := Extras$ + " -T " + str$(attTrainingContrastPct%);
    endif
    
    'Hardcode the choice points to be red no matter what
    'Turns out that for the attention program the color in the fixation argument sets the color of the choice
    'points but that the actual fixation point is set differently.  FixationArg$ is created at the outset of
    'the script, but here I'm overriding the value to make the choice points always red.
    FixationArg$ := " -f " + str$(FixationX) + "," + str$(FixationY) + "," + str$(FixationDiameter) + ",red";
	
	'CommandLine$ := "cmd /c " + bin$ + "\\dAttention " + FixationArg$ + Extras$ + Distractors$;
	'CommandLine$ := "cmd /k " + bin$ + "\\Attention " + FixationArg$ + Extras$ + Stim$ + Contrast$;
    CommandLine$ := "cmd /k " + bin$ + "\\Attention -F " + specFileName$;
    
    'open a file to write the trial-by-trial specs for the VSG
    specHandle% := FileOpen(specFileName$, 8, 1);
    'print to spec file
    Print("%s %s %s %s",FixationArg$,Extras$,Stim$,Contrast$);  'file should be everything starting from FixationArg$ on
    'close spec file
	FileClose(0);
    
    'Print the parameters
    for i% := 1 to Len(CommandLine$) step 100 do
        SampleText(Mid$(CommandLine$, i%, 100));
    next
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(CommandLine$+"\n");
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	'Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(.1);
    return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawStim
' 
' Draws stimulus in xy window (iDraw%==1) or blanks it (0). 
proc DrawStim(iDraw%)
    
	if iDraw% > 0 then
		var xstim, ystim;
		xstim := FixationX;
		ystim := FixationY;
        
		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif
    
end;




'
'
'===== GetLogProgression =====

' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
' There will be a total of nsteps%+1 values entered into vec[], vec[0] will be xmin, vec[nsteps%] will be xmax
Proc GetLogProgression(xmin, xmax, nsteps%, &vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		'PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;

'
'
'======= CreateContrastList =======
'Fill input variable c$ with the long-form contrast specifier for the Attention experiment
'and cList%[] with the actual contrast to be used on each trial
'and vList%[] with ones if valid and zeros for each trial
'and udList%[] with 1 if contrast change is increase and -1 if contrast change is decrease
'Creating all of these here (including easy trials) allows us to just blast through once we get to the actual experiment
'without too much counting going on.
Proc CreateContrastList(&c$,cList%[],&vList%[],&udList%[])
    var i%;
    var j%;
    var stdCount%;  'a counter for standard (i.e. "valid") trials, index into attTrialOrder%[]
    var catchCount%;  'a counter for catch trials
    var totalCount%;  'the current index of the xList% variables
    
    c$ := " -t ";
       
    for i% := 1 to attNumberOfBlocks% do
        for j% := 1 to attTrialsPerBlock%+attEasyTrialsPerBlock% do
            if j% <= attEasyTrialsPerBlock% then
                vList%[totalCount%] := 1;  'all easy trials are valid
                udList%[totalCount%] := 1;  'up contrast
                'cList%[totalCount%] := attContrastList[attNContLevels%-1];  'fill cList%[] with the highest contrast
                'c$ := c$ + "0," + Str$(attContrastBase%) + "," + Str$(attContrastList[attNContLevels%-1]) + ",";  'fill c$ with easy, up trial
                cList%[totalCount%] := 100;  'change easy trials to 100% contrast
                c$ := c$ + "0," + Str$(attContrastBase%) + "," + Str$(100) + ",";  'fill c$ with easy, up trial at 100% contrast
            else 'regular trial
                if (Rand()*100 < attNoGoTrialPercentage) then 'NoGo trial
                    vList%[totalCount%] := 1;  'all no-go trials are valid
                    udList%[totalCount%] := -1;  '"down" contrast, which now indicates no-go
                    cList%[totalCount%] := attContrastBase%;  'fill cList%[] with the base contrast
                    c$ := c$ + Str$(attContrastBase%) + "," + Str$(attContrastBase%) + "," + "0,";  'fill c$ with no-go trial
                else    
                    docase
                    case (Rand()*100 < attCatchTrialPercentage) then 'catch trial
                        vList%[totalCount%] := 0;  'catch = invalid
                        if attOnlyOneCatch% = 0 then  'if we are doing a tuning curve over catch trials
                            cList%[totalCount%] := attContrastList[attCatchTrialOrder%[catchCount%]];
                            'commenting out this IF because in the No-Go experiment the first half will never execute
                            'if attCatchTrialOrder%[catchCount%] >= attNContLevels% then  'use index to determine whether contrast change is up or down
                            '    udList%[totalCount%] := -1;  'the second half are down contrast
                            '    c$ := c$ + Str$(attContrastList[attCatchTrialOrder%[catchCount%]]) + "," + Str$(attContrastBase%) + "," + "0,";  'fill c$ with down catch trial
                            'else
                            udList%[totalCount%] := 1;   'the first half are up contrast
                            c$ := c$ + "0," + Str$(attContrastBase%) + "," + Str$(attContrastList[attCatchTrialOrder%[catchCount%]]) + ",";  'fill c$ with up catch trial
                            'endif;
                        else  'if we are doing only one catch trial (note the commented stuff above is not re-included)
                            cList%[totalCount%] := attOneCatchContrast%;  'there is only one contrast
                            udList%[totalCount%] := 1;   'the first half are up contrast
                            c$ := c$ + "0," + Str$(attContrastBase%) + "," + Str$(attOneCatchContrast%) + ",";  'fill c$ with up catch trial, there is only one contrast
                        endif;
                        catchCount% += 1;
                    case (Rand()*100 < attUncatchTrialPercentage) then 'uncatch trial
                        'this is guaranteed to go along with attOnlyOneCatch% = 1
                        vList%[totalCount%] := 1;  'catch = valid
                        cList%[totalCount%] := attOneCatchContrast%;  'there is only one contrast
                        udList%[totalCount%] := 1;   'the first half are up contrast
                        c$ := c$ + "0," + Str$(attContrastBase%) + "," + Str$(attOneCatchContrast%) + ",";  'fill c$ with up catch trial, there is only one contrast
                        
                    else  'valid trial
                        vList%[totalCount%] := 1;  'valid
                        cList%[totalCount%] := attContrastList[attTrialOrder%[stdCount%]];
                        'commenting out this IF because in the No-Go experiment the first half will never execute
                        'if attTrialOrder%[stdCount%] >= attNContLevels% then  'use index to determine whether contrast change is up or down
                        '    udList%[totalCount%] := -1;  'the second half are down contrast
                        '    c$ := c$ + Str$(attContrastList[attTrialOrder%[stdCount%]]) + "," + Str$(attContrastBase%) + "," + "0,";  'fill c$ with down std trial
                        'else
                            udList%[totalCount%] := 1;   'the first half are up contrast
                            c$ := c$ + "0," + Str$(attContrastBase%) + "," + Str$(attContrastList[attTrialOrder%[stdCount%]]) + ",";  'fill c$ with up std trial
                        'endif;
                        stdCount% += 1;
                    endcase;
                endif;
            endif;
            totalCount% += 1;
        next;        
    next;
    c$ := Left$(c$,len(c$)-1); 'remove trailing comma from the list
end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ParseGratingParametersBrief%(gr$, &x, &y, &w, &h);
' 
' Given a grating parameter list, parse the individual values in to the given variable list. 
' Simpler version than the full-blown one, as it doesn't return all values. 
' This version will work for all possible variable list lengths - with/without phase/cv/pattern/aperture/inner/outer
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func ParseGratingParametersBrief%(gr$, &x, &y, &w, &h)
    var status% := 0;
    var n%;
	ReadSetup("", "", "", "", ",");
	n% := ReadStr(gr$, x, y, w, h);
    ReadSetup();
    if n% <> 4 then status% := -1; endif;
    return n%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var tempPrimary$;
    var tempSecondary$;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	'Print("Background color           : %s\n", tunBackgroundColor$);

	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);

	' write stimulus parameters
	var Tstimstr$;
	var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
    var phase;
    Print("\nStimulus\n");  'Master grating
	Print("-------------------\n\n");
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
    Print("Inner Width (degrees)           : %s\n", Tstimiw$);
	Print("Inner Height (degrees)          : %s\n", Tstimih$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    Print("Initial Phase (degrees)         : %f\n", phase);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
    
    ' write distractor parameters
    Print("\nDistractor\n");  'Master grating
	Print("-------------------\n\n");
    Tstimstr$ := GetGratingParameters$("Distractor1");
    ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
    Print("Inner Width (degrees)           : %s\n", Tstimiw$);
	Print("Inner Height (degrees)          : %s\n", Tstimih$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    Print("Initial Phase (degrees)         : %f\n", phase);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
    
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

	Print("Acquisition time (s)   : %f\n", attAcquisitionTime);
    Print("Min fixation cue time (s)   : %f\n", attFixationCueMinTime);
    Print("Max fixation cue time (s)   : %f\n", attFixationCueMaxTime);
    Print("Min Hazard time (s)   : %f\n", attHazardMinTime);
    Print("Mean Hazard time (s)   : %f\n", attHazardExpMeanTime);
    Print("Hazard Cutoff time (s)   : %f\n", attHazardCutoffTime);
    Print("Time to answer (s)   : %f\n", attTimeToAnswer);
    Print("Intertrial time (s)   : %f\n", attInterTrialTime);
    Print("Abort penalty time (s)   : %f\n", attAbortWaitTime);
    Print("False Alarm penalty time (s)   : %f\n", attFalseAlarmWaitTime);
    Print("False Alarm check window (s)   : %f\n", attFalseAlarmCheckWindow);
    Print("Miss penalty time (s)   : %f\n", attMissPenalty);
    
    
	Print("\nTuning parameters\n");
	Print("-------------------\n\n");    
    'Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
    
    Print("Number of blocks   : %d\n", attNumberOfBlocks%);
    Print("Trials per block   : %d\n", attTrialsPerBlock%);
    Print("Easy trials per block   : %d\n", attEasyTrialsPerBlock%);
    Print("Catch trial percentage   : %f\n", attCatchTrialPercentage);
    Print("No-go trial percentage   : %f\n", attNoGoTrialPercentage);
    Print("Alternate Cue Type by block?   : %d\n", attBlockAlternate%);
    Print("Do NOT randomize by block?   : %d\n", attNoBlockRand%);
    Print("Base Contrast   : %d\n", attContrastBase%);
    Print("Max contrast change   : %f\n", attMaxContChange);
    Print("Min contrast change   : %f\n", attMinContChange);
    Print("N Contrast levels   : %d\n", attNContLevels%);
    Print("Answer point window radius   : %f\n", attAnswerPointWindowRadius);
    Print("Use Training Contrast?   : %d\n", attTrainingContrastCheck%);
    Print("Training contrast   : %d\n", attTrainingContrastPct%);
    'Print("Set phase at contrast change?   : %d\n", attPhaseCheck%);
    'Print("Phase at contrast change   : %d\n", attPhaseDeg% );
    
    Print("Values: " + Contrast$ + "\n");
    Print("\n");

	' close parfile
	FileClose(0);

end;