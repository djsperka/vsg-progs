' $Log: not supported by cvs2svn $ 



	'Initialize environment
	var sRootPath$;	' this has leading and trailing \'s
	var sBinPath$;		' this has leading and trailing \'s
	var sRootDrive$;	' this is a letter and :, e.g. c:

	const pi := 3.14159265;
	const pts% := 100;
	var DistanceToScreen;
	var ScreenHeightMM;
	var ScreenWidthMM;
	var xEye;
	var yEye;
	var xStim;			' angle amplitude of outlying stimuli
	var yStim;
	var xStimCurrent;	' Where the stimulus is. Valid only in certain states. 
	var yStimCurrent;
	var xCircle[100];
	var yCircle[100];
	var xWindow[100];
	var yWindow[100];
	var xScreen[4];	' angular coordinates of screen corners
	var yScreen[4];	' angular coordinates of screen corners
	var DegreesPerVoltX, DegreesPerVoltY;
	var MaxAcquisitionTime := .3; 	' Max time (s) allowed for acquisition of target
	var MinFixationTime := .7;			' Min time required (s) for fixation (and reward)
	var InterTrialTime := 1.0;			' Time between trials
	var NumberOfRewards% :=0;			' Nubmer of rewards per successful trial
	var BackgroundColor$ := "Black";	' Background color to use
	var FixationPointDegrees:=.1;		' Diameter of fixation point in degrees
	var FixationWindowDegrees:=1;		' Diameter of fixation window in degrees
	var FixationColor$ := "Red";		' Fixation point color
	var PctCoverage := .9;				' % of screen to cover with stimuli

	var DataWindow%;						' Data sampling window
	var XYWindow%;							' Window for eye position

	var iStimX%[8];
	var iStimY%[8];
	var iStimIndex% := -1;	' incremented prior to display

	var XChannel% := 1;
	var YChannel% := 2;
	var TriggerChannel% := 3;
	var iStimWindowChannel%;
	var iStimChannel%;

	var TodaysRewards := 0;
	var TodaysTrials := 0;

	InitParameters();

	ParametersDialog();

	CreateSampleConfiguration();

	InitDrawingParameters();

	OpenWindows();

	'Create and display the Toolbar, not yet activating the IdleProcessing function

	'Toolbar and IdleProcessing variables
	var Pause,Stim$,StimHandle;
	var Time,OldTime:=0,NewTriggerTime,NewTriggerState;
	var StartTrial :=1, AcquireTarget :=0, HoldFixation :=0, WaitForBlank :=0, WaitForStim:=0, TargetAcquired :=0;
	var TrialCounter :=1,TrialStartTime, TargetAcquiredTime, BlankStartTime;
	var TriggerState,TriggerTime:=-1,TriggerOnTime, TriggerOffTime;
	var EyePosX,EyePosY;

	var tLast := -1;
	var tLastUpdate := -1;
	var tLastTrigger := -1;
	var tNow  := -1;
	var tTrigger := -1;
	var tStateStart := -1;
	var iState% := 0;
	var vTrigger := -1;
	var iSeqVar%;

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice",Juice%);
	ToolbarSet(4,"Horizontal",Horizontal%);
	ToolbarSet(5,"Vertical",Vertical%);
	ToolbarSet(6,"Corners",Corners%);
	ToolbarSet(7,"Pause stimuli",PauseStimuli%);
	ToolbarSet(8,"Resume stimuli",ResumeStimuli%);
	ToolbarSet(9,"Punt",Punt%);
	ToolbarEnable(2,0);
	ToolbarEnable(7,0);
	ToolbarEnable(8,0);
'	ToolbarEnable(9,0);
	Toolbar("Go",12345);


' Run real time analysis here. 
func IdleProcessing%()

	tNow := MaxTime();

	xEye := ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
	yEye := ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastUpdate := tNow;
	endif

	' What state are we in? 
	docase 
		case iState% = 0 then

			' initial state on startup. 
			' DIGOUT to present stimulus
			' Enter state 1

			' Set sequencer var
			iStimIndex% := (iStimIndex% + 1) mod 8;
			iSeqVar% := (32 + (iStimY%[iStimIndex%]*8) + (iStimX%[iStimIndex%]*2))*256 + 1;
			SampleSeqVar(1,iSeqVar%);
			SampleKey("S");
			iState% := 1;
			PrintLog("State 0 - Start new trial - present stimulus at " + str$(iStimX%[iStimIndex%]) + "," + str$(iStimY%[iStimIndex%]) + "\n");

		case iState% = 1 then
	
			' Waiting for stimulus to be presented by vsg and trigger to return. 
			' NextTime returns a non-negative value whenever there is a TRANSITION. In that case, the 
			' value of 'vTrigger' returned is 1 (0) if the transition is high (low) to low (high). Maybe not
			' intuitive, but that's the way it is. 
			tTrigger := NextTime(TriggerChannel%,tLast,vTrigger);
			if tTrigger > tLastTrigger then

				if vTrigger = 0 then
		
					' Stimulus has been presented. Display stim location and window. Enter state 2
					DrawStim(1);
					iState% := 2;
					tStateStart := tTrigger;
					tLastTrigger := tTrigger;

				endif

			endif

		case iState% = 2 then

			if tNow-tStateStart < MaxAcquisitionTime then
				
				' Acquisition happens when the eye falls within the fixation window.
				if InFixationWindow%(xEye, yEye) > 0 then

					PrintLog("State 2 - acquired target. tNow=" + str$(tNow) + " Enter state 3\n");
					iState% := 3;
					tStateStart := tNow;
	
				endif

			else

				' Failed. Turn off stim and try again.
				PrintLog("State 2 - acquisition failed. Enter state 4\n");
				iState% := 4;
				tStateStart := tNow;

			endif

		case iState% = 3 then

			' Waiting for fixation....
			if InFixationWindow%(xEye, yEye) <= 0 then

				iState% := 4;
				tStateStart := tNow;

			else

				if tNow - tStateStart >= MinFixationTime then

					' Fixation. Reward. New trial.
					Reward%();
					iState% := 4;
					tStateStart := tNow;

				endif

			endif

		case iState% = 4 then

			' Turn off stimulus, enter state 5 - wait for stimulus off msg
			DrawStim(0);
			PrintLog("State 4 - turning off stimulus....\n");
			SampleKey("Q");
			iState% := 5;
			tStateStart := tNow;

		case iState% = 5 then

			' Wait for stim to be off
			tTrigger := NextTime(TriggerChannel%,tLast,vTrigger);
			if tTrigger > tLast then

				if vTrigger = 1 then
		
					' Stimulus has been turned off by vsg. Enter state 6
					PrintLog("State 5 - Stim OFF trigger found. Enter state 6\n");
					iState% := 6;
					tStateStart := tTrigger;
					tLastTrigger := tTrigger;
	
				endif

			endif

		case iState% = 6 then

			' Inter-trial wait time
			if tNow - tStateStart > InterTrialTime then
	
				' Back to state 0
				PrintLog("State 6 - IT wait is done. Start new trial.\n");
				iState% := 0;
				tStateStart := tNow;
	
			endif

		else 

			' Unknown state!
			Message("Unknown state=" + str$(iState%));
			halt;

	endcase;

	tLast := tNow;
	
	return 1;

end;

func Horizontal%()
	iStimX%[0] := 1; iStimY%[0] := 2;
	iStimX%[1] := 1; iStimY%[1] := 2;
	iStimX%[2] := 2; iStimY%[2] := 2;
	iStimX%[3] := 2; iStimY%[3] := 2;
	iStimX%[4] := 3; iStimY%[4] := 2;
	iStimX%[5] := 3; iStimY%[5] := 2;
	iStimX%[6] := 2; iStimY%[6] := 2;
	iStimX%[7] := 2; iStimY%[7] := 2;
	return 1;
end;

func Vertical%()
	iStimX%[0] := 2; iStimY%[0] := 1;
	iStimX%[1] := 2; iStimY%[1] := 1;
	iStimX%[2] := 2; iStimY%[2] := 2;
	iStimX%[3] := 2; iStimY%[3] := 2;
	iStimX%[4] := 2; iStimY%[4] := 3;
	iStimX%[5] := 2; iStimY%[5] := 3;
	iStimX%[6] := 2; iStimY%[6] := 2;
	iStimX%[7] := 2; iStimY%[7] := 2;
	return 1;
end;

func Corners%()
	iStimX%[0] := 1; iStimY%[0] := 1;
	iStimX%[1] := 1; iStimY%[1] := 1;
	iStimX%[2] := 3; iStimY%[2] := 1;
	iStimX%[3] := 3; iStimY%[3] := 1;
	iStimX%[4] := 3; iStimY%[4] := 3;
	iStimX%[5] := 3; iStimY%[5] := 3;
	iStimX%[6] := 1; iStimY%[6] := 3;
	iStimX%[7] := 1; iStimY%[7] := 3;
	return 1;
end;

proc ParametersDialog()
	'Dialog specific variables
	var BackgroundColorList$[3]; 
	var BackgroundListIndex := 1;
	var DlgResponse;
	BackgroundColorList$[0]:="Black"; 
	BackgroundColorList$[1]:="Gray"; 
	BackgroundColorList$[2]:="White";

	GetParameters();

	if BackgroundColor$="Black" then BackgroundListIndex := 0; endif
	if BackgroundColor$="Gray" then BackgroundListIndex := 1; endif
	if BackgroundColor$="White" then BackgroundListIndex := 2; endif

	var FixationColorList$[3]; 
	var FixationListIndex := 1;
	FixationColorList$[0] := "Red"; 
	FixationColorList$[1] := "Green"; 
	FixationColorList$[2] := "Blue";

	if FixationColor$="Red" then FixationListIndex := 0; endif
	if FixationColor$="Green" then FixationListIndex := 1; endif
	if FixationColor$="Blue" then FixationListIndex := 2; endif


 	
	DlgCreate("Specify calibration parameters");
	DlgReal(1, "Acquisition time (s):", 0, 20);
	DlgReal(2, "Fixation time (s): ",0,20);
	DlgReal(3,"Inter-trial time (s): ",0,20);
	DlgInteger(4,"Number of juices per reward",0,10);
	DlgList(5,"Background color:",BackgroundColorList$[]);
	DlgReal(6,"Fixation point diameter (degrees):",.01,5);
	DlgReal(7,"Fixation window diameter (degrees):",.01,5);
	DlgList(8,"Fixation point color:",FixationColorList$[]);
	DlgReal(9,"Pct screen coverage:", 0.1,1.0);
	DlgResponse := DlgShow(	MaxAcquisitionTime,
									MinFixationTime,
									InterTrialTime,
									NumberOfRewards%,
									BackgroundListIndex,
									FixationPointDegrees,
									FixationWindowDegrees,
									FixationListIndex,
									PctCoverage);

	if DlgResponse	= 0 
	then
		halt;
	endif

	BackgroundColor$ := BackgroundColorList$[BackgroundListIndex];
	FixationColor$ := FixationColorList$[FixationListIndex];

	SaveParameters();
end


proc SaveParameters()

	var Monkey$;
	Profile("AlertRig","CurrentMonkey","",Monkey$);

	Profile("AlertRig\\"+Monkey$+"\\Calibation","MaxAcquisitionTime",str$(MaxAcquisitionTime));
	Profile("AlertRig\\"+Monkey$+"\\Calibation","MinFixationTime",str$(MinFixationTime));
	Profile("AlertRig\\"+Monkey$+"\\Calibation","InterTrialTime",str$(InterTrialTime));
	Profile("AlertRig\\"+Monkey$+"\\Calibation","NumberOfRewards",NumberOfRewards%);
	Profile("AlertRig\\"+Monkey$+"\\Calibation","BackgroundColor",BackgroundColor$);
	Profile("AlertRig\\"+Monkey$+"\\Calibation","FixationPointDegrees",str$(FixationPointDegrees));
	Profile("AlertRig\\"+Monkey$+"\\Calibation","FixationWindowDegrees",str$(FixationWindowDegrees));
	Profile("AlertRig\\"+Monkey$+"\\Calibation","FixationColor",FixationColor$);
	Profile("AlertRig\\"+Monkey$+"\\Calibation","PctCoverage",str$(PctCoverage));

end;

proc GetParameters()
	var sTemp$;
	var iTemp%;
	var Monkey$;
	Profile("AlertRig","CurrentMonkey","",Monkey$);

	Profile("AlertRig\\"+Monkey$+"\\Calibation","MaxAcquisitionTime",str$(MaxAcquisitionTime),sTemp$);
	MaxAcquisitionTime := val(sTemp$);

	Profile("AlertRig\\"+Monkey$+"\\Calibation","MinFixationTime",str$(MinFixationTime),sTemp$);
	MinFixationTime := val(sTemp$);
	
	Profile("AlertRig\\"+Monkey$+"\\Calibation","InterTrialTime",str$(InterTrialTime),sTemp$);
	InterTrialTime := val(sTemp$);

	Profile("AlertRig\\"+Monkey$+"\\Calibation","NumberOfRewards",NumberOfRewards%, NumberOfRewards%);

	Profile("AlertRig\\"+Monkey$+"\\Calibation","BackgroundColor",BackgroundColor$,BackgroundColor$);

	Profile("AlertRig\\"+Monkey$+"\\Calibation","FixationPointDegrees",str$(FixationPointDegrees),sTemp$);
	FixationPointDegrees := val(sTemp$);

	Profile("AlertRig\\"+Monkey$+"\\Calibation","FixationWindowDegrees",str$(FixationWindowDegrees),sTemp$);
	FixationWindowDegrees := val(sTemp$);

	Profile("AlertRig\\"+Monkey$+"\\Calibation","FixationColor",FixationColor$,FixationColor$);

	Profile("AlertRig\\"+Monkey$+"\\Calibation","PctCoverage",str$(PctCoverage),sTemp$);
	PctCoverage := val(sTemp$);

end;

proc OpenWindows()

	'Open an XY view to display eye position
	'Channel 1 in this vew will be the data channel. 
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(-0.550314,0.114416,41.5094,52.746);
	XYColour(1,16);
	XYSize(1,-1);

	'Channel 2 will be monitor location
	var ichan%;
	ichan% := XYSetChan(0);
	PrintLog("monitor is chan " + str$(ichan%));
	XYColour(2,13);
	XYDrawMode(2,3,1);
	XYJoin(2,2);
	XYAddData(2,xScreen[],yScreen[]);

	' Stimulus and window channel
	iStimChannel% := XYSetChan(0);
	iStimWindowChannel% := XYSetChan(0);
	XYColour(iStimWindowChannel%,13);
	XYDrawMode(iStimWindowChannel%,2,1);
	XYJoin(iStimWindowChannel%,1);

	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(-0.235849,52.746,97.2484,99.8856);
	View(DataWindow%).WindowVisible(1);

end

' This function is tied to the 'Start' button.
func Start%()
	var CommandLine$;
	var args$;

	' Initialize orientation to horizontal
	Horizontal%();
	args$ :=  BackgroundColor$ + " " + FixationColor$ + " " + str$(FixationPointDegrees) + " " + str$(DistanceToScreen) + " " + str$(PctCoverage);
'	CommandLine$ :="C:\\AlertRig\\Fixation\\Calibration\\Debug\\Calibration " + args$;
'	CommandLine$ :="c:\\alertrig\\Fixation\\Calibration\\Debug\\Calibration " + args$;
	CommandLine$ := sRootDrive$ + sBinPath$ + "Calibration " + args$;
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(CommandLine$+"\n");
	StimHandle := ProgRun(CommandLine$,0);
	if StimHandle <0 then Message("Could not start stimulus."); halt; endif
	Yield(3);	'Wait a few seconds to make sure the VSG has time to initialize.
'	SampleKey("T");
	SampleKey("S");
	SampleStart(0); 'Start sampling
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(4,1);
	ToolbarEnable(5,1);
	ToolbarEnable(6,1);
	View(DataWindow%);
	Yield(.1);
	return 1;
end;

' This function is tied to the Stop button
func Stop%()
	Yield(.1);
	SampleStop();
	ProgKill(StimHandle);
	ProgRun("C:\\AlertRig\\ClearTrigger",0);
end;

' This function tied to Juice button
func Juice%()
	SampleKey("J");
	return 1;
end;

'This function tied to punt button. 
func Punt%()
	Halt;
	return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
	Pause :=1;
	ToolbarEnable(4,0);
	ToolbarEnable(5,1);
	return 1;
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
	Pause :=0;
	ToolbarEnable(4,1);
	ToolbarEnable(5,0);
	return 1;
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
	var istatus;
	SampleClear(); 'Set standard sampling state
	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit

	SampleEvent(TriggerChannel%,1,2,3600); 'Trigger channel, level
	SampleComment$(TriggerChannel%,"Stimulus");
	SampleTitle$(TriggerChannel%,"Stimulus");

	' There are 0 channels when calibrating

	SampleWaveform(XChannel%,14,28000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%,15,28000);
	SampleTitle$(YChannel%,"Eye Y");

	istatus := SampleSequencer(sRootDrive$ + sRootPath$ + "Calibration.pls");
	if istatus<0
	then
		Message("Cannot open sequencer file.");
		halt;
	endif
		
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;

proc InitParameters()

	var index%;
	var rad;
	var DegreesPerVoltX$, DegreesPerVoltY$;

	' get directory paths....
	sRootPath$ := View(App(3)).FileName$(2);
 	sRootDrive$ := View(App(3)).FileName$(1);
	sBinPath$ := sRootPath$ + "..\\bin\\";


	'Determine the current distance to the screen and screen dimensions
	var Dist$;
	var Dist%;
	Profile("AlertRig\\CurrentExperiment","DistanceToScreen","850",Dist$);
	DistanceToScreen := val(Dist$);

	Profile("AlertRig", "ScreenWidthMM", 428, Dist%);
	ScreenWidthMM := Dist%;
	Profile("AlertRig", "ScreenHeightMM", 321, Dist%);
	ScreenHeightMM := Dist%;


	'Get information on current calibration constants (software gains) for the eye coil from the registry
	var Monkey$;
	Profile("AlertRig","CurrentMonkey","",Monkey$);
	if Monkey$="" then Message("Could not determine current monkey"); halt; endif

	Profile("AlertRig\\"+Monkey$,"DegreesPerVoltX","",DegreesPerVoltX$);
	Profile("AlertRig\\"+Monkey$,"DegreesPerVoltY","",DegreesPerVoltY$);
	DegreesPerVoltX := val(DegreesPerVoltX$);		'Since registry values are either integers are strings, 
	DegreesPerVoltY := val(DegreesPerVoltY$);		'we store decimals as strings and convert them to decimals

end;

' Initialize parameters needed to draw stuff on output windows. These cannot be initialized until 
' after all parameters are set in the input dialog. 
proc InitDrawingParameters()

	var index%;
	var xmax;
	var ymax;
	var rad;

	' This will be used as the fixation window. 	
	for index% := 0 to pts%-1 do
		' 100 is the number of pts -- can I use a const? 
		rad := 2*pi/100*index%;
		xCircle[index%] := rad;
		yCircle[index%] := rad;
	next;
	Cos(xCircle[]);
	Sin(yCircle[]);
	ArrMul(xCircle[], FixationWindowDegrees);
	ArrMul(yCircle[], FixationWindowDegrees);

	' This is the approx location of the screen, in degree coordinates.
	xmax := ATan(.5*ScreenWidthMM/DistanceToScreen) * 180/pi;
	ymax := ATan(.5*ScreenHeightMM/DistanceToScreen) * 180/pi;

	PrintLog(str$(ScreenWidthMM) + "\n");
	PrintLog(str$(ScreenHeightMM) + "\n");
	PrintLog(str$(xmax) + "\n");
	PrintLog(str$(ymax) + "\n");
	xScreen[0] := xmax;
	xScreen[1] := xMax;
	xScreen[2] := -xmax;
	xScreen[3] := -xmax;
	yScreen[0] := ymax;
	yScreen[1] := -ymax;
	yScreen[2] := -ymax;
	yScreen[3] := ymax;

	' These are the magnitudes of the stimulus locations on the screen. 
	xStim := ATan(.5*ScreenWidthMM*PctCoverage/DistanceToScreen) * 180/pi;
	yStim := ATan(.5*ScreenHeightMM*PctCoverage/DistanceToScreen) * 180/pi;


end;

proc DrawStim(iDraw%)

	var xWindowCurrent[100];
	var yWindowCurrent[100];

	if iDraw% > 0 then
		xStimCurrent := xStim * (iStimX%[iStimIndex%]-2);
		yStimCurrent := -1 * yStim * (iStimY%[iStimIndex%]-2);
		View(XYWindow%).XYAddData(iStimChannel%,xStimCurrent,yStimCurrent);

		' Generate the window
		ArrConst(xWindow[], xCircle[]);
		ArrConst(yWindow[], yCircle[]);
		ArrAdd(xWindow[], xStimCurrent);
		ArrAdd(yWindow[], yStimCurrent);
		View(XYWindow%).XYAddData(iStimWindowChannel%,xWindow[],yWindow[]);		
	else 
		View(XYWindow%).XYDelete(iStimChannel%);
		View(XYWindow%).XYDelete(iStimWindowChannel%);
	endif

end;

func Reward%()

	var i;
	TodaysRewards:=TodaysRewards+1;
	ToolbarText("Trial Number: "+str$(TodaysTrials)+"     Number of Rewards: "+str$(TodaysRewards));
'	Profile("AlertRig\\"+Monkey$,"TotalRewards",TodaysRewards);
	for i:=1 to NumberOfRewards% do Yield(.05); SampleKey("J"); next

end;

func InFixationWindow%(x, y)

	var iReturn%:=0;
	var xprime;
	var yprime;
	xprime := x - xStimCurrent;
	yprime := y - yStimCurrent;
	if (xprime*xprime + yprime*yprime) <= (FixationWindowDegrees*FixationWindowDegrees) then
		iReturn% := 1;
	endif
	return iReturn%;

end;

