#include "ExtractionUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "../../Spike2Util/ChannelUtilities.s2s"

var txTLast := -1;
var txTStop := -1;
var txIsInitialized% := -1;
const txstateError% := -1;
const txstateStart% := 0;
const txstateStimUp% := 1;
const txstateStimDn% := 2;
const txstateAdvance% := 3;
const txstateX% := 4;

' additional states for Version 3 data
const txStatePreStim% := 5;
const txStateTrialSuccess% := 6;
const txStateTrialFailure% := 7;

var txOutputHandle := -1;

var txIState% := txstateStart%;

var txChanFixpt% := 24;
var txChanStim% := 25;
var txChanStimChg% := 26;
var txChanFixptSlave% := 28;
var txChanStimSlave% := 29;
var txChanFrame% := 19;
var txChanFrameSlave% := 20;

' Trial vars
var tS;     ' onset time of stim
var tE;     ' off time of stim
var tSSlave;' onset time of stim for slave screen
var tESlave;' off time of stim for slave screen
var iCurrentParam% := 0;

' version info
var txVersion% := 0;
var txDualVSG% := 0;

' tuning params
var nparams% := 0;
var params[1000];
var v3param;

LogInit(1);


' InitStr has the parameter filename
func TuningExtractInit%(hOutput, initStr$)
    if InitFileVars%(initStr$) < 0 then
        return -1;
    endif    
    txIsInitialized% := 1;
    txOutputHandle := hOutput;
    iCurrentParam% := 0;
    InitTrialVars();
    return;
end


func InitFileVars%(s$)
    var status% := 0;
    var h;
    var line$;
    nparams% := 0;
    h := FileOpen(s$, 8);
    if h < 0 then
        status% := -1;
        PrintLog("Parameter file " + s$ + " should be in same dir as data file.");
    endif

    while Read(line$) >= 0 and nparams% = 0 do    ' read while not EOF or error
        ' parameters line starts with "Values:"
        if InStr(line$, "Values:") = 1 then
            nparams% := ReadStr(Mid$(line$, 9), params[]);
        endif    
    wend;
    
    FileClose(); 
    PrintLog("Got %d params from file %s\n", nparams%, s$);
    if nparams% < 1 then
        status% := -1;
    endif
    
end

proc InitTrialVars()
    tS := -1;
    tE := -1;
    tSSlave := -1;
    tESlave := -1;
    return;
end


func FindStimPulses%(chan%, tS1, tS2, tP[])
    var count% := 0;
    var tN;
    var t0, t1;
    var st%;
    
    ' Look for 3 pulses
    tN := tS1-.001;
    st% := FindPulseUp%(chan%, tN, t0, t1);
    while st% = 1 and count% < 3 do
        tP[count%] := t0;
        count% += 1;
        'PrintLog("Pulse %d at %f - %f\n", count%, t0, t1);
        tN := t1;
        st% := FindPulseUp%(chan%, tN, t0, t1);
    wend
    
    if count% = 3 and tP[2] < tS2 then
        return 1;
    endif
    
    return 0;
end



proc FlushTrial()
    var s$;
    var tPM[3];
    var tPS[3];
    
    if (txVersion% = 2 or txVersion% = 3) and txDualVSG% = 1 then
        if FindStimPulses%(txChanFrame%, tS, tE, tPM[]) <> 1 then
            PrintLog("ERROR: Cannot find master stim pulses in window from %f - %f\n", tS, tE);
            return;
        endif
    
        if FindStimPulses%(txChanFrameSlave%, tSSlave, tESlave, tPS[]) <> 1 then
            PrintLog("ERROR: Cannot find slave stim pulses in window from %f - %f\n", tSSlave, tESlave);
            return;
        endif
    
        s$ := Print$("%f %f %f %f %f\n", params[iCurrentParam%], tPM[1], tPM[2], tPS[1], tPS[2]);
    else
        s$ := Print$("%f %f %f %f %f\n", params[iCurrentParam%], tS, tE, tSSlave, tESlave);
    endif
        
    View(LogHandle()).Print(s$);
    if txOutputHandle >= 0 then
        View(txOutputHandle).Print(s$);
    endif

    return;
end


' GetTuningVersion%
'
' Looks at text marks at beginning of data file to determine what "version" the tuning data is. 

proc GetTuningVersion(&version%, &isDual%)
    var s$;
    var iStatus% := 0;
    var tLast := -1;
    var count% := 0;
    var cLength%;
    var i%;
    isDual% := 0;
    while iStatus% = 0 do
        tLast := NextTextMark(tLast, s$);
        docase
        case count% = 0 then
            ' Parse version and command line length
            i% := InStr(s$, ",");
            ReadStr(DelStr$(s$, 1, i%), version%, cLength%);
            PrintLog("Version %d Len %d\n", version%, cLength%);
            count% := 1;
        case count% = 1 then
            count% := 2;    ' ignore this text mark - its the CVS ID. 
        case count% = 2 then
            if InStr(LCase$(s$), "dualstim") > 0 then
                isDual% := 1;
            endif
            iStatus% := 1;
        endcase
    wend
end



' TuningExtract%(tStart, tStop)
' 
' Extract attention data betwen tStart and tStop. If tStart<0, start at beginning of file. 
' If tStop<0, extract to the end of the file. 
'
' When called the current view must be the data file/time view to be analyzed. 

func TuningExtract%(tStart, tStop)
    var status% := 0;
    var tFound := -1;
    var sFound$;
    var sIgnore$;
    var tTrigger;
    
    GetTuningVersion(txVersion%, txDualVSG%);
    PrintLog("Version %d dual %d\n", txVersion%, txDualVSG%);
    
    txTLast := tStart;
    txTStop := tStop;
    
    docase
    case txVersion% = 1 or txVersion% = 2 then
        
        sIgnore$ := "0FJQR+";
        tFound := NextKey(txTLast, sFound$, sIgnore$);
        while tFound >= 0 and (txTStop < 0 or (txTStop > 0 and tFound <= txTStop)) and txIState% <> txstateError% do

            'LogInfo(sFound$ + " " + str$(tFound));
            
            docase 
            case txIState% = txstateStart% then
                docase
                case InStr(sFound$, "S") = 1 then
                    if FindRisingEdge%(txChanStim%, tFound, tS) < 0 or FindRisingEdge%(txChanStimSlave%, tFound, tSSlave) < 0 then
                        LogError("", "Rising edge not found after S at t=" + str$(tFound) + "\n");
                        txIState% := txstateError%;
                    else
                        txIState% := txstateStimUp%;
                    endif
                case sFound$ = "X" then
                    ' nothing to see here. An X here is OK, we stay in same state. 
                else
                    LogError("", "Unexpected key \"" + sFound$ + "\" found at " + str$(tFound) + "\n");
                endcase
            case txIState% = txstateStimUp% then
                ' Expecting "s" or "X"
                docase 
                case sFound$ = "s" then
                    if FindFallingEdge%(txChanStim%, tFound, tE) < 0 or FindFallingEdge%(txChanStimSlave%, tFound, tESlave) < 0 then
                        LogError("", "Falling edge not found after s at t=" + str$(tFound) + "\n");
                        txIState% := txstateError%;
                    else
                        txIState% := txstateStimDn%;
                    endif
                case sFound$ = "X" then
                    InitTrialVars();
                    txIState% := txstateStart%;
                else
                    LogError("", "Unexpected key \"" + sFound$ + "\" found at " + str$(tFound) + "\n");
                    txIState% := txstateError%;
                endcase
            case txIState% = txstateStimDn% then
                ' Expecting "a"
                docase
                case sFound$ = "a" then
                    FlushTrial();
                    InitTrialVars();
                    iCurrentParam% += 1;
                    txIState% := txstateStart%;
                else
                    LogError("", "Unexpected key \"" + sFound$ + "\" found at " + str$(tFound) + "\n");
                    txIState% := txstateError%;
                endcase
            else
                LogError("", "Unexpected state (" + str$(txIState%) + ") found at " + str$(tFound) + "\n");
                txIState% := txstateError%;
            endcase
            
            txTLast := tFound;
            tFound := NextKey(txTLast, sFound$, sIgnore$);
            
        wend
    case txVersion% = 3 then
        
        sIgnore$ := "0FJQR";        
        tFound := NextKeyOrText(txTLast, sFound$, sIgnore$);
        while tFound >= 0 and (txTStop < 0 or (txTStop > 0 and tFound <= txTStop)) and txIState% <> txstateError% do

            'LogInfo(sFound$ + " " + str$(tFound));
            
            docase 
            case txIState% = txstateStart% then
                docase
                    
                case InStr(sFound$, "T,") = 1 then
                    v3param := val(Mid$(sFound$, 3));
                    txIState% := txStatePreStim%;
                case sFound$ = "X" then
                    LogStatus("txstateStart", "Aborted trial at " + str$(tFound));
                else
                    LogError("txstateStart", "Unexpected key \"" + sFound$ + "\" found at " + str$(tFound) + "\n");
                endcase
                
            case txIState% = txStatePreStim% then
                docase
                case sFound$ = "S" then
                    if FindRisingEdge%(txChanStim%, tFound, tS) < 0 or FindRisingEdge%(txChanStimSlave%, tFound, tSSlave) < 0 then
                        LogError("txstatePreStim", "Rising edge not found after S at t=" + str$(tFound) + "\n");
                        txIState% := txstateError%;
                    else
                        txIState% := txstateStimUp%;
                    endif
                else
                    LogError("txstatePreStim", "Unexpected key \"" + sFound$ + "\" found at " + str$(tFound) + "\n");
                endcase
                 
            case txIState% = txstateStimUp% then
                ' Expecting "+" or "-"
                docase 
                case sFound$ = "+" then
                    if FindFallingEdge%(txChanStim%, tFound, tE) < 0 or FindFallingEdge%(txChanStimSlave%, tFound, tESlave) < 0 then
                        LogError("txstateStimUp", "Falling edge not found after s at t=" + str$(tFound) + "\n");
                        txIState% := txstateError%;
                    else
                        txIState% := txStateTrialSuccess%;
                    endif
                case sFound$ = "-" then
                    txIState% := txStateTrialFailure%;
                else
                    LogError("txstateStimUp", "Unexpected key \"" + sFound$ + "\" found at " + str$(tFound) + "\n");
                    txIState% := txstateError%;
                endcase
                
            case txIState% = txStateTrialSuccess% then
                docase
                case sFound$ = "X" then
                    
                    ' Check that param found in data file matches order in par file
                    if v3param <> params[iCurrentParam%] then
                        LogError("txStateTrialSuccess", "Trial parameter does not match par file at " + str$(tFound));
                    endif
                    
                    FlushTrial();                
                    InitTrialVars();
                    txIState% := txstateAdvance%;
                else
                    LogError("txstateTrialSuccess", "Unexpected key \"" + sFound$ + "\" found at " + str$(tFound) + "\n");
                    txIState% := txstateError%;
                endcase
            case txIState% = txStateTrialFailure% then
                docase
                case sFound$ = "X" then
                    InitTrialVars();
                    txIState% := txstateStart%;
                else
                    LogError("txstateTrialFailure", "Unexpected key \"" + sFound$ + "\" found at " + str$(tFound) + "\n");
                    txIState% := txstateError%;
                endcase
            case txIState% = txstateAdvance% then
                ' Expecting "a"
                docase
                case sFound$ = "a" then
                    iCurrentParam% += 1;
                    txIState% := txstateStart%;
                else
                    LogError("txstateAdvance", "Unexpected key \"" + sFound$ + "\" found at " + str$(tFound) + "\n");
                    txIState% := txstateError%;
                endcase
            else
                LogError("", "Unexpected state (" + str$(txIState%) + ") found at " + str$(tFound) + "\n");
                txIState% := txstateError%;
            endcase
            
            txTLast := tFound;
            tFound := NextKeyOrText(txTLast, sFound$, sIgnore$);
            
        wend
        
        
    endcase
    
        
    return 0;
end
