' $Id: AttentionGoNoGo.s2s,v 1.97 2017/05/31 01:33:25 devel Exp $
'
#include "../../Spike2Util/UsreyUtil.s2s"
#include "AttentionExtractFunctions.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"
#include "UsreyGratings.s2s"  'not sure why we didn't just do this from the start...


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' 	Attention script dialog START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'	Vars that control the Attention script 

var attNumberOfBlocks%;
var attTrialsPerBlock%;
var attEasyTrialsPerBlock%;
var distracterOffForEasy%;
var attCatchTrialPercentage;
var attUncatchTrialPercentage;
var attDoUncatch%;
var attNoGoTrialPercentage;
var attNumPatches%;  'how many stimulus patches on the screen?
var attGetGPFromMainStim%;  'check box variable, should we get the distractor grating parameters (except for XY position) from the main stimulus?
var attUseCueCircles%;
var attCueCircleExtraRadius;
var attBackgroundColor$;
var attBackgroundRed% := 0;
var attBackgroundGreen% := 0;
var attBackgroundBlue% := 0;
var attBackgroundFromRed% := 0;
var attBackgroundFromGreen% := 0;
var attBackgroundFromBlue% := 0;
var attBackgroundToRed% := 0;
var attBackgroundToGreen% := 0;
var attBackgroundToBlue% := 0;
var attAnswerPointDiameter := 0.05;
var attAnswerPointOffset := 5.0;
var attAnswerPointWindowRadius := 2.5;
var attContrastBase%;
var attMaxContChange;
var attMinContChange;
var attNContLevels%;
var attContrastList[20];        'max of 20 (10 up, 10 down) contrast levels
var attFixationTime;
'var attWhitePointTime;          ' xxxxx
var attFixationCueMinTime;      ' xxxxx
var attFixationCueMaxTime;      ' xxxxx
var attHazardMinTime;
var attHazardExpMeanTime;
var attHazardCutoffTime;
var attAcquisitionTime;
var attInterTrialTime;
var attInterTrialTime2;
var attTimeToAnswer;
var attTimeToAnswerPerTrial;  'filled on a trial-to-trial basis because the value is different for no-change trials
var attNoChangeDuration;
var attAbortWaitTime;
var attMissPenalty;
var attFalseAlarmWaitTime;
var attFalseAlarmCheckWindow;
var attBlockAlternate%;
var attSelectRandomContrastEachTrial%;  'if 1, don't do blocked randomization
var attTrainingContrastCheck%:=0;
var attTrainingContrastPct%:=0;
var randBlockOrderVar%;     'this will be 0 or 1, and will determine whether we start attend-toward or attend-away
randBlockOrderVar% := round(rand(0.0)); 'just set it right now, may need 0.0 to properly seed random number generator


'Variables for colors dialog
var attendRGB%[3];
var ignore1RGB%[3];
var ignore2RGB%[3];
var ignore3RGB%[3];
var ignore4RGB%[3];
var noattenRGB%[3];
var attCueCircleContrastAttend%;
var attCueCircleContrastIgnore1%;
var attCueCircleContrastIgnore2%;
var attCueCircleContrastIgnore3%;
var attCueCircleContrastIgnore4%;

var attStartBlock%;
var attNoChangeCondition%;
var attSwapCueCircle%;
var attCueCircleStrokeWidth%;
var attUseFlashers%;
var attFlasherGratingParams$;
var attFlasherDur; 
var attFlasherTemporalBuffer;
var attFlasherSpatialBuffer;
var attFlasherMaxDist;
var attFlasherHazardValue;
var attFlasherWidth;
var attFlasherHeight;


var attCustomGratingColorCheck%;
var attCustomGratingColorStimFrom%[3];
var attCustomGratingColorStimTo%[3];
var attCustomGratingColorDistractorFrom%[3];
var attCustomGratingColorDistractorTo%[3];
var attCustomGratingDialogLabel%[6];  'make a vector, it's easier!

'var attLollipopCheck%;
'var attCueLinePct;
'var attCircleDiameterDiff;
'var attLollipopContrast%;
'var attLollipopStickContrast%;
'var attCueLineGap;
var attPhaseCheck%;
var attPhaseDeg%;
var Contrast$;
var Flashers$;

' Counter vars for attention script
var attCountAllTrials% := 0;
var attCountAllTrialsCorrect% := 0;
var attCountAllTrialsIncorrect% := 0;
var attCountAllTrialsAbort% := 0;
var attCountTowardTrials% := 0;
var attCountTowardTrialsCorrect% := 0;
var attCountTowardTrialsIncorrect% := 0;
var attCountTowardTrialsAbort% := 0;
var attCountAwayTrials% := 0;
var attCountAwayTrialsCorrect% := 0;
var attCountAwayTrialsIncorrect% := 0;
var attCountAwayTrialsAbort% := 0;
var attNoChangeAwayTrials% := 0;
var attCountNoChangeTrials% := 0;
var attCountNoChangeTrialsCorrect% := 0;
var attCountNoChangeTrialsIncorrect% := 0;
var attCountNoChangeTrialsAbort% := 0;
var attOnlyOneCatch% := 0;
var attOneCatchContrast% := 0;
var attUseLowReward% := 0;
var attLowReward% := 0;
var attCatchIsNoGo% := 0;


var lowRewardMS%;
var origRewardMS%;
const screenXmm := 400;
const screenYmm := 300;
var screenXmax;  'these are the borders of the screen in visual degrees
var screenYmax;
var xT;  'target x
var yT;  'target y
var wT;  'target width
var hT;  'target height
var xD1; 'distracter 1, etc.
var yD1;
var wD1;
var hD1;
var xD2;
var yD2;
var wD2;
var hD2;
var xD3;
var yD3;
var wD3;
var hD3;
var xD4;
var yD4;
var wD4;
var hD4;
var xF1; 'flasher 1, the x and y won't really be used but we need them to take dummy values from ParseGratingParametersBrief
var yF1;
var wF1;
var hF1;


' constants for dialog and check function - start with 10 because there are 9 dialog entries prior
' sure, it would be great if all the dialog numbers were done like this, but they ain't, and time is time
const attdlgAnsWindowRadius% := 12;
const attdlgTrainingContrastCheck% := 13;
const attdlgTrainingContrastPct% := 14;
const attdlgPhaseCheck% := 15;
const attdlgPhaseDeg% := 16;
'const attdlgLollipopCheck% := 14;  'these constant values obviously don't fly anymore, so if we bring it back re-assign them
'const attdlgCueLinePct% := 15;
'const attdlgCircleDiameterDiff% := 16;
'const attdlgLollipopContrast% := 17;
'const attdlgLollipopStickContrast% := 18;
'const attdlgLollipopStickGap := 19;
'const attdlgUseAnsWindow% := 20;
const attdlgOnlyOneCatch% := 17;
const attdlgOneCatchContrast% := 18;
const attdlgDoUncatch% := 19;
const attdlgNumPatches% := 20;
const attdlgGetGP% := 21;
const attdlgUseCueCircles% := 22;
const attdlgCueCircleExtraRadius% := 23;
const attdlgDistracterOffForEasy% := 24;
const attdlgStartBlock% := 25;
const attdlgNoChangeCondition% := 26;
const attdlgSwapCueCircle% := 27;
const attdlgUseLowReward% := 28;
const attdlgLowReward% := 29;
const attdlgCueCircleStrokeWidth% := 30;
const attdlgUseFlashers% := 31;
const attdlgCatchIsNoGo% := 32;
const attdlgDoOpto% := 33;

' constants for timing dialog
const atttimingdlgFixationCueMinTime% := 2;
const atttimingdlgFixationCueMaxTime% := 3;
const atttimingdlgHazardMinTime% := 4;
const atttimingdlgHazardExpMeanTime% := 5;
const atttimingdlgHazardCutoffTime% := 6;

' constants for color dialog
var attdlgColorIndexGray% := 0;
var attdlgColorIndexBlack% := 1;
var attdlgColorIndexWhite% := 2;
var attdlgColorIndexCustom% := 3;
var attcolorsdlgBackgroundColor% := 1;
var attcolorsdlgBackgroundRed% := 2;
var attcolorsdlgBackgroundGreen% := 3;
var attcolorsdlgBackgroundBlue% := 4;
var attcolorsdlgCueContrastAttend% := 5;
var attcolorsdlgCueContrastIgnore1% := 6;
var attcolorsdlgCueContrastIgnore2% := 7;
var attcolorsdlgCueContrastIgnore3% := 8;
var attcolorsdlgCueContrastIgnore4% := 9;
var attcolorsdlgCustomGratingColorCheck% := 10;
var attcolorsdlgCustomGratingColorStimFromRed% := 11;
var attcolorsdlgCustomGratingColorStimFromGreen% := 12;
var attcolorsdlgCustomGratingColorStimFromBlue% := 13;
var attcolorsdlgCustomGratingColorStimToRed% := 14;
var attcolorsdlgCustomGratingColorStimToGreen% := 15;
var attcolorsdlgCustomGratingColorStimToBlue% := 16;
var attcolorsdlgCustomGratingColorDistractorFromRed% := 17;
var attcolorsdlgCustomGratingColorDistractorFromGreen% := 18;
var attcolorsdlgCustomGratingColorDistractorFromBlue% := 19;
var attcolorsdlgCustomGratingColorDistractorToRed% := 20;
var attcolorsdlgCustomGratingColorDistractorToGreen% := 21;
var attcolorsdlgCustomGratingColorDistractorToBlue% := 22;
var attcolorsdlgCueCircleColorAttendR% := 23;
var attcolorsdlgCueCircleColorAttendG% := 24;
var attcolorsdlgCueCircleColorAttendB% := 25;
var attcolorsdlgCueCircleColorIgnore1R% := 26;
var attcolorsdlgCueCircleColorIgnore1G% := 27;
var attcolorsdlgCueCircleColorIgnore1B% := 28;
var attcolorsdlgCueCircleColorIgnore2R% := 29;
var attcolorsdlgCueCircleColorIgnore2G% := 30;
var attcolorsdlgCueCircleColorIgnore2B% := 31;
var attcolorsdlgCueCircleColorIgnore3R% := 32;
var attcolorsdlgCueCircleColorIgnore3G% := 33;
var attcolorsdlgCueCircleColorIgnore3B% := 34;
var attcolorsdlgCueCircleColorIgnore4R% := 35;
var attcolorsdlgCueCircleColorIgnore4G% := 36;
var attcolorsdlgCueCircleColorIgnore4B% := 37;
var attcolorsdlgCueCircleColorNoAttenR% := 38;
var attcolorsdlgCueCircleColorNoAttenG% := 39;
var attcolorsdlgCueCircleColorNoAttenB% := 40;


'variables for Henry's tuning curve version
const attMaxTrl% := 1000;
var attTrialOrder%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the test trials
var attCatchTrialOrder%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the catch trials
var attTrial[attMaxTrl%];       'this variable is really only here because GetRepeatedParameterProgression wants to fill it; we will ignore it
var attCurrTrialIndex%;         'We'll need to keep track of the current trial index
var attContrastList%[attMaxTrl%];  'A list of which contrast is being used on each trial, filled by CreateContrastList
var attChangeList%[attMaxTrl%];  'A list of which stimulus patch (1 = main, 2 = dist1, 3 = dist2, etc.) changes
var attValidList%[attMaxTrl%];     '1 if valid, 0 if catch trial, filled by CreateContrastList
var attAttendList%[attMaxTrl%];  'A list of which stimulus patch (1 = main, 2 = dist1, 3 = dist2, etc.) is being attended
var attHazardList[attMaxTrl%];     'holds hazard times, now pre-calculated
var attOffBitsList%[attMaxTrl%];  'A list of which stimulus patches are off for this trial, in a bit sum, 1 = main, 2 = dist1, 4 = dist2, etc.
var attRotationList%[attMaxTrl%]; 'A list of which rotation is being used for this trial
var attFixColor%[attMaxTrl%];     'A list of which color fixation point (as a number) is being used for this trial
var attBlockList%[attMaxTrl%];    'A list of which block a trial comes in - this is relative, useful for equalizing hazard times etc. across blocks
var attEasyList%[attMaxTrl%];     '1 if the trial is an easy trial, 0 if not - need to keep track of this because there are no flashers on easy trials
var thisContrast%;                 'for sampletexty stuff
var fixColor$;                  'more sampletexty stuff
var FAIsResponse%;              'if 1, use "response abort", otherwise use regular abort
var expectedAnswer%;            'keeps track of expected answer, saves a bunch of redundant code
'var useSpikeTemplate%;          'not sure where to put it, allows us to load up the most recent spike template, not used
'For fixation/cue colors, use a master list so we don't get a bunch of values redefined, and have to change them all if a change is made
var masterColorList$[6];  'human readable, updated to hold 6 (1 on-RF, 4 distractor, 1 No-change)
var masterColorListVSG$[6];  'VSG readable
const attMaxFlashers% := 30;  'use a maximum of 30 flashers per trial
var flasherTimes[attMaxTrl%][attMaxFlashers%];  'hold flasher times, this is 2-d because we can have multiple per trial
var flasherX[attMaxTrl%][attMaxFlashers%];  'hold flasher x position
var flasherY[attMaxTrl%][attMaxFlashers%];  'hold flasher y position
var flasherCount%[attMaxTrl%];  'hold number of flashers on each trial
var flasherCountThisTrial%;  'keep track of number of flashers played on the current trial


'we need to explicitly know the position of the gratings to place the answer windows on the gratings
var mainX;  'the main grating patch is expected to be the one located over the receptive field
var mainY;
var mainW;
var mainH;
var dist1X;  'there are also four possible distracters, these are set in config
var dist1Y;
var dist1W;
var dist1H;
var dist2X; 
var dist2Y;
var dist2W;
var dist2H;
var dist3X; 
var dist3Y;
var dist3W;
var dist3H;
var dist4X; 
var dist4Y;
var dist4W;
var dist4H;


' Optogenetics variables
var attPreStimOptoTime;
var attPostStimOptoTime;
var attOptoStaysOn%;  'this is currently disabled, Henry does not appear to want it under any circumstances
var attOptoVoltageOut;
var attOptoPctOpto;  'proportion (not percentage) of trials on which we do opto
var attOptoState% := 0;  'current opto state, will toggle (on a per-trial basis), can set here in dialog box
var attOptoStarted% := 0;  'keeps track of whether the opto is currently on
'var dontToggleOpto% := 0;  'by default, toggle opto on every block
var attOptoNPulses%;
var attPulsedOptoOnset;
var attPulsedOptoWidth;
var attPulsedOptoIPI;
var attPulsedOptoOnsetClockSteps%;
var attPulsedOptoOffsetClockSteps%;
var attPulsedOptoWidthClockSteps%;
var attPulsedOptoIPIClockSteps%;
var attDoOpto%;                     ' New, 1 if doing optogenetics
var attOptoUsePulse% := 0;  'Are we using a "pulsing stimulation"?
var attLaserDiode% := 0;  'Are we recording the output of the laser using a photodiode?
var attInterBlockTime := 0;        ' New, time between blocks, important for opto
var SequencerPeriodMS;
var DigitalLaserChannel%;
var OptoCopyChannel%;

var autoNameTemplate$;

proc GetAttentionScriptParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
	Profile(key$, "NumberOfBlocks", 1, attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", 1, attTrialsPerBlock%);
    Profile(key$, "EasyTrialsPerBlock", 1, attEasyTrialsPerBlock%);
    Profile(key$, "DistracterOffForEasy", 1, distracterOffForEasy%);
    Profile(key$, "DoUncatch", 1, attDoUncatch%);
    Profile(key$, "NumPatches", 1, attNumPatches%);
    Profile(key$, "UseFlashers", 1, attUseFlashers%);
    Profile(key$, "GetGPFromMainStim", 1, attGetGPFromMainStim%);
    Profile(key$, "UseCueCircles", 1, attUseCueCircles%);
    Profile(key$, "CueCircleExtraRadius", "0.0", stmp$);
    attCueCircleExtraRadius := val(stmp$);
	Profile(key$, "CatchTrialPercentage", "0.0", stmp$);
	attCatchTrialPercentage := val(stmp$);
    Profile(key$, "NoGoTrialPercentage", "0.0", stmp$);
	attNoGoTrialPercentage := val(stmp$);
	Profile(key$, "BlockAlternate", 1, attBlockAlternate%);
    Profile(key$, "NoBlockRand", 1, attSelectRandomContrastEachTrial%);
	Profile(key$, "TrainingContrastCheck", 0, attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", 0, attTrainingContrastPct%);
    Profile(key$, "OnlyOneCatch", 0, attOnlyOneCatch%);
    Profile(key$, "OneCatchContrast", 0, attOneCatchContrast%);

    
    Profile(key$, "ContrastBase", 50, attContrastBase%);
	'Profile(key$, "ContrastMax", 80, attMaxContChange);  ;now reals, have to do pull a string and convert
	'Profile(key$, "ContrastMin", 20, attMinContChange);
    Profile(key$, "NContrastLevels", 20, attNContLevels%);
    
    
    Profile(key$, "ContrastMax", "1", stmp$);
	attMaxContChange := val(stmp$);
    
    Profile(key$, "ContrastMin", "1", stmp$);
	attMinContChange := val(stmp$);
    
	Profile(key$, "AnswerPointDiameter", "0.5", stmp$);
	attAnswerPointDiameter := val(stmp$);
    
	Profile(key$, "AnswerPointOffset", "5.0", stmp$);
	attAnswerPointOffset := val(stmp$);
    
	Profile(key$, "AnswerPointWindowRadius", "2.0", stmp$);
	attAnswerPointWindowRadius := val(stmp$);
   
    Profile(key$, "NoChangeCondition", 0, attNoChangeCondition%);
    Profile(key$, "SwapCueCircle", 0, attSwapCueCircle%);
    Profile(key$, "CueCircleStrokeWidth", 0, attCueCircleStrokeWidth%);
    
    Profile(key$, "UseLowReward", 0, attUseLowReward%);
    Profile(key$, "LowReward", 0, attLowReward%);
    
    Profile(key$, "CatchIsNoGo", 0, attCatchIsNoGo%);

    Profile(key$, "DoOpto", 0, attDoOpto%);
    
	'Profile(key$, "LollipopCheck", 0, attLollipopCheck%);
	'Profile(key$, "CueLinePct", "100.0", stmp$);
    'attCueLinePct := val(stmp$);
    'Profile(key$, "CircleDiameterDiff", "0.1", stmp$);
    'attCircleDiameterDiff := val(stmp$);
    'Profile(key$, "LollipopContrast", 100, attLollipopContrast%);
    'Profile(key$, "LollipopStickContrast", 100, attLollipopStickContrast%);
	'Profile(key$, "CueLineGap", "0.5", stmp$);
    'attCueLineGap := val(stmp$);
    
    Profile(key$, "DoPhase", 1, attPhaseCheck%);
    Profile(key$, "PhaseDeg", 1, attPhaseDeg%);
    
end;

proc SaveAttentionScriptParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
    
	Profile(key$, "NumberOfBlocks", attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", attTrialsPerBlock%);
    Profile(key$, "EasyTrialsPerBlock", attEasyTrialsPerBlock%);
    Profile(key$, "DistracterOffForEasy", distracterOffForEasy%);
    Profile(key$, "DoUncatch", attDoUncatch%);
    Profile(key$, "NumPatches", attNumPatches%);
    Profile(key$, "UseFlashers", attUseFlashers%);
    Profile(key$, "GetGPFromMainStim", attGetGPFromMainStim%);
    Profile(key$, "UseCueCircles", attUseCueCircles%);
    Profile(key$, "CueCircleExtraRadius", str$(attCueCircleExtraRadius));
	Profile(key$, "CatchTrialPercentage", str$(attCatchTrialPercentage));
    Profile(key$, "NoGoTrialPercentage", str$(attNoGoTrialPercentage));
	Profile(key$, "BlockAlternate", attBlockAlternate%);
    Profile(key$, "NoBlockRand", attSelectRandomContrastEachTrial%);
	Profile(key$, "TrainingContrastCheck", attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", attTrainingContrastPct%);
    Profile(key$, "OnlyOneCatch", attOnlyOneCatch%);
    Profile(key$, "OneCatchContrast", attOneCatchContrast%);
	Profile(key$, "ContrastBase", attContrastBase%);
	Profile(key$, "ContrastMax", str$(attMaxContChange));
	Profile(key$, "ContrastMin", str$(attMinContChange));
    Profile(key$, "NContrastLevels", attNContLevels%);
	Profile(key$, "AnswerPointDiameter", str$(attAnswerPointDiameter));
	Profile(key$, "AnswerPointOffset", str$(attAnswerPointOffset));
	Profile(key$, "AnswerPointWindowRadius", str$(attAnswerPointWindowRadius));
    'Profile(key$, "AnswerPointWindowRadius", str$(1.5));
    Profile(key$, "NoChangeCondition", attNoChangeCondition%);
    Profile(key$, "SwapCueCircle", attSwapCueCircle%);  
    Profile(key$, "CueCircleStrokeWidth", attCueCircleStrokeWidth%);
    Profile(key$, "UseLowReward", attUseLowReward%);
    Profile(key$, "LowReward", attLowReward%);  
    Profile(key$, "CatchIsNoGo", attCatchIsNoGo%);    
    Profile(key$, "DoOpto", attDoOpto%); 
    
	'Profile(key$, "LollipopCheck", attLollipopCheck%);
	'Profile(key$, "CueLinePct", str$(attCueLinePct));
    'Profile(key$, "CircleDiameterDiff", str$(attCircleDiameterDiff));
    'Profile(key$, "LollipopContrast", attLollipopContrast%);
    'Profile(key$, "LollipopContrast", attLollipopContrast%);
    'Profile(key$, "LollipopStickContrast", attLollipopStickContrast%);
	'Profile(key$, "CueLineGap", str$(attCueLineGap));
    
    Profile(key$, "DoPhase", attPhaseCheck%);
    Profile(key$, "PhaseDeg", attPhaseDeg%);

    
end;



proc GetTimingDialogParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
    
	Profile(key$, "FixationCueMinTime", "1.0", stmp$);
	attFixationCueMinTime := val(stmp$);
    
	Profile(key$, "FixationCueMaxTime", "1.0", stmp$);
	attFixationCueMaxTime := val(stmp$);
    
    '	Profile(key$, "WhitePointTime", "1.0", stmp$);
    '	attWhitePointTime := val(stmp$);
    
	Profile(key$, "HazardMinTime", "0.5", stmp$);
	attHazardMinTime := val(stmp$);
    
	Profile(key$, "HazardExpMeanTime", "1.0", stmp$);
	attHazardExpMeanTime := val(stmp$);
    
   	Profile(key$, "HazardCutoffTime", "5.0", stmp$);
	attHazardCutoffTime := val(stmp$);
    
	Profile(key$, "AcquisitionTime", "1.0", stmp$);
	attAcquisitionTime := val(stmp$);
    
	Profile(key$, "InterTrialTime", "1.0", stmp$);
	attInterTrialTime := val(stmp$);
    
	Profile(key$, "TimeToAnswer", "1.0", stmp$);
	attTimeToAnswer := val(stmp$);
    
    Profile(key$, "NoChangeDuration", "1.0", stmp$);
	attNoChangeDuration := val(stmp$);
    
	Profile(key$, "AbortWaitTime", "1.0", stmp$);
	attAbortWaitTime := val(stmp$);
    
    Profile(key$, "MissPenalty", "1.0", stmp$);
	attMissPenalty := val(stmp$);
    
    Profile(key$, "FalseAlarmWaitTime", "1.0", stmp$);
	attFalseAlarmWaitTime := val(stmp$);
    
    Profile(key$, "FalseAlarmCheckWindow", "1.0", stmp$);
	attFalseAlarmCheckWindow := val(stmp$);
    
end;

proc SaveTimingDialogParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
	Profile(key$, "FixationCueMinTime", str$(attFixationCueMinTime));
	Profile(key$, "FixationCueMaxTime", str$(attFixationCueMaxTime));
    '	Profile(key$, "WhitePointTime", str$(attWhitePointTime));
	Profile(key$, "HazardMinTime", str$(attHazardMinTime));
	Profile(key$, "HazardExpMeanTime", str$(attHazardExpMeanTime));
    Profile(key$, "HazardCutoffTime", str$(attHazardCutoffTime));
	Profile(key$, "AcquisitionTime", str$(attAcquisitionTime));
	Profile(key$, "AbortWaitTime", str$(attAbortWaitTime));
    Profile(key$, "MissPenalty", str$(attMissPenalty));
    Profile(key$, "FalseAlarmWaitTime", str$(attFalseAlarmWaitTime));
    Profile(key$, "FalseAlarmCheckWindow", str$(attFalseAlarmCheckWindow));
	Profile(key$, "InterTrialTime", str$(attInterTrialTime));
	Profile(key$, "TimeToAnswer", str$(attTimeToAnswer));
    Profile(key$, "NoChangeDuration", str$(attNoChangeDuration));
    
end;



proc GetColorsDialogParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    

	Profile(key$, "BackgroundColor", "gray", attBackgroundColor$);
    
    
    if InStr(attBackgroundColor$, "(") = 1 then
        if ParseColor%(attBackgroundColor$, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%) <> 0 then
            attBackgroundColor$ := "gray";
        endif
    endif
    

    Profile(key$, "CueCircleContrastStim", 0, attCueCircleContrastAttend%);
    Profile(key$, "CueCircleContrastD1", 0, attCueCircleContrastIgnore1%);
    Profile(key$, "CueCircleContrastD2", 0, attCueCircleContrastIgnore2%);
    Profile(key$, "CueCircleContrastD3", 0, attCueCircleContrastIgnore3%);
    Profile(key$, "CueCircleContrastD4", 0, attCueCircleContrastIgnore4%);
    Profile(key$, "CustomGratingColorsCheck", 0, attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", 0, attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", 0, attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", 0, attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", 255, attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", 255, attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", 255, attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", 0, attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", 0, attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", 0, attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", 255, attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", 255, attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", 255, attCustomGratingColorDistractorTo%[2]);
    Profile(key$, "CueCircleColorAttendR", 0, attendRGB%[0]);
    Profile(key$, "CueCircleColorAttendG", 0, attendRGB%[1]);
    Profile(key$, "CueCircleColorAttendB", 0, attendRGB%[2]);
    Profile(key$, "CueCircleColorIgnore1R", 0, ignore1RGB%[0]);
    Profile(key$, "CueCircleColorIgnore1G", 0, ignore1RGB%[1]);
    Profile(key$, "CueCircleColorIgnore1B", 0, ignore1RGB%[2]);
    Profile(key$, "CueCircleColorIgnore2R", 0, ignore2RGB%[0]);
    Profile(key$, "CueCircleColorIgnore2G", 0, ignore2RGB%[1]);
    Profile(key$, "CueCircleColorIgnore2B", 0, ignore2RGB%[2]);
    Profile(key$, "CueCircleColorIgnore3R", 0, ignore3RGB%[0]);
    Profile(key$, "CueCircleColorIgnore3G", 0, ignore3RGB%[1]);
    Profile(key$, "CueCircleColorIgnore3B", 0, ignore3RGB%[2]);
    Profile(key$, "CueCircleColorIgnore4R", 0, ignore4RGB%[0]);
    Profile(key$, "CueCircleColorIgnore4G", 0, ignore4RGB%[1]);
    Profile(key$, "CueCircleColorIgnore4B", 0, ignore4RGB%[2]);
    Profile(key$, "CueCircleColorNoAttenR", 0, noattenRGB%[0]);
    Profile(key$, "CueCircleColorNoAttenG", 0, noattenRGB%[1]);
    Profile(key$, "CueCircleColorNoAttenB", 0, noattenRGB%[2]);
    
end;

proc SaveColorsDialogParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    

	Profile(key$, "BackgroundColor", attBackgroundColor$);
    Profile(key$, "CueCircleContrastStim", attCueCircleContrastAttend%);
    Profile(key$, "CueCircleContrastD1", attCueCircleContrastIgnore1%);
    Profile(key$, "CueCircleContrastD2", attCueCircleContrastIgnore2%);
    Profile(key$, "CueCircleContrastD3", attCueCircleContrastIgnore3%);
    Profile(key$, "CueCircleContrastD4", attCueCircleContrastIgnore4%);  
    Profile(key$, "CustomGratingColorsCheck", attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", attCustomGratingColorDistractorTo%[2]);
    Profile(key$, "CueCircleColorAttendR", attendRGB%[0]);
    Profile(key$, "CueCircleColorAttendG", attendRGB%[1]);
    Profile(key$, "CueCircleColorAttendB", attendRGB%[2]);
    Profile(key$, "CueCircleColorIgnore1R", ignore1RGB%[0]);
    Profile(key$, "CueCircleColorIgnore1G", ignore1RGB%[1]);
    Profile(key$, "CueCircleColorIgnore1B", ignore1RGB%[2]);
    Profile(key$, "CueCircleColorIgnore2R", ignore2RGB%[0]);
    Profile(key$, "CueCircleColorIgnore2G", ignore2RGB%[1]);
    Profile(key$, "CueCircleColorIgnore2B", ignore2RGB%[2]);
    Profile(key$, "CueCircleColorIgnore3R", ignore3RGB%[0]);
    Profile(key$, "CueCircleColorIgnore3G", ignore3RGB%[1]);
    Profile(key$, "CueCircleColorIgnore3B", ignore3RGB%[2]);
    Profile(key$, "CueCircleColorIgnore4R", ignore4RGB%[0]);
    Profile(key$, "CueCircleColorIgnore4G", ignore4RGB%[1]);
    Profile(key$, "CueCircleColorIgnore4B", ignore4RGB%[2]);
    Profile(key$, "CueCircleColorNoAttenR", noattenRGB%[0]);
    Profile(key$, "CueCircleColorNoAttenG", noattenRGB%[1]);
    Profile(key$, "CueCircleColorNoAttenB", noattenRGB%[2]);

    
end;





func AttentionScriptDialog%()
	var i%;
    var tempNBlocks%;
    var tempTotal;  'friggin integer math
    var tempWhoops;
    var fiveints%[5];
    var tenmoreints%[10];
    var blockAlternateList$[3];
    var blockStartList$[7];
    var cueCircleList$[3];
    
    GetAttOptoParameters();  'We must get these or the user has to open the opto dialog every time.
'    docase 'And recalculate tunOptoState, in case the user doesn't click on opto parameters button
'    case attOptoStartState% = 3 then
'        dontToggleOpto% := 1;
'        attOptoState% := 1;
'    case attOptoStartState% = 2 then
'        attOptoState% := round(Rand());
'    else
'        attOptoState% := attOptoStartState%;
'    endcase;
    
    
    blockAlternateList$[0] := "Randomize cue type by trial";
    blockAlternateList$[1] := "Randomize cue type by block";
    blockAlternateList$[2] := "Alternate cue type by block";
    
    blockStartList$[0] := "Start Block: Random";
    blockStartList$[1] := "Start Block: Attend-Toward";
    blockStartList$[2] := "Start Block: Distracter 1";
    blockStartList$[3] := "Start Block: Distracter 2";
    blockStartList$[4] := "Start Block: Distracter 3";
    blockStartList$[5] := "Start Block: Distracter 4";
    blockStartList$[6] := "Start Block: No Change";
    
    cueCircleList$[0] := "No Cue Circles";
    cueCircleList$[1] := "Cue Circles";
    cueCircleList$[2] := "Cue Circles + Cue Points";
    
	GetAttentionScriptParameters();
    GetColorsDialogParameters();  'we need to GET the parameters here, even though we may not use any of them...but we WILL use backgroundColor$, that's why
    GetTimingDialogParameters();  'this too...
    GetFlasherDialogParameters(); 'and this...
    CreateMasterColorLists();  'and this...
    
    fiveints%[0] := attOnlyOneCatch%;
    fiveints%[1] := attOneCatchContrast%;
    fiveints%[2] := attDoUncatch%;
    fiveints%[3] := attNumPatches%;
    fiveints%[4] := attGetGPFromMainStim%;
    
    tenmoreints%[0] := distracterOffForEasy%;
    tenmoreints%[1] := attStartBlock%;
    tenmoreints%[2] := attNoChangeCondition%;
    tenmoreints%[3] := attSwapCueCircle%; 
    tenmoreints%[4] := attUseLowReward%;
    tenmoreints%[5] := attLowReward%;
    tenmoreints%[6] := attCueCircleStrokeWidth%;
    tenmoreints%[7] := attUseFlashers%;
    tenmoreints%[8] := attCatchIsNoGo%;
    tenmoreints%[9] := attDoOpto%;
    
    
    
    
	DlgCreate("Attention Training Parameters",30,10);   'on Spike2 v6, must extend height, on v8, will auto-extend height
    DlgGroup("Blocks", 1, 1, 34, 11);
	DlgInteger(1, "Number of Blocks:", 1, 1000, 22, 2);
	DlgInteger(2, "Reg. Trials per block:", 1, 1000, 22, 3);
    DlgInteger(3, "Easy Trials per block:", 0, 1000, 22, 4);
    DlgCheck(attdlgDistracterOffForEasy%, "Distracter Off for Easy Trials", 2, 5);
	DlgReal(4, "Catch Trial pct (0-100)", 0, 100, 22, 6);
    DlgCheck(attdlgDoUncatch%, "Use 'Uncatch' trials at same %age", 2, 7);
    DlgReal(5, "No-Go Trial pct (0-100)", 0, 100, 22, 8);
	'DlgCheck(6, "Alternate cue type by block", 2, 9);
    DlgList(6, 30, blockAlternateList$[], 3, 4, 9);
    DlgCheck(7, "Select random contrast each trial", 2, 10);  '"Do NOT randomize by block"
    DlgList(attdlgStartBlock%, 30, blockStartList$, 7, 4, 11);  'I put it in, don't want to take it out just because it does nothing, in principle it can be repurposed easier than it can be removed (the whole fourmoreints thing)
    
    'Moving this group to the right, so we have to use DlgText because otherwise CED justifies the text all the way left
    DlgGroup("Contrast",36,1,34,11);
    DlgInteger(8, "", 0, 100, 56, 2);  DlgText("Base contrast (%)",37,2);
	DlgReal(9, "", 0, 10, 56, 3);  DlgText("Max dContrast (oct)",37,3);
	DlgReal(10, "", 0, 10, 56, 4);  DlgText("Min dContrast (oct)",37,4);
    DlgInteger(11, "", 1, 10, 56, 5);  DlgText("N contrast levels",37,5);
    DlgReal(attdlgAnsWindowRadius%, "", -1, 10, 56, 6);  DlgText("Ans. window rad. (deg)",37,6);
	DlgCheck(attdlgTrainingContrastCheck%, "Training Contrast", 37, 7);
	DlgInteger(attdlgTrainingContrastPct%, "", 0, 100, 56, 8);  DlgText("Training Contrast(%)",37,8);
    DlgCheck(attdlgOnlyOneCatch%, "Use only one catch value", 37,9);
    DlgInteger(attdlgOneCatchContrast%,"",0,100,56,10);  DlgText("Single Catch Cont (%)",37,10);
    DlgCheck(attdlgNoChangeCondition%, "Include no-change condition", 37, 11);  
    
    DlgGroup("Phase", 1, 12, 34, 3);
    DlgCheck(attdlgPhaseCheck%, "Set phase at contrast change", 2, 13);
	DlgInteger(attdlgPhaseDeg%, 7, 0, 360, 27, 14);  DlgText("Phase at cc (deg, 0 = white)",2,14);
    DlgCheck(attdlgUseFlashers%, "Use Flashers", 2, 15);
    
    DlgGroup("Stimuli", 36, 12, 34, 4);
    DlgInteger(attdlgNumPatches%, 10, 1, 5, 58, 13); DlgText("Num of grating patches",37,13);
    DlgCheck(attdlgGetGP%, "Get distracter params from main stim", 37, 14);
    DlgCheck(attdlgUseFlashers%, "Use Flashers", 37, 15);
    
    DlgGroup("Cue Circles", 1, 15, 34, 5);
    'DlgCheck(attdlgUseCueCircles%, "Use Cue Circles", 2, 16);
    DlgList(attdlgUseCueCircles%, 30, cueCircleList$[], 3, 4, 16);
    DlgCheck(attdlgSwapCueCircle%, "Swap Cue Circles (if used)", 2, 17);
	DlgReal(attdlgCueCircleExtraRadius%, "Cue extra radius (deg)", 0, 5, 22, 18);
    DlgInteger(attdlgCueCircleStrokeWidth%, 4, 0, 20, 30, 19); DlgText("Cue Circle Stroke Width (integer)",2,19);
    
    
    DlgGroup("Reward", 36, 16, 34, 4);
    DlgCheck(attdlgUseLowReward%, "Use Low Reward For No-Change Trls", 37, 17);
    DlgInteger(attdlgLowReward%, 10, 1, 1000, 58, 18); DlgText("Low Reward (ms)",37,18);
    DlgCheck(attdlgCatchIsNoGo%, "Treat Catch as No-Go", 37, 19);
    
    DlgGroup("Optogenetics", 1, 20, 68, 2);
    DlgCheck(attdlgDoOpto%,"Opto On",2,21);
    DlgButton(5, "Optogenetics Parameters", AttOptoDialog%, 36, 21);
    
    DlgButton(2, "Colors", ColorsDialog%, 2+36, 23);
    DlgButton(3, "Timing", TimingDialog%, 11+36, 23);  
    DlgButton(4, "Flashers", CallDlgGratingFlashers%, 21+36, 23);  'temporarily directs to TimingDialog%
    'DlgGroup("Lollipops", 1, 18, 34, 7);
    'DlgCheck(attdlgLollipopCheck%, "Use lollipop cues", 2, 19);
    'DlgReal(attdlgCueLinePct%, "Cue line %", 0, 100, 22, 20);
    'DlgReal(attdlgCircleDiameterDiff%, "Circle diameter diff", 0, 10, 22, 21);
    'DlgInteger(attdlgLollipopContrast%, "Lollipop contrast", 0, 100, 22, 22);
    'DlgInteger(attdlgLollipopStickContrast%, "Stick contrast", 0, 100, 22, 23);
    'DlgReal(attdlgLollipopStickGap, "Lollipop stick gap", 0, 10, 22, 24);
    DlgAllow(0, 0, AttentionScriptDialogChanged%);
	i%:=DlgShow(attNumberOfBlocks%, attTrialsPerBlock%, attEasyTrialsPerBlock%, attCatchTrialPercentage, attNoGoTrialPercentage, 
    attBlockAlternate%, attSelectRandomContrastEachTrial%, attContrastBase%, attMaxContChange, attMinContChange, attNContLevels%,
    attAnswerPointWindowRadius, attTrainingContrastCheck%, attTrainingContrastPct%, attPhaseCheck%, attPhaseDeg%, fiveints%[], 
    attUseCueCircles%,attCueCircleExtraRadius,tenmoreints%);
    
    'attLollipopCheck%, attCueLinePct, attCircleDiameterDiff, 
    'attLollipopContrast%, attLollipopStickContrast%, attCueLineGap);
    
	if i% = 1 then
        '	attBackgroundColor$ := bcl$[ibcl%];
        
        'put fiveints values back into variables
        attOnlyOneCatch% := fiveints%[0];
        attOneCatchContrast% := fiveints%[1];
        attDoUncatch% := fiveints%[2];
        attNumPatches% := fiveints%[3];
        attGetGPFromMainStim% := fiveints%[4];
        
        'put sixmoreints values back into variables
        distracterOffForEasy% := tenmoreints%[0];
        attStartBlock% := tenmoreints%[1];
        attNoChangeCondition% := tenmoreints%[2];
        attSwapCueCircle% := tenmoreints%[3];
        attUseLowReward% := tenmoreints%[4];
        attLowReward% := tenmoreints%[5];
        attCueCircleStrokeWidth% := tenmoreints%[6];
        attUseFlashers% := tenmoreints%[7];
        attCatchIsNoGo% := tenmoreints%[8];
        attDoOpto% := tenmoreints%[9];
        
        
        'Check values of attStartBlock% for legality
        docase
        case attStartBlock% = 6 then
            if attNoChangeCondition% = 0 then
                message("Error: No Change was selected as the start block, but 'No Change' is OFF!!!");
                Quit%();
            endif
        case attStartBlock% > 1 and attNumPatches% < attStartBlock% then
            message("Error: The requested start block is for an undefined distracter!!!  Check 'number of patches'!");
            Quit%();
        endcase
        
        'randBlockOrderVar is a variable which allows us to alternate between attend-toward and random attend-away blocks
        'and indicates which comes first.  But if we set a start block, then we know which comes first, so override it
        docase
        case attStartBlock% = 1 then
            randBlockOrderVar% := 1;
        case attStartBlock% > 1 then
            randBlockOrderVar% := 0;
        endcase
        
        
        'set low reward if we are using it
        if attUseLowReward% = 1 then
            lowRewardMS% := attLowReward%;
        else
            lowRewardMS% := origRewardMS%;
        endif;
        
        
        'put twoints values back into variables
        'attUseCueCircles% := twoints%[0];
        'attCueCircleExtraRadius% := twoints%[1];
        
        'If we are doing the Uncatch trials, set UncatchTrialPercentage to 2x CatchTrialPercentage
        'The logic here is:  case rand < catch, then catch; case rand < uncatch, then uncatch
        'When uncatch = catch, there will be no uncatch; when uncatch = 2x catch, there will be the
        'same number of each.
        
        if attDoUncatch% = 1 and attOnlyOneCatch% = 1 then
            attUncatchTrialPercentage := 2*attCatchTrialPercentage;
        else
            attUncatchTrialPercentage := 0;'attCatchTrialPercentage; 'hja_edit
        endif;
        'sanity check
        if attUncatchTrialPercentage > 100 then
            message("Error: Catch Trials + Uncatch Trials > 100%!!!");
            Quit%();
        endif;
        
        if attMinContChange > attMaxContChange then
            message("The maximum contrast change must be MORE than the minimum!  Swapping!");
            tempWhoops := attMinContChange;
            attMinContChange := attMaxContChange;
            attMaxContChange := tempWhoops;
        endif;
        
		SaveAttentionScriptParameters();
        
        'After saving parameters, set phase to -1 if we are not controlling it
        if attPhaseCheck% = 0 then
            attPhaseDeg% := -1;
        endif;
        
        'After saving parameters, ensure no hang if catch trials are requested for a single patch
        if attNumPatches% = 1 and attCatchTrialPercentage > 0 then
            attCatchTrialPercentage := 0;
            message("You have tried to have a non-zero percentage of catch trials, but there is only one patch.\nNo catch trial is possible, so percentage of catch trials is being set to zero!");
        endif;
        
        'if we aren't alternating cues by block, then "easy" trials don't make any sense
        'I'm doing this after the parameter save so that the actual Easy Trials value sticks around as default in this event
        if attBlockAlternate% = 0 then
            attEasyTrialsPerBlock% := 0;
        endif;
        
        'get contrast list
        if attNContLevels% > 1 and attContrastBase% > 0 then  'if base contrast is zero, then the contrast list will be all zeros anyway, do nothing (rather than break GetLogProgression)
            GetLogProgression(attContrastBase%*(pow(2,attMinContChange)),attContrastBase%*(pow(2,attMaxContChange)),attNContLevels%-1,attContrastList[0:attNContLevels%]);  'levels above base
            Arrconst(attContrastList[attNContLevels%:attNContLevels%],attContrastBase%);  'for no-go, assign the second half of stimuli as identical to the base contrast
            round(attContrastList[]);  'we can only use integer values in the VSG call
        else
            'if only one value is requested, this will crash GetLogProgression, so just do it manually
            attContrastList[0] := attContrastBase%*(pow(2,attMaxContChange));
            attContrastList[1] := attContrastBase%;  'for go/no-go, use the base, not a down contrast
            
            'Henry does not want this warning
            'message("Note that only one contrast level was requested, using MAX as actual value!");
        endif;
        
        'get number of trials to run, which is hypothetical "max" number for both test trials and catch trials regardless of catch/test percentage
        tempTotal := attNumberOfBlocks%*attTrialsPerBlock%;  'total number of non-"easy" trials
        tempNBlocks% := ceil(tempTotal/(attNContLevels%));  'MAXIMUM number of times we have to repeat the tuning curve to reach the total number of trials, if 0 no-go trials
        
        printlog("number of contrast levels is %d and tempnblocks is %d\n",attNContLevels%,tempNBlocks%);
        
        'It's a bit tricky to try to push the idea of variable No-Go percentage (as opposed to 50%) into the GetRepeatedParameterProgression
        'schematic, but I think I've got a plan.
        'First step - create a list of contrasts as normal in a temporary variable, but only include "go" contrasts 
        if attSelectRandomContrastEachTrial% = 0 then
            'get trial order, attTrialOrder%[] will hold indices into attContrastList[] for all trials
            GetRepeatedParameterProgression%(attNContLevels%,tempNBlocks%,attTrial[],attTrialOrder%[],0,(attNContLevels%)-1,0,1);  'this has only Go contrasts
        else 'Henry sez just do true random, selects a random contrast level for every trial for the entire experiment
            Rand(attTrialOrder%[0:attNContLevels%*tempNBlocks%],attNContLevels%);  'this has only the Go contrast
        endif;   

        'The below line will assign only GO trials as catch trials
        GetRepeatedParameterProgression%(attNContLevels%,tempNBlocks%,attTrial[],attCatchTrialOrder%[],0,attNContLevels%-1,0,1);
        
        
        'Commented out - useful for testing the creation of the trial order
        var Contrast$;
        CreateContrastList(Contrast$,Flashers$,attContrastList%,attChangeList%,attValidList%,attAttendList%,attHazardList,attOffBitsList%,attRotationList%,attFixColor%,attBlockList%,attEasyList%,flasherTimes,flasherX,flasherY,flasherCount%);
        'var specFileName$:="E:\\AttentionSpecFile.txt";
        'var specHandle%;
        'specHandle% := FileOpen(specFileName$, 8, 1);
        ''print to spec file
        'Print("%s",Contrast$);  'file should be everything starting from FixationArg$ on
        ''close spec file
        'FileClose(0);
        'printlog("Temp trial order list is %d\n",attTrialOrderTemp%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("Contrast list is %d\n",attContrastList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("Valid list is %d\n",attValidList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("contrasts are %d\n",attContrastList[]);
        'halt;
	endif;
	return i%;
end;


func ParseColor%(s$, &r%, &g%, &b%)
    var status% := -1;
    var n;
    ReadSetup("", "/(", "(", ")");
    n := ReadStr(s$, r%, g%, b%);
    ReadSetup();
    if n = 3 then
        status% := 0;
    endif
    return status%;
end

func EncodeColor$(r%, g%, b%)
    var s$;
    s$ := Print$("(%d/%d/%d)", r%, g%, b%);
    return s$;
end


' Called when items in attention script dialog change. WARNING: The item #s are coded as constants
' If format of dialog changes then those constants should be changed. 

func AttentionScriptDialogChanged%(item%)
    var status% := 1;
    
    docase
    case item% = attdlgTrainingContrastCheck% then
        DlgEnable(DlgValue(attdlgTrainingContrastCheck%), attdlgTrainingContrastPct%);
    case item% = attdlgOnlyOneCatch% then
        DlgEnable(DlgValue(attdlgOnlyOneCatch%), attdlgOneCatchContrast%);
        DlgEnable(DlgValue(attdlgOnlyOneCatch%), attdlgDoUncatch%);
    case item% = attdlgPhaseCheck% then
        DlgEnable(DlgValue(attdlgPhaseCheck%), attdlgPhaseDeg%);
'    case item% = attdlgLollipopCheck% then
'        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgCircleDiameterDiff%);
'        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgCueLinePct%);
        '        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgLollipopContrast%);
    case item% = attdlgUseCueCircles% then
        DlgEnable(DlgValue(attdlgUseCueCircles%), attdlgCueCircleExtraRadius%);
    case item% = attdlgUseLowReward% then
        DlgEnable(DlgValue(attdlgUseLowReward%), attdlgLowReward%);
    case item% = attdlgUseFlashers% then
        DlgEnable(DlgValue(attdlgUseFlashers%),-4);
    case item% = 0 then
        DlgEnable(attTrainingContrastCheck%, attdlgTrainingContrastPct%);
        DlgEnable(attPhaseCheck%, attPhaseDeg%);
        DlgEnable(attOnlyOneCatch%, attdlgOneCatchContrast%);
        DlgEnable(attOnlyOneCatch%, attdlgDoUncatch%);
        DlgEnable(attdlgUseCueCircles%, attdlgCueCircleExtraRadius%);
        DlgEnable(DlgValue(attdlgUseLowReward%), attdlgLowReward%);
        'DlgEnable(0,attdlgAnsWindowRadius%);  'Turn off answer window radius, it is currently unused, OK, now it is used
        DlgEnable(DlgValue(attdlgUseFlashers%),-4);
'        DlgEnable(attLollipopCheck%, attdlgCircleDiameterDiff%);
'        DlgEnable(attLollipopCheck%, attdlgCueLinePct%);
'        DlgEnable(attLollipopCheck%, attdlgLollipopContrast%);
    endcase
    return status%;
end


func TimingDialog%()
    var i%;
    
    GetTimingDialogParameters();
    
	DlgCreate("Attention timing", 25, 10);
	DlgReal(1, "Acquisition time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMinTime%, "Fixation cue min time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMaxTime%, "Fixation cue max time(s):", .01, 10);  'We will presumably lose the ability to have a variable stimulus onset time when the animation is implemented
	DlgReal(atttimingdlgHazardMinTime%, "Hazard min time(s):", 0, 10);
	DlgReal(atttimingdlgHazardExpMeanTime%, "Hazard exp mean time(s):", 0, 10);
	DlgReal(atttimingdlgHazardCutoffTime%, "Hazard cutoff time(s):", 0, 10);
	DlgReal(7, "Time to answer(s):", 0.01, 10.0);
    DlgReal(8, "No-Change duration(s):", 0.2, 10.0);
	DlgReal(9, "Intertrial time(s):", .01, 10);
	DlgReal(10, "Abort wait time(s):", .01, 10);
    DlgReal(11, "False Alarm penalty time(s):", .01, 100);  'I'll let that be really really long
    DlgReal(12, "False Alarm check window(s): ", .01, 1);
    DlgReal(13, "Miss penalty time(s): ", 0, 100);
    
    DlgAllow(0, 0, TimingDialogChanged%);
	i%:=DlgShow(attAcquisitionTime, attFixationCueMinTime, attFixationCueMaxTime, 
    attHazardMinTime, attHazardExpMeanTime, attHazardCutoffTime, attTimeToAnswer, attNoChangeDuration,
    attInterTrialTime, attAbortWaitTime,attFalseAlarmWaitTime,attFalseAlarmCheckWindow,attMissPenalty);
    if i% = 1 then
        if attAbortWaitTime < attFalseAlarmCheckWindow then
            message("False Alarm Check Window is longer than Abort Wait Time!");
            message("Reducing window to be equal to Abort Wait Time!");
            attFalseAlarmCheckWindow := attAbortWaitTime;
        endif;
        
        SaveTimingDialogParameters();
        
    endif;
    return 1;
end


func TimingDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = atttimingdlgFixationCueMinTime% or item% = atttimingdlgFixationCueMaxTime% then
        ' max >= min
        if DlgValue(atttimingdlgFixationCueMinTime%) > DlgValue(atttimingdlgFixationCueMaxTime%) then
            status% := 0;
            Message("Fixation cue min time cannot be greater than max time!");
        endif
    case item% = atttimingdlgHazardMinTime% or item% = atttimingdlgHazardExpMeanTime% or item% = atttimingdlgHazardCutoffTime% then
        ' max >= min
        if DlgValue(atttimingdlgHazardMinTime%) > DlgValue(atttimingdlgHazardExpMeanTime%)  or DlgValue(atttimingdlgHazardExpMeanTime%) > DlgValue(atttimingdlgHazardCutoffTime%) then
            status% := 0;
            Message("Hazard min time <= Hazard mean time <= Hazard cutoff time");
        endif
    endcase
    return status%;
end


func ColorsDialog%()
	var i%; var j%;
	var bcl$[4];
	var ibcl%:=0;
    var fiveints%[5];
    var eighteenints%[18];
    
    GetColorsDialogParameters();
    
    'put defaults into fiveints%[]
    fiveints%[0] := attCueCircleContrastAttend%;
    fiveints%[1] := attCueCircleContrastIgnore1%;
    fiveints%[2] := attCueCircleContrastIgnore2%;  'Ignore2-Ignore4 are currently constrained to be identical by the dialog-changed function,
    fiveints%[3] := attCueCircleContrastIgnore3%;  'but the old syntax still works so it's much easier to change back, if desired,
    fiveints%[4] := attCueCircleContrastIgnore4%;  'just undo the changes (noted) in the dialog-changed function.
    
    'put defaults into eighteenints%[]
    eighteenints%[0] := attendRGB%[0];
    eighteenints%[1] := attendRGB%[1];
    eighteenints%[2] := attendRGB%[2];
    eighteenints%[3] := ignore1RGB%[0];
    eighteenints%[4] := ignore1RGB%[1];
    eighteenints%[5] := ignore1RGB%[2];
    eighteenints%[6] := ignore2RGB%[0];
    eighteenints%[7] := ignore2RGB%[1];
    eighteenints%[8] := ignore2RGB%[2];
    eighteenints%[9] := ignore3RGB%[0];
    eighteenints%[10] := ignore3RGB%[1];
    eighteenints%[11] := ignore3RGB%[2];
    eighteenints%[12] := ignore4RGB%[0];
    eighteenints%[13] := ignore4RGB%[1];
    eighteenints%[14] := ignore4RGB%[2];
    eighteenints%[15] := noattenRGB%[0];
    eighteenints%[16] := noattenRGB%[1];
    eighteenints%[17] := noattenRGB%[2];

    
	GetAttentionScriptParameters();
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
    bcl$[3] := "custom";
    if InStr(attBackgroundColor$, "(") = 1 then
        ibcl% := attdlgColorIndexCustom%;
    else
        ibcl% := 2;
        for i%:=0 to 2 do
            if attBackgroundColor$ = bcl$[i%] then
                ibcl% := i%;
            endif
        next;
    endif
    
	DlgCreate("Attention colors", 25, 10);
    DlgAllow(0, 0, ColorsDialogChanged%);
	DlgList(1, "Background color:", bcl$);
    DlgInteger(2, "Background red (0-255)", 0, 255);
    DlgInteger(3, "Background green (0-255)", 0, 255);
    DlgInteger(4, "Background blue (0-255)", 0, 255);
    
    DlgGroup("Cue Circles",1,5,72,8);
    DlgInteger(attcolorsdlgCueContrastAttend%, "Attend Cue Circle Contrast", 0, 100, 27, 7);
    DlgInteger(attcolorsdlgCueContrastIgnore1%, "Ignore1 Cue Circle Contrast", 0, 100, 27, 8);
    DlgInteger(attcolorsdlgCueContrastIgnore2%, "Ignore2 Cue Circle Contrast", 0, 100, 27, 9);
    DlgInteger(attcolorsdlgCueContrastIgnore3%, "Ignore3 Cue Circle Contrast", 0, 100, 27, 10);
    DlgInteger(attcolorsdlgCueContrastIgnore4%, "Ignore4 Cue Circle Contrast", 0, 100, 27, 11);
    DlgText("0-100",30,6);
    DlgText("(0/255)       R         G          B",47,6);
    DlgText("FixPt 1",47,7);
    DlgText("FixPt 2",47,8);
    DlgText("FixPt 3",47,9);
    DlgText("FixPt 4",47,10);
    DlgText("FixPt 5",47,11);
    DlgText("No Atten FixPt",41,12);  'no cue circles will match this color if not multiply defined
    DlgInteger(attcolorsdlgCueCircleColorAttendR%, 5, 0, 255, 55, 7);
    DlgInteger(attcolorsdlgCueCircleColorAttendG%, 5, 0, 255, 61, 7);
    DlgInteger(attcolorsdlgCueCircleColorAttendB%, 5, 0, 255, 67, 7);
    DlgInteger(attcolorsdlgCueCircleColorIgnore1R%, 5, 0, 255, 55, 8);
    DlgInteger(attcolorsdlgCueCircleColorIgnore1G%, 5, 0, 255, 61, 8);
    DlgInteger(attcolorsdlgCueCircleColorIgnore1B%, 5, 0, 255, 67, 8);
    DlgInteger(attcolorsdlgCueCircleColorIgnore2R%, 5, 0, 255, 55, 9);
    DlgInteger(attcolorsdlgCueCircleColorIgnore2G%, 5, 0, 255, 61, 9);
    DlgInteger(attcolorsdlgCueCircleColorIgnore2B%, 5, 0, 255, 67, 9);
    DlgInteger(attcolorsdlgCueCircleColorIgnore3R%, 5, 0, 255, 55, 10);
    DlgInteger(attcolorsdlgCueCircleColorIgnore3G%, 5, 0, 255, 61, 10);
    DlgInteger(attcolorsdlgCueCircleColorIgnore3B%, 5, 0, 255, 67, 10);
    DlgInteger(attcolorsdlgCueCircleColorIgnore4R%, 5, 0, 255, 55, 11);
    DlgInteger(attcolorsdlgCueCircleColorIgnore4G%, 5, 0, 255, 61, 11);
    DlgInteger(attcolorsdlgCueCircleColorIgnore4B%, 5, 0, 255, 67, 11);
    DlgInteger(attcolorsdlgCueCircleColorNoAttenR%, 5, 0, 255, 55, 12);
    DlgInteger(attcolorsdlgCueCircleColorNoAttenG%, 5, 0, 255, 61, 12);
    DlgInteger(attcolorsdlgCueCircleColorNoAttenB%, 5, 0, 255, 67, 12);
    
    
    DlgCheck(attcolorsdlgCustomGratingColorCheck%, "Custom grating colors",2,13);
    DlgGroup("Stimulus", 1, 14, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromRed%, "From Red (0-255)", 0, 255, 20, 15);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromGreen%, "From Green (0-255)", 0, 255, 20, 16);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromBlue%, "From Blue (0-255)", 0, 255, 20, 17);
    DlgInteger(attcolorsdlgCustomGratingColorStimToRed%, "To Red (0-255)", 0, 255, 20, 18);
    DlgInteger(attcolorsdlgCustomGratingColorStimToGreen%, "To Green (0-255)", 0, 255, 20, 19);
    DlgInteger(attcolorsdlgCustomGratingColorStimToBlue%, "To Blue (0-255)", 0, 255, 20, 20);
    DlgGroup("Distractor", 37, 14, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromRed%, 12, 0, 255, 56, 15);  'make these width 12, will match the default ones above for Stim
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromGreen%, 12, 0, 255, 56, 16);  
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromBlue%, 12, 0, 255, 56, 17);  
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToRed%, 12, 0, 255, 56, 18);  
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToGreen%, 12, 0, 255, 56, 19);  
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToBlue%, 12, 0, 255, 56, 20);  
    attCustomGratingDialogLabel%[0] := DlgText("From Red (0-255)",38,15);  'will match the default labels above from Stim, return value allows us to gray them out
    attCustomGratingDialogLabel%[1] := DlgText("From Green (0-255)",38,16);
    attCustomGratingDialogLabel%[2] := DlgText("From Blue (0-255)",38,17);
    attCustomGratingDialogLabel%[3] := DlgText("To Red (0-255)",38,18);
    attCustomGratingDialogLabel%[4] := DlgText("To Green (0-255)",38,19);
    attCustomGratingDialogLabel%[5] := DlgText("To Blue (0-255)",38,20);
    
	i% := DlgShow(ibcl%, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%, 
    fiveints%,attCustomGratingColorCheck%, 
    attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2], 
    attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2], 
    attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2], 
    attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2], eighteenints%);
    
    
    
    
	' If user cancelled, reload params
	if i% = 1 then
        if ibcl% = attdlgColorIndexCustom% then
            attBackgroundColor$ := EncodeColor$(attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%);
        else
            attBackgroundColor$ := bcl$[ibcl%];
        endif
        
        'unpack the cue circle contrasts
        attCueCircleContrastAttend% := fiveints%[0];
        attCueCircleContrastIgnore1% := fiveints%[1];  
        attCueCircleContrastIgnore2% := fiveints%[2];  'don't need to change old version, the dialog-changed function fixes it
        attCueCircleContrastIgnore3% := fiveints%[3];
        attCueCircleContrastIgnore4% := fiveints%[4];         
        
        
        'unpack the cue circle colors
        'put defaults into eighteenints%[]
        attendRGB%[0] := eighteenints%[0];
        attendRGB%[1] := eighteenints%[1];
        attendRGB%[2] := eighteenints%[2];
        ignore1RGB%[0] := eighteenints%[3];
        ignore1RGB%[1] := eighteenints%[4];
        ignore1RGB%[2] := eighteenints%[5];
        ignore2RGB%[0] := eighteenints%[6];
        ignore2RGB%[1] := eighteenints%[7];
        ignore2RGB%[2] := eighteenints%[8];
        ignore3RGB%[0] := eighteenints%[9];
        ignore3RGB%[1] := eighteenints%[10];
        ignore3RGB%[2] := eighteenints%[11];
        ignore4RGB%[0] := eighteenints%[12];
        ignore4RGB%[1] := eighteenints%[13];
        ignore4RGB%[2] := eighteenints%[14];
        noattenRGB%[0] := eighteenints%[15];
        noattenRGB%[1] := eighteenints%[16];
        noattenRGB%[2] := eighteenints%[17];
        
        
        'masterColorList$ and masterColorListVSG$ define fixation colors and should have the same progression as cue circle colors
        'but due to the command line need to be in a text format.  Use cue circle colors to fill these variables.
        'This function will allow any integer color values from 0-255 even though the above code currently will not.
        CreateMasterColorLists();
        
        'if the background is not gray, set cue circles to full contrast, if you want to change contrast of cue circles
        'but use a different color background the you will have to adapt FadeColorToGray$()
        if ibcl% <> attdlgColorIndexGray% then
            attCueCircleContrastAttend% := 100;
            attCueCircleContrastIgnore1% := 100;
            attCueCircleContrastIgnore2% := 100;
            attCueCircleContrastIgnore3% := 100;
            attCueCircleContrastIgnore4% := 100;
        endif
        
        
        SaveColorsDialogParameters();
        
	endif
    
	return 1;
end;

func ColorsDialogChanged%(item%)
    var status% := 1;    
    var constantContrast%;
    
    constantContrast% := DlgValue(attcolorsdlgCueContrastIgnore1%);  'get contrast of Ignore stim 1
    DlgValue(attcolorsdlgCueContrastIgnore2%,constantContrast%);  'and set contrast of Ignore stims 2-4, currently not allowed to vary
    DlgValue(attcolorsdlgCueContrastIgnore3%,constantContrast%);
    DlgValue(attcolorsdlgCueContrastIgnore4%,constantContrast%);
    
    if item% = 0 or item% = attcolorsdlgBackgroundColor% then
        docase
        case DlgValue(attcolorsdlgBackgroundColor%) = 3 then
            DlgEnable(1, attcolorsdlgBackgroundRed%);
            DlgEnable(1, attcolorsdlgBackgroundGreen%);
            DlgEnable(1, attcolorsdlgBackgroundBlue%);
            DlgEnable(0, attcolorsdlgCueContrastAttend%);  'For now, no changing cue circle contrast if background is not gray
            DlgEnable(0, attcolorsdlgCueContrastIgnore1%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore2%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore3%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore4%);
        case DlgValue(attcolorsdlgBackgroundColor%) = 0 then  
            DlgEnable(0, attcolorsdlgBackgroundRed%);
            DlgEnable(0, attcolorsdlgBackgroundGreen%);
            DlgEnable(0, attcolorsdlgBackgroundBlue%);
            DlgEnable(1, attcolorsdlgCueContrastAttend%);  'Allow changing cue circle contrast if background is gray
            DlgEnable(1, attcolorsdlgCueContrastIgnore1%);
'            DlgEnable(1, attcolorsdlgCueContrastIgnore2%);
'            DlgEnable(1, attcolorsdlgCueContrastIgnore3%);
'            DlgEnable(1, attcolorsdlgCueContrastIgnore4%);
        else
            DlgEnable(0, attcolorsdlgBackgroundRed%);
            DlgEnable(0, attcolorsdlgBackgroundGreen%);
            DlgEnable(0, attcolorsdlgBackgroundBlue%);
            DlgEnable(0, attcolorsdlgCueContrastAttend%);  'For now, no changing cue circle contrast if background is not gray
            DlgEnable(0, attcolorsdlgCueContrastIgnore1%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore2%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore3%);
            DlgEnable(0, attcolorsdlgCueContrastIgnore4%);
        endcase
    endif
    
    if item% = 0 or item% = attcolorsdlgCustomGratingColorCheck% then
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[0]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[1]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[2]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[3]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[4]);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attCustomGratingDialogLabel%[5]);
    endif
    
    'If we decide to make the different invalid cue circles have different contrasts, get rid of this
    'if statement altogether and uncomment three commented lines above.  
    if item% = 0 or item% = attcolorsdlgCueContrastIgnore1% then
        'Currently, just don't allow these to change
        DlgEnable(0, attcolorsdlgCueContrastIgnore2%);
        DlgEnable(0, attcolorsdlgCueContrastIgnore3%);
        DlgEnable(0, attcolorsdlgCueContrastIgnore4%);
        DlgValue(attcolorsdlgCueContrastIgnore2%,DlgValue(attcolorsdlgCueContrastIgnore1%));  'update the other values to whatever the d1 value is
        DlgValue(attcolorsdlgCueContrastIgnore3%,DlgValue(attcolorsdlgCueContrastIgnore1%));
        DlgValue(attcolorsdlgCueContrastIgnore4%,DlgValue(attcolorsdlgCueContrastIgnore1%));
    endif
    
    return status%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Attention script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''






' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameTriggerChannel%;
var SynchChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;

' tuning curves
var TuningWindow%[8];	' one for each channel. There'd better not be more than 8 channels! 
' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iFixationWindowChannel%;' channel number for fixation window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iAnswerWindowChannelMain%;  'channel number for main stimulus answer window display in xy window
var iAnswerWindowChannelDist1%;  'channel number for distracter 1 answer window display in XY window
var iAnswerWindowChannelDist2%;  'channel number for distracter 2 answer window display in XY window
var iAnswerWindowChannelDist3%;  'channel number for distracter 3 answer window display in XY window
var iAnswerWindowChannelDist4%;  'channel number for distracter 4 answer window display in XY window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Check for valid data file path
if Len(dataDataSet$) = 0 then
	Message("No data set is selected! Edit Data parameters...");
	' Might be nice to open the dialog here....
	halt;
endif

'we're going to muck with reward so that Henry can have a "high reward" and a "low reward"
'I hate to do it this way, but I think that the alternative of doing it in the config is even
'worse.  This way, we simply override the config value, but only for the low-reward state. 
'For the high-reward state we still use the config value.  It's not pretty, but it keeps
'everything from cascading into a comedy of errors in other scripts.
'get original reward value from config
origRewardMS% := GetJuiceRewardMS%();

' run dialog
iScript% := AttentionScriptDialog%();
if iScript% <> 1 then
	PrintLog("User cancel - exit gracefully\n");
	Halt;
endif;





' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 23;
YChannel% := 24;
FrameTriggerChannel% := 25;
FixationPointChannel% := 26;
StimChannel% := 27;
StimChangeChannel% := 28;
ReadyChannel% := 29;
SynchChannel% := 32;
DigitalLaserChannel% := 48;  'is 32 on Acute tuning, but let's not shove it in the midst of other stuff
OptoCopyChannel% := 49;

ExcludedChans%[0] := 23;  'XChannel is lowest non-electrode channel used by this function
ExcludedChans%[1] := 49;  'OptoCopyChannel is highest non-electrode channel used by this function


'If we are not using the Plexon (and thus linking the two 1401s together, just use the standard order of operations:
'1) create sampling configuration, 2) Initialize windows, 3) Initialize/run toolbar.
'However, if we are linking the 1401s we have to do this in a different order, because we have to open up the second
'instance of Spike 2 BEFORE setting up the sampling configuration/windows on the first instance.  Doing this in the
'wrong order results in a non-fatal error in the second Spike2 instance indicating that the file which is preparing
'to be recorded in the first instance cannot be accessed, despite no explicit attempt to access any such thing.
'Hence, for the Plexon setups, we first initialize the toolbar, which has a specialty button "Start Plexon".  StartPlexon%()
'launches the second instance and the associated script, and both scripts move forward independently to create their own
'sampling configuration, initialize their own windows and are ready to have sampling started.  Note well that sampling
'must be started on the POWER 1401 (the second, non-dominant instance of Spike2) FIRST and on the MICRO 1401 (the first, 
'dominant instance of Spike 2) SECOND.  Starting sampling on the Micro will run the VSG program (Fixstim) which gives
'the sampling trigger and sets the experiment in motion.
if UsePlexon% = 0 then
    CreateSampleConfiguration();

    ' Initialize extraction
    'AttentionExtractInit%(-1, "");

    ' Get display windows ready
    InitializeWindows();

    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' UpdateToolbarText - Print tallies of trials in toolbar
'

proc UpdateToolbarText()
    
	var s$;
	var allPct$ := "--";
	var towardPct$ := "--";
    var awayPct$ := "--";
    var noChangePct$ := "--";
    var num, den, pct;
    
    if (attCountAllTrials% > 0) then
        num := attCountAllTrialsCorrect%;
        den := attCountAllTrials%;
        pct := num/den*100;
		allPct$ := print$("%2.0f", pct);
	endif
	if (attCountTowardTrials% > 0) then
        num := attCountTowardTrialsCorrect%;
        den := attCountTowardTrials%;
        pct := num/den*100;
		towardPct$ := print$("%2.0f", pct);
	endif
	if (attCountAwayTrials% > 0) then
        num := attCountAwayTrialsCorrect%;
        den := attCountAwayTrials%;
        pct := num/den*100;
		awayPct$ := print$("%2.0f", pct);
	endif
    if (attCountNoChangeTrials% > 0) then
        num := attCountNoChangeTrialsCorrect%;
        den := attCountNoChangeTrials%;
        pct := num/den*100;
		noChangePct$ := print$("%2.0f", pct);
	endif
    

    'only print stats for conditions that have occurred
    s$ := "Tallies count/correct/incorrect/aborted (correct%%):";
    if attCountAllTrials% > 0 or attCountAllTrialsAbort% > 0 then  
        s$ := s$ + Print$(" ALL %d/%d/%d/%d (%s%%)",attCountAllTrials%, attCountAllTrialsCorrect%, attCountAllTrialsIncorrect%, attCountAllTrialsAbort%, allPct$);
    endif
    if attCountTowardTrials% > 0 or attCountTowardTrialsAbort% > 0 then
        s$ := s$ + Print$(" TOWARD %d/%d/%d/%d (%s%%)",attCountTowardTrials%, attCountTowardTrialsCorrect%, attCountTowardTrialsIncorrect%, attCountTowardTrialsAbort%, towardPct$);
    endif;
    if attCountAwayTrials% > 0 or attCountAwayTrialsAbort% > 0 then
        s$ := s$ + Print$(" AWAY %d/%d/%d/%d (%s%%)",attCountAwayTrials%, attCountAwayTrialsCorrect%, attCountAwayTrialsIncorrect%, attCountAwayTrialsAbort%, awayPct$);
    endif
    if attCountNoChangeTrials% > 0 or attCountNoChangeTrialsAbort% > 0 then
        s$ := s$ + Print$(" NOCHANGE %d/%d/%d/%d (%s%%)",attCountNoChangeTrials%, attCountNoChangeTrialsCorrect%, attCountNoChangeTrialsIncorrect%, attCountNoChangeTrialsAbort%, noChangePct$);
    endif

    
	ToolbarText(s$);
    
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()
    
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	UpdateToolbarText();
    if UsePlexon% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    '	ToolbarSet(6,"Exp Parameters",%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);
    
end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Answer%(EyePosX, EyePosY)
    var ans% := 0;
    var ansptRadius;
    'ansptRadius := Pow(attAnswerPointWindowRadius,2);  'answer point radius is now the size of the grating
    
    'note that in the case statement, we will not consider grating patches that don't exist - see how smart we are!
    docase
    case (Pow(EyePosX-mainX,2) + Pow(EyePosY-(mainY),2)) <= Pow(mainW,2) then 'Looking at main grating location, just assuming mainW = mainH!
        ans% := 1;
    case (Pow(EyePosX-dist1X,2) + Pow(EyePosY-(dist1Y),2)) <= Pow(dist1W,2) and attNumPatches% > 1 then 'Looking at distracter 1 location, just assuming dist1W = dist1H!
        ans% := -1;
    case (Pow(EyePosX-dist2X,2) + Pow(EyePosY-(dist2Y),2)) <= Pow(dist2W,2) and attNumPatches% > 2 then 'Looking at distracter 2 location, just assuming dist2W = dist2H!
        ans% := -2;
    case (Pow(EyePosX-dist3X,2) + Pow(EyePosY-(dist3Y),2)) <= Pow(dist3W,2) and attNumPatches% > 3 then 'Looking at distracter 3 location, just assuming dist3W = dist3H!
        ans% := -3;
    case (Pow(EyePosX-dist4X,2) + Pow(EyePosY-(dist4Y),2)) <= Pow(dist4W,2) and attNumPatches% > 4 then 'Looking at distracter 4 location, just assuming dist4W = dist4H!
        ans% := -4;
    endcase;
    
	return ans%;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func LookingAtCuePoint%(EyePosX, EyePosY, windowRadius)
    'this function is essentially Answer% except with a variable window radius
    var ans% := 0;
    'ansptRadius := Pow(attAnswerPointWindowRadius,2);  'answer point radius is now the size of the grating
    
    'note that in the case statement, we will not consider grating patches that don't exist - see how smart we are!
    docase
    case (Pow(EyePosX-mainX,2) + Pow(EyePosY-(mainY),2)) <= Pow(windowRadius,2) then 'Looking at main grating cue dot
        ans% := 1;
    case (Pow(EyePosX-dist1X,2) + Pow(EyePosY-(dist1Y),2)) <= Pow(windowRadius,2) and attNumPatches% > 1 then 'Looking at distracter 1 cue dot
        ans% := -1;
    case (Pow(EyePosX-dist2X,2) + Pow(EyePosY-(dist2Y),2)) <= Pow(windowRadius,2) and attNumPatches% > 2 then 'Looking at distracter 2 cue dot
        ans% := -2;
    case (Pow(EyePosX-dist3X,2) + Pow(EyePosY-(dist3Y),2)) <= Pow(windowRadius,2) and attNumPatches% > 3 then 'Looking at distracter 3 cue dot
        ans% := -3;
    case (Pow(EyePosX-dist4X,2) + Pow(EyePosY-(dist4Y),2)) <= Pow(windowRadius,2) and attNumPatches% > 4 then 'Looking at distracter 4 cue dot
        ans% := -4;
    endcase;
    
	return ans%;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
    DefaultReward();
    'No sample text, just use 'R' from keyboard channel
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 

' Constants for states
const stateStartTrial%:=0;		        ' Start trial state
const stateWaitForFixPtOn%:=1;		    ' Waiting for fixation/cue point return trigger (on)
const stateHoldFixationToStimOn%:=2;		    ' Maintaining fixation with cue color point and lollipops up
const stateWaitForStimOn%:=3;		    ' Wait for stimulus return trigger (on)
const stateWaitForContrastChange%:=4;	' Wait for indication that contrast change has happened
const stateWaitForAcquisition%:=5;	    ' Waiting for subject to acquire fixation point
const stateHoldFixationToCC%:=6;		    ' Holding fixation point
const stateAbort%:=7;			        ' Failed trial state
const stateWaitForAnswer%:=8;			' waiting for answer
const stateAbortWait%:=9;	            ' time out after failed trial
const stateVSGWait%:=10;		        ' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		    ' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		    ' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForBlank%:=14;
const stateBlockCompleted%:=16;
const stateStartBlock%:=17;
const stateTrialCompletedWaitForBlank% := 18;
const stateTrialCompletedPause% := 19;
const stateWaitForWhitePointOn%:=20;    ' Waiting for fixation white point  This white point stuff is mostly or wholly excised
const stateWhitePointFixation%:=21;     ' white point up, remain fixation
const stateNoResponse% := 22;
const stateFalseAlarmWait% := 23;
const stateCheckFalseAlarm% := 24;
const stateMiss% := 25;
const stateCorrectRejection% := 26;
const stateCheckTurnOnOpto% := 27;
const stateRequestStimulus% := 28;
const stateStartOpto% := 29;
const statePulsedOpto% := 30;
const stateWaitOptoPrestim% := 31;
const stateCheckTurnOffOpto% := 32;
const stateTurnOffOpto% := 33;
var iState% := stateVSGWait%;	' present state

const trialtypeAttendToward% := 100;
const trialtypeAttendAway% := 101;
const trialtypeNoChange% := 102;
var trialType%;
var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 
var nBlocksCompleted%:=0;
var iAnswer%;
var isStimDistractorOff% := 0;
var trialCatch%;
var trialIsTarget%;
var trialAttendLoc%;
var trialHazardFunctionTime;
var tOpt;
var queueReward% := 0;

func IdleProcessing%()
    'var getPreciseTiming := 1;
	var iStatus% := 1;	
    var tempanswer%;
    var temptext$;
    var CCHappened%;
    
    'The trick here is that sometimes sampling isn't caught up on all channels.  MaxTime() may return a lower
    'value than MaxTime(ChanN%). When we find a trigger and try to place a TextMark, SampleText will do an internal
    'call to MaxTime() - no channel # - to determine whether to place it at the requested time or at MaxTime().
    'In some instances, this has resulted in the TextMark being placed earlier than the event which caused it.
    'We are now explicitly checking for this - if we find it, we have to avoid updating tLast and continue checking
    'in order to not miss the trigger AND to put the TextMark at the right time.
    'Note that we will ONLY do the additional check in instances where a timed TextMark is being placed at the 
    'time of the trigger.
    var updateTLast% := 1;  'due to trigger issues, we may not always update tLast (but we usually will)
    
    'while getPreciseTiming = 1 do 
    
    'getPreciseTiming := 0;  'don't get precise timing unless we ask to (if 0, return control to windows after each idle loop iteration)
    
    tNow := View(DataWindow%).MaxTime();
    
    'get eye position, but don't check if tNow is small enough that we would give a negative value to ChanMeasure
    if tNow > .006 then
        xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
        yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;
    endif;
        
    ' Don't update display every time....
    if tNow-tLastUpdate > .005 then
        View(XYWindow%).XYAddData(1,xEye,yEye);
        tLastUpdate := tNow;
    endif
    
    
    docase 
    case iState% = stateVSGWait% then
        
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        tTrigger := View(DataWindow%).NextTime(ReadyChannel%, tLast, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 0 then
            PrintLog("state stateVSGWait: Got leading edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateVSGWaitConfirm%, tTrigger);
        endif;
        
    case iState% = stateVSGWaitConfirm% then
        
        ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
        tTrigger := View(DataWindow%).NextTime(ReadyChannel%, tLastTrigger, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 1 then
            PrintLog("state stateVSGWaitConfirm: Got trailing edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateStartBlock%, tTrigger);
        endif;
        
        
    case iState% = stateStartBlock% then
        
        PrepareBlock();
        ChangeStateTo(stateStartTrial%, tNow);
        
    case iState% = stateStartTrial% then
        
        ' Start trial. Put up fixation point.
        UpdateToolbarText();
        PrepareTrial();
        attCountAllTrials% += 1;
        'SafeSampleKey("W");
        docase
        case trialType% = trialtypeAttendToward% then
            attCountTowardTrials% += 1;
        case trialType% = trialtypeAttendAway% then
            attCountAwayTrials% += 1;
        case trialType% = trialtypeNoChange% then
            attCountNoChangeTrials% += 1;
        else
            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
        endcase
        PrintLog("Request Fixation Point\n");
        SafeSampleKey("F");
        ChangeStateTo(stateWaitForFixPtOn%, tNow);
        
        
    case iState% = stateWaitForFixPtOn% then
        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
        if tTrigger > tLast then
            if tTrigger < tNow then    'View(DataWindow%).MaxTime() then  'try using tNow to avoid rare double-catch
                ' Fixation point is up
                PrintLog("stateWaitForFixPtOn: signal received. " + str$(tTrigger) + "\n");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateWaitForAcquisition%, tTrigger);
                docase
                case trialType% = trialtypeAttendToward% then
                    SampleText("Fixation point on, Attend Toward",tTrigger);
                case trialType% = trialtypeAttendAway% then
                    SampleText("Fixation point on, Attend Away",tTrigger);
                case trialType% = trialtypeNoChange% then 
                    SampleText("Fixation point on, No Change",tTrigger);
                endcase;
                DrawStim(1);	' this draws the location of the fixpt.
            else
                updateTLast% := 0;  'waiting for sampling to catch up
            endif;
        endif
        
        
    case iState% = stateWaitForAcquisition% then
        'getPreciseTiming := 1;
        ' Waiting for eye to fall inside of fixation window
        docase
        case Looking%(xEye, yEye) = 1 then
            PrintLog("stateWaitForAcquisition: eye in fixation window.\n");
            ChangeStateTo(stateHoldFixationToStimOn%, tNow);
            SampleText("Fixation Acquired",tNow);
            'getPreciseTiming := 0;
        case attUseCueCircles% = 2 and LookingAtCuePoint%(xEye, yEye, 1) <> 0 then  'using a hardcoded radius of 1 degree, only check if we are using cue circles
            'Simple abort on acquisition of cue point instead of fixpt.  Note that IF fixpt window and cue point windows overlap, priority is given to the fixpt window...
            PrintLog("stateWaitForAcquisition: eye in cue circle window, aborting trial.\n");
            ChangeStateTo(stateAbort%, tNow);
            SampleText("Animal Fixated Cue Circle, Trial Aborted",tNow);
        else 
            if tNow - tStateStart > attAcquisitionTime then  'simple abort on failure to acquire
                PrintLog("stateWaitForAcquisition: failed.\n");
                ChangeStateTo(stateAbort%, tNow);
                'getPreciseTiming := 0;
            endif
        endcase
        
        
    case iState% = stateHoldFixationToStimOn% then
        
        ' Eye must remain inside of fixation window
        docase
        case Looking%(xEye, yEye) = 1 then
            if tNow - tStateStart > attFixationTime then
'                PrintLog("stateHoldFixationToStimOn: Success. Gratings up...\n");
'                SafeSampleKey("S");
'                ChangeStateTo(stateWaitForStimOn%, tNow);
                PrintLog("stateHoldFixationToStimOn: Success. Checking to see if we do opto...\n");
                ChangeStateTo(stateCheckTurnOnOpto%, tNow);
            endif
        else 'if fixation fails before stim on, begin abort, check to see if it is a FA
            tempanswer% := Answer%(xEye, yEye);
            if tempanswer% < 0 then  'adjust tempanswer to correspond to trialAttendLoc syntax
                tempanswer% := -tempanswer%+1;
            endif;
            if tempanswer% <> 0 then  'if it's in a response window, quit while you're ahead
                docase
                case tempanswer% = trialAttendLoc% then 'answer in "attend toward" window
                    PrintLog("stateWaitForStimOn: in attend toward response window, aborting trial.\n");
                    FAIsResponse% := 1;
                    ChangeStateTo(stateAbort%, tNow);
                    SampleText(Print$("Fixation broken, False Alarm to location %d (attend toward window) before stimulus on, trial aborted",tempanswer%),tNow);
                case tempanswer% = -1 then 'answer in "attend away" = "down" window
                    PrintLog("stateWaitForStimOn: in attend away response window, aborting trial.\n");
                    FAIsResponse% := 1;
                    ChangeStateTo(stateAbort%, tNow);
                    SampleText(Print$("Fixation broken, False Alarm to location %d (attend away window) before stimulus on, trial aborted",tempanswer%),tNow);    
                endcase;
            else  'keep checking until false alarm check window is closed
                ChangeStateTo(stateCheckFalseAlarm%, tNow);
                temptext$ := "before stimulus on";
            endif;
        endcase
        
        
    case iState% = stateCheckTurnOnOpto% then
        docase
        case attdoOpto% = 0 then 'if this is not an opto trial, just start it
            ChangeStateTo(stateRequestStimulus%, tNow);
            printlog("Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",attDoOpto%,attOptoState%,tNow);
        case attOptoUsePulse% = 1 and attOptoState% = 0 then 'if this is a pulsed opto scenario, but not an opto trial, just start it
            'This is the same as the above step, separated to make the logic of the case statement easier
            ChangeStateTo(stateRequestStimulus%, tNow);
            printlog("Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",attDoOpto%,attOptoState%,tNow);
        case attOptoUsePulse% = 1 and attOptoState% = 1 then  'it is a pulsed opto trial, the sequencer will time this
            ChangeStateTo(statePulsedOpto%,tNow);
'        case attOptoStaysOn% = 1 and nTrialsCompleted% <> 0 then 'this is for when we're keeping the opto on and it's mid block --- currently disabled
'            ChangeStateTo(stateRequestStimulus%, tNow);
'            printlog("Opto is already on, OptoStaysOn = %d, TrialsComplete = %d, time = %f\n",attOptoStaysOn%,nTrialsCompleted%,tNow);
        else 'otherwise it is a wraparound opto trial and we need to turn opto on
            ChangeStateTo(stateStartOpto%, tNow);
            printlog("Turning Opto On at time = %f\n",tNow);
        endcase   
        
        
    case iState% = stateStartOpto% then
        if attOptoState% = 1 then 'this is an opto-on trial
            SafeSampleKey("O");  'turn on opto
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOn at %f\n",tOpt);
            SampleText("OptoOn",tOpt);
            attOptoStarted% := 1;
        else 'this is an opto-off trial
            SafeSampleKey("N");  'don't turn on opto    'this seems pointless - the real thing is we have to wait the same amount of time as for wraparound
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOn at %f\n",tOpt);
            SampleText("NoOpto",tOpt);
        endif;
        
        ChangeStateTo(stateWaitOptoPrestim%, tNow);   
        
        
    case iState% = stateWaitOptoPrestim% then
        if tNow > tStateStart + attPreStimOptoTime then
            ChangeStateTo(stateRequestStimulus%, tNow);
        endif;        
        
        
    case iState% = statePulsedOpto% then
        SafeSampleKey("P");  'start pulsed opto, the whole sequence is controlled by the sequencer, this does the "S" implicitly
        tOpt := View(DataWindow%).MaxTime();
        'SampleText("T," + str$(GetPlotXCoord(nTrialsCompleted%)),tOpt);
        SampleText("Pulsed Opto on",tOpt);
        printlog("Started wraparound opto for trial at %f\n",tOpt);
        attOptoStarted% := 2;  'use a different number to keep track here, if pulsed opto is going, we can't use any SafeSampleKeys until it is stopped
        ChangeStateTo(stateWaitForStimOn%, tOpt);
        
        
    case iState% = stateRequestStimulus% then

        ' Start trial. Put up stimulus.
        LogStatus("StartTrial", "Request stimulus");
        SafeSampleKey("S");  'request stimulus  
        ChangeStateTo(stateWaitForStimOn%, tNow); 
        
        
    case iState% = stateWaitForStimOn% then
        tTrigger := View(DataWindow%).NextTime(StimChannel%, tLast, vTrigger);
        if tTrigger > tLast and vTrigger = 0 then
            if tTrigger < tNow then         'View(DataWindow%).MaxTime() then   'try using tNow to avoid rare double-catch
                ' gratings et al are up
                PrintLog("stateWaitForStimOn: stim is up.\n");
                tStimOn := tTrigger;
                tLastTrigger := tTrigger;
                ChangeStateTo(stateHoldFixationToCC%, tTrigger);
                SampleText("Stimulus on, Fixation color " + fixColor$ + ", Base contrast " + Str$(attContrastBase%) + ", hazard dur " + Str$(trialHazardFunctionTime)
                + ", attend location " + Str$(trialAttendLoc%) + ", change location " + Str$(trialIsTarget%) + ", change contrast " + Str$(thisContrast%),tTrigger);
            else
                updateTLast% := 0;  'waiting for sampling to catch up
            endif;
        endif
        
        
    case iState% = stateAbort% then
        
        ' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
        ' fixpt off. 
        PrintLog("stateAbort: send X key.\n");
        docase
        case attOptoStarted% = 2 then  'it is a pulsed opto trial and we have started the opto
            'on a pulsed opto abort, we need to turn off the laser and break out of the opto loop
            SampleKey("B");  'NOT SafeSampleKey - sequencer is in use and we're killing it anyway, by design
            SampleSeqVar(6,attOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens
            tOpt := View(DataWindow%).MaxTime();
            SampleText("OptoOff",tOpt);
            SafeSampleKey("X");  'just turn off stimulus, follow up to get fixation channel down
            attOptoStarted% := 0;  'opto is stopped
        case attOptoStarted% = 1 then  'any other non-pulsed opto trial, kill opto on abort if we have started opto
'            if attOptoState% = 1 then
            SafeSampleKey("o");  'turn it off
            tOpt := View(DataWindow%).MaxTime();
            'printlog("OptoOff at %f\n",tOpt);
            SampleText("OptoOff",tOpt);
            attOptoStarted% := 0;  'opto is stopped
'            else
'                SafeSampleKey("n");  'turn it off           'This can no longer be reached with the current logic.
'                tOpt := View(DataWindow%).MaxTime();        'That said, I'm not sure it was very useful anyway
'                'printlog("OptoOff at %f\n",tOpt);          'Why bother sampletexting that something didn't happen?
'                SampleText("NoOptoSoNoOff",tOpt);
'            endif;
            SafeSampleKey("X");  'just turn off stimulus
        else
            SafeSampleKey("X");  'just turn off stimulus
        endcase;
        

        
        view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Force fixation window to blue
        view(XYWindow%).XYColour(iAnswerWindowChannelMain%,13);  'Force main stimulus answer window to blue
        if attNumPatches% > 1 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,13);  'Force distracter1 answer window to blue
        endif;
        if attNumPatches% > 2 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,13);  'Force distracter2 answer window to blue
        endif;
        if attNumPatches% > 3 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,13);  'Force distracter3 answer window to blue
        endif;
        if attNumPatches% > 4 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,13);  'Force distracter4 answer window to blue
        endif;
        
        
        ' tally up aborted trials, right now not distinguishing between response aborts and regular aborts
        ' but we also have to decrement "all trials" because this messes with the percentages
        attCountAllTrialsAbort% += 1;
        attCountAllTrials% -= 1;
        docase
        case trialType% = trialtypeAttendToward% then
            attCountTowardTrialsAbort% += 1;
            attCountTowardTrials% -= 1;
        case trialType% = trialtypeAttendAway% then
            attCountAwayTrialsAbort% += 1;
            attCountAwayTrials% -= 1;
        case trialType% = trialtypeNoChange% then
            attCountNoChangeTrialsAbort% += 1;
            attCountNoChangeTrials% -= 1;
        else 
            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
        endcase
        
        ' move on
        'ChangeStateTo(stateWaitForBlank%, tNow);
        ChangeStateTo(stateWaitForBlank%, tStateStart);  'don't update time, carry forward
        
    case iState% = stateWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
        if tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            if FAIsResponse% = 1 then
                FAIsResponse% := 0;
                ChangeStateTo(stateFalseAlarmWait%, tTrigger);
                'advance on false alarm
'                SafeSampleKey("a");  'this is the only place to get into stateFalseAlarmWait, so advance here is fine
'                nTrialsCompleted% += 1;  'trial is complete, change of count here makes logic easier 
'                attCurrTrialIndex% += 1;
            else                
                ChangeStateTo(stateAbortWait%, tStateStart);  'don't update time, "credits" for time served
            endif;
            DrawStim(0);	' this undraws the location of the fixpt.
        endif
        
    case iState% = stateAbortWait% then
        
        if tNow - tStateStart > attAbortWaitTime then
            PrintLog("stateAbortWait: time out is done.\n");
            ChangeStateTo(stateStartTrial%, tNow);
        endif
        
       
        
    case iState% = stateCheckFalseAlarm% then
        
        if tNow - tStateStart < attFalseAlarmCheckWindow then
            tempanswer% := Answer% (xEye, yEye);
            if tempanswer% < 0 then  'adjust tempanswer to correspond to trialAttendLoc syntax
                tempanswer% := -tempanswer%+1;
            endif;
            docase
            case tempanswer% = trialAttendLoc% then 'answer in "attend toward" window
                PrintLog("stateCheckFalseAlarm: in attend toward response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText(Print$("Fixation broken, False Alarm to location %d (attend toward window) %s, trial aborted",tempanswer%,temptext$),tNow);
            case tempanswer% = -1 then 'answer in "attend away" = "down" window
                PrintLog("stateCheckFalseAlarm: in attend away response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText(Print$("Fixation broken, False Alarm to location %d (attend away window) %s, trial aborted",tempanswer%,temptext$),tNow);    
            endcase;
        else 'credit the animal for time served on the abort if it's not a response
            PrintLog("stateCheckFalseAlarm: no response in window, aborting trial.\n");
            ChangeStateTo(stateAbort%, tNow-attFalseAlarmCheckWindow); 
            SampleText("Fixation broken, no response, trial aborted");
        endif;
        
         
    case iState% = stateFalseAlarmWait% then
        
        if tNow - tStateStart > attFalseAlarmWaitTime then
            PrintLog("stateFalseAlarmWait: time out is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
        endif        
        
              
        
        
    case iState% = stateHoldFixationToCC% then
        
        'Check to see if there was a trigger
        tTrigger := View(DataWindow%).NextTime(FrameTriggerChannel%, tLast, vTrigger);
        if tTrigger > tLast and vTrigger = 0 then  'only look at rising edge
            if tTrigger < tNow then      'View(DataWindow%).MaxTime() then  'try using tNow to avoid rare double-catch
               tLastTrigger := tTrigger;
               'put in a sample text for Flashers, sample text for CC will be done below
                CCHappened% := TagTriggerWithSampletext%(tLastTrigger,tStimOn,attCurrTrialIndex%,flasherCountThisTrial%);
            else
                updateTLast% := 0;  'waiting for sampling to catch up
            endif;
        endif;
        
        docase            
        case Looking%(xEye, yEye) = 0 then  'begin abort procedure, check to see if it's a FA
            tempanswer% := Answer% (xEye, yEye);
            if tempanswer% < 0 then  'adjust tempanswer to correspond to trialAttendLoc syntax
                tempanswer% := -tempanswer%+1;
            endif;
            docase
            case tempanswer% = trialAttendLoc% then 'answer in "attend toward" window
                PrintLog("stateHoldFixationToCC: in attend toward response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText(Print$("Fixation broken, False Alarm to location %d (attend toward window) during stimulus, trial aborted",tempanswer%),tNow);
            case tempanswer% = -1 then 'answer in "attend away" = "down" window
                PrintLog("stateHoldFixationToCC: in attend away response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText(Print$("Fixation broken, False Alarm to location %d (attend away window) during stimulus, trial aborted",tempanswer%),tNow);           
            else  'keep checking
                ChangeStateTo(stateCheckFalseAlarm%, tNow);
                temptext$ := "during stimulus";
            endcase;
            
        else 
            if CCHappened% = 1 then
            'if (tNow - tStateStart) > (trialHazardFunctionTime) then
                CCHappened% := 0;  'reset, shouldn't matter
                ' we no longer turn off stimulus and advance it, but we DO allow response now
                isStimDistractorOff% := 0;
                ChangeStateTo(stateWaitForAnswer%, tNow);
                'This docase sets the color of the changed location to red on the "monitor screen"
                docase
                case trialIsTarget% = 0 then
                    view(XYWindow%).XYColour(iFixationWindowChannel%,16);  'Change fixation window to red
                case trialIsTarget% = 1 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelMain%,16);  'Change main window to red
                case trialIsTarget% = 2 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,16);  'Change dist1 window to red
                case trialIsTarget% = 3 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,16);  'Change dist2 window to red
                case trialIsTarget% = 4 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,16);  'Change dist3 window to red
                case trialIsTarget% = 5 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,16);  'Change dist4 window to red
                endcase
                'This docase does the appropriate SampleTexting
                docase
                case trialType% = trialtypeAttendToward% then
                    if trialIsTarget% > 0 then
                        if trialCatch% = 0 then
                            Sampletext("Contrast Change, Level " + Str$(thisContrast%) + ", Attend Toward",tLastTrigger);
                        else
                            Sampletext("Contrast Change, Level " + Str$(thisContrast%) + ", Attend Toward (catch)",tLastTrigger);
                        endif
                    else
                        Sampletext("Attend Toward, No Contrast Change",tLastTrigger);
                    endif
                case trialType% = trialtypeAttendAway% then
                    if trialIsTarget% > 0 then
                        if trialCatch% = 0 then
                            Sampletext("Contrast Change, Level " + Str$(thisContrast%) + ", Attend Away",tLastTrigger);
                        else
                            Sampletext("Contrast Change, Level " + Str$(thisContrast%) + ", Attend Away (catch)",tLastTrigger);
                        endif
                    else
                        Sampletext("Attend Away, No Contrast Change",tLastTrigger);
                    endif
                case trialType% = trialtypeNoChange% then  
                    Sampletext("No Change, No Contrast Change",tLastTrigger);
                else
                    PrintLog("ERROR! Unknown blocktype!!!\n");    
                endcase
            endif
            
        endcase
        

        
    case iState% = stateWaitForAnswer% then
        'getPreciseTiming := 1;  'we need precise timing here, stay in while loop until we get eye movements we expect
        'Check to see if there was a trigger, this only is relevant in this state if there are Flashers
        if attUseFlashers% = 1 then
            tTrigger := View(DataWindow%).NextTime(FrameTriggerChannel%, tLast, vTrigger);
            if tTrigger > tLast and vTrigger = 0 then  'only look at rising edge
                if tTrigger < tNow then     'View(DataWindow%).MaxTime() then   'try using tNow to avoid rare double-catch
                    tLastTrigger := tTrigger;
                    'put in a sample text based on which flasher this trigger was representing
                    TagTriggerWithSampletext%(tLastTrigger,tStimOn,attCurrTrialIndex%,flasherCountThisTrial%);
                else
                    updateTLast% := 0;  'waiting for sampling to catch up
                endif;
            endif;
        endif;
        
        
        if tNow - tStateStart > attTimeToAnswerPerTrial then  'no response, answer window is over
            docase
            case attCatchIsNoGo% = 1 and trialCatch% = 1 and isStimDistractorOff% = 0 then  'catch-as-no-go trial, this is correct
                if attOptoStarted% = 2 then  'if it's pulsed opto, kill it
                    SampleKey("B");  'NOT SafeSampleKey - sequencer is in use and we're killing it anyway, by design
                    SampleSeqVar(6,attOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens
                    attOptoStarted% := 0;  'opto is now off, as is the stimulus (but not the fixpt)
                endif;
                SafeSampleKey("X");  'turn off animation
                PrintLog("stateWaitForAnswer: no response on catch-as-no-go trial, correct rejection\n");
                docase
                case trialType% = trialtypeAttendToward% then
                    attCountTowardTrialsCorrect% += 1;
                    SampleText("Correct Rejection, Catch-As-No-Go, Attend Toward",tNow);
                case trialType% = trialtypeAttendAway% then
                    attCountAwayTrialsCorrect% += 1;
                    SampleText("Correct Rejection, Catch-As-No-Go, Attend Away",tNow);
                case trialType% = trialtypeNoChange% then
                    attCountNoChangeTrialsCorrect% += 1;
                    SampleText("Correct Rejection, Catch-As-No-Go, No Change",tNow);
                endcase;
                attInterTrialTime2 := attInterTrialTime;
                'Reward%();
                'ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
                queueReward% := 1;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
            case attCatchIsNoGo% = 1 and trialCatch% = 1 and isStimDistractorOff% = 1 then  'catch-as-no-go trial, fixation broken but no response, this is an abort
                ChangeStateTo(stateAbort%, tNow);
                PrintLog("stateWaitForAnswer: fixation break on catch-as-no-go trial, abort\n");
            case trialIsTarget% > 0 then  'GO trial, expected response
                if attOptoStarted% = 2 then  'if it's pulsed opto, kill it
                    SampleKey("B");  'NOT SafeSampleKey - sequencer is in use and we're killing it anyway, by design
                    SampleSeqVar(6,attOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens
                    attOptoStarted% := 0;  'opto is now off, as is the stimulus (but not the fixpt)
                endif;
                SafeSampleKey("X");  'turn off animation
                PrintLog("stateWaitForAnswer: no response on go trial, miss\n");
                docase
                case trialType% = trialtypeAttendToward% then
                    attCountTowardTrialsIncorrect% += 1;
                    SampleText("Miss, Attend Toward",tNow);
                case trialType% = trialtypeAttendAway% then
                    attCountAwayTrialsIncorrect% += 1;
                    SampleText("Miss, Attend Away",tNow);
                endcase;
                queueReward% := -1;  'indicates a miss
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
                'ChangeStateTo(stateMiss%, tNow); 'go to miss penalty
                'SafeSampleKey("a");
            else
                if attOptoStarted% = 2 then  'if it's pulsed opto, kill it
                    SampleKey("B");  'NOT SafeSampleKey - sequencer is in use and we're killing it anyway, by design
                    SampleSeqVar(6,attOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens
                    attOptoStarted% := 0;  'opto is now off, as is the stimulus (but not the fixpt)
                endif;
                SafeSampleKey("X");  'turn off animation
                PrintLog("stateWaitForAnswer: no response on no-go trial, correct rejection\n");
                docase
                case trialType% = trialtypeAttendToward% then
                    attCountTowardTrialsCorrect% += 1;
                    SampleText("Correct Rejection, Attend Toward",tNow);
                case trialType% = trialtypeAttendAway% then
                    attCountAwayTrialsCorrect% += 1;
                    SampleText("Correct Rejection, Attend Away",tNow);
                case trialType% = trialtypeNoChange% then
                    attCountNoChangeTrialsCorrect% += 1;
                    SampleText("Correct Rejection, No Change",tNow);
                endcase;
                attInterTrialTime2 := attInterTrialTime;
'                Reward%();
'                ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
                queueReward% := 1;
                ChangeStateTo(stateCheckTurnOffOpto%, tNow);
            endcase;
        else
            ' When fixation is first broken we turn off the stim and distractor. Fixation remains up.
            ' The test for fixation is done separately from the test for an answer. Also set up 
            ' a var to tell us whether the stim has been turned off. 
            if isStimDistractorOff% = 0 then
                if Looking%(xEye, yEye) = 0 then
                    if attOptoStarted% <> 2 then  'we can't turn off the stim this way if pulsed opto is going
                        SafeSampleKey("s");
                    else  'the stimulus may already have been turned off in the answer portion
                        SampleKey("B");  'NOT SafeSampleKey - sequencer is in use and we're killing it anyway, by design
                        SampleSeqVar(6,attOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens
                        attOptoStarted% := 0;  'opto is now off, as is the stimulus (but not the fixpt)
                    endif;
                    'SampleText("Fixation broken during response window",tNow);
                    PrintLog("stateWaitForAnswer: fix broken - turn off stim\n");
                    isStimDistractorOff% := 1;
                endif
            endif
            
            iAnswer% := Answer%(xEye, yEye);
            if iAnswer% <> 0 then
                ' Got an answer. Record marker for correct/incorrect answer
                printlog("Got answer %d with expected answer %d\n",iAnswer%,expectedAnswer%);
                docase
                case iAnswer% = expectedAnswer% then
                'if trialIsTarget% = 1 then 'it's a GO trial
                    ' Hit                    
                    attCountAllTrialsCorrect% += 1;
                    attInterTrialTime2 := attInterTrialTime;
                    'SampleText("+");
                    docase
                    case trialType% = trialtypeAttendToward% then
                        attCountTowardTrialsCorrect% += 1;
                        SampleText("Hit, Attend Toward, Contrast Up",tNow);
                    case trialType% = trialtypeAttendAway% then
                        attCountAwayTrialsCorrect% += 1;
                        SampleText("Hit, Attend Away, Contrast Up",tNow);
                    case trialType% = trialtypeNoChange% then
                        PrintLog("ERROR: No-Change trial, expectedAnswer should be zero but was " + str$(expectedAnswer%) + "\n");
                    else
                        PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                    endcase
                    'getPreciseTiming := 0;
'                    Reward%();
'                    ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
                    queueReward% := 1;
                    ChangeStateTo(stateCheckTurnOffOpto%, tNow);
                    'SafeSampleKey("X");  'do this in stateCheckTurnOffOpto
                case iAnswer% <> expectedAnswer% and expectedAnswer% <> 0 then
                    'it's a GO trial
                    ' Saccade to wrong grating                    
                    attCountAllTrialsIncorrect% += 1;
                    attInterTrialTime2 := attInterTrialTime + attMissPenalty;
                    'SampleText("+");
                    docase
                    case trialType% = trialtypeAttendToward% then
                        attCountTowardTrialsIncorrect% += 1;
                        SampleText("Miss, Attend Toward, Moved To Wrong Grating, Contrast Up",tNow);
                    case trialType% = trialtypeAttendAway% then
                        attCountAwayTrialsIncorrect% += 1;
                        SampleText("Miss, Attend Away, Moved To Wrong Grating, Contrast Up",tNow);
                    case trialType% = trialtypeNoChange% then
                        PrintLog("ERROR: No-Change trial, expectedAnswer should be zero but was " + str$(expectedAnswer%) + "\n");
                    else
                        PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                    endcase
                    'getPreciseTiming := 0;
                    'ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
                    ChangeStateTo(stateCheckTurnOffOpto%, tNow);
                    'SafeSampleKey("X");  'do this in stateCheckTurnOffOpto
                else  'it's a NO-GO or catch-as-No-Go trial, and we got an answer
                    'SampleText("-");
                    attCountAllTrialsIncorrect% += 1;
                    attInterTrialTime2 := attInterTrialTime + attMissPenalty;
                    docase
                    case trialType% = trialtypeAttendToward% then
                        attCountTowardTrialsIncorrect% += 1;
                        if attCatchIsNoGo% = 1 and trialCatch% = 1 then
                            SampleText("False Alarm on Catch-as-No-Go, Attend Toward",tNow);
                        else
                            SampleText("False Alarm, Attend Toward",tNow);
                        endif;
                    case trialType% = trialtypeAttendAway% then
                        attCountAwayTrialsIncorrect% += 1;
                        if attCatchIsNoGo% = 1 and trialCatch% = 1 then
                            SampleText("False Alarm on Catch-as-No-Go, Attend Away",tNow);
                        else
                            SampleText("False Alarm, Attend Away",tNow);
                        endif;
                    case trialType% = trialtypeNoChange% then
                        attCountNoChangeTrialsIncorrect% += 1;
                        SampleText("False Alarm, No Change",tNow);
                    else
                        PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                    endcase
                    'getPreciseTiming := 0;
                    Yield(.01);    ' necessary so that the SampleText and SafeSampleKey below don't land on the same time (makes extraction difficult)
                    FAIsResponse% := 1;
                    ChangeStateTo(stateAbort%,tNow);
                    'SafeSampleKey("X");
                endcase
            else 'there is no answer
                if isStimDistractorOff% = 1 and trialType% = trialtypeNoChange% then 'if fixation has been broken
                    'normally we will wait to see if the animal DOES respond, but if there is no contrast change, this is a fixation break                    
                    ChangeStateTo(stateAbort%, tNow); 
                    SampleText("Fixation broken, no response, trial aborted");
                endif
            endif
        endif
        
        
    case iState% = stateCheckTurnOffOpto% then
        'nTrialsCompleted% += 1;  'trial is complete, change of count here makes logic easier 
        'attCurrTrialIndex% += 1;
        docase
        case attDoOpto% = 0 or attOptoStarted% = 0 then 'if this is not an opto trial, trial is complete
            if queueReward% = -1 then 'on a miss, go to miss penalty, otherwise we are done
                ChangeStateTo(stateMiss%, tStateStart);
            else
                ChangeStateTo(stateTrialCompletedWaitForBlank%, tStateStart);
            endif;
            SafeSampleKey("X");  'do this in stateCheckTurnOffOpto
            printlog("Trial complete, Not an opto trial, doOpto = %d, optoState = %d, time = %f\n",attDoOpto%,attOptoState%,tStateStart);
'        case attOptoStaysOn% = 1 and nTrialsCompleted% <> attTrialsPerBlock%+attEasyTrialsPerBlock% then 'this is for when we're keeping the opto on and it's mid block  --- currently disabled
'            if queueReward% = -1 then 'on a miss, go to miss penalty, otherwise we are done
'                ChangeStateTo(stateMiss%, tStateStart);
'            else
'                ChangeStateTo(stateTrialCompletedWaitForBlank%, tStateStart);
'            endif;
'            printlog("Opto is staying on, OptoStaysOn = %d, TrialsComplete = %d, time = %f\n",attOptoStaysOn%,nTrialsCompleted%,tStateStart);
        case attOptoUsePulse% = 1 and attOptoState% = 1 then  'it is a pulsed opto trial
            printlog("Trial complete, Pulsed opto trial, time = %f\n",tStateStart);
            'on a pulsed opto ending, we need to turn off the laser and break out of the opto loop
            if attOptoStarted% = 2 then  'the stimulus may already have been turned off in the answer portion
                SampleKey("B");  'NOT SafeSampleKey - sequencer is in use and we're killing it anyway, by design
                SampleSeqVar(6,attOptoNPulses%);  'reset number of pulses, otherwise bad stuff happens
                attOptoStarted% := 0;  'opto is now off
            endif;
            if queueReward% = -1 then 'on a miss, go to miss penalty, otherwise we are done
                ChangeStateTo(stateMiss%, tStateStart);
                queueReward% := 0;  'reset value, will not reward
            else
                ChangeStateTo(stateTrialCompletedWaitForBlank%, tStateStart);
            endif;
            SafeSampleKey("X");  'do this in stateCheckTurnOffOpto
        else 'otherwise it is an opto trial and we need to turn opto off
            ChangeStateTo(stateTurnOffOpto%, tStateStart);
            printlog("Turning Opto Off at time = %f\n",tStateStart);
        endcase  
        'give out reward, if necessary, in THIS state
        if queueReward% = 1 then
            Reward%();
            queueReward% := 0;  'reset reward
        endif;
        
        
    case iState% = stateTurnOffOpto% then
        'if attOptoState% = 1 then
        SafeSampleKey("o");  'turn it off
        tOpt := View(DataWindow%).MaxTime();
        'printlog("OptoOff at %f\n",tOpt);
        SampleText("OptoOff",tOpt);
        attOptoStarted% := 0;  'opto is now off
        SafeSampleKey("X");  'not done in stateCheckTurnOffOpto if we are actually turning off opto
'        else
'            SafeSampleKey("n");  'turn it off        'again, don't see the point here
'            tOpt := View(DataWindow%).MaxTime();
'            'printlog("OptoOff at %f\n",tOpt);
'            SampleText("NoOptoSoNoOff",tOpt);
        'endif;
        
        ChangeStateTo(stateTrialCompletedWaitForBlank%,tNow);
        
        
    case iState% = stateTrialCompletedWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := View(DataWindow%).NextTime(FrameTriggerChannel%, tLast, vTrigger);
        'if tTrigger > tLast and vTrigger = 1 then
        if tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateTrialCompleteWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            'advance
            'SafeSampleKey("a");
            ChangeStateTo(stateTrialCompletedPause%, tTrigger);
            DrawStim(0);	' actually this draws the location of the fixpt.
        endif
        
'    case iState% = stateNoResponse% then
'        
'        ' we just wait for fix point off signal in this case. 
'        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
'        'tTrigger := View(DataWindow%).NextTime(FrameTriggerChannel%, tLast, vTrigger);
'        'if tTrigger > tLast and vTrigger = 1 then
'        if tTrigger > tLast then
'            ' Fixation point is off
'            PrintLog("stateTrialNoResponse: Fix pt is off.\n");
'            tLastTrigger := tTrigger;
'            'advance
'            'SafeSampleKey("a");  'maybe don't advance
'            ChangeStateTo(stateTrialCompletedPause%, tTrigger);
'            DrawStim(0);	' actually this draws the location of the fixpt.
'        endif        
        
    case iState% = stateTrialCompletedPause% then
        
        if tNow - tStateStart > attInterTrialTime2 then
            
            PrintLog("stateTrialCompletedPause: inter-trial time is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
            
        endif
        
    case iState% = stateMiss% then
        
        if tNow - tStateStart > attMissPenalty then
            
            PrintLog("stateMiss: penalty time is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
            
        endif
        
        
    case iState% = stateTrialCompleted% then
        view(XYWindow%).XYColour(iAnswerWindowChannelMain%,13);  'Force main answer window to blue
        if attNumPatches% > 1 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,13);  'Force distracter1 answer window to blue
        endif;
        if attNumPatches% > 2 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,13);  'Force distracter2 answer window to blue
        endif;
        if attNumPatches% > 3 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,13);  'Force distracter3 answer window to blue
        endif;
        if attNumPatches% > 4 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,13);  'Force distracter4 answer window to blue
        endif;
        view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Force fixation window to blue
        'Things got a bit out of hand in advancing/incrementing as the function got more complex.  Here I am re-simplifying everything.
        'All non-abort states go through stateTrialCompleted as a final step.  Thus, advance and increment in stateTrialCompleted and
        'nowhere else.
        PrintLog("Trial completed.\n");
        nTrialsCompleted% += 1;
        attCurrTrialIndex% += 1;
        SafeSampleKey("a");
        if nTrialsCompleted% = attTrialsPerBlock%+attEasyTrialsPerBlock% then
            ChangeStateTo(stateBlockCompleted%, tNow);
        else
            ChangeStateTo(stateStartTrial%, tNow);
        endif
        
    case iState% = stateBlockCompleted% then
        
        PrintLog("Block completed.\n");
        nBlocksCompleted% := nBlocksCompleted% + 1;
        if nBlocksCompleted% = attNumberOfBlocks% then
            ChangeStateTo(stateDone%, tNow);
            Stop%();
            iStatus% := 0;
        else
            ChangeStateTo(stateStartBlock%, tNow);
        endif
        
    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;
        
    endcase;
    
    
    if updateTLast% = 1 then 
        tLast := tNow;
    endif;
    
    'wend;
    
	return iStatus%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareTrial()
    
	PrintLog("Prepare trial: ");
    
	if attBlockAlternate% = 0 then
        docase
		case attAttendList%[attCurrTrialIndex%] = 1 then
			trialType% := trialtypeAttendToward%;
			PrintLog("Trial type: attend-toward\n");
            JuiceRewardMS% := origRewardMS%; 'set reward at trial prep, this will then be good for the reward on this trial, if any.
        case attAttendList%[attCurrTrialIndex%] = 6 then  
            trialType% := trialtypeNoChange%;
            JuiceRewardMS% := lowRewardMS%;  'use low reward for no-change trials
			PrintLog("Trial type: no-change\n");    
		else
			trialType% := trialtypeAttendAway%;
            JuiceRewardMS% := origRewardMS%;
			PrintLog("Trial type: attend-away\n");
		endcase
	else
        docase
		case attAttendList%[attCurrTrialIndex%] = 1 then
            trialType% := trialtypeAttendToward%;
            JuiceRewardMS% := origRewardMS%;
			PrintLog("Trial type: attend-toward (for this entire block)\n");
        case attAttendList%[attCurrTrialIndex%] = 6 then  
            trialType% := trialtypeNoChange%;
            JuiceRewardMS% := lowRewardMS%;  'use low reward for no-change trials
			PrintLog("Trial type: no-change (for this entire block)\n");     
		else
            trialType% := trialtypeAttendAway%;
            JuiceRewardMS% := origRewardMS%;
			PrintLog("Trial type: attend-away (for this entire block)\n");
		endcase
	endif
       
    
    ' Fixation time is a random number between attFixationMinTime and attFixationMaxTime. 
    attFixationTime := Rand(attFixationCueMaxTime - attFixationCueMinTime, attFixationCueMinTime);
    PrintLog("Fixation time " + str$(attFixationTime) + "\n");
    
    ' Set hazard function time and time to answer per trial
    ' Note that the trialHazardFunction time must be set in CreateContrastList because the value of this variable is not used in *creating the animation*
    if trialType% = trialTypeNoChange% then
        trialHazardFunctionTime := 0.1;  'for no-change trials, set hazard time to 0.1, this is hard coded
        attTimeToAnswerPerTrial := attNoChangeDuration - 0.1;  'the 0.1 is the hardcoded hazard time, the remainder is answer window
    else
        trialHazardFunctionTime := attHazardList[attCurrTrialIndex%];  'hazard time has been pre-calculated for regular trials
        attTimeToAnswerPerTrial := attTimeToAnswer;  'Use the standard time to answer
    endif
    

    'Determine if trial is catch trial
    trialCatch% := 1-attValidList%[attCurrTrialIndex%];
    if trialCatch% = 1 then
        if attCatchIsNoGo% = 0 then
            PrintLog("CATCH\n");
        else
            PrintLog("CATCH - will be treated as No-Go\n");
        endif;
    endif;
    
    
    'Determine if opto should be on
    if attDoOpto% = 1 then  'if there can be opto
        if nTrialsCompleted% >= attEasyTrialsPerBlock% then  'if it's not an easy trial
            if Rand(1,0) <= attOptoPctOpto then
                attOptoState% := 1;  'opto on (random)
            else
                attOptoState% := 0;  'opto off (random)
            endif;
        else
            attOptoState% := 0;  'if it's an easy trial, set opto off
        endif;
    else
        attOptoState% := 0;  'if no opto at all, set opto off
    endif;
    
    
    
    
    'Determine if contrast is changing (target) or not (nontarget)
'    if attContrastList%[attCurrTrialIndex%] = attContrastBase% then
'        trialIsTarget% := 0; 
'    else
'        trialIsTarget% := 1;
'    endif;
    trialIsTarget% := attChangeList%[attCurrTrialIndex%];  'this tells me not only whether the contrast is changing, but WHICH patch
    trialAttendLoc% := attAttendList%[attCurrTrialIndex%];  'this is the attend location
    fixColor$ := masterColorList$[attFixColor%[attCurrTrialIndex%]-1];
    
    'Record actual contrast level on this trial
    thisContrast% := attContrastList%[attCurrTrialIndex%];
    
    'Calculate expected answer
    docase
    case attCatchIsNoGo% = 1 and trialCatch% = 1 then
        expectedAnswer% := 0;  'force expectedAnswer% to 0 (no-go) for catch trials when requested
    case trialIsTarget% < 2 then
        expectedAnswer% := trialIsTarget%;
    else
        expectedAnswer% := -trialIsTarget%+1;
    endcase;
    
    'reset trial flasher count
    if attUseFlashers% = 1 then
        flasherCountThisTrial% := 0;
    endif;
    
    
    'printlog("Trial is target value is %d and expected answer is %d\n",trialisTarget%,expectedAnswer%);
    
'    docase
'    case trialType% = trialtypeAttendToward% then
'        if trialIsTarget% > 0 then
'            if trialCatch% = 0 then
'                expectedAnswer% := 1;
'            else
'                expectedAnswer% := -1;
'            endif
'        else
'            expectedAnswer% := 0;
'        endif
'    case trialType% = trialtypeAttendAway% then
'        if trialIsTarget% > 0 then
'            if trialCatch% = 0 then
'                expectedAnswer% := -1;
'            else
'                expectedAnswer% := 1;
'            endif
'        else
'            expectedAnswer% := 0;
'        endif
'    else
'        PrintLog("ERROR! Unknown blocktype!!!\n");
'    endcase;
    
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareBlock()
    'This function used to do more, but now that all stimuli are determined in advance, it just kinda does some printlogging now
	PrintLog("Block starting: "); 
	if attBlockAlternate% <> 0 then
		if attAttendList%[attCurrTrialIndex%] = 1 then
			PrintLog("Attend-toward ");
		else
			PrintLog("Attend-away ");
		endif
	else
		PrintLog("Attend-toward/away done on a trial-by-trial basis.");
	endif
	PrintLog("\n");
    'reset block-specific variables
	ntrialsCompleted% := 0;
	nTrialsStarted% := 0;
	nTrialsAborted% :=0; 
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
    Pause% :=1;
    ToolbarEnable(4,0);
    ToolbarEnable(5,1);
    return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
    Pause% :=0;
    ToolbarEnable(4,1);
    ToolbarEnable(5,0);
    return 1;
end





proc InitializeWindows()
    
'    'this first bit is just getting testing values for machines that don't have a 1401
'    var stimSpec$;
'    var dist1Spec$;
'    var flasherSpec$;
'    'get all these grating parameters
'    stimSpec$ := GetGratingParameters$("Stimulus");
'    ParseGratingParametersBrief%(stimSpec$, xT, yT, wT, hT);  'we may as well just do this every time - 90+% of the time we will anyway, and why put it in the if statements four times?
'    if attNumPatches% > 1 then
'        if attGetGPFromMainStim% = 1 then
'            ParseGratingParametersBrief%(GetGratingParameters$("Distractor1"), xT, yT, wT, hT);
'            dist1Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
'            ParseGratingParametersBrief%(dist1Spec$, xD1, yD1, wD1, hD1);  'for helping placement of flashers, etc.
'        else
'            dist1Spec$ := GetGratingParameters$("Distractor1");
'            ParseGratingParametersBrief%(dist1Spec$, xD1, yD1, wD1, hD1);
'        endif;
'    endif;
'    flasherSpec$ := GetGratingParameters$("Flasher");
'    ParseGratingParametersBrief%(flasherSpec$, xF1, yF1, wF1, hF1);
'    'run ScreenBounds to get max size of x/y on screen, to be used to make flashers in random locations
'    ScreenBounds(screenXmm,screenYmm,screenXmax,screenYmax);
'    CreateContrastList(Contrast$,Flashers$,attContrastList%,attChangeList%,attValidList%,attAttendList%,attHazardList,attOffBitsList%,attRotationList%,attFixColor%,attBlockList%,attEasyList%,flasherTimes,flasherX,flasherY,flasherCount%);
'    printlog("Contrast list is %s\n",Contrast$);
'    printlog("Flasher list is %s\n",Flashers$);
'    halt;  'No-1401 halt
    
	'Open the data sampling window
	DataWindow% := FileNew(0,4);  'show spike shape setup dialog
    printlog("datawindow is %d\n",dataWindow%);
	Window(0,48,100,95);
	View(DataWindow%).WindowVisible(1);
    
    if UsePlexon% = 1 then
        'Get the name of the most recent .s2r resource file, if any
        var key$;
        var fn$;
        key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
        Profile(key$, "microS2Rfile", "x", fn$);
        printlog("S2R file name %s was retrieved from registry\n",fn$);
        
        'Apply the ,s2r resource file to the current data window, which will apply the spike shape templates
        'if useSpikeTemplate% = 1 and fn$ <> "x" then
        if fn$ <> "x" then  'OK, Henry says no checkbox necessary, just load up every time 
            FileApplyResource(fn$);
            printlog("S2R file name %s was loaded using FileApplyResource\n",fn$);
        endif
    endif;
    

    
	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
    
	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;
    
	'Create a new channel in the XY view to display the fixation window
	iFixationWindowChannel% := XYSetChan(0);
	XYColour(iFixationWindowChannel%,13);
	XYDrawMode(iFixationWindowChannel%,2,1);
	XYJoin(iFixationWindowChannel%,1);
	'Draw the fixation window
	XYAddData(iFixationWindowChannel%, FixWindowX[], FixWindowY[]);
    
    
    'get locations of stimuli so that answer windows overlap them
    ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"),mainX,mainY,mainW,mainH); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor1"),dist1X,dist1Y,dist1W,dist1H);
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor2"),dist2X,dist2Y,dist2W,dist2H); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor3"),dist3X,dist3Y,dist3W,dist3H); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor4"),dist4X,dist4Y,dist4W,dist4H);     
    
    'Not sure if Henry wants this feature
    'If we are getting our grating parameters from the main stimulus, get ONLY the X and Y position and NOT the width/height, match W/H to main grating
    if attGetGPFromMainStim% = 1 then
        dist1W := mainW;
        dist1H := mainH;
        dist2W := mainW;
        dist2H := mainH;
        dist3W := mainW;
        dist3H := mainH;
        dist4W := mainW;
        dist4H := mainH;
    endif;
    
    'And finally, override answer window size if specified answer window is positive
    if attAnswerPointWindowRadius > 0 then
        mainW := attAnswerPointWindowRadius;
        mainH := attAnswerPointWindowRadius;
        dist1W := attAnswerPointWindowRadius;
        dist1H := attAnswerPointWindowRadius;
        dist2W := attAnswerPointWindowRadius;
        dist2H := attAnswerPointWindowRadius;
        dist3W := attAnswerPointWindowRadius;
        dist3H := attAnswerPointWindowRadius;
        dist4W := attAnswerPointWindowRadius;
        dist4H := attAnswerPointWindowRadius;
    endif;
    
    
    'Create new channels in the XY view to display the answer windows
    'reuse FixationX, FixationY
    'Main stimulus window
    for index% := 0 to 35 do
        FixWindowX[index%] := mainX + mainW * Cos(index% * twopi/36.0);
		FixWindowY[index%] := mainY + mainH * Sin(index% * twopi/36.0);
	next;
    iAnswerWindowChannelMain% := XYSetChan(0);
    XYColour(iAnswerWindowChannelMain%,13);
	XYDrawMode(iAnswerWindowChannelMain%,2,1);
	XYJoin(iAnswerWindowChannelMain%,1);
	'Draw the answer window
	XYAddData(iAnswerWindowChannelMain%, FixWindowX[], FixWindowY[]);
    

    'Distracter1 window
    if attNumPatches% > 1 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist1X + dist1W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist1Y + dist1H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist1% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist1%,13);
        XYDrawMode(iAnswerWindowChannelDist1%,2,1);
        XYJoin(iAnswerWindowChannelDist1%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist1%, FixWindowX[], FixWindowY[]);
    endif;
       
    'Distracter2 window
    if attNumPatches% > 2 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist2X + dist2W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist2Y + dist2H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist2% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist2%,13);
        XYDrawMode(iAnswerWindowChannelDist2%,2,1);
        XYJoin(iAnswerWindowChannelDist2%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist2%, FixWindowX[], FixWindowY[]);
    endif;    
    
    'Distracter3 window
    if attNumPatches% > 3 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist3X + dist3W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist3Y + dist3H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist3% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist3%,13);
        XYDrawMode(iAnswerWindowChannelDist3%,2,1);
        XYJoin(iAnswerWindowChannelDist3%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist3%, FixWindowX[], FixWindowY[]);
    endif;
    
    'Distracter4 window
    if attNumPatches% > 4 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist4X + dist4W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist4Y + dist4H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist4% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist4%,13);
        XYDrawMode(iAnswerWindowChannelDist4%,2,1);
        XYJoin(iAnswerWindowChannelDist4%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist4%, FixWindowX[], FixWindowY[]);
    endif;    
    
    
    
    
	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);
    
	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%,13);
	XYDrawMode(iMonitorChannel%,3,1);
	XYJoin(iMonitorChannel%,2);
	XYAddData(iMonitorChannel%,-9,-7);
	XYAddData(iMonitorChannel%,9,-7);
	XYAddData(iMonitorChannel%,9,7);
	XYAddData(iMonitorChannel%,-9,7);
    
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
    var key$;
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    SampleClear(); 'Set standard sampling state
    SampleChannels(64);  '32 does not work, we need more!

    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    if UsePlexon% = 0 then
        SampleAutoName$(dataCellName$ + "_atn_000");  'NOTE: maximum of 13 characters!!!
    else
        EqualizeSMRFilenumbers(dataPathRoot$ + "\\" + dataDataSet$,dataCellName$+"_atnMICRO_",dataCellName$+"_atnPOWER_");
        SampleAutoName$(dataCellName$ + "_atnMICRO_000");  'NOTE: maximum of 13 characters!!!
        SetStringRegistryValue(key$, "pref", "atn");
    endif;
    'autoNameTemplate$ := SampleAutoName$();  'to retrieve sample name, this must be called AFTER setting ::rolls eyes::
    SampleAutoFile(1);  'Enable automatic file naming
    
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
	'Channel recording definitions
	SampleEvent(FrameTriggerChannel%,0,2,3600); 'Trigger channel, level
	SampleComment$(FrameTriggerChannel%,"Frame");
	SampleTitle$(FrameTriggerChannel%,"Frame");
    
    ' Synch channel for checking synchronization.  Synch is good down to the microsecond.  Have to change 
' Edit->Edit Preferences->Sampling->Event Ports 0 and 1 on rear digital... to unchecked or it won't work    
'   SampleEvent(SynchChannel%,1,2,3600); 'Synch channel, level
'	SampleComment$(SynchChannel%,"Synch");
'	SampleTitle$(SynchChannel%,"Synch");
    
 	SampleEvent(FixationPointChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixation");
	SampleTitle$(FixationPointChannel%,"Fixation");
	
	SampleEvent(StimChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
	
	SampleEvent(StimChangeChannel%,4,2,3600); 'Trigger channel, level
	SampleComment$(StimChangeChannel%,"Stim Chg.");
	SampleTitle$(StimChangeChannel%,"Stim Chg.");
	
	SampleEvent(ReadyChannel%,6,2,3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
    ' Set up channels for sampling electrodes.
    docase
    case UsePlexon% = 1 then  'call Plexon setup function, this will ONLY set up the sampling configuration for the Micro1401 mark II.  The Power1401 will be set up from its own dedicated script in its dedicated Spike2 instance
        CreatePlexonSamplingConfiguration1824Micro(); 'Note that for right now the ONLY Plexon configuration is 18 WaveMark/24 LFP (maximal WMs for 24 LFPs, trust me)
    case UsePlexon7WM15CN% = 1 then  'call 7 wavemark, 15 continuous setup
        CreateElectrodeSamplingConfiguration7WM15CN();
    case UsePlexon15WF15WF2k% = 1 then  'call 15 waveform, 15 waveform@2k setup
        CreateElectrodeSamplingConfiguration15WF15WF2k();
    case UsePlexon24WF% = 1 then
        CreateElectrodeSamplingConfiguration24WF();
    else  'just set up the channels as expected
        'CreateElectrodeSamplingConfiguration(1, 11);
        CreateElectrodeSamplingConfiguration32(1, 1+numWavemarkPorts%, ExcludedChans%);  'Allows a lot of channels while preventing accidentally re-defining a channel
    endcase;
	
    ' Set up eye channels whether using Plexon or not
	'SampleWaveform(XChannel%,14,1000);
    SampleWaveform(XChannel%,GetEyeXPort%(),1000);
	SampleTitle$(XChannel%,"Eye X");
	'SampleWaveform(YChannel%,15,1000);
    SampleWaveform(YChannel%,GetEyeYPort%(),1000);
	SampleTitle$(YChannel%,"Eye Y");
    
    
    'Add a digital marker channel for pulsing optogenetics
    'Do it for every opto, easy enough to add this into the wraparound calls in the PLS
    'Will record a '1' for laser on and a '0' for laser off
    if attDoOpto% = 1 then
        SampleDigMark(20);  '20 Hz should be plenty high for an expected sustained rate
        SampleTitle$(DigitalLaserChannel%,"Laser On");
    endif
    
    'Add a waveform channel for efference copy.  This can come from either the 1401 itself or
    'from the stimulator, it doesn't really matter.
    'It would be nice to have these as level channels on event inputs, but that does not fly with the VSG box. (Several months later, I do not know how to interpret that comment...jj)
    if attOptoUsePulse% = 1 and attDoOpto% = 1 then
        SampleWaveform(OptoCopyChannel%,31,5000);  'on adc31, which is Henry's max, hardcoded for now
        SampleTitle$(OptoCopyChannel%, "OptoCopy");
    endif;
    
    
    'I don't know what this is, but it's a problem for Plexon configs
'    if UsePlexon% = 0 and UsePlexon7WM15CN% = 0 then  'Kill it if we're using the Plexon
'        SampleWaveform(NumberOfElectrodes%+10, 6, 1000);
'        SampleTitle$(NumberOfElectrodes%+10, "PD");
'    endif;
    
    
	SampleTextMark(200);  'increase number of allowed characters, 1 is so stingy!
    
	'SampleSequencer(script$ + "Attention.pls");
    SampleSequencer(script$ + "Tuning.pls");
    docase
    case UsePlexon% = 1 then  'Set optimise mode (do this last, so it's outside of the CreatePlexonSamplingConfiguration... functions)
        SampleOptimise(0,1,4,0,0,0,0);  'for the Micro 1401 mk II: manually set sampling timing, group channels with same ideal rate, micro1401, unused, unused, do not disable for compatibility, no burst mode
    case UsePlexon15WF15WF2k% = 1 or UsePlexon24WF% = 1 then 
        SampleOptimise(2,2,9,1,50,0,1);  'for big-data, need to set for burst mode, Power1401-3 setting is not clear because help does not list it.  9?  8 for micro1401-3?
    else
        SampleOptimise(2,2,Get1401Type%(),2,50);  'otherwise: full optimize timing, channels may have different rates, Power1401 (lowest common denominator, so eh), low usPerTime of 2, high usPerTime of 50
    endcase;
	SampleMode(1); 'Continuous sampling
end;


'''This is now covered by #include UsreyGratings
' Get grating parameters from registry AlertRig\\(config)\\Gratings\\type$
'func GetGratingParameters$(type$)
'	var key$;
'	var stmp$;
'	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\Gratings";
'	Profile(key$, type$, "", stmp$);
'	return stmp$;
'end;

' Replace the color vector spec in a grating with the specified value
func ReplaceGratingColorVector$(gspec$, cvspec$)
    var s$;
    var i1%, i2%;
    var index%:=0;
    var i%;
    ' i1% and i2% are the index positions of the 8th and 9th commas
    PrintLog(gspec$ + "\n");
    for i% := 1 to 10 do
        index% := InStr(gspec$, ",", index%+1);
        PrintLog("%d index %d\n", i%, index%);
    next;
    i1% := InStr(gspec$, ",", index%+1);
    i2% := InStr(gspec$, ",", i1%+1);
    s$ := Mid$(gspec$, 1, i1%) + cvspec$ + Mid$(gspec$, i2%);
    PrintLog(s$ + "\n");
    return s$;
end

' Replace the X and Y positions in the grating spec with new XY positions but leave the rest (including W/H) the same
func ReplaceGratingXY$(sSpec$,x,y);
    var s$;
    var i1%, i2%;
    i1% := InStr(sSpec$, ",");  'get first comma position
    i2% := InStr(sSpec$, ",", i1%+1);  'get second comma position
    s$ := Str$(x) + "," + Str$(y) + "," + Right$(sSpec$,Len(sSpec$)-i2%);  'and put the X and Y values in front
    return s$;
end    
    
' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, mylen%;
    var fn$;
    var chanToExport%[30];
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    ' Save the current resource file - might be causing problems
    'FileSaveResource(1);   
    
    'turn off opto just in case it might be on (it shouldn't, but...)
    if attDoOpto% = 1 then
        SafeSampleKey("o");
    endif;
    
	' Tell stim app to shut down
	SafeSampleKey("Q");
	Yield(.1);
	SampleStop();
    
	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend
    
    
    '''As of now, Henry does not want there to be .mat file output on attenGNG (3/21/16 jj)   
    '''Note that I've updated the syntax here in other code to make sure the eye channels
    '''actually come out, check CuedAtten.s2s for details
'    View(DataWindow%);
'    ExportChanList(); 
'    chanToExport%[1] := 30;  'channels to export go in elements 1:...'30 is the textmark channel
'    chanToExport%[2] := 31;  '31 is the keyboard channel
'    chanToExport%[3] := StimChannel%;  'stim channel
'    docase
'    case UsePlexon% = 1 then  'use hardcoded Plexon values - 18 WaveMarks and 24 LFPs for now, on the micro it's 
'        for i% := 0 to 12 do
'            chanToExport%[i%+4] := i%+1;  'wavemark channels are in order
'        next;
'        chanToExport%[0] := 3+i%;  'total number of channels goes in element 0
'    case UsePlexon7WM15CN% = 1 then  'use hardcoded Plexon values - 7 WaveMarks and 15 LFPs
'        for i% := 0 to 13 do
'            chanToExport%[i%+4] := i%+1;  'wavemark channels are in order
'        next;
'        for i% := 14 to 21 do
'            chanToExport%[i%+4] := i%+3;  'wavemark channels are in order, but we're skipping eye channels
'        next;
'        chanToExport%[0] := 3+i%;  'total number of channels goes in element 0
'    else
'        for i% := 0 to NumWavemarkPorts% do
'            chanToExport%[i%+4] := i%+1;  'wavemark channels are in order
'        next;
'        chanToExport%[0] := 3+i%;  'total number of channels goes in element 0
'    endcase;
'    
'    ExportChanList(0,view(datawindow%).maxtime(),chanToExport%[]);
'    
'    'Code for putting other various channels into the Matlab extraction, Ben doesn't want them but they will be useful for other code    
'    ExportChanList(0,View(DataWindow%).maxtime(),XChannel%);  'Eye position channel, X
'    ExportChanList(0,View(DataWindow%).maxtime(),YChannel%);  'Eye position channel, Y
'    'for i% := 0 to NumWavemarkPorts%-1 do
'    '    ExportChanList(0,View(DataWindow%).maxtime(),i%+1);  'Wavemark channel(s)
'    'next;
'    
'    
'    fn$ := FileName$();  'get current file name
'    printlog("file name is %s\n",fn$);
'    mylen% := Len(fn$);
'    fn$ := Left$(fn$,mylen%-4);
'    fn$ := fn$ + ".mat";
'    FileSaveAs(fn$,100,0,"",0,"UseSName=0"); 'Do not overwrite the .mat file - should have a different name and if it doesn't that is a red flag    
    
    ' Write parameter file
	WriteParameterFile();
    
    if UsePlexon% = 1 then
        ' Save most recent .s2r file name to registry
        fn$ := Left$(fn$,mylen%-4);
        fn$ := fn$ + ".s2r";
        var key$;
        key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
        Profile(key$, "microS2Rfile", fn$);
        printlog("S2R file name %s was saved to registry\n",fn$);
    endif;
    
    
    ' update statistics
    'AttentionExtract%(-1, -1);
    
	'ProgRun(bin$ + "\\ClearTrigger",0);
    
end;



func StartPlexon%()
    
    
    'Start the Power1401!  This is a bit cumbersome, and I'm not sure it's transferable, but it's a start, perhaps.
    var fp$;  'to hold current file path
    var fp2$;  'to hold destination file path
    fp$ := FilePath$();  'get current file path
    printlog("%s\n",fp$);  'and tell the world what it was
    FilePathSet("F:/work/AlertRig/Spike2Scripts");  'change the file path
    fp2$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp2$);  'by telling the world about it (hint: it works)
    
    'These two functions are not done before initializing the toolbar in dual-1401 mode
    'Must run this BEFORE the PROGRUN command, because both this sequence AND SetPlexon...
    'access the same directory, and this was causing conflicts because they were running
    'simultaneously.  Here, CreateSampleConfiguration is done accessing the directory before
    'SetPlexon... is started, and everything is kosher.
    CreateSampleConfiguration();
    
    progrun("sonview.exe /M /u2 SetPlexonRecording1824OnPower1401.s2s");  'run the program, .s2s file is now on default path by design
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar, this may not work

    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar
    
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
	var Extras$;
	var Tune$;
	var Stim$:="";
	'var Contrast$;  'made global so that WriteParameterFile can use it
    var ttemp;
    var stimSpec$;
    var dist1Spec$;
    var dist2Spec$;
    var dist3Spec$;
    var dist4Spec$;
    var flasherSpec$;
    var lolSpec$;  'LOLlerskates!  ROFLcopter!
    var x;
    var i%;
    var specFileName$:="F:\\work\\AttentionSpecFile.txt";
    var specHandle%;
    var spec2FileBase$;
    var spec2FileName$;
    var spec2Handle%;
    var CueCirc$;  'this begins blank, if we don't use cue circles then it won't get filled
    'var tOff;  'holds the offset time for calculation of flasher times
    'vars for opto setup
    var voltageInteger%;
    var stimRemaining;
    stimRemaining := attFixationCueMaxTime + attHazardCutoffTime + attTimeToAnswer;
    var tempNPulses%;
    var tempCount%;
    var tempSeqVarValue;
    var tempSeqVarValue%;
    
    
	
    'hard code pReward to 1, per Henry
    pReward := 1;
   
  
    'start sampling
    if UsePlexon% = 1 then
        SampleStart(1);  'set sampling to start on a trigger     
    else
    	SampleStart(0); 'Start sampling now
    endif;
    
    SequencerPeriodMS := SampleSeqClock(1);  'Get the clock period of the sequencer, in MS, must do this after starting sampling
    
    
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    ttemp := View(DataWindow%).MaxTime();
    Yield();
    tLast := View(DataWindow%).MaxTime();
    PrintLog("ttemp " + str$(ttemp) + " tlast " + str$(tLast) + "\n");
    
    
    
    if attDoOpto% = 1 then
        'set sequencer variable 4 for opto voltage
        'Please note that the input for this has to be a 32-bit variable. Use vdac32% to get the right value.
        voltageInteger% := vdac32%(attOptoVoltageOut, 1, 0);
        SampleSeqVar(4,voltageInteger%);
        printlog("Voltage integer is %d\n",voltageInteger%);
        
        'If pulsing, because the user could have changed the duration of the stimulus after setting the opto
        'parameters, we need to check the parameters again (even though the opto dialog box did it already)
        if attOptoUsePulse% = 1 then
            
            
            stimRemaining := stimRemaining - attPulsedOptoOnset;  'duration of stimulus after onset delay
            stimRemaining := stimRemaining - attPulsedOptoWidth;  'duration of stimulus after first opto pulse
            if stimRemaining < 0 then  'if first pulse will extend beyond stimulus duration
                attOptoNPulses% := 0;  'turn off opto by using no pulses
                'tell user they blew it
                Message("The first opto pulse will extend beyond the stimulus!  Quitting!!!");
                Quit%();
            else
                tempNPulses% := attOptoNPulses% - 1;  'how many more pulses are left?
                tempCount% := 1;  'temporary successful pulse count
                while tempNPulses% > 0 do
                    stimRemaining := stimRemaining - attPulsedOptoWidth - attPulsedOptoIPI;  'subtract duration of one more pulse+IPI
                    if stimRemaining < 0 then  'if this pulse will extend beyond stimulus duration
                        Message("Due to stimulus length, only " + Str$(tempCount%) + " pulses can be completed!");
                        attOptoNPulses% := tempCount%;  'only use this many pulses if user does not recalculate
                        stimRemaining := stimRemaining + attPulsedOptoWidth + attPulsedOptoIPI;  'add back duration of one more pulse+IPI, gets actual stimulus duration remaining
                        tempNPulses% := 0;  'break while
                    else  'if this pulse is OK
                        tempCount% += 1;  'increment temporary successful pulse count
                    endif;
                    tempNPulses% -= 1;  'decrement temporary pulse count remaining
                wend
            endif;
        endif;
        
        'If pulsing, set sample sequencer variables
        if attOptoUsePulse% = 1 then  'yes, this is the same "if" as above, just seems cleaner this way
            SampleSeqVar(6,attOptoNPulses%);  'set number of pulses
            printlog("Opto N pulses is %d\n",attOptoNPulses%);
            'For below calculations, the standard numbers we are getting are in seconds, sequencer period is in MS (because that's how it comes)
            
            tempSeqVarValue := attPulsedOptoWidth*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-2;  'now convert to integer, subtract two ticks for sequencer instructions
            SampleSeqVar(7,tempSeqVarValue%);  'set duration of pulse in clock ticks
            printlog("Opto width is %d\n",tempSeqVarValue%);
            
            tempSeqVarValue := attPulsedOptoIPI*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-3;  'now convert to integer, subtract three ticks for sequencer instructions
            SampleSeqVar(8,tempSeqVarValue%);  'set interpulse interval in clock ticks
            printlog("Opto IPI width is %d\n",tempSeqVarValue%);
            
            tempSeqVarValue := attPulsedOptoOnset*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-1;  'now convert to integer, subtract one tick for sequencer instructions
            SampleSeqVar(9,tempSeqVarValue%);  'set pre-pulse stimulus duration in clock ticks
            printlog("Opto onset is %d\n",tempSeqVarValue%);
            
            tempSeqVarValue := stimRemaining*1000/SequencerPeriodMS;  'do math in float
            tempSeqVarValue% := tempSeqVarValue-3;  'now convert to integer, subtract three ticks for sequencer instructions
            SampleSeqVar(10,tempSeqVarValue%);  'set post-pulse stimulus duration in clock ticks
            printlog("Opto remaining time is %d\n",tempSeqVarValue%);
        endif;
        
    endif;
    
    
    
    
    if attUseCueCircles% > 0 then
        CueCirc$ := CreateCueCircleColorSets$();
    endif;
    
    'get all these grating parameters
    stimSpec$ := GetGratingParameters$("Stimulus");
    ParseGratingParametersBrief%(stimSpec$, xT, yT, wT, hT);  'we may as well just do this every time - 90+% of the time we will anyway, and why put it in the if statements four times?
    if attNumPatches% > 1 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor1"), xT, yT, wT, hT);
            dist1Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
            ParseGratingParametersBrief%(dist1Spec$, xD1, yD1, wD1, hD1);  'for helping placement of flashers, etc.
        else
            dist1Spec$ := GetGratingParameters$("Distractor1");
            ParseGratingParametersBrief%(dist1Spec$, xD1, yD1, wD1, hD1);
        endif;
    endif;
    if attNumPatches% > 2 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor2"), xT, yT, wT, hT);
            dist2Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
            ParseGratingParametersBrief%(dist1Spec$, xD2, yD2, wD2, hD2);
        else
            dist2Spec$ := GetGratingParameters$("Distractor2");
            ParseGratingParametersBrief%(dist1Spec$, xD2, yD2, wD2, hD2);
        endif;
    endif;
    if attNumPatches% > 3 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor3"), xT, yT, wT, hT);
            dist3Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
            ParseGratingParametersBrief%(dist1Spec$, xD3, yD3, wD3, hD3);
        else
            dist3Spec$ := GetGratingParameters$("Distractor3");
            ParseGratingParametersBrief%(dist1Spec$, xD3, yD3, wD3, hD3);
        endif;
    endif;
    if attNumPatches% > 4 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor4"), xT, yT, wT, hT);
            dist4Spec$ := ReplaceGratingXY$(stimSpec$,xT,yT);
            ParseGratingParametersBrief%(dist1Spec$, xD4, yD4, wD4, hD4);
        else
            dist4Spec$ := GetGratingParameters$("Distractor4");
            ParseGratingParametersBrief%(dist1Spec$, xD4, yD4, wD4, hD4);
        endif;
    endif;

    
    
    if attCustomGratingColorCheck% = 1 then
        var f$, t$;
        f$ := EncodeColor$(attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2]);
        stimSpec$ := ReplaceGratingColorVector$(stimSpec$, f$ + "-" + t$);
        f$ := EncodeColor$(attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);
        if attNumPatches% > 1 then
            dist1Spec$ := ReplaceGratingColorVector$(dist1Spec$, f$ + "-" + t$);
        endif;
        if attNumPatches% > 2 then
            dist2Spec$ := ReplaceGratingColorVector$(dist2Spec$, f$ + "-" + t$);
        endif;
        if attNumPatches% > 3 then
            dist3Spec$ := ReplaceGratingColorVector$(dist3Spec$, f$ + "-" + t$);
        endif;
        if attNumPatches% > 4 then
            dist4Spec$ := ReplaceGratingColorVector$(dist4Spec$, f$ + "-" + t$);
        endif;
    endif

    
	Stim$ := " -s " + stimSpec$;  
    if attNumPatches% > 1 then
            Stim$ := Stim$ + " -s " + dist1Spec$;
    endif;
    if attNumPatches% > 2 then
            Stim$ := Stim$ + " -s " + dist2Spec$;
    endif;
    if attNumPatches% > 3 then
            Stim$ := Stim$ + " -s " + dist3Spec$;
    endif;
    if attNumPatches% > 4 then
            Stim$ := Stim$ + " -s " + dist4Spec$;
    endif;
    
    if attUseFlashers% = 1 then
        flasherSpec$ := GetGratingParameters$("Flasher");
        ParseGratingParametersBrief%(flasherSpec$, xF1, yF1, wF1, hF1);
        Stim$ := Stim$ + " -k " + flasherSpec$;  'This specifies flasher #0, the VSG side software allows more flasher gratings to be spec'ed but as of now we will only use one
    endif;
    
    
    'run ScreenBounds to get max size of x/y on screen, to be used to make flashers in random locations
    ScreenBounds(screenXmm,screenYmm,screenXmax,screenYmax);
    
    'Fills Contrast$/Flashers$ with the big ol' list, plus some vars to make it easier on us all
	CreateContrastList(Contrast$,Flashers$,attContrastList%,attChangeList%,attValidList%,attAttendList%,attHazardList,attOffBitsList%,attRotationList%,attFixColor%,attBlockList%,attEasyList%,flasherTimes,flasherX,flasherY,flasherCount%);     

    

    
    
    'Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$() + " -A " + str$(attAnswerPointOffset) + " -D " + str$(attAnswerPointDiameter) + lolSpec$;  'answer points on
    Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$(); '+ " -N ";' + lolSpec$;  'answer points off, lollipop spec off as well
    'if attTrainingContrastCheck% = 1 then
    '    Extras$ := Extras$ + " -T " + str$(attTrainingContrastPct%);
    'endif
    
    'Hardcode the choice points to be red no matter what
    'Turns out that for the attention program the color in the fixation argument sets the color of the choice
    'points but that the actual fixation point is set differently.  FixationArg$ is created at the outset of
    'the script, but here I'm overriding the value to make the choice points always red.
    FixationArg$ := " -f " + str$(FixationX) + "," + str$(FixationY) + "," + str$(FixationDiameter) + ",red";
	
	'CommandLine$ := "cmd /c " + bin$ + "\\dAttention " + FixationArg$ + Extras$ + Distractors$;
	'CommandLine$ := "cmd /k " + bin$ + "\\Attention " + FixationArg$ + Extras$ + Stim$ + Contrast$;
    'CommandLine$ := "cmd /k " + bin$ + "\\Attention -F " + specFileName$;
    
    
    ' djs Update this to use remote stim when configured
    if GetUseRemoteStimulus%() = 1 then
        CommandLine$ := "cmd /k " + GetBinDir$(1) + "remote.exe " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim -F " + specFileName$;
    else
        CommandLine$ := "cmd /k " + GetBinDir$(1) + "fixstim.exe -F " + specFileName$;
    endif
    
    
    'open a file to write the trial-by-trial specs for the VSG
    specHandle% := FileOpen(specFileName$, 8, 1);
    'print to spec file
    if attUseFlashers% = 1 then
        Print("%s %s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,Flashers$,Contrast$);  'file should be everything starting from FixationArg$ on, use flashers, Flashers$ must come before Contrast$!
    else
        Print("%s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,Contrast$);  'file should be everything starting from FixationArg$ on
    endif;    
    'close spec file
	FileClose(0);
    
    'Print the parameters
    for i% := 1 to Len(CommandLine$) step 100 do
        SampleText(Mid$(CommandLine$, i%, 100));
    next
    
    'Save the spec file in a secondary, permanent location
    ' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	spec2FileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
    'added specfile write because this is not retained anywhere, for debug and in case of crash
    spec2FileName$ := spec2FileBase$ + ".spc";
	PrintLog("spec filename is " + specFileName$ + "\n");
	spec2Handle% := FileOpen(spec2FileName$, 8, 1);
    if attUseFlashers% = 1 then
        Print("%s %s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,Contrast$,Flashers$);  'file should be everything starting from FixationArg$ on, use flashers
    else
        Print("%s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,Contrast$);  'file should be everything starting from FixationArg$ on
    endif; 
    ' close specfile
	FileClose(0);
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(CommandLine$+"\n");
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	'Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(.1);
    return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawStim
' 
' Draws stimulus in xy window (iDraw%==1) or blanks it (0). 
proc DrawStim(iDraw%)
    
	if iDraw% > 0 then
		var xstim, ystim;
		xstim := FixationX;
		ystim := FixationY;
        
		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif
    
end;




'
'
'===== GetLogProgression =====

' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
' There will be a total of nsteps%+1 values entered into vec[], vec[0] will be xmin, vec[nsteps%] will be xmax
Proc GetLogProgression(xmin, xmax, nsteps%, &vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		'PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;

'
'
'======= CreateContrastList =======
'Fill input variable c$ with the long-form contrast specifier for the Attention experiment
'and cList%[] with the actual contrast (at change) to be used on each trial - note that if this is equal to attContrastBase% then the trial is a non-target trial
'and chgList%[] with the stimulus location that is changed (new)
'and vList%[] with ones if valid and zeros for invalid trials
'and attList%[] for which stimulus is being attended (new)
'and hazList[] with the required hazard time (time to contrast change) for each trial (new)
'and offList%[] with a series of off-bits (1=stim 1 off, 2 = dist1 off, 4 = dist2 off, etc.) (new, probably not used later but nice to have in case)
'and rotList%[] with a series of rotation values
'and fixColor%[] with the current fixation color
'and blockList%[] with the current block value (0 for first block, 1 for second block, etc., resets once all unique blocks are used [could call this an uberblock])
'and flashTimes[][] with the times of the flashers
'and flashX[][] with the x location of the flashers
'and flashY[][] with the y location of the flashers
'and flashN[] with the number of flashers per trial
'Creating all of these here (including easy trials) allows us to just blast through once we get to the actual experiment
'without too much counting going on.
Proc CreateContrastList(&c$,&f$,&cList%[],&chgList%[],&vList%[],&attList%[],&hazList[],&offList%[],&rotList%[],&fixColor%[],&blockList%[],&easyList%[],&flashTimes[][],&flashX[][],&flashY[][],&flashN%[])
        'hja looking at current function
    var i%;
    var ii%;
    var j%;
    var k%;
    var timesLoop%;
    var tempInvalid%;  'holds number of invalid stimulus patch 
    var stdCount%;  'a counter for standard (i.e. "valid") trials, index into attTrialOrder%[]
    var catchCount%;  'a counter for catch trials
    var totalCount%;  'the current index of the xList% variables
    var blockCount%;
    var attDirection%;
    var attColor%;
    var alloff%;  'this is for the bitwise "off" indicator
    var cueCircleRotation% := 0;
    var trialDur;
    
    var blockTypes%[6];  'These are only used if we are "alternating" blocks and simultaneously using a no-change condition
    var btIndices%[6];  'index, for the shuffle
    var nBlockTypes%;
    var blockTypeIndex% := 0;
    
    'variables for allowing blocks to have the same list of hazard times
    var randHazValList[attTrialsPerBlock%];  'allows us to reassign hazard values, "rand" because we're going to shuffle it
    var randHazValInd%[attTrialsPerBlock%];  'with flashers as well, we need to scramble indices
    var randHazIndex%;  'index into randHazValList
    var firstBlockType%;  'lets us know if this is the first block type
    var firstRun := 1;  'for some housekeeping on UpdateFlasherSpecString
    var tempFlashTimes[attMaxFlashers%][attTrialsPerBlock%];
    var tempFlashX[attMaxFlashers%][attTrialsPerBlock%];
    var tempFlashY[attMaxFlashers%][attTrialsPerBlock%];
    var tempNFlashPerTrial%[attTrialsPerBlock%];
    
    'Get Flasher dialog parameters, gets width and height
    GetFlasherDialogParameters();
    
    'preliminaries for no-change condition, which messes with numbering because the number of distractors is variable
    if attNoChangeCondition% = 1 then    
        'If we are asked to "alternate" blocks and to use a No-Change condition, here's the protocol:
        'Create a list of legal block numbers (1 = on-RF, 2-5 = existing distractors, 6 = no-change)
        for i% := 0 to attNumPatches%-1 do
            blockTypes%[i%] := i%+1;
        next
        blockTypes%[attNumPatches%] := 6;  'no change value is hardcoded 
        'printlog("original blocktype is %d\n",blockTypes%[]);
        'and shuffle the list
        Shuffle%(attNumPatches%+1,btIndices%[]); 'hja comment:  Shuffle% ia a function in MiscUtilities.
      
        'when you pass a variable into a function, any changes made inside the function may apply to the value in the
        'original domain (even with no output).
        'printlog("shuffled blocktype is %d\n",blockTypes%[]);
    endif
    
    
    'calculate the value of alloff%, this is bitwise indicator if all stimuli are shut off
    'this is simply 2^0 + 2^1 + 2^2 ... + 2^(n-1), which is (2^n)-1
    alloff% := pow(2,attNumPatches%)-1;
    
    
    c$ := " -J " + Str$(attTimeToAnswer) + ",";  'put in the first two elements of the specifier string, the -J and the post-CC time
    f$ := " -j ";  'Flasher list is led by a lower case -j
    
    for i% := 1 to attNumberOfBlocks% do
        
        'If we are alternating by block or randomizing by block, set attDirection% here, otherwise we set it on a trial-by-trial basis
        docase 
        'if randomizing by trial do nothing, this is dealt with later
        case attBlockAlternate% = 0 then
        'if a start block is specified and it is the first block, use that start block
        case i% = 1 and attStartBlock% > 0 then
            attColor% := attStartBlock%; 
            'Also, for the alternate+no change condition, get starting block index, because this cycles
            if attBlockAlternate% = 2 and attNoChangeCondition% = 1 then 
                for k% := 0 to len(btIndices%[])-1 do
                    if attStartBlock% = blockTypes%[btIndices%[k%]] then
                        blockTypeIndex% := k%+1;
                        'and cycle back to index zero if we go past the end
                        if blockTypeIndex% > attNumPatches% then  'attNumPatches% is right because there are attNumPatches%+1 total legal indices
                            blockTypeIndex% := 0;
                        endif;
                    endif
                next
            endif
        'if randomizing by block without a no-change, select random stim to attend (block > 1 or start block not specified)
        case attBlockAlternate% = 1 and attNoChangeCondition% = 0 then  'randomize by block, choose a random stimulus to attend for each block, all stims have equal probability
            attColor% := Floor(Rand(attNumPatches%,1));  'offset by 1 so the value comes out 1:N instead of 0:N-1    
        'if randomizing by block with a no-change, select random stim to attend (block > 1 or start block not specified)    
        case attBlockAlternate% = 1 and attNoChangeCondition% = 1 then  'randomize by block, choose a random stimulus to attend for each block, all stims including no-change have equal probability 
            attColor% := blockTypes%[btIndices%[Floor(Rand(attNumPatches%+1,0))]];  'do not offset by one, we are shuffling indices
        'if alternating without a no-change condition, every other block is on RF...note that randBlockOrderVar is appropriately changed above (in dialog code) if attStartOrder is set  
        case attBlockAlternate% = 2 and attNoChangeCondition% = 0 then  'alternate by block, every other block is on receptive field, blocks off RF are randomly selected
            if ((blockCount%+randBlockOrderVar%) mod 2) = 1 then
                attColor% := 1;  'Attend main stimulus
            else
                attColor% := Floor(Rand(attNumPatches%-1,2));  'choose a random stim to attend that is not the main
            endif
        'if alternating with a no-change condition, Henry wants to cycle through blocks, starting with attend-toward unless otherwise specified
        case attBlockAlternate% = 2 and attNoChangeCondition% = 1 then 
            'select a starting block from the list of legal starting blocks using an index
            attColor% := blockTypes%[btIndices%[blockTypeIndex%]]; 'this should put the randomization back in
            'update blockTypeIndex%
            blockTypeIndex% += 1;
            'and cycle back to index zero if we go past the end
            if blockTypeIndex% > attNumPatches% then  'attNumPatches% is right because there are attNumPatches%+1 total legal indices
                blockTypeIndex% := 0;
            endif;
        endcase
        
        'get color of first block type (only on first block, obviously) to allow reset of randomizing hazard variables
        if i% = 1 then
            firstBlockType% := attColor%;
        endif;
        
        'reset variables as necessary, at the beginning of each block
        'also, create lists of flasher times and locations
        randHazIndex% := 0;  'reset this at the beginning of each block
        if attColor% = firstBlockType% then 'the block has cycled back to the beginning
            ArrConst(randHazValList[],0);  'reset list of hazard times
            if attUseFlashers% = 1 then
                ArrConst(tempFlashTimes[][],0);  'reset list of flash times (dim 1 per flasher, dim 2 per trial)
                ArrConst(tempFlashX[][],0);  'reset list of flash X pos
                ArrConst(tempFlashY[][],0);  'reset list of flash Y pos                
            endif;
        else
            Shuffle%(attTrialsPerBlock%,randHazValInd%[]);  'shuffle indices, can be used for flasher properties as well
        endif;
        'need to update flasher spec string on every trial, use unshuffled (or shuffled) indices
        'UpdateFlasherSpecString(&f$,numFlashers%,x[],y[],onset[],dur,firstRun)
        'have to set firstRun to 0 after running it once
        
        
        for j% := 1 to attTrialsPerBlock%+attEasyTrialsPerBlock% do
            'if we are NOT alternating by block, choose a direction on each trial
            docase
            case attBlockAlternate% = 0 and attNoChangeCondition% = 0 then
                if (Rand(0.0) < 0.5) then
                    attColor% := 1;  'Attend main stimulus, this happens half the time
                else
                    attColor% := Floor(Rand(attNumPatches%-1,2));  'choose a random stim to attend that is not the main
                endif
            case attBlockAlternate% = 0 and attNoChangeCondition% = 1 then
                attColor% := blockTypes%[btIndices%[Floor(Rand(attNumPatches%+1,0))]];  'choose a straight-up random color, unless Hank sez otherwise
            endcase;
            
            fixColor%[totalCount%] := attColor%;  'this is the color of the fixation point, which is the same regardless of attention/valid/etc.  It's kind of ground truth and everything builds from there.            
            
            if j% <= attEasyTrialsPerBlock% then  'Note that Easy trials will now only happen if the attend directions are blocked
                
'old version                
'                'if we are cue-swapping, select set of cue circles, this will hopefully make cue circles swap on easy trials
'                if attSwapCueCircle% = 1 then
'                    cueCircleRotation% := Floor(Rand(attNumPatches%,0));  '0 for no rotation, 1 for cycle forward 1, etc.
'                endif
'                rotList%[totalCount%] := cueCircleRotation%;            
'                'determine stimulus being attended (i.e., which stimulus has the same cue circle color as the fixation point)
'                if attColor% = 6 then 'on a no-change trial, just set direction to the arbitrary 6
'                    attDirection% := 6;  
'                else 'on a regular trial, add rotation
'                    attDirection% := attColor% + cueCircleRotation%;  'add in the rotation
'                    if attDirection% > attNumPatches% then  'get the modulus if necessary
'                        attDirection% := attDirection% mod attNumPatches%; 
'                    endif
'                endif;
                
                
                'New version 7/25/16
                'if we are cue-swapping, select set of cue circles
                if attSwapCueCircle% = 1 then
                    cueCircleRotation% := Floor(Rand(attNumPatches%,0));  '0 for no rotation, 1 for cycle forward 1, etc.
                endif
                'determine stimulus being attended (i.e., which stimulus has the same cue circle color as the fixation point)
                if attColor% = 6 then 'on a no-change trial, just set direction to the arbitrary 6
                    attDirection% := 6;  
                    rotList%[totalCount%] := (attNumPatches%*cueCircleRotation%);  'this selects the first brightness distribution for this rotation
                else 'on a regular trial, add rotation
                    attDirection% := attColor% + attNumPatches% - cueCircleRotation%;  'do the math to get direction
                    if attDirection% > attNumPatches% then  'get the modulus if necessary
                        attDirection% := attDirection% mod attNumPatches%; 
                    endif
                    if attDirection% = 0 then 'and then fix if modulus comes out to 0
                        attDirection% := attNumPatches%;
                    endif
                    rotList%[totalCount%] := (attNumPatches%*cueCircleRotation%)+attDirection%-1; 'this selects the correct brightness distribution for this rotation
                endif;
                           
                attList%[totalCount%] := attDirection%;  'set direction of attention, same for regular or no-change trials
                
                
                'attDirection% := attColor%;  'no tricks here, we won't rotate cue circles on "easy" trials (well, now we will)
                vList%[totalCount%] := 1;  'all easy trials are valid
                easyList%[totalCount%] := 1;  'all easy trials are easy
                blockList%[totalCount%] := attColor%;  'remember block for potential use in making flashers
                hazList[totalCount%] := attHazardMinTime;  'don't calculate a hazard time, just use the minimum
                flashN%[totalCount%] := 0;  'no flashers on easy trials, this is redundant since it should be 0 to start, but...
                
                'rotList%[totalCount%] := 0;  'no rotation on easy trials, this was replaced by cue-circle-swapping code above
                'rotList%[totalCount%] := attNumPatches%*(attColor%-1);  'no rotation on easy trials, but get cue circle contrast correct - this is the oldest version of this line
                UpdateFlasherSpecString(f$,0,flashX[totalCount%][],flashY[totalCount%][],attFlasherWidth,attFlasherHeight,flashTimes[totalCount%][],0,firstRun);  'On easy trials, num of flashers is zero, remainder of function does not run
                if attDirection% <> 6 then 'for all blocks that are not no-change blocks, do this
                    chgList%[totalCount%] := attDirection%;  'set stimulus that changes
                    cList%[totalCount%] := 100;  'change easy trials to 100% contrast            
                    if distracterOffForEasy% = 1 then
                        offList%[totalCount%] := alloff% - Pow(2,attDirection%-1);  'turn off all stimuli but the attended one
                        'insert easy trial with 100% contrast
                        'note that for easy trials cueCircleRotation is 0 by definition, but just keeping this so the logic is consistent 
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,100,attHazardMinTime,attPhaseDeg%,alloff%-Pow(2,attDirection%-1)+(256*rotList%[totalCount%]),masterColorListVSG$);  
                    else
                        offList%[totalCount%] := 0;  'show all grating patches                
                        'insert easy trial with 100% contrast
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,100,attHazardMinTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                    endif;
                else
                    chgList%[totalCount%] := 0;  'no stimulus changes
                    cList%[totalCount%] := attContrastBase%;  'fill cList%[] with the base contrast
                    offList%[totalCount%] := 0;  'show all grating patches
                    'insert no-go trial
                    UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,attContrastBase%,attHazardMinTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                endif;
                
              
            else 'regular trial
                easyList%[totalCount%] := 0;  'all regular trials are not easy
                
'old version                
'                'if we are cue-swapping, select set of cue circles
'                if attSwapCueCircle% = 1 then
'                    cueCircleRotation% := Floor(Rand(attNumPatches%,0));  '0 for no rotation, 1 for cycle forward 1, etc.
'                endif
'                rotList%[totalCount%] := cueCircleRotation%;            
'                'determine stimulus being attended (i.e., which stimulus has the same cue circle color as the fixation point)
'                if attColor% = 6 then 'on a no-change trial, just set direction to the arbitrary 6
'                    attDirection% := 6;  
'                else 'on a regular trial, add rotation
'                    attDirection% := attColor% + cueCircleRotation%;  'add in the rotation
'                    if attDirection% > attNumPatches% then  'get the modulus if necessary
'                        attDirection% := attDirection% mod attNumPatches%; 
'                    endif
'                endif;
                
                'New version 7/25/16
                'if we are cue-swapping, select set of cue circles
                if attSwapCueCircle% = 1 then
                    cueCircleRotation% := Floor(Rand(attNumPatches%,0));  '0 for no rotation, 1 for cycle forward 1, etc.
                endif
                'determine stimulus being attended (i.e., which stimulus has the same cue circle color as the fixation point)
                if attColor% = 6 then 'on a no-change trial, just set direction to the arbitrary 6
                    attDirection% := 6;  
                    rotList%[totalCount%] := (attNumPatches%*cueCircleRotation%);  'this selects the first brightness distribution for this rotation
                else 'on a regular trial, add rotation
                    attDirection% := attColor% + attNumPatches% - cueCircleRotation%;  'do the math to get direction
                    if attDirection% > attNumPatches% then  'get the modulus if necessary
                        attDirection% := attDirection% mod attNumPatches%; 
                    endif
                    if attDirection% = 0 then 'and then fix if modulus comes out to 0
                        attDirection% := attNumPatches%;
                    endif
                    rotList%[totalCount%] := (attNumPatches%*cueCircleRotation%)+attDirection%-1; 'this selects the correct brightness distribution for this rotation
                endif;
                
                
                attList%[totalCount%] := attDirection%;  'set direction of attention, same for regular or no-change trials
                            
                
                'Get a new hazard time and new set of flasher times for this trial - the one caveat is that
                'follow-up blocks have to have the same hazard times and flasher times as the first block if
                'we are alternating blocks - in that case only get new times if we are on the first block type
                'and otherwise pull randomly from the old values
                if (attColor% = firstBlockType% and attBlockAlternate% = 2) or attBlockAlternate% < 2 then
                    'if we're NOT shuffling block type, or if it's a "first-type" block, get a new hazard time
                    trialHazardFunctionTime := RandExp(attHazardExpMeanTime, attHazardMinTime);
                    if trialHazardFunctionTime > attHazardCutoffTime then
                        trialHazardFunctionTime := attHazardCutoffTime;
                    endif;

                    
                    'create a set of flasher times and locations (also number) for this trial only
                    if attUseFlashers% = 1 then
                        'create flasher times
                        if attDirection% = 6 then
                            trialDur := attNoChangeDuration;
                        else
                            trialDur := attTimeToAnswer;
                        endif;
                        CreateFlasherTimes(tempFlashTimes[][randHazIndex%],tempNFlashPerTrial%[randHazIndex%],trialHazardFunctionTime,trialDur);
                        flashN%[totalCount%] := tempNFlashPerTrial%[randHazIndex%];  'set flasher count for use in main loop
                        for timesLoop% := 0 to attMaxFlashers%-1 do
                            flashTimes[totalCount%][timesLoop%] := tempFlashTimes[timesLoop%][randHazIndex%];  'set flasher times for use in main loop
                        next;
                        'create flasher locations (not done)
                        CreateFlasherLocations(flashN%[totalCount%],tempFlashX[][randHazIndex%],tempFlashY[][randHazIndex%]);
                        for timesLoop% := 0 to attMaxFlashers%-1 do
                            flashX[totalCount%][timesLoop%] := tempFlashX[timesLoop%][randHazIndex%];
                            flashY[totalCount%][timesLoop%] := tempFlashY[timesLoop%][randHazIndex%];
                        next;
                    endif;
                    
                    hazList[totalCount%] := trialHazardFunctionTime;  'set hazard function time
                    randHazValList[randHazIndex%] := trialHazardFunctionTime;  'put hazard function time into the random list
                    randHazIndex% += 1;  'increment the index
                else
                    'get flasher count/time/location from previous calculation, randomizing order
                    flashN%[totalCount%] := tempNFlashPerTrial%[randHazValInd%[randHazIndex%]];  'set flasher count for use in main loop
                    for timesLoop% := 0 to attMaxFlashers%-1 do
                        flashTimes[totalCount%][timesLoop%] := tempFlashTimes[timesLoop%][randHazValInd%[randHazIndex%]];  'set flasher times for use in main loop
                        flashX[totalCount%][timesLoop%] := tempFlashX[timesLoop%][randHazValInd%[randHazIndex%]];
                        flashY[totalCount%][timesLoop%] := tempFlashY[timesLoop%][randHazValInd%[randHazIndex%]];
                    next;
                    trialHazardFunctionTime := randHazValList[randHazValInd%[randHazIndex%]];
                    hazList[totalCount%] := trialHazardFunctionTime;  'set hazard function time, from shuffled list of prior values
                    randHazIndex% += 1;  'increment the index
                endif;
                
                UpdateFlasherSpecString(f$,flashN%[totalCount%],flashX[totalCount%][],flashY[totalCount%][],attFlasherWidth,attFlasherHeight,flashTimes[totalCount%][],attFlasherDur,firstRun);
                
                if (Rand()*100 < attNoGoTrialPercentage) and attDirection% <> 6 then 'NoGo trial, don't do this on no-change trials, even though I guess it's the same thing
                    vList%[totalCount%] := 1;  'all no-go trials are valid
                    chgList%[totalCount%] := 0;  'no stimulus changes, it's a no-go -- note that we cannot pass 0 to UpdateTrialSpecString, though, so pass the attend direction
                    cList%[totalCount%] := attContrastBase%;  'fill cList%[] with the base contrast
                    offList%[totalCount%] := 0;  'show all grating patches
                    'insert no-go trial
                    UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,attContrastBase%,trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                else    
                    docase
                    case attDirection% = 6 then  'no-change trial, these are the same as no-go trials, but with a different fix color
                        vList%[totalCount%] := 1;  'all no-go trials are valid
                        chgList%[totalCount%] := 0;  'no stimulus changes, it's a no-go -- note that we cannot pass 0 to UpdateTrialSpecString, though, so pass the attend direction
                        cList%[totalCount%] := attContrastBase%;  'fill cList%[] with the base contrast
                        offList%[totalCount%] := 0;  'show all grating patches
                        hazList[totalCount%] := 0.1;  'override hazard time with 0.1 for no-change trials. This cannot be done above because we need to calculate the list of hazard times and keep them for block alternation.
                        'insert no-go trial  
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,attContrastBase%,trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                    case (Rand()*100 < attCatchTrialPercentage) then 'catch trial
                        vList%[totalCount%] := 0;  'catch = invalid
                        offList%[totalCount%] := 0;  'show all grating patches
                        'select a random patch that is not the attended direction
                        tempInvalid% := ceil(rand(attNumPatches%,0));  'select a random patch for invalid stimuli                          
                        while tempInvalid% = attDirection% do  'it's not catch if it's the attended patch, try again
                            if attNumPatches% = 1 then
                                message("This combination of settings will hang a while loop!  Quitting!");
                                'Just some notes - I want to catch this earlier, but maybe another way to break here will come up
                                'in the future.  The problem essentially is that you can't ask for a catch trial if there is only
                                'one stimulus on the screen - there's no alternate stimulus to have a contrast change.  Again, I
                                'think there was only one circumstance where this request could be made and I'll try to catch it
                                'at the level of the dialog box, but if it happens again at least this will give a clue to what's
                                'going on.  (Random hangs are hard to track down.)
                                stop%();
                                quit%();
                                halt'
                            endif;
                            tempInvalid% := ceil(rand(attNumPatches%,0));  'yes, this is technically ugly but much easier to code than a method guaranteed to get a result in one shot
                        wend;
                        chgList%[totalCount%] := tempInvalid%;  'set stimulus that changes
                        if attOnlyOneCatch% = 0 then  'if we are doing a tuning curve over catch trials
                            cList%[totalCount%] := attContrastList[attCatchTrialOrder%[catchCount%]];
                        else  'if we are doing only one catch trial (note the commented stuff above is not re-included)
                            cList%[totalCount%] := attOneCatchContrast%;  'there is only one contrast
                        endif;
                        'insert catch trial
                        UpdateTrialSpecString(c$,attColor%,tempInvalid%,attContrastBase%,cList%[totalCount%],trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                        catchCount% += 1;  
                    case (Rand()*100 < attUncatchTrialPercentage) then 'uncatch trial
                        'this is guaranteed to go along with attOnlyOneCatch% = 1
                        vList%[totalCount%] := 1;  'uncatch = valid
                        cList%[totalCount%] := attOneCatchContrast%;  'there is only one contrast
                        offList%[totalCount%] := 0;  'show all grating patches
                        chgList%[totalCount%] := attDirection%;  'set stimulus that changes
                        'insert uncatch trial
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,cList%[totalCount%],trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                    else  'valid trial
                        vList%[totalCount%] := 1;  'valid
                        cList%[totalCount%] := attContrastList[attTrialOrder%[stdCount%]];
                        offList%[totalCount%] := 0;  'show all grating patches
                        chgList%[totalCount%] := attDirection%;  'set stimulus that changes
                        'insert uncatch trial
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,cList%[totalCount%],trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                        stdCount% += 1;
                    endcase;
                endif;
            endif;
            totalCount% += 1;
        next;        
        blockCount% += 1;
    next;
    c$ := Left$(c$,len(c$)-1); 'remove trailing comma from the list
end;


'
'
'======= CreateFlasherTimes =======
'Fill input variable times[] with the flasher times and nFlashers% with the count of flashers
Proc CreateFlasherTimes(&times[],&nFlashers%,hazTime,respWindow)
    var tOff;
    var i%;
    var temp;
    var tMax;
    
    nFlashers% := 0;  'Reset this value every time we calculate a new set of flashers, otherwise we can repeat and cause all sorts of problems
    
    tMax := hazTime + respWindow;
    tOff := attFlasherTemporalBuffer;  'set first offset to the time of the buffer
    while i% < attMaxFlashers% do
        'get random value with mean distribution which takes into account the buffers (so that attFlasherHazardValue is very ~= Hz of the stimulus) and min of tOff
        temp := RandExp(attFlasherHazardValue,tOff);  'improved logic!
        if (temp + attFlasherDur + attFlasherTemporalBuffer) <= tMax then  'if random value is less than max time
            if abs(temp-hazTime) > 0.1 then  'if the flasher time does not overlap with the contrast change
                times[i%] := temp;  'put random value into times list
                i% += 1;  'increment i%
                nFlashers% += 1;  'increment count of flashers
                tOff := temp + attFlasherDur + attFlasherTemporalBuffer;  'change offset, option to offset with temporal buffer, also option to not allow temporal overlap
            else
                'printlog("Rejected overlapping flasher at %f\n",temp);
            endif
        else 'if the "next" time is after the max time
            i% := attMaxFlashers% + 1;  'break the loop
        endif
    wend
    
end  
    
'
'
'======= CreateFlasherLocations =======
'Will create locations for each flasher on a given trial
Proc CreateFlasherLocations(nFlashers%,&x[],&y[])
    var i%;
    var isOverlap%;
    var isInBounds%;  'technically a "box" around the main grating
    var breakCount%;
    var xBound;
    var yBound;
    
    xBound := screenXmax-wF1-attFlasherSpatialBuffer;
    yBound := screenYmax-hF1-attFlasherSpatialBuffer;
    
'Testing    
'printlog("screenXmax is %f and wF1 is %f and attFlasherSpatialBuffer is %f\n",screenXmax,wF1,attFlasherSpatialBuffer);    
'printlog("Flasher count is %d\n",nFlashers%); 
'printlog("xbound is %f and ybound is %f\n",xBound,yBound);
'printlog("Flasher max dist is %f\n",attFlasherMaxDist); 
    
    'Locations of our non-flasher stimuli have been set in Start%
    
    'For each flasher time
    for i% := 0 to nFlashers%-1 do
        
        breakCount% := 0;
        
        'force while loop to execute at least once
        isOverlap% := 1;  
        isInBounds% := 0; 
        
        'select a random location within the bounds of the screen
        while breakCount% < 10000 and (isOverlap% > 0 or isInBounds% < 1) do
            
            isOverlap% := 0;  'Reset or you'll never get out of the loop!
            isInBounds% := 0;  'Reset
            
            'reassign the X, Y values randomly, use bounds of screen
            x[i%] := Rand(2*xBound,-xBound);
            y[i%] := Rand(2*yBound,-yBound);
        
            'One check for the target patch
            isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xT, yT, wT, hT, attFlasherSpatialBuffer);
            
            'Then several checks against potential distracter patches
            if attNumPatches% > 1 then
                'use xD1, yD1, wD1, hD1
                isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xD1, yD1, wD1, hD1, attFlasherSpatialBuffer);
            endif;
            if attNumPatches% > 2 then
                isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xD2, yD2, wD2, hD2, attFlasherSpatialBuffer);
            endif;
            if attNumPatches% > 3 then
                isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xD3, yD3, wD3, hD3, attFlasherSpatialBuffer);
            endif;
            if attNumPatches% > 4 then
                isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, xD4, yD4, wD4, hD4, attFlasherSpatialBuffer);
            endif;
            
            'Check the location of the fixation point
            'FixationX, FixationY, and FixationDiameter ought to be available variables
            isOverlap% := isOverlap% + Overlap%(x[i%], y[i%], wF1, hF1, FixationX, FixationY, FixationDiameter, FixationDiameter, attFlasherSpatialBuffer);
            
            'And check to see if it is within the bounds that are set - here we actually will use
            'Overlap%() to see if it overlaps the bounds (rather than writing a new function)
            isInBounds% := Overlap%(x[i%], y[i%], wF1, hF1, xT, yT, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);  'use zero spatial buffer

            'The flasher is also legal if it is in the box surrounding any distracter patch
            if attNumPatches% > 1 then
                'use xD1, yD1
                isInBounds% := isInBounds% + Overlap%(x[i%], y[i%], wF1, hF1, xD1, yD1, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);
            endif;
            if attNumPatches% > 2 then
                isInBounds% := isInBounds% + Overlap%(x[i%], y[i%], wF1, hF1, xD2, yD2, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);
            endif;
            if attNumPatches% > 3 then
                isInBounds% := isInBounds% + Overlap%(x[i%], y[i%], wF1, hF1, xD3, yD3, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);
            endif;
            if attNumPatches% > 4 then
                isInBounds% := isInBounds% + Overlap%(x[i%], y[i%], wF1, hF1, xD4, yD4, 2*(attFlasherMaxDist-wF1), 2*(attFlasherMaxDist-hF1), 0);
            endif;
            
            'increment breakCount% so we don't get stuck
            breakCount% += 1;
            
        wend;
        
        if breakCount% = 10000 then
            message("Could not find a legal location for flasher after 10000 tries!\nProbably no legal position exists!\nCheck settings of flasher/target/distractors!  Quitting!");
            halt;  'haven't started sampling yet, so halt should be fine
        endif;
        'printlog("Location of flasher is x %f    y %f\n",x[i%],y[i%]);
    next
    
    
end




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ParseGratingParametersBrief%(gr$, &x, &y, &w, &h);
' 
' Given a grating parameter list, parse the individual values in to the given variable list. 
' Simpler version than the full-blown one, as it doesn't return all values. 
' This version will work for all possible variable list lengths - with/without phase/cv/pattern/aperture/inner/outer
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'''This is now covered by #include UsreyGratings
'func ParseGratingParametersBrief%(gr$, &x, &y, &w, &h)
'    var status% := 0;
'    var n%;
'	ReadSetup("", "", "", "", ",");
'	n% := ReadStr(gr$, x, y, w, h);
'    ReadSetup();
'    if n% <> 4 then status% := -1; endif;
'    return n%;
'end
'

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var tempPrimary$;
    var tempSecondary$;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	'Print("Background color           : %s\n", tunBackgroundColor$);

	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);

	' write stimulus parameters
	var Tstimstr$;
	var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
    var phase;
    Print("\nStimulus\n");  'Master grating
	Print("-------------------\n\n");
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
    Print("Inner Width (degrees)           : %s\n", Tstimiw$);
	Print("Inner Height (degrees)          : %s\n", Tstimih$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    Print("Initial Phase (degrees)         : %f\n", phase);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        
    ' write distractor parameters
    if attNumPatches% > 1 then
        Print("\nDistractor1\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor1");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            Print("Initial Phase (degrees)         : %f\n", phase);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
    endif;
    if attNumPatches% > 2 then
        Print("\nDistractor2\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor2");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            Print("Initial Phase (degrees)         : %f\n", phase);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
    endif;
    if attNumPatches% > 3 then
        Print("\nDistractor3\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor3");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            Print("Initial Phase (degrees)         : %f\n", phase);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
    endif;
    if attNumPatches% > 4 then
        Print("\nDistractor4\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor4");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            Print("Initial Phase (degrees)         : %f\n", phase);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
    endif;
    
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

	Print("Acquisition time (s)   : %f\n", attAcquisitionTime);
    Print("Min fixation cue time (s)   : %f\n", attFixationCueMinTime);
    Print("Max fixation cue time (s)   : %f\n", attFixationCueMaxTime);
    Print("Min Hazard time (s)   : %f\n", attHazardMinTime);
    Print("Mean Hazard time (s)   : %f\n", attHazardExpMeanTime);
    Print("Hazard Cutoff time (s)   : %f\n", attHazardCutoffTime);
    Print("Time to answer (s)   : %f\n", attTimeToAnswer);
    Print("No Change Duration (s)   : %f\n", attNoChangeDuration);
    Print("Intertrial time (s)   : %f\n", attInterTrialTime);
    Print("Abort penalty time (s)   : %f\n", attAbortWaitTime);
    Print("False Alarm penalty time (s)   : %f\n", attFalseAlarmWaitTime);
    Print("False Alarm check window (s)   : %f\n", attFalseAlarmCheckWindow);
    Print("Miss penalty time (s)   : %f\n", attMissPenalty);
    
    
    if attUseFlashers% = 1 then
        Print("\nFlasher parameters\n");
        Print("-------------------------\n\n");
        Print("Flasher Duration (s)   : %f\n", attFlasherDur);
        Print("Flasher Temporal Buffer (s)   : %f\n", attFlasherTemporalBuffer);
        Print("Flasher Spatial Buffer (deg)   : %f\n", attFlasherSpatialBuffer);
        Print("Flasher Max Distance From Main Grating (deg)   : %f\n", attFlasherMaxDist);
        Print("Flasher Hazard Value (s)   : %f\n", attFlasherHazardValue);
    endif;
    
    
    
    
	Print("\nTuning parameters\n");
	Print("-------------------\n\n");    
    'Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
    
    Print("Number of blocks   : %d\n", attNumberOfBlocks%);
    Print("Trials per block   : %d\n", attTrialsPerBlock%);
    Print("Easy trials per block   : %d\n", attEasyTrialsPerBlock%);
    Print("Distracter off for easy trials?   : %d\n", distracterOffForEasy%);
    Print("Catch trial percentage   : %f\n", attCatchTrialPercentage);
    Print("No-go trial percentage   : %f\n", attNoGoTrialPercentage);
    Print("Alternate Cue Type by block?   : %d\n", attBlockAlternate%);
    Print("Do NOT randomize by block?   : %d\n", attSelectRandomContrastEachTrial%);
    Print("Base Contrast   : %d\n", attContrastBase%);
    Print("Max contrast change   : %f\n", attMaxContChange);
    Print("Min contrast change   : %f\n", attMinContChange);
    Print("N Contrast levels   : %d\n", attNContLevels%);
    if attAnswerPointWindowRadius > 0 then
        Print("Answer point window radius   : %f\n", attAnswerPointWindowRadius);  
    else
        Print("Answer point window radius   : Matches Stimulus\n");  
    endif;
    Print("Use Training Contrast?   : %d\n", attTrainingContrastCheck%);
    Print("Training contrast   : %d\n", attTrainingContrastPct%);
    Print("Set phase at contrast change?   : %d\n", attPhaseCheck%);
    Print("Phase at contrast change   : %d\n", attPhaseDeg% );
    Print("Number of Distractors     : %d\n", attNumPatches%);
    Print("Get distractor params from main stim?     : %d\n", attGetGPFromMainStim%);
    Print("Use only one catch contrast?     : %d\n", attOnlyOneCatch%);
    Print("Value of only catch contrast   : %d\n", attOneCatchContrast%);
    Print("Do 'uncatch'     : %d\n", attDoUncatch%);
    Print("Do Catch-Trials-As-No-Go     : %d\n", attCatchIsNoGo%);
    Print("Use cue circles?    : %d\n", attUseCueCircles%);
    Print("Cue Circle extra radius    : %f\n", attCueCircleExtraRadius);
    Print("Start Block     : %d\n", attStartBlock%);
    Print("No Change Condition    : %d\n", attNoChangeCondition%);
    Print("Swap Cue Circle    : %d\n", attSwapCueCircle%);  
            

    
    Print("Values: " + Contrast$ + "\n");
    Print("\n");
    
    
    
    if attDoOpto% = 1 then
        Print("\nOptogenetics parameters\n");
        Print("-------------------------\n\n");
        if attLaserDiode% = 1 then
            Print("Laser Diode recorded\n");
        endif;
        Print("Opto Voltage Out: %f\n", attOptoVoltageOut);
        var label$[4]; 
        label$[0] := "Opto Off First";
        label$[1] := "Opto On First";
        label$[2] := "Random First";
        label$[3] := "Opto On All Blocks";
        Print("Proportion of Opto Trials : %f\n", attOptoPctOpto);
        if attOptoUsePulse% = 1 then
            Print("Pulsing Opto selected\n");
            Print("Opto#Pulses,OptoPeriodOnset,OptoPulseWidth,OptoInterpulseInterval: %d,%f,%f,%f\n",attOptoNPulses%,attPulsedOptoOnset,attPulsedOptoWidth,attPulsedOptoIPI);
        else
            Print("Wraparound Opto selected\n");
            Print("PreStimulusOptoOn,PostStimulusOptoOn: %f,%f\n",attPreStimOptoTime,attPostStimOptoTime);
            'Print("PreStimulusOptoOn,PostStimulusOptoOn,KeepOptoOnBetweenStims: %f,%f,%d\n",attPreStimOptoTime,attPostStimOptoTime,attOptoStaysOn%);  --- currently disabled, using line above instead
        endif;
        
    endif;
    
    
	' close parfile
	FileClose(0);
    

end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculates initial phase given params
func GetInitialPhase%(phaseAtCC%,tempFreq,dur)
    'phases in degrees (integer)
    'temporal frequency in Hz
    'duration in seconds
    var Po%;
    var deg;
    var deg%;
    
    deg := (360*((tempFreq*dur)mod 1));
    deg% := round(deg);  'this corrects to nearest degree, non-explicit conversion of real to int results in a floor operation

    'This is the way you would THINK it would work
    'Po% := phaseAtCC% - deg%;
    'Po% := phaseAtCC% - (360*((tempFreq*dur)mod 1));
    'if Po% < 0 then
    '    Po% := Po% + 360;
    'endif;
    
    'This is the way it actually works, because the grating drifts "backwards" - that is to say that if the grating
    'starts at 150 degrees and drifts through 30 degrees, the final grating position is 120 degrees, not 180 degrees.  
    Po% := phaseAtCC% + deg%;
    if Po% >= 360 then
        Po% := Po% - 360;
    endif;
        
    'printlog("Requested initial phase is %d\n",Po%);
    return Po%;
    
end


func GetStimulusTF(stim%)
    var gr$;
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var cv$, pattern$, aperture$;
    docase
    case stim% = 1 then
        gr$ := GetGratingParameters$("Stimulus");
    case stim% = 2 then
        gr$ := GetGratingParameters$("Distractor1");
    case stim% = 3 then
        gr$ := GetGratingParameters$("Distractor2");
    case stim% = 4 then
        gr$ := GetGratingParameters$("Distractor3");
    case stim% = 5 then
        gr$ := GetGratingParameters$("Distractor4");  
    endcase;    
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    LogStatus("GetStimulusTF", "TF=" + str$(tf));
    return tf;
end


proc UpdateTrialSpecString(&c$,color%,chgdir%,base%,chg%,haz,phase%,off%,colListVSG$[])
    var col$;
    var trainbase%;
    
    'if we are using training contrast, set non-changing gratings to different base contrast
    if attTrainingContrastCheck% = 1 then
        trainbase% := attTrainingContrastPct%;
    else
        trainbase% := base%;  'by default we will use the same base
    endif;
                            
    
    'order of colors is taken from colors dialog
    'printlog("color num is %d\n",color%);
    col$ := colListVSG$[color%-1]; 
    c$ := c$ + col$ + ",";  'add color spec
    
    'get temporal frequency of the changing grating
    var tf;
    var initphase%;
    if attGetGPFromMainStim% = 1 then  'use main value if we're getting values from main
        tf := GetStimulusTF(1);  '1 is Stimulus1 
    else
        
        tf := GetStimulusTF(chgdir%);  'or actual changing value if not
                                       '2 is Distracter1, 3 is Distracter2, etc.
    endif;

    'set phase
    if phase% < 0 then
        initphase% := 0;
    else
        initphase% := GetInitialPhase%(phase%,tf,haz);
    endif;
    
    c$ := c$ + Str$(initphase%) + ",";  'add initial phase
    
    c$ := c$ + Str$(haz) + ",";  'add hazard time
    
    c$ := c$ + Str$(off%) + ",";  'add offbits, these are already updated based on the rotation of the cue circles
    
    'now go through the base and change contrasts
    var k%;
    
   for k% := 1 to attNumPatches% do
        if k% = chgdir% then  'do base and change
            c$ := c$ + Str$(base%) + "," + Str$(chg%) + ",";
        else 'change is identical to original, typically trainbase% = base% but if training contrast is on that is not necessarily true
            c$ := c$ + Str$(trainbase%) + "," + Str$(trainbase%) + ",";
        endif;
    next;  

end


proc UpdateFlasherSpecString(&f$,numFlashers%,x[],y[],w,h,onset[],dur,&fR)
    var ind%;
    
    if fR = 0 then  'check if it's the first run, return this variable
        f$ := f$ + ",";  'if not the first run, put in initial comma
    else
        fR := 0;  'or reset fR on first run!
    endif;
    
    f$ := f$ + Str$(numFlashers%);  'add number of flashers on this trial
    
    'if there are no flashers, do not specify location, etc.
    while numFlashers% > 0 do
        f$ := f$ + ",0,";  'We are only using one flasher, index 0
        f$ := f$ + Str$(x[ind%]) + ",";  'add x position for this flasher
        f$ := f$ + Str$(y[ind%]) + ",";  'add y position for this flasher
        f$ := f$ + Str$(w) + ",";  'add width for this flasher
        f$ := f$ + Str$(h) + ",";  'add height for this flasher
        f$ := f$ + Str$(onset[ind%]) + ",";  'add onset for this flasher
        f$ := f$ + Str$(onset[ind%]+dur);  'add offset for this flasher
        ind% += 1;  'increment index
        numFlashers% -= 1; 'decrement numFlashers%
    wend
    
    
end





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' FadeColorToGray$(rgb[]%,contrast%)
' 
' (New version)
'
' Takes an RGB direction and applies the value from CONTRAST to fade the color towards gray.  Gray
' is taken to be 128,128,128 in RGB.  Returns a string in the format (255/255/0) which is placed
' directly into the command line.
'
' For this new version all color directions are legal to start.  Contrast will be an integer
' between 0 and 100, where 0 will result in 128,128,128 and 100 will result in the input color
' being unchanged.  Please note that we must round our RGB values to integers.  This means that:
' 1) Contrast steps will not be strictly equal in size.  e.g., the rounding will result in a 100-99-98
'    contrast step giving 255-254-252 in RGB units.
' 2) If the original color is not fully saturated, some small contrast changes may produce no difference
'    e.g., 50,50,206 would produce 73,73,183 for both 71% and 70% contrasts.
' 3) Hues may shift very slightly because the contrast steps are not strictly equal on each channel.
'
' These effects should be very minor and will doubtfully cause any issue - the animal should not be
' expected to be capable of discriminating these small differences and so the idea that a 71% and 70%
' contrast change would be "different" to the experimenter is unlikely.  Henry has signed off on this
' idea.
'
' For super convenience have changed this so that rgb% is 1x3 vector to split into r% g% b%
' No other direction is legal; r%, g%, and b% must have a value of 0 or 1.
' 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


func FadeColorToGray$(rgb%[],contrast%)
    var r$;
    var g$;
    var b$;
    var r%;
    var g%;
    var b%;
    var r2%;
    var g2%;
    var b2%;
    var contrast;  'for non-integer calcs
    var out$;
    
    contrast := contrast%;
    
    r% := rgb%[0];
    g% := rgb%[1];
    b% := rgb%[2];
    
    
    r2% := 128 + (r%-128)*(contrast/100);
    g2% := 128 + (g%-128)*(contrast/100);
    b2% := 128 + (b%-128)*(contrast/100);
    
    'set output string
    out$ := "(" + Str$(r2%) + "/" + Str$(g2%) + "/" + Str$(b2%) + ")";
    return out$;
end


'old version
'
'
'======= CreateCueCircleColorSets =======
'This function creates the cue circle color sets which are the basis of Cue Circle Swapping and
'Start%() places in CueCirc$ for inclusion in the long spec file.
'
'func CreateCueCircleColorSets$()
'    
'    var CueCirc$;
'    var RadAndWid$;  'these are all the same for every cue circle
'    
'    var ContrastList%[5];    
'    var i%;
'    var j%;
'    var k%;
'    var x%;
'    var y%;
'    var cueFlag$;
'    
'    
'    'assign contrasts
'    'message(attCueCircleContrastAttend%);
'    ContrastList%[0] := attCueCircleContrastAttend%;
'    ContrastList%[1] := attCueCircleContrastIgnore1%;
'    ContrastList%[2] := attCueCircleContrastIgnore2%;
'    ContrastList%[3] := attCueCircleContrastIgnore3%;
'    ContrastList%[4] := attCueCircleContrastIgnore4%;
'    
'    'Set cue flag
'    docase
'    case attUseCueCircles% = 1 then
'        cueFlag$ := "-Q ";
'    case attUseCueCircles% = 2 then
'        cueFlag$ := "-q ";
'    else
'        message("Error!  UseCueCircles% holds an illegal value!  Quitting!");
'        quit%();
'    endcase
'    
'    'Radius and Width includes following commas but NOT leading comma - leading comma is not always used
'    RadAndWid$ := Str$(attCueCircleExtraRadius) + "," + Str$(attCueCircleStrokeWidth%) + ",";
'    
'    'Put in cue circle opener and first cue circle, which always happens
'    'CueCirc$ := "-Q " + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'This is for old version of cue circle call (as of 6/5/15)
'    'This is for new version of cue circle call, adding stroke width, whenever it gets implemented
'    CueCirc$ := cueFlag$ + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  
'    
'    docase
'    case attNumPatches% = 2 then
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'        'end of first cue color circle set, rotate if attSwapCueCircle is 1
'        if attSwapCueCircle% = 1 then
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'        endif
'        
'    case attNumPatches% = 3 then
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'        'end of first cue color circle set, rotate if attSwapCueCircle is 1
'        if attSwapCueCircle% = 1 then
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            'end of second cue color circle set, rotate
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'        endif
'        
'    case attNumPatches% = 4 then
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore3RGB%[],attCueCircleContrastIgnore3%);  'Add D3
'        'end of first cue color circle set, rotate if attSwapCueCircle is 1
'        if attSwapCueCircle% = 1 then
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore3RGB%[],attCueCircleContrastIgnore3%);  'Add D3
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'            'end of second cue color circle set, rotate
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore3RGB%[],attCueCircleContrastIgnore3%);  'Add D3
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            'end of third cue color circle set, rotate
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore3RGB%[],attCueCircleContrastIgnore3%);  'Add D3
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'        endif
'        
'    case attNumPatches% = 5 then   
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore3RGB%[],attCueCircleContrastIgnore3%);  'Add D3
'        CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore4RGB%[],attCueCircleContrastIgnore4%);  'Add D4
'        'end of first cue color circle set, rotate if attSwapCueCircle is 1
'        if attSwapCueCircle% = 1 then
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore4RGB%[],attCueCircleContrastIgnore4%);  'Add D4
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore3RGB%[],attCueCircleContrastIgnore3%);  'Add D3
'            'end of second cue color circle set, rotate
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore3RGB%[],attCueCircleContrastIgnore3%);  'Add D3
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore4RGB%[],attCueCircleContrastIgnore4%);  'Add D4
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'            'end of third cue color circle set, rotate
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore3RGB%[],attCueCircleContrastIgnore3%);  'Add D3
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore4RGB%[],attCueCircleContrastIgnore4%);  'Add D4
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            'end of fourth cue color circle set, rotate
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore1RGB%[],attCueCircleContrastIgnore1%);  'Add D1
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore2RGB%[],attCueCircleContrastIgnore2%);  'Add D2
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore3RGB%[],attCueCircleContrastIgnore3%);  'Add D3
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(ignore4RGB%[],attCueCircleContrastIgnore4%);  'Add D4
'            CueCirc$ := CueCirc$ + "," + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'Add Stim
'        endif
'    endcase;
'
'    
'    'put in closing space
'    CueCirc$ := CueCirc$ + " ";
'    
'    return CueCirc$;
'end



'New version 7/25/16
'
'
'======= CreateCueCircleColorSets =======
'This function creates the cue circle color sets which are the basis of Cue Circle Swapping and
'Start%() places in CueCirc$ for inclusion in the long spec file.

func CreateCueCircleColorSets$()
    
    var CueCirc$;
    var RadAndWid$;  'these are all the same for every cue circle
    
    var ContrastList%[5];  
    var RGBList%[5][3];
    var i%;
    var j%;
    var k%;
    var x%;
    var y%;
    var cueFlag$;
    var colIdx%;
    var conIdx%;
    var tempCol%[3];
    
    
    'assign contrasts
    'message(attCueCircleContrastAttend%);
    ContrastList%[0] := attCueCircleContrastAttend%;
    ContrastList%[1] := attCueCircleContrastIgnore1%;
    ContrastList%[2] := attCueCircleContrastIgnore2%;  'note that Ignore 2-4 are identical to Ignore 1
    ContrastList%[3] := attCueCircleContrastIgnore3%;
    ContrastList%[4] := attCueCircleContrastIgnore4%;
    
    'assign RGBs
    RGBList%[0][0] := attendRGB%[0];
    RGBList%[0][1] := attendRGB%[1];
    RGBList%[0][2] := attendRGB%[2];
    RGBList%[1][0] := ignore1RGB%[0];
    RGBList%[1][1] := ignore1RGB%[1];
    RGBList%[1][2] := ignore1RGB%[2];
    RGBList%[2][0] := ignore2RGB%[0];
    RGBList%[2][1] := ignore2RGB%[1];
    RGBList%[2][2] := ignore2RGB%[2];
    RGBList%[3][0] := ignore3RGB%[0];
    RGBList%[3][1] := ignore3RGB%[1];
    RGBList%[3][2] := ignore3RGB%[2];
    RGBList%[4][0] := ignore4RGB%[0];
    RGBList%[4][1] := ignore4RGB%[1];
    RGBList%[4][2] := ignore4RGB%[2];

    
    'Set cue flag
    docase
    case attUseCueCircles% = 1 then
        cueFlag$ := "-Q ";
    case attUseCueCircles% = 2 then
        cueFlag$ := "-q ";
    else
        message("Error!  UseCueCircles% holds an illegal value!  Quitting!");
        quit%();
    endcase
    
    'Radius and Width includes following commas but NOT leading comma - leading comma is not always used
    RadAndWid$ := Str$(attCueCircleExtraRadius) + "," + Str$(attCueCircleStrokeWidth%) + ",";
    
    'Put in cue circle opener and first cue circle, which always happens
    'CueCirc$ := "-Q " + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  'This is for old version of cue circle call (as of 6/5/15)
    'This is for new version of cue circle call, adding stroke width, whenever it gets implemented
    'CueCirc$ := cueFlag$ + RadAndWid$ + FadeColorToGray$(attendRGB%[],attCueCircleContrastAttend%);  
    
    'start building
    CueCirc$ := cueFlag$;
    
    for i% := 0 to attNumPatches%-1 do 'loop through outer rotations
        for j% := 0 to attNumPatches%-1 do 'loop through inner rotations
            for k% := 0 to attNumPatches%-1 do 'loop through contrasts
                if i%<>0 or j%<>0 or k%<>0 then
                    CueCirc$ := CueCirc$ + ",";  'do not insert comma on very first spec, otherwise insert comma
                endif
                CueCirc$ := CueCirc$ + RadAndWid$;  'insert radius and width, always the same here.
                'get index of correct color
                colIdx% := (i% + k%) mod attNumPatches%;

                tempCol%[0] := RGBList%[colIdx%][0];
                tempCol%[1] := RGBList%[colIdx%][1];
                tempCol%[2] := RGBList%[colIdx%][2];
                
                'put in correct color/contrast, which starts on the very first list as index zero and then is very complicatedly updated to behave as desired
                CueCirc$ := CueCirc$ + FadeColorToGray$(tempCol%[],ContrastList%[conIdx%]);
                
                'update index of correct contrast
                'for each cue circle in an individual set, advance the contrast index, and reset to zero if we go past the end
                conIdx% += 1;
                if conIdx% = attNumPatches% then
                    conIdx% := 0;
                endif
            next
            'update index of correct contrast
            'for each new cue circle set, back the index up once, which makes the high contrast come one position later, reset to the end if go go lower than zero
            conIdx% -= 1;
            if conIdx% = -1 then
                conIdx% := attNumPatches%-1;
            endif
        next
    next
    
    'put in closing space
    CueCirc$ := CueCirc$ + " ";
    
    return CueCirc$;
end



func CallDlgGratingFlashers%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    
    attFlasherGratingParams$ := GetGratingParameters$("Flasher");
    i% := GratingParametersDialogFlashers%(label$, attFlasherGratingParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("Flasher", attFlasherGratingParams$);
    endif
    
    return 1;
end;


func GratingParametersDialogFlashers%(label$, &param$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    
	var i% := 50;  'That's right, 15, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    GetFlasherDialogParameters();
    
    while i% = 50 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Flasher Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        'DlgReal(1, "X:", -40, 40);
        'DlgReal(2, "Y:", -40, 40);
        DlgReal(1, "Outer Width:", .1, 30);  'before button x/y values for dialog elements are not necessary
        DlgReal(2, "Outer Height:", .1, 30);
        DlgReal(3, "Inner Width:", 0, 30);
        DlgReal(4, "Inner Height:", 0, 30);
        DlgInteger(5, "Contrast(%):", -100, 100);
        DlgReal(6, "Spatial Freq:", .01, 10);
        DlgReal(7, "Temporal Freq:", 0, 10);
        DlgReal(8, "Orientation (degrees):", -360, 360);
        DlgReal(9, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(10, "Color:", ColorVectorList$[]);
        DlgList(11, "Pattern:", PatternList$[]);
        DlgList(12, "Aperture:", ApertureList$[]);
        DlgButton(50, "Copy from Master", TunCopyMasterVals%(param$), 2, 13); 'after the button, use x/y values so button can offset grating params from flasher params
        DlgReal(13, "Flasher Duration (s):", .01, 3, 42, 14);
        DlgReal(14, "Temporal Buffer (s):", .01, 3, 42, 15);
        DlgReal(15, "Spatial Buffer (deg):", .01, 10, 42, 16);
        DlgReal(16, "Max distance from main grating (deg):", 1, 30, 42, 17);
        DlgReal(17, "Hazard Value (s/flasher):", .01, 1000, 42, 18);  'don't know what reasonable values for this will be yet
        
        i% := DlgShow(attFlasherWidth, attFlasherHeight, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%, attFlasherDur, attFlasherTemporalBuffer, attFlasherSpatialBuffer, attFlasherMaxDist, attFlasherHazardValue);
        Convert180(phase);
        
    wend;
      
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if attFlasherWidth > iw and attFlasherHeight > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters
            param$ := EncodeGratingParameters$(x, y, attFlasherWidth, attFlasherHeight, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
        SaveFlasherDialogParameters();
    endif
    return i%;
end;


func TunCopyMasterVals%(&param$)

    param$ := GetGratingParameters$("Stimulus");

    return 1;
end;


proc GetFlasherDialogParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    

	Profile(key$, "FlasherDur", "1.0", stmp$);
	attFlasherDur := val(stmp$);
    
    Profile(key$, "FlasherTemporalBuffer", "1.0", stmp$);
	attFlasherTemporalBuffer := val(stmp$);
    
    Profile(key$, "FlasherSpatialBuffer", "1.0", stmp$);
	attFlasherSpatialBuffer := val(stmp$);
    
    Profile(key$, "FlasherMaxDist", "1.0", stmp$);
	attFlasherMaxDist := val(stmp$);
    
    Profile(key$, "FlasherHazardValue", "1.0", stmp$);
	attFlasherHazardValue := val(stmp$);
    
    Profile(key$, "FlasherWidth", "1.0", stmp$);
	attFlasherWidth := val(stmp$);
    
    Profile(key$, "FlasherHeight", "1.0", stmp$);
	attFlasherHeight := val(stmp$);

end;

proc SaveFlasherDialogParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
	Profile(key$, "FlasherDur", str$(attFlasherDur));
    Profile(key$, "FlasherTemporalBuffer", str$(attFlasherTemporalBuffer));
    Profile(key$, "FlasherSpatialBuffer", str$(attFlasherSpatialBuffer));
    Profile(key$, "FlasherMaxDist", str$(attFlasherMaxDist));
    Profile(key$, "FlasherHazardValue", str$(attFlasherHazardValue));
    Profile(key$, "FlasherWidth", str$(attFlasherWidth));
    Profile(key$, "FlasherHeight", str$(attFlasherHeight));
    
end;


'Returns 1 if the two patches overlap, 0 if they do not.  Overlap includes a buffer region if BUFFER is non-zero
'Overlap goes to extremes of simplicity in computing (because doing it properly turns out to be VERY DIFFICULT)
'and models potentially elliptical gratings as...rectangles.  The basic effects of this simplification will be:
'1A) The effective buffer will be somewhat larger than the requested buffer
'1B) Tangent/near-tangent gratings will be considered to overlap unless their centers have the same X or Y values
'    (but we weren't TRYING to get tangent gratings, so that's not a biggie)
func Overlap%(x,y,width,height,x2,y2,width2,height2,buffer)
    var overlap;
    var dist;
    
    
    'Check X
    dist := width/2 + width2/2 + buffer; 'this is how far apart the X centers must be, width values are diameters
    'printlog("X Dist is %f\n",dist);
    if abs(x-x2) < dist then
        overlap += 1;
    endif;
    
    'Check Y
    dist := height/2 + height2/2 + buffer; 'this is how far apart the Y centers must be, height values are diameters
    'printlog("Y Dist is %f\n",dist);
    if abs(y-y2) < dist then
        overlap += 1;
    endif;
    
    if overlap = 2 then  'if both x and y overlap, then the rectangles overlap
        return 1;
    else
        return 0;
    endif;
    
end


'Returns max limits (in degrees in variables xmax, ymax) for the screen, used to constrain random x/y position
'use 400 for width and 300 for height unless otherwise specified
'when using recall that width/height definitions are total w/h and distance from the center point is width/2
proc ScreenBounds(scrXmm,scrYmm,&xmax,&ymax)
    var d2s$;
    var d2s; 
    
    d2s$ := GetDistanceToScreenMM$();
    d2s := val(d2s$);
    'printlog("Distance to screen is %f\n",d2s);
    
    xmax := ATan((scrXmm/2)/d2s)*180/(4.0*ATan(1.0));  'maximum x in degrees
    ymax := ATan((scrYmm/2)/d2s)*180/(4.0*ATan(1.0));  'maximum y in degrees
    'printlog("Max x is %f degrees and max y is %f degrees\n",xmax,ymax);
    
end

'This function places a SampleText to indicate the onset/location of flashers or the time of the contrast change
'Since these are on the same channel, it just looks for the nearest expected time to the known trigger.
'Since there is a buffer of 100 ms between any onset, there should be no difficulty, but I will have the
'SampleText indicate a possible problem if the timing is off by more than, say, 2ms
func TagTriggerWithSampletext%(triggerTime,tStimOn,trialCount%,&flasherCount%)
    var cc%;  'did contrast change happen?
    var fTime;  'expected time of next flasher
    var ccTime; 'expected time of contrast change
    var diffF;
    var diffCC;
    var diffEOW;
    
    'don't tag the very first trigger that coincides with the stim onset
    if triggerTime - tStimOn < 0.005 then
        return cc%;  'instead return and indicate CC has not happened
    endif;
    
    if flasherTimes[trialCount%][flasherCount%] > 0 then
        fTime := tStimOn + flasherTimes[trialCount%][flasherCount%];
    else
        fTime := 9999999; 'there is no flasher, this will make diffF huge
    endif;
    ccTime := tStimOn + attHazardList[trialCount%];
    
    diffF := abs(fTime - triggerTime);
    diffCC := abs(ccTime - triggerTime);
    diffEOW := abs((ccTime + attTimeToAnswer) - triggerTime);
    
'printlog("*** Tag Trigger - Flasher count is %d, expected flasher time is %f, expected ccTime is %f, trigger time is %f, delta was %f\n",flasherCount%,fTime,ccTime,triggerTime,Min(diffF,diffCC));    
    
    docase
    case diffF > .05 and diffCC > .05 then  'if tolerance > 50 ms (eeek!), sampletext an error or end-of-window
        if diffEOW < .1 then 'use big tolerance for end of window
            SampleText("End of response window",triggerTime);
        else
            SampleText("Error - trigger time not recognized!",triggerTime);
        endif;
    case diffF < diffCC and diffF > 0.05 then
        SampleText("Flasher X = " + Str$(flasherX[trialCount%][flasherCount%]) + " Y = " + Str$(flasherY[trialCount%][flasherCount%]) + " Note, trigger time more than 2ms off!",triggerTime);
        flasherCount% += 1;
    case diffCC < diffF and diffCC > 0.05 then
        cc% := 1;
    case diffF < diffCC then
        SampleText("Flasher X = " + Str$(flasherX[trialCount%][flasherCount%]) + " Y = " + Str$(flasherY[trialCount%][flasherCount%]),triggerTime);
        flasherCount% += 1;
    case diffCC < diffF then
        cc% := 1;
    else
        message("Trigger was exactly halfway between expected Flasher and Contrast Change.  This should never happen.  Argh.");
    endcase
    
    return cc%;
end





'masterColorList$ and masterColorListVSG$ define fixation colors and should have the same progression as cue circle colors
'but due to the command line need to be in a text format.  Use cue circle colors to fill these variables.
'This function will allow any integer color values from 0-255 even though the dialog box code currently will not.
proc CreateMasterColorLists()
    var temp%[3][6];  'our list of colors
    var i%;
    var r%;
    var g%;
    var b%;
    var mystr$;
    
    temp%[0][0] := attendRGB%[0];
    temp%[1][0] := attendRGB%[1];
    temp%[2][0] := attendRGB%[2];
    temp%[0][1] := ignore1RGB%[0];
    temp%[1][1] := ignore1RGB%[1];
    temp%[2][1] := ignore1RGB%[2];
    temp%[0][2] := ignore2RGB%[0];
    temp%[1][2] := ignore2RGB%[1];
    temp%[2][2] := ignore2RGB%[2];
    temp%[0][3] := ignore3RGB%[0];
    temp%[1][3] := ignore3RGB%[1];
    temp%[2][3] := ignore3RGB%[2];
    temp%[0][4] := ignore4RGB%[0];
    temp%[1][4] := ignore4RGB%[1];
    temp%[2][4] := ignore4RGB%[2];
    temp%[0][5] := noattenRGB%[0];
    temp%[1][5] := noattenRGB%[1];
    temp%[2][5] := noattenRGB%[2];
    
    'not ready to do this yet
    for i% := 0 to 5 do
        r% := temp%[0][i%];
        g% := temp%[1][i%];
        b% := temp%[2][i%];
        
        mystr$ := "(" + str$(r%) + "/" + str$(g%) + "/" + str$(b%) + ")";
        
        masterColorListVSG$[i%] := mystr$;
        
        docase
        case r% = 255 and g% = 255 and b% = 255 then
            masterColorList$[i%] := "white";
        case r% = 0 and g% = 0 and b% = 0 then
            masterColorList$[i%] := "black";
        case r% = 255 and g% = 0 and b% = 0 then
            masterColorList$[i%] := "red";
        case r% = 0 and g% = 255 and b% = 0 then
            masterColorList$[i%] := "green";
        case r% = 0 and g% = 0 and b% = 255 then
            masterColorList$[i%] := "blue";
        case r% = 255 and g% = 255 and b% = 0 then
            masterColorList$[i%] := "yellow";
        case r% = 0 and g% = 255 and b% = 255 then
            masterColorList$[i%] := "cyan";
        case r% = 255 and g% = 0 and b% = 255 then
            masterColorList$[i%] := "magenta";
        else
            masterColorList$[i%] := mystr$;
        endcase
    next
    
    
    
end




func AttOptoDialog%()
	var iReturn% := 1;
	var i%;
'    var labels$[4];
    var stimdur;
    var tempNPulses%;
    var tempCount%;
    stimdur := attFixationCueMaxTime + attHazardCutoffTime + attTimeToAnswer;  'get stimulus duration value from calling (main) dialog, limit opto period based on this
    
'    labels$[0] := "Opto Off First";
'    labels$[1] := "Opto On First";
'    labels$[2] := "Random First";
'    labels$[3] := "Opto On All Blocks";
	GetAttOptoParameters();
	DlgCreate("Optogenetics Parameters");
    DlgGroup("Common Parameters", 1, 1, 38, 5);
    DlgReal(1, "Opto Voltage Out (V)",0.0002,5,20,2); '.0002 is the minimum value that will give any change at all (to 1 in a 15-bit range) on the DAC
    DlgReal(2, "Proportion of Opto Trials (0-1)",0,1,20,3);
    DlgReal(3, "InterBlock Time(s):", 0, 100, 20, 4);  'new, allow really long stimuli
    DlgCheck(4, "Use pulsing opto",2,5);
    DlgCheck(5, "Record Laser Diode",2,6);
    DlgGroup("Wrap-Around Opto", 1, 7, 38, 4);
    DlgReal(6, "PreStimulus Opto On (s)",0,10,20,8);
    DlgReal(7, "PostStimulus Opto On (s)",0,10,20,9);
    DlgCheck(8, "Keep Opto on between stims",2,10);
    DlgGroup("Pulsing Opto", 1, 11, 38, 5);
    DlgInteger(9, "Opto # Pulses ",0,1000,20,12);
    DlgReal(10, "Opto Period Onset (s)",0,stimdur,20,13);
    DlgReal(11, "Opto Pulse Width (s)",0,stimdur,20,14);
    DlgReal(12, "Opto Interpulse Interval (s)",0,100,20,15);
    
    'DlgCheck(6, "Record control box voltage");
    'DlgCheck(7, "Record stimulator");
    
    DlgAllow(0xffff, 0, AttOptoDialogChanged%);    
    
    i% := DlgShow(attOptoVoltageOut,attOptoPctOpto,attInterBlockTime,attOptoUsePulse%,attLaserDiode%,attPreStimOptoTime,attPostStimOptoTime,attOptoStaysOn%,attOptoNPulses%,attPulsedOptoOnset,attPulsedOptoWidth,attPulsedOptoIPI);
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 

	if i% = 1 then
		SaveAttOptoParameters();
'        docase
'        case attOptoStartState% = 3 then
'            dontToggleOpto% := 1;
'            attOptoState% := 1;
'        case attOptoStartState% = 2 then
'            attOptoState% := round(Rand());
'        else
'            attOptoState% := attOptoStartState%;
'        endcase;

        
        'do temporary calculation to make sure all pulses will occur during the stimulus
        'unfortunately we will have to do this AGAIN once the script starts because the user could change the stimulus duration after the opto parameters
        'fortunately, the calculation is the same and it all worked on the first try
        if attOptoUsePulse% = 1 then
            stimdur := stimdur - attPulsedOptoOnset;  'duration of stimulus after onset delay
            stimdur := stimdur - attPulsedOptoWidth;  'duration of stimulus after first opto pulse
            if stimdur < 0 then  'if first pulse will extend beyond stimulus duration
                attOptoNPulses% := 0;  'turn off opto by using no pulses
                'tell user to try again
                Message("The first opto pulse will extend beyond the stimulus!  There will be no pulses!  Please try again!");
            else
                tempNPulses% := attOptoNPulses% - 1;  'how many more pulses are left?
                tempCount% := 1;  'temporary successful pulse count
                while tempNPulses% > 0 do
                    stimdur := stimdur - attPulsedOptoWidth - attPulsedOptoIPI;  'subtract duration of one more pulse+IPI
                    if stimdur < 0 then  'if this pulse will extend beyond stimulus duration
                        Message("Due to stimulus length, only " + Str$(tempCount%) + " pulses can be completed!  You may try again!");
                        attOptoNPulses% := tempCount%;  'only use this many pulses if user does not recalculate
                        tempNPulses% := 0;  'break while
                    else  'if this pulse is OK
                        tempCount% += 1;  'increment temporary successful pulse count
                    endif;
                    tempNPulses% -= 1;  'decrement temporary pulse count remaining
                wend
                
            endif;
            
        endif;
        
        
        
	endif;
    
	return iReturn%;
end;



' This function is initially called with a "0" input
func AttOptoDialogChanged%(item%) 
    DlgEnable(0,5);  'Just straight up disable the laser diode recording
    DlgEnable(0,3);  'Just straight up disable the inter block time
    DlgEnable(0,8);  'Just straight up disable keeping opto on between stims (but the code ought to be right-ish) - DEFINITELY test if this is re-enabled
    DlgEnable(0,7);  'Just straight up disable post-stimulus wraparound opto - we are not doing it and Henry doesn't want it
    if DlgValue(4) = 1 then
        DlgEnable(1,9);  'enable pulsing dialog values 
        DlgEnable(1,10);
        DlgEnable(1,11);
        DlgEnable(1,12);
        DlgEnable(0,6);  'disable wrap-around dialog values 
        'DlgEnable(0,7);
        'DlgEnable(0,8);  'Just straight up disable keeping opto on between stims (but the code ought to be right-ish)  
    else
        DlgEnable(0,9);  'disable pulsing dialog values 
        DlgEnable(0,10);
        DlgEnable(0,11);
        DlgEnable(0,12);
        DlgEnable(1,6);  'enable wrap-around dialog values 
        'DlgEnable(1,7);
        'DlgEnable(1,8);  'Just straight up disable keeping opto on between stims (but the code ought to be right-ish)
    endif;
    
    return 1;
end


proc GetAttOptoParameters()
	var stmp$;
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG\\Opto";
    
    attPreStimOptoTime := GetFloatRegistryValue(key$, "PreStimOptoTime", attPreStimOptoTime);
    attPostStimOptoTime := GetFloatRegistryValue(key$, "PostStimOptoTime", attPostStimOptoTime);
    attOptoStaysOn% := GetIntRegistryValue%(key$, "OptoStaysOn", attOptoStaysOn%);
    attOptoVoltageOut := GetFloatRegistryValue(key$, "OptoVoltageOut", attOptoVoltageOut);
    attOptoPctOpto := GetFloatRegistryValue(key$, "OptoPctOpto", attOptoPctOpto);
    attOptoUsePulse% := GetIntRegistryValue%(key$, "OptoUsePulse", attOptoUsePulse%);
    attLaserDiode% := GetIntRegistryValue%(key$, "LaserDiode", attLaserDiode%);
    attOptoNPulses% := GetIntRegistryValue%(key$, "OptoNPulses", attOptoNPulses%);
    attPulsedOptoOnset := GetFloatRegistryValue(key$, "PulsedOptoOnset", attPulsedOptoOnset);
    attPulsedOptoWidth := GetFloatRegistryValue(key$, "PulsedOptoWidth", attPulsedOptoWidth);
    attPulsedOptoIPI := GetFloatRegistryValue(key$, "PulsedOptoIPI", attPulsedOptoIPI);
    attInterBlockTime := GetFloatRegistryValue(key$, "InterBlockTime", attInterBlockTime);

end;

proc SaveAttOptoParameters()
	var key$;
	key$:= GetRigName$() + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG\\Opto";
    SetFloatRegistryValue(key$, "PreStimOptoTime", attPreStimOptoTime);
    SetFloatRegistryValue(key$, "PostStimOptoTime", attPostStimOptoTime);
    SetIntRegistryValue(key$, "OptoStaysOn", attOptoStaysOn%);
    SetFloatRegistryValue(key$, "OptoVoltageOut", attOptoVoltageOut);
    SetFloatRegistryValue(key$, "OptoPctOpto", attOptoPctOpto);
    SetIntRegistryValue(key$, "OptoUsePulse", attOptoUsePulse%);
    SetIntRegistryValue(key$, "LaserDiode", attLaserDiode%);
    SetIntRegistryValue(key$, "OptoNPulses", attOptoNPulses%);
    SetFloatRegistryValue(key$, "PulsedOptoOnset", attPulsedOptoOnset);
    SetFloatRegistryValue(key$, "PulsedOptoWidth", attPulsedOptoWidth);
    SetFloatRegistryValue(key$, "PulsedOptoIPI", attPulsedOptoIPI);
    SetFloatRegistryValue(key$, "InterBlockTime", attInterBlockTime);
    

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' The vdac32% function converts a value in user DAC units into an integer value
'  (the result of the function) suitable for passing into a sequencer variable
'  for use in the DAC, ADDAC, RAMP and OFFSET sequencer instructions. It mimics
'  the vdac32() expression in the text sequence compiler.
'
' out     is the output value that you want to generate, in user DAC units.
' scale   is the user DAC units corresponding to one volt on the actual DAC
'         (or two volts for a ten-volt system). This is exactly the same as
'         the DACscale field used with the SET or SDAC directives.
' offset  is the user DAC units corresponding to zero volts output. This is
'         exactly the same as the DACOffset field in SET or SDAC.
'
' If you want to use this function to calculate the slope for a ramp, use
'  vdac32%(volts/sticks%(time)) for maximum accuracy.
'
func vdac32%(out, scale, offset)
var v32;                                ' Real variable for the calculation
out := out - offset;                    ' First compensate for offset
v32 := ((out * (6553.6 / scale)) * 65536.0);   ' Floating point result
var v32%;                               ' Integer value for the result
if v32 > 2147483647.0 then              ' 2147483647 is the largest positive
    v32% := 2147483647;                 '  integer value
else
    if v32 < -2147483647.0 then         ' -2147483648 is the lowest negative value
        v32% := -2147483647;            '  but we have to stay one above that
    else
        v32% := round(v32);             ' We can be sure this will not overflow
    endif;
endif;
return v32%;
end
