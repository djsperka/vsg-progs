' $Id: AttaJoy.s2s,v 1.23 2010-10-02 00:09:19 devel Exp $

' Stimulator/shock setup: 
' DOUT0 from VSG ----> TRIG input on 1401 _T_ ajRecordShockTriggerPort% (if not set to -1)
' DAC0 output on 1401 -----> stimulator pulse _T_ ajRecordShockPort% (if not set to -1)



#include "../../Spike2Util/TrialGenInterface.s2s"
#include "../../Spike2Util/ChannelUtilities.s2s"
#include "../../Spike2Util/DlgUtilities.s2s"
#include "../../Spike2Util/UsreyUtil.s2s"
#include "UsreyGratings.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"
#include "Joystick.s2s"

' Local config variables

var ajNBlocks% := 1;
var ajNTrialsEachTypePerBlock% := 10;
const ajNoTraining% := 0;
const ajReadyTraining% := 1;
const ajReadyFixTraining% := 2;
const ajReadyFixStimTraining% := 3;
var ajTrainingType% := ajNoTraining%;
var ajCatchTrialPct := 0;
var ajAlternateCueTypeByBlock% := 0;
var ajMaxWaitForReadyTime := 1.0;
var ajReadyFailPauseTime := 1.0;
var ajReadyBreakPauseTime := 1.0;
var ajMaxAcquisitionTime := 1.0;
var ajUseCueCircles% := 1;
var ajHoldFixationTime := 1.0;
var ajHoldFixation1Time := 1.0;
var ajHoldFixation2Time := 1.0;
var ajHoldFixation3Time := 1.0;
var ajFixationBreakPauseTime := 1.0;
var ajAcquisitionFailPauseTime := 1.0;
var ajTrainingSuccessPauseTime := 1.0;
var ajHazardTimeMin := 1.0;
var ajHazardTimeMean := 1.5;
var ajHazardTimeMax := 2.0;
var ajMaxResponseTime := 2.0;
var ajCorrectResponsePauseTime := 1.0;
var ajIncorrectResponsePauseTime := 1.0;
var ajRewardSize% := 1;
var ajUseBeep% := 1;
var ajContrastBase% := 75;
var ajContrastUp% := 100;
var ajContrastDown% := 50;
var ajAlwaysLooking% := 0;      ' Set to 1 in timing dialog. Will cause Looking% to always return 1. 
var ajTrialTypesListIndex% := 0;
var ajShowSingleStim% := 0;
var ajExtraFixationTime := 0.2;     ' Extra fixation time during stateWaitForResponse
var ajDoHoldFixationMiniReward% := 0;   ' DO NOT MODIFY! Use Bonus dialog!!!
var ajHoldFixationMiniRewardEnable% := 0;   ' when 1 mini reward is enabled; used per-trial
var ajHoldFixationMiniRewardFraction := .99; ' fraction of hold fixation time passed before mini-reward given
const ajNPorts% := 8;   ' Number of analog ports. Is there a way to programatically determine this? 
var ajWavemark%[ajNPorts%]; 
var ajContinuous%[ajNPorts%];
var ajDoJoystickReadyMiniReward% := 0;      ' When set, will deliver a reward 
var ajJoystickReadyMiniRewardDelay := .2;   ' delay after joystick ready to reward
var ajJoystickReadyMiniRewardSize% := 1;    ' size of joystick ready reward 
var ajDoShockTrials% := 0;
var ajNShockPerBlock% := 0;
var ajShockDelayMS% := 500;
var ajJoystickAlwaysCorrect% := 0;  ' if 1 then JoystickPostionCorrect% always returns 1 (correct)
var ajTestShockTrials% := 0;        ' if 1 then every trial is a shock trial
var ajPulse[2500];                   ' max 5s at 1khz
var ajShockDoRecordShock% := 1;
var ajRecordShockPort% := 4;                  ' Must hardcode this or set in dialog! Set to -1 for no record
var ajRecordShockTriggerPort% := 3;           ' Hardcode. Set to -1 for no record. 
var ajShockTrialEnable% := 1;                 ' See PrepareTrial(). Set to 1 on trials where there will be a shock. 
var ajWeights%[4];                              ' for trial generator


' Strings for DlgList training type
var ajTrainingTypes$[4];

' Counters

var ajCtrNTrials% := 0;
var ajCtrReadyFail% := 0;
var ajCtrReadyBreak% := 0;
var ajCtrIncorrect% := 0;
var ajCtrCorrect% := 0;
var ajCtrNRewards% := 0;
var ajCtrNTrialsReady% := 0;
var ajCtrNTrialsAcq% := 0;
var ajCtrNTrialsAcqFail% := 0;
var ajCtrNTrialsFix% := 0;
var ajCtrNTrialsFixBreak% := 0;
var ajCtrNTrialsStim% := 0;
var ajCtrNTrialsChg% := 0;
var ajCtrNBlocksCompleted% := 0;

' Channel numbers for DAQ inputs

var ajChanEyeX%                 := 11;
var ajChanEyeY%                 := 12;
var ajChanJoy%                  := 13;
var ajChanRecordShock%          := 14;
var ajChanRecordShockTrigger%   := 15;

' VSG trigger input channels

var ajChanVSGReady%    :=  20;
var ajChanFixpt%       :=  21;
var ajChanCircle%      :=  22;
var ajChanStimulus%    :=  23;
var ajChanContrastChg% :=  24;

' windows

var ajWindowData%;
var ajWindowXY%;

' display channels

var ajChanMonitor%;
var ajChanJoystickPos%;
var ajChanJoystickRangeL%;
var ajChanJoystickRangeC%;
var ajChanJoystickRangeR%;
var ajChanStimDisplay0%;
var ajChanStimDisplay1%;
var ajChanFixptDisplay%;
var ajChanFixptWindowDisplay%;
var ajVCoeff;
var ajVConst;
var ajJoystickDisplayY;
var ajUnitCircleX[36];
var ajUnitCircleY[36];
var ajCircleX[36];
var ajCircleY[36];
var ajStim0X, ajStim0Y, ajStim1X, ajStim1Y;
var ajStim0D, ajStim1D;
var ajFixationX, ajFixationY, ajFixationD, ajFixationWindowRadius;

' Controls

var ajIsPaused% := 0;
var ajStimHandle% := 0;
var ajTrialTypesList$[3];
var ajNTrialTypes%;
var ajTrialTypeIndex%;
var ajTrialFixptTypeKeys$[2];
var ajTrialChangeTypeKeys$[2];
var ajTrialFixptSampleKey$;
var ajTrialChangeSampleKey$;
var ajIsCatchTrial% := 0;
var ajTrialHazardTime := 1.0;
var ajReadyResponse% := JSRight%;
var ajCorrectResponse%;
var ajIncorrectResponse%;
var ajUniversalIntertrialTime;     ' time to wait between trials

' States - these constants define a particular state

const stateStartup%             :=  1;
const statePaused%              :=  2;
const stateTrialStart%          :=  3;
const stateBeep%                :=  4;
const stateWaitForReady%        :=  5;
const stateReadyFail%           :=  6;
const stateIntertrialWait%      :=  7;
const stateTrialCompleted%      :=  8;
const stateWaitForFixpt%        :=  9;
const stateReadyBreak%          :=  10;
const stateWaitForFixptOff%     :=  11;
const stateWaitForAcquisition%  :=  12;
const stateAcquisitionFail%     :=  13;
const stateHoldFixation%        :=  14;
const stateHoldFixation1%       :=  15;
const stateHoldFixation2%       :=  16;
const stateHoldFixation3%       :=  17;
const stateFixationBreak%       :=  18;
const stateWaitForCircle%       :=  19;
const stateWaitForCircleOff%    :=  20;
const stateWaitForStimOn%       :=  21;
const stateWaitHazardTime%      :=  22;
const stateWaitForContrastChange% :=  23;
const stateWaitForResponse%     :=  24;
const stateCorrectResponse%     :=  25;
const stateIncorrectResponse%   :=  26;
const stateQuit%                :=  27;
const stateDone%                :=  28;
const stateVSGWait%             :=  29;
const stateVSGConfirm%          :=  30;
const stateT1Success%           :=  31;
const stateT2Success%           :=  32;
const stateWaitForNeutral%      :=  33;
const stateT3Success%           :=  34;

var iState% := stateStartup%;              ' This holds the current state

var tNow:=0;		    ' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		    ' last time we checked for a trigger. 
var xEye, yEye;		    ' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		    ' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	    ' temp var for newly discovered trigger times
var doCorrectionTrial% := 0;    ' this is set to 1 when a trial fails and correction trials were requested
var isCorrectionTrial% := 0;    ' this is set to 1 when we are in a trial that is a correction trial
var tCircleOn := -1;

'===========================================================================================
'
' Script execution starts here. 
'
'===========================================================================================

LogInit(1);
InitJoystick(13);
ajTrialTypesList$[0] := "Both";
ajTrialTypesList$[1] := "Red";
ajTrialTypesList$[2] := "Green";
ajTrainingTypes$[ajNoTraining%] := "No Training";
ajTrainingTypes$[ajReadyTraining%] := "Ready Training";
ajTrainingTypes$[ajReadyFixTraining%] := "Ready/Fix Training";
ajTrainingTypes$[ajReadyFixStimTraining%] := "Ready/Fix/Stim Training";

if AttaJoyDialog%() = 0 then
    halt;
endif

' Check a few values for reasonable-ness....
if ajHazardTimeMax < ajHazardTimeMean or ajHazardTimeMean < ajHazardTimeMin then
    Message("Must have hazard time max > mean > min!");
    halt;
endif

' 
if ajJoystickAlwaysCorrect% = 1 then
    if Query("JoystickAlwaysCorrect is set to 1. This means the joystick is presumed to always be in correct position. Change back to 0?") = 1 then
        ajJoystickAlwaysCorrect% := 0;
    endif
endif

if ajDoShockTrials% = 1 and ajTestShockTrials% = 1 then
    if Query("TestShockTrials is set to 1. This means every trial is a shock trial. Change back to 0?") = 1 then
        ajTestShockTrials% := 0;
    endif
endif


' Each trial type may have different cue/fixpt sample key values, depending
' on dialog choices regarding training, etc. 
if ajTrainingType% <> ajReadyTraining% and ajTrialTypesListIndex% = 0 then
    ajNTrialTypes% := 2;
    ajTrialFixptTypeKeys$[0] := "F";
    ajTrialFixptTypeKeys$[1] := "G";
    ajTrialChangeTypeKeys$[0] := "C";
    ajTrialChangeTypeKeys$[1] := "D";
else
    ajNTrialTypes% := 1;
    docase
    case ajTrainingType% = ajReadyTraining% then
        ajTrialFixptTypeKeys$[0] := "Z";
        ajTrialFixptTypeKeys$[1] := "Z";
        ajTrialChangeTypeKeys$[0] := "Z";
        ajTrialChangeTypeKeys$[1] := "Z";        
    case ajTrialTypesListIndex% = 1 then
        ajTrialFixptTypeKeys$[0] := "F";
        ajTrialFixptTypeKeys$[1] := "Z";
        ajTrialChangeTypeKeys$[0] := "C";
        ajTrialChangeTypeKeys$[1] := "Z";
    case ajTrialTypesListIndex% = 2 then
        ajTrialFixptTypeKeys$[0] := "G";
        ajTrialFixptTypeKeys$[1] := "Z";
        ajTrialChangeTypeKeys$[0] := "D";
        ajTrialChangeTypeKeys$[1] := "Z";
    endcase
endif        

' Init trial generator
if ajAlternateCueTypeByBlock% <> 1 then
    tbgInit(ajNTrialTypes%, ajNTrialsEachTypePerBlock%, ajNBlocks%);
else
    tbaltgInit(ajNTrialTypes%, ajNTrialsEachTypePerBlock%, ajNBlocks%);
endif

' Get fixation point parameters
GetFixationPointParameters();

' Sampling config
CreateSampleConfiguration();

' Prepare display windows, input channels, etc. 
InitializeWindows();

' Set up toolbar and launch
InitializeToolbar();




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration - Set up recording channels, dig input channels for VSG communication
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc CreateSampleConfiguration()
	var i%;
    
	SampleClear(); 'Set standard sampling state
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 3);
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 1);
    SampleAutoName$(dataCellName$ + "_aj_000");
	SampleAutoFile(1);
    
	'Channel recording definitions
	SampleEvent(ajChanVSGReady%, 6, 2, 3600); 'Trigger channel, level
	SampleComment$(ajChanVSGReady%, "VSG Ready");
	SampleTitle$(ajChanVSGReady%, "VSG Ready");
    
	SampleEvent(ajChanFixpt%, 1, 2, 3600);
	SampleComment$(ajChanFixpt%, "Fixpt");
	SampleTitle$(ajChanFixpt%, "Fixpt");
    
	SampleEvent(ajChanCircle%, 3, 2, 3600);
	SampleComment$(ajChanCircle%, "Cue");
	SampleTitle$(ajChanCircle%, "Cue");
    
	SampleEvent(ajChanStimulus%, 2, 2, 3600);
	SampleComment$(ajChanStimulus%, "Stim");
	SampleTitle$(ajChanStimulus%, "Stim");    
    
	SampleEvent(ajChanContrastChg%, 4, 2, 3600);
	SampleComment$(ajChanContrastChg%, "Chg");
	SampleTitle$(ajChanContrastChg%, "Chg");
	
	SampleWaveform(ajChanJoy%, GetJoystickPort%(), 1000);
	SampleTitle$(ajChanJoy%, "Joy");
    
	SampleWaveform(ajChanEyeX%, GetEyeXPort%(), 1000);
	SampleTitle$(ajChanEyeX%, "Eye X");
	SampleWaveform(ajChanEyeY%, GetEyeYPort%(), 1000);
	SampleTitle$(ajChanEyeY%, "Eye Y");
    
    if ajShockDoRecordShock% = 1 then
        if ajRecordShockPort% >= 0 then
            SampleWaveform(ajChanRecordShock%, ajRecordShockPort%, 10000);
            SampleTitle$(ajChanRecordShock%, "Shock");
        endif
        if ajRecordShockTriggerPort% >= 0 then
            SampleWaveform(ajChanRecordShockTrigger%, ajRecordShockTriggerPort%, 1000);
            SampleTitle$(ajChanRecordShockTrigger%, "ShockTrigger");
        endif            
    endif
    
    ' Electrodes: wavemark/continuous
    for i% := 0 to ajNPorts%-1 do
        if ajWavemark%[i%] = 1 then
            if ajContinuous%[i%] = 0 then
                SampleWaveMark(i%+1, i%, 2000, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
                SampleTitle$(i%+1, "WvMk" + str$(i%)); 
            else
                SampleWaveform(i%+1, i%, 28000);
                SampleTitle$(i%+1, "Cont" + str$(i%)); 
            endif
        endif
    next
    
    
    ' Create play wave area if needed. We have to do this before FileNew()
    if ajDoShockTrials% = 1 then
        var s;
        var ch%[2];
        LogInfo("Preparing play wave area...");
        ArrConst(ajPulse[], 0);
        for i% := ajShockDelayMS% to ajShockDelayMS% + 5 do
            LogInfo("ajPulse[" + str$(i%) + "] = 5");
            ajPulse[i%] := 5;
        next
        s := PlayWaveAdd("P", "Pulse", 0, 1000, ajPulse[0:2500]);
        if s < 0 then
            LogError("Start", "Cannot create play wave area status=" + str$(s));
            halt;
        else
            LogInfo("Play wave area \"P\" created.");
            s := PlayWaveTrigger("P", 1);
            LogInfo("Shock trial - area \"P\" trig status now " + str$(PlayWaveTrigger("P")));

            s := PlayWaveChans("P", ch%[]);
            LogInfo("Play wave area has " +str$(s) + " channels.\n");
            if s > 0 then
                PrintLog("First chan is " + str$(ch%[0]) + "\n");
            endif
        endif
        
    endif
    
    
    
	SampleSequencer(script$ + "AttaJoy.pls");
	SampleOptimise(2, 2, 2, 2, 50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
    
    
    
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
'	UpdateToolbarText();
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",Pause%);
	ToolbarSet(5,"Resume stimuli",Resume%);
	ToolbarSet(6,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeWindows - Open data file, set up windows for online display.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc InitializeWindows()
    var i%;
	var twopi;
    
    ' These set the max and min window dimensions. They are also used to scale the joystick 
    ' position to the xy display, so if you change the size of the window, do it by changing
    ' these vars!
    var xyXMin := -20;
    var xyXMax := 20;
    var xyYMin := -15;
    var xyYMax := 15;
    var lh, cl, ch, rl;
    ajJoystickDisplayY := -12;     ' y coord in xy window where joystick position is shown. 
        
	'Open the data sampling window
	ajWindowData% := FileNew(0,4);
	Window(0,48,100,95);
	View(ajWindowData%).WindowVisible(1);
    XRange(0, 15);

	'Open an XY view to display eye position
	ajWindowXY% := FileNew(12);
	XRange(xyXMin, xyXMax);
	YRange(-2, xyYMin, xyYMax);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
	'Create a new channel in the XY view to show the monitor's location
	ajChanMonitor% := XYSetChan(0);
	XYColour(ajChanMonitor%, 13);
	XYDrawMode(ajChanMonitor%, 3, 1);
	XYJoin(ajChanMonitor%, 2);
	XYAddData(ajChanMonitor%, -9, -7);
	XYAddData(ajChanMonitor%, 9, -7);
	XYAddData(ajChanMonitor%, 9, 7);
	XYAddData(ajChanMonitor%, -9, 7);
    
    ' Set up joystick range numbers
    lh := GetJoystickLeftHigh();
    cl := GetJoystickCenterLow();
    ch := GetJoystickCenterHigh();
    rl := GetJoystickRightLow();
    
    ' We'll take the joystick voltage 'v' (which should be between 1 and 4volts) and 
    ' convert it for display in the xy window like this:
    ' x coord = v * rivVCoeff + rivVConst;
    
    ajVCoeff := (xyXMax - xyXMin)/3;
    ajVConst := -2.5 * ajVCoeff;
    
    ajChanJoystickRangeL% := XYSetChan(0);
    XYColour(ajChanJoystickRangeL%, 13);
    XYSize(ajChanJoystickRangeL%, 2);
    XYJoin(ajChanJoystickRangeL%, 1);
    XYDrawMode(ajChanJoystickRangeL%, 4, 3);
    XYAddData(ajChanJoystickRangeL%, xyXMin, ajJoystickDisplayY+1);
    XYAddData(ajChanJoystickRangeL%, lh * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    
    ajChanJoystickRangeC% := XYSetChan(0);
    XYColour(ajChanJoystickRangeC%, 13);
    XYSize(ajChanJoystickRangeC%, 2);
    XYJoin(ajChanJoystickRangeC%, 1);
    XYDrawMode(ajChanJoystickRangeC%, 4, 3);
    XYAddData(ajChanJoystickRangeC%, cl * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    XYAddData(ajChanJoystickRangeC%, ch * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    
    ajChanJoystickRangeR% := XYSetChan(0);
    XYColour(ajChanJoystickRangeR%, 13);
    XYSize(ajChanJoystickRangeR%, 2);
    XYJoin(ajChanJoystickRangeR%, 1);
    XYDrawMode(ajChanJoystickRangeR%, 4, 3);
    XYAddData(ajChanJoystickRangeR%, rl * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    XYAddData(ajChanJoystickRangeR%, xyXMax, ajJoystickDisplayY+1);
    
    
    ' this channel is for a symbol representing the actual joystick position
    ajChanJoystickPos% := XYSetChan(0);
    XYColour(ajChanJoystickPos%, 11);
    XYDrawMode(ajChanJoystickPos%, 1, 8);
    XYDrawMode(ajChanJoystickPos%, 2, 10);
    XYSize(ajChanJoystickPos%, -1);
    
    ' this channel is for displaying the stimulus
    ajChanStimDisplay0% := XYSetChan(0);
    XYColour(ajChanStimDisplay0%, 8);
    XYDrawMode(ajChanStimDisplay0%, 2, 0);
    XYDrawMode(ajChanStimDisplay0%, 3, 0);
    XYJoin(ajChanStimDisplay0%, 2);
    XYSize(ajChanStimDisplay0%, 36);
    
    ajChanStimDisplay1% := XYSetChan(0);
    XYColour(ajChanStimDisplay1%, 8);
    XYDrawMode(ajChanStimDisplay1%, 2, 0);
    XYDrawMode(ajChanStimDisplay1%, 3, 0);
    XYJoin(ajChanStimDisplay1%, 2);
    XYSize(ajChanStimDisplay1%, 36);
    
    ajChanFixptDisplay% := XYSetChan(0);
    XYColour(ajChanFixptDisplay%, 8);
    XYDrawMode(ajChanFixptDisplay%, 2, 0);
    XYDrawMode(ajChanFixptDisplay%, 3, 0);
    XYJoin(ajChanFixptDisplay%, 2);
    XYSize(ajChanFixptDisplay%, 36);
    
    ajChanFixptWindowDisplay% := XYSetChan(0);
    XYColour(ajChanFixptWindowDisplay%, 8);
    XYDrawMode(ajChanFixptWindowDisplay%, 2, 0);
    XYDrawMode(ajChanFixptWindowDisplay%, 3, 0);
    XYJoin(ajChanFixptWindowDisplay%, 2);
    XYSize(ajChanFixptWindowDisplay%, 36);

    ' prepare unit circles for drawing 
	twopi := 2.0*4.0*ATan(1.0);
	for i% := 0 to 35 do
		ajUnitCircleX[i%] := Cos(i% * twopi/36.0);
		ajUnitCircleY[i%] := Sin(i% * twopi/36.0);
	next;

    
end;

proc DisplayStim(iOn%)
    var x, y, d, wr;
    
    docase
    case iOn% = 0 then
        ' erase all
        View(ajWindowXY%).XYDelete(ajChanFixptDisplay%);
        View(ajWindowXY%).XYDelete(ajChanFixptWindowDisplay%);
        View(ajWindowXY%).XYDelete(ajChanStimDisplay0%);
        View(ajWindowXY%).XYDelete(ajChanStimDisplay1%);
    case iOn% = 1 then
        ' fixpt and fixation window
		View(ajWindowXY%).XYAddData(ajChanFixptDisplay%, ajFixationX, ajFixationY);
        MakeCircle(ajFixationWindowRadius, ajFixationX, ajFixationY);
        View(ajWindowXY%).XYAddData(ajChanFixptWindowDisplay%, ajCircleX[], ajCircleY[]);
    case iOn% = 2 then
        if ajShowSingleStim% = 1 then
            ' single stim only
            if ajTrialFixptSampleKey$ = "F" then
                MakeCircle(ajStim0D/2, ajStim0X, ajStim0Y);
                View(ajWindowXY%).XYAddData(ajChanStimDisplay0%, ajCircleX[], ajCircleY[]);
            else
                MakeCircle(ajStim1D/2, ajStim1X, ajStim1Y);
                View(ajWindowXY%).XYAddData(ajChanStimDisplay1%, ajCircleX[], ajCircleY[]);        
            endif
        else
            ' both stim
            MakeCircle(ajStim0D/2, ajStim0X, ajStim0Y);
            View(ajWindowXY%).XYAddData(ajChanStimDisplay0%, ajCircleX[], ajCircleY[]);
            MakeCircle(ajStim1D/2, ajStim1X, ajStim1Y);
            View(ajWindowXY%).XYAddData(ajChanStimDisplay1%, ajCircleX[], ajCircleY[]);        
        endif
    else
        ' do nothing
    endcase
    
    return;
end

' Helper function - makes a circle of radius 'r' centered at (x, y). 
' The results are in ajCircleX[] and ajCircleY[]. 
proc MakeCircle(r, x, y)
    ArrConst(ajCircleX[], ajUnitCircleX[]);
    ArrMul(ajCircleX[], r);
    ArrAdd(ajCircleX[], x);
    ArrConst(ajCircleY[], ajUnitCircleY[]);
    ArrMul(ajCircleY[], r);
    ArrAdd(ajCircleY[], y);
    return;
end


func IdleProcessing%()
	var iStatus% := 1;	
    var iLoop% := 0;        ' States can set this to 1 if we stay in state loop
    var joystickPosition%;
    var joystickVoltage;
    var playPos%;
    
	tNow := MaxTime();
    
    ' Get and display joystick voltage and position
    joystickPosition% := GetJoystickPosition%(joystickVoltage);
    View(ajWindowXY%).XYAddData(ajChanJoystickPos%, joystickVoltage * ajVCoeff + ajVConst, ajJoystickDisplayY);
    
    if tNow > 0.005 then
        xEye := ChanMeasure(ajChanEyeX%, 2, tNow, tNow-.005) * DegreesPerVoltX;
        yEye := ChanMeasure(ajChanEyeY%, 2, tNow-.001, tNow-.006) * DegreesPerVoltY;
        View(ajWindowXY%).XYAddData(1, xEye, yEye);
    endif
    
    
    repeat
        iLoop% := 0;
        docase 
        case iState% = stateStartup% then
            
            LogStatus("stateStartup", "Starting up.");
            ChangeStateTo(stateVSGWait%, tNow);
            iLoop% := 1;
            
        case iState% = stateVSGWait% then
            
            ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.

            tTrigger := NextTime(ajChanVSGReady%, tLast, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 0 then
                LogStatus("stateVSGWait", "Got leading edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateVSGConfirm%, tTrigger);                
                iLoop% := 1;
            endif;
            
        case iState% = stateVSGConfirm% then
            
            ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
            tTrigger := NextTime(ajChanVSGReady%, tLastTrigger, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 1 then                
                LogStatus("stateVSGConfirm", "Got trailing edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateTrialStart%, tTrigger);
                iLoop% := 1;
            endif;
            
        case iState% = stateTrialStart% then
            
            var s%;
            s% := PrepareTrial%();
            if s% = 1 then
                ajCtrNTrials% += 1;
                ChangeStateTo(stateWaitForNeutral%, tNow);
            else
                ChangeStateTo(stateDone%, tNow);
            endif
            iLoop% := 1;
            
        case iState% = stateWaitForNeutral% then
            
            if JoystickPositionCorrect%(joystickPosition%, JSCenter%) = 1 then
                LogStatus("stateWaitForNeutral", "Joystick in neutral. Proceed.");
                ChangeStateTo(stateBeep%, tNow);
                iLoop% := 0;
            endif
            
        case iState% = stateBeep% then
            
            if ajUseBeep% <> 0 then
                Sound("ding", 1);
            endif
            Yield(.5);
            ChangeStateTo(stateWaitForReady%, tNow);
            iLoop% := 1;
            
        case iState% = stateWaitForReady% then
            
            ' Wait for joystick to be positioned in the center. 
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 1 then
                LogStatus("WaitForReady", "Joystick ready.");
                ajCtrNTrialsReady% += 1;
                if ajTrainingType% <> ajReadyTraining% then
                    ' If the joystick-ready-mini-reward is enabled, then we deliver it now
                    SampleKey(ajTrialFixptSampleKey$);                   ' this is determined in PrepareTrial, depends on trial type
                    Yield();
                    if ajDoJoystickReadyMiniReward% = 1 then
                        DeliverRewardDelayed(ajJoystickReadyMiniRewardDelay, ajJoystickReadyMiniRewardSize%);
                    endif
                    ChangeStateTo(stateWaitForFixpt%, tNow);
                else
                    ChangeStateTo(stateT1Success%, tNow);
                    iLoop% := 1;
                endif
            case tNow - tStateStart > ajMaxWaitForReadyTime then
                LogStatus("WaitForReady", "Ready wait time expired.");
                ChangeStateTo(stateReadyFail%, tNow);
            endcase
            iLoop% := 0;
            
        case iState% = stateT1Success% then
            
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajTrainingSuccessPauseTime;
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            ChangeStateTo(stateIntertrialWait%, tNow);
            iLoop% := 0;
            
        case iState% = stateReadyFail% then
            
            ajCtrReadyFail% += 1;
            ajUniversalIntertrialTime := ajReadyFailPauseTime;
            ChangeStateTo(stateIntertrialWait%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForFixpt% then
            
            ' Waiting for fixpt signal on channel ajChanFixpt%
            if FindRisingEdge%(ajChanFixpt%, tStateStart, tTrigger) = 0 then
				LogStatus("stateWaitForFixpt", "Fixpt is up.");
                DisplayStim(1); ' display fixpt and fixation window in xy view
				ChangeStateTo(stateWaitForAcquisition%, tTrigger);
			endif;
            iLoop% := 0;
            
        case iState% = stateWaitForAcquisition% then
            
            ' Waiting for eye to fall in fixation window. Joystick must remain in ready position.
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateWaitForAcquisition", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) = 1 then
                LogStatus("stateWaitForAcquisition", "Eye in fixation window.");
                ajCtrNTrialsAcq% += 1;
                if ajUseCueCircles% then
                    ChangeStateTo(stateHoldFixation1%, tNow);
                else
                    ajHoldFixationMiniRewardEnable% := 1;
                    ChangeStateTo(stateHoldFixation%, tNow);
                endif
            case tNow - tStateStart > ajMaxAcquisitionTime then
                LogStatus("stateWaitForAcquisition", "Acquisition time is up!");
                ajCtrNTrialsAcqFail% += 1;
                ChangeStateTo(stateAcquisitionFail%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateReadyBreak% then
            
            ajCtrReadyBreak% += 1;
            SampleKey("X");
            ajUniversalIntertrialTime := ajReadyBreakPauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateAcquisitionFail% then
            
            ajCtrNTrialsAcqFail% += 1;
            ajUniversalIntertrialTime := ajAcquisitionFailPauseTime;
            SampleKey("X");
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateHoldFixation% then
            
            iLoop% := 0;
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateHoldFixation", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajHoldFixationTime then
                ajCtrNTrialsFix% += 1;
'                if ajDoReadyFixTraining% = 0 then
                if ajTrainingType% <> ajReadyFixTraining% then
                    LogStatus("stateHoldFixation", "Fixation held. Request stim up.");
                    if ajDoShockTrials% = 1 and ajShockTrialEnable% = 1 then
                        SampleKey("P");
                        Yield();
                        LogInfo("PlayWaveStatus = " + PlayWaveStatus$(playPos%) + " pos " + str$(playPos%));
                    endif
                    SampleKey("S");
                    ChangeStateTo(stateWaitForStimOn%, tNow);
                else
                    LogStatus("stateHoldFixation", "Fixation held, trial complete.");
                    ChangeStateTo(stateT2Success%, tNow);
                endif
            case ajDoHoldFixationMiniReward% = 1 and (tNow-tStateStart)/ajHoldFixationTime > ajHoldFixationMiniRewardFraction and ajHoldFixationMiniRewardEnable% = 1 then
                LogStatus("stateHoldFixation", "Mini-reward fraction " + str$((tNow-tStateStart)/ajHoldFixationTime));
                ajHoldFixationMiniRewardEnable% := 0;
                DeliverReward(1);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateT2Success% then
            
            SampleKey("X");
            Yield();
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajTrainingSuccessPauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateHoldFixation1% then
            
            iLoop% := 0;
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateHoldFixation1", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation1", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajHoldFixation1Time then
                LogStatus("stateHoldFixation1", "Fixation held. Request circle up.");
                SampleKey("W");
                ChangeStateTo(stateWaitForCircle%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForCircle% then
            
            iLoop% := 0;
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateWaitForCircle", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForCircle", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanCircle%, tStateStart, tCircleOn) = 0 then
                LogStatus("stateWaitForCircle", "Circle up.");
                ChangeStateTo(stateHoldFixation2%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateHoldFixation2% then
            
            iLoop% := 0;
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateHoldFixation2", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation2", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tCircleOn > ajHoldFixation2Time then
                LogStatus("stateHoldFixation2", "Fixation held. Request circle off.");
                SampleKey("w");
                ChangeStateTo(stateWaitForCircleOff%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForCircleOff% then
            
            iLoop% := 0;
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateWaitForCircleOff", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForCircleOff", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindFallingEdge%(ajChanCircle%, tStateStart, tTrigger) = 1 then
                LogStatus("stateWaitForCircleOff", "Circle off.");
                ChangeStateTo(stateHoldFixation3%, tTrigger);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateHoldFixation3% then
            
            iLoop% := 0;
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateHoldFixation3", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation3", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajHoldFixation3Time then
                ajCtrNTrialsFix% += 1;
'                if ajDoReadyFixTraining% = 0 then
                if ajTrainingType% <> ajReadyFixTraining% then
                    LogStatus("stateHoldFixation3", "Fixation held. Request stim up.");
                    if ajDoShockTrials% = 1 and ajShockTrialEnable% = 1 then
                        SampleKey("P");
                        Yield();
                        LogInfo("PlayWaveStatus = " + PlayWaveStatus$(playPos%) + " pos " + str$(playPos%));
                    endif
                    SampleKey("S");
                    ChangeStateTo(stateWaitForStimOn%, tNow);
                else
                    LogStatus("stateHoldFixation3", "Fixation held, trial complete.");
                    ChangeStateTo(stateT2Success%, tNow);
                endif
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateFixationBreak% then
            
            ajUniversalIntertrialTime := ajFixationBreakPauseTime;
            ajCtrNTrialsFixBreak% += 1;
            SampleKey("X");
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForStimOn% then
            
            iLoop% := 0;
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateWaitForStimOn", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForStimOn", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanStimulus%, tStateStart, tTrigger) = 0 then
                LogStatus("stateWaitForStimOn", "Stim up.");
                ChangeStateTo(stateWaitHazardTime%, tTrigger);  ' wait state starts when stim came on, not tNow
                DisplayStim(2);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitHazardTime% then
            
            iLoop% := 0;
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateWaitHazardTime", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitHazardTime", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajTrialHazardTime then
'                if ajDoReadyFixStimTraining% = 0 then
                if ajTrainingType% <> ajReadyFixStimTraining% then
                    LogStatus("stateWaitHazardTime", "Request stim contrast change.");
                    ajCtrNTrialsChg% += 1;
                    SampleKey(ajTrialChangeSampleKey$);
                    ChangeStateTo(stateWaitForContrastChange%, tNow);
                else
                    LogStatus("stateWaitHazardTime", "Fixation held, trial complete.");
                    ChangeStateTo(stateT3Success%, tNow);
                endif
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateT3Success% then
            
            SampleKey("X");
            Yield();
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajTrainingSuccessPauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForContrastChange% then
            
            iLoop% := 0;
            docase
            case JoystickPositionCorrect%(joystickPosition%, ajReadyResponse%) = 0 then
                LogStatus("stateWaitForContrastChange", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForContrastChange", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanContrastChg%, tStateStart, tTrigger) = 0 then
                LogStatus("stateWaitForContrastChange", "Got contrast change.");
                ChangeStateTo(stateWaitForResponse%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForResponse% then
            
            iLoop% := 0;
            docase
                ' djs 6-9-2010
                ' Farran wanted to impose a short "must continue fixating" period 
                ' during this state. The subject must remain fixated for a short time
                ' (ajExtraFixationTime, not in dialogs)
            case Looking%(xEye, yEye) <> 1 and tNow - tStateStart < ajExtraFixationTime then
                LogStatus("stateWaitForResponse", "Eye not in fixation window for at least " + str$(ajExtraFixationTime) + "s after contrast change.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case JoystickPositionCorrect%(joystickPosition%, JSCenter%) = 1 then
                LogStatus("stateWaitForResponse", "Got response.");
                ChangeStateTo(stateCorrectResponse%, tNow);
            case tNow - tStateStart > ajMaxResponseTime then
                LogStatus("stateWaitForResponse", "Time's up!");
                ChangeStateTo(stateIncorrectResponse%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateCorrectResponse% then
            
            iLoop% := 0;
            ajCtrCorrect% += 1;
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            SampleKey("X");
            Yield();
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajCorrectResponsePauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            
        case iState% = stateIncorrectResponse% then
            
            iLoop% := 0;
            ajCtrIncorrect% += 1;
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            ajUniversalIntertrialTime := ajIncorrectResponsePauseTime;
            SampleKey("X");
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            
        case iState% = stateWaitForFixptOff% then
            
            iLoop% := 0;
            if FindFallingEdge%(ajChanFixpt%, tStateStart, tTrigger) = 1 then
                DisplayStim(0);
                LogStatus("stateWaitForFixptOff", "Fixpt off.");
                ChangeStateTo(stateIntertrialWait%, tNow);
            else
                iLoop% := 0;
            endif
            
        case iState% = stateIntertrialWait% then
            
            ' Any states that exit to here should have set the universal intertrial wait time!
            iLoop% := 0;
            if tNow - tStateStart > ajUniversalIntertrialTime then
                ChangeStateTo(stateTrialCompleted%, tNow);
                iLoop% := 1;
            endif
            
        case iState% = stateTrialCompleted% then
            
            LogStatus("stateTrialCompleted", "Trial completed.");
            ChangeStateTo(stateTrialStart%, tNow);
            iLoop% := 1;
            UpdateToolbarText(0);
            
        case iState% = stateDone% then
            
            LogStatus("stateDone", "Reached done state. Calling Stop%()...\n");
            Stop%();
            iLoop% := 0;
            iStatus% := 0;
            
        else
            
            ' Unknown state!
            Message("Unknown state=" + str$(iState%));
            Stop%();
            halt;
            
        endcase;
    until iLoop% = 0;
    
	tLast := tNow;
	return iStatus%;
end;

' This function makes it possible to test without a joystick. Anywhere the joystick 
' position must be tested call this! Returns 1 if position is correct. 
' First arg pos% is current position, second arg is where it should be for correctness. 
' Set ajJoystickAlwaysCorrect% = 1 to enable always-correctness. 

func JoystickPositionCorrect%(pos%, expectedPos%)
    if ajJoystickAlwaysCorrect% = 1 then
        return 1;
    else
        if pos% = expectedPos% then
            return 1;
        else
            return 0;
        endif
    endif
    return 0;   ' should never get here
end



proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;

proc DeliverReward(iNumRewards%)
    SampleSeqVar(1, iNumRewards%);
    SampleKey("R");
    return;
end

proc DeliverRewardDelayed(tDelay, iNumRewards%)
    SampleSeqVar(1, iNumRewards%);
    SampleSeqVar(2, tDelay*1000);
    SampleKey("T");
    return;
end


func ajChanFixptWindowDisplay()
    DeliverReward(1);
    return 1;
end


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	if ajStimHandle% > 0 then
        ProgKill(ajStimHandle%);
        while ProgStatus(ajStimHandle%) > 0 do
            Yield();
        wend
        ajStimHandle% := 0;
    endif
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    
    ' Dump results to log window
    UpdateToolbarText(1);
    
	' Disable idle process func
	ToolbarSet(0, "");

	' Tell stim app to shut down
	SampleKey("q");
	Yield(.1);
	SampleStop();

	if ajStimHandle% > 0 then
        ProgKill(ajStimHandle%);
        while ProgStatus(ajStimHandle%) > 0 do
            Yield();
        wend
        ajStimHandle% := 0;
    endif
    return 0;

end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    var cmdLine$;
    var h, contrast%, sf, tf, ori, cv$, pattern$, aperture$;
    var stimSpec$;
    var distSpec$;
    var fixSpec$;
    var extra$;
    var status% := 1;   ' return 0 on errors that should halt expt
    
    ' Get stimulus, distractor and fixpt specs
    stimSpec$ := GetGratingParameters$("Stimulus");
    ParseGratingParametersBrief%(stimSpec$, ajStim0X, ajStim0Y, ajStim0D, ajStim0D);
    distSpec$ := GetGratingParameters$("Distractor1");
    ParseGratingParametersBrief%(distSpec$, ajStim1X, ajStim1Y, ajStim1D, ajStim1D);
    fixSpec$ := GetFixationArg$();
    GetFixationPointParameterValues(ajFixationX, ajFixationY, ajFixationD, ajFixationWindowRadius);
    
    ' extra parameters
    extra$ := " -d " + GetDistanceToScreenMM$() + " -b gray -N -Q -t " + str$(ajContrastDown%) + "," + str$(ajContrastBase%) + "," + str$(ajContrastUp%);
    if ajUseCueCircles% = 1 then
        extra$ += " -Q -c 0.5";
    endif
    if ajShowSingleStim% = 1 then
        extra$ += " -S";
    endif
    
    ' Generate command line
    cmdLine$ := "cmd /k " + GetBinDir$(1) + "Attention " + fixSpec$ + extra$ + " -s " + stimSpec$ + " -g " + distSpec$;
    
    ' Start sampling
    if status% = 1 then
        SampleStart(0);
    
        'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
        LogInfo(cmdLine$+"\n");
        ajStimHandle% := ProgRun(cmdLine$, 1);
        if ajStimHandle% < 0 then 
            LogError("Start", "Could not start stimulus."); 
            status% := 0;
        endif
        
        ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
        ToolbarEnable(1,0);
        ToolbarEnable(2,1);
        ToolbarEnable(4,1);
        View(ajWindowData%);
    endif
    
    return status%;
end;

func Pause%()
    LogInfo("Pause requested.");
    ajIsPaused% := 1;
    return 1;
end

func Resume%()
    LogInfo("Resume requested.");
    ajIsPaused% := 0;
    return 1;
end

func Reward%()
    DeliverReward(1);
    return 0;
end


' PrepareBlock
'
' Prepares variables etc used for driving a block of trials for this expt. 
' TODO 

proc PrepareBlock()
    LogInfo("Preparing block...");
' TODO     tbgInit(2, rivNTrialsEachTypePerBlock%, rivNBlocks%);
    return
end

' PrepareTrial
'
' Prepares variables etc used for driving a single trial

' TODO

func PrepareTrial%()
    var index%;
    var s% := 1;
    
    s% := trialgenGetTrialIndex%(ajTrialTypeIndex%);
    LogInfo("Preparing trial... index " + str$(ajTrialTypeIndex%) + " s=" + str$(s%));
    ajIsCatchTrial% := 0;
'    if s% = 1 and ajDoReadyTraining% = 0 and ajDoReadyFixTraining% = 0 then
    if s% = 1 and ajTrainingType% <> ajReadyTraining% and ajTrainingType% <> ajReadyFixTraining% then
            
        ' Generate hazard time
        repeat
            ajTrialHazardTime := RandExp(ajHazardTimeMean, ajHazardTimeMin);
            until ajTrialHazardTime <= ajHazardTimeMax;
        
        ' Will there be a shock on this trial? 
        ajShockTrialEnable% := 0;
        if ajTestShockTrials% = 1 then
            ajShockTrialEnable% := 1;
        endif
        
        ' Catch trial?
        if ajShowSingleStim% = 0 and ajCatchTrialPct > 0 and Rand()*100 < ajCatchTrialPct then
            ajIsCatchTrial% := 1;
            LogInfo("Catch trial!");
        else
            ajIsCatchTrial% := 0;
        endif
        
    endif
        
    if ajIsCatchTrial% = 0 then
        ajTrialFixptSampleKey$ := ajTrialFixptTypeKeys$[ajTrialTypeIndex%];
        ajTrialChangeSampleKey$ := ajTrialChangeTypeKeys$[ajTrialTypeIndex%];
    else
        ajTrialFixptSampleKey$ := ajTrialFixptTypeKeys$[ajTrialTypeIndex%];
        ajTrialChangeSampleKey$ := ajTrialChangeTypeKeys$[1-ajTrialTypeIndex%];
    endif

    return s%;
end


func AttaJoyDialog%()
    var status% := 1;
    GetAttaJoyParameters();
    DlgCreate("AttaJoy Parameters");
	DlgInteger(1, "Number of Blocks:", 1, 1000);
	DlgInteger(2, "# each type/block:", 1, 1000);
    DlgCheck(3, "Shock trials");
    DlgInteger(4, "# shock/block", 1, 1000);
    DlgInteger(5, "Shock delay (ms)", 1, 5000);
    DlgList(6, "Types", "Both|Red|Green", 3);
    DlgList(7, "Training type", ajTrainingTypes$[], 4);
    DlgCheck(8, "Use Beep");
	DlgInteger(9, "Reward size:", 1, 1000);
	DlgReal(10, "Catch Trial pct (0-100)", 0, 100);
	DlgCheck(11, "Show Single Stim");
	DlgCheck(12, "Alternate cue type by block");
	DlgInteger(13, "Base contrast(%)", 0, 100);
	DlgInteger(14, "Chg contrast(%)", 0, 100);
    
    DlgButton(100, "Fix/Hazard", AttaJoyFixHazDialog%);
    DlgButton(101, "Timing", AttaJoyTimingDialog%);
    DlgButton(102, "Electrodes", AttaJoyElectrodeDialog%);
    DlgButton(103, "Testing", AttaJoyTestingDialog%);
    DlgButton(104, "Bonus", AttaJoyBonusDialog%);
    
    DlgAllow(0, 0, AttaJoyDialogChanged%);

    status% := DlgShow(ajNBlocks%, ajNTrialsEachTypePerBlock%, ajTrialTypesListIndex%, 
                       ajDoShockTrials%, ajNShockPerBlock%, ajShockDelayMS%,
                       ajTrainingType%, ajUseBeep%, ajRewardSize%,
                       ajCatchTrialPct, ajShowSingleStim%, ajAlternateCueTypeByBlock%, 
                       ajContrastBase%, ajContrastUp%);
    if status% = 1 then
        SaveAttaJoyParameters();
    endif
    return status%;
end



' Called when items in attention script dialog change. WARNING: The item #s are coded as constants
' If format of dialog changes then those constants should be changed. 

func AttaJoyDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = 0 then
        DlgEnable(ajDoShockTrials%, 4, 5);
    case item% = 3 then
        DlgEnable(DlgValue(3), 4, 5);
    endcase
    return status%;
end


func AttaJoyFixHazDialog%()
	DlgCreate("Fixation/Hazard time");
    DlgCheck(1, "Use Cue Circles");
    DlgReal(2, "HoldFix time #1", 0.0, 100.0);
    DlgReal(3, "HoldFix time #2", 0.0, 100.0);
    DlgReal(4, "HoldFix time #3", 0.0, 100.0);
    DlgReal(5, "HoldFix time", 0.0, 100.0);
    DlgReal(6, "Hazard time (min)", 0.0, 100.0);
    DlgReal(7, "Hazard time (mean)", 0.0, 100.0);
    DlgReal(8, "Hazard time (max)", 0.0, 100.0);
    DlgAllow(0xffff, 0, AttaJoyFixHazDialogChanged%);
    DlgShow(ajUseCueCircles%, ajHoldFixation1Time, ajHoldFixation2Time, ajHoldFixation3Time,
    ajHoldFixationTime, ajHazardTimeMin, ajHazardTimeMean, ajHazardTimeMax);
    return 1;
end

func AttaJoyFixHazDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = 1 then
        DlgEnable(DlgValue(1), 2);
        DlgEnable(DlgValue(1), 3);
        DlgEnable(DlgValue(1), 4);
        DlgEnable(1-DlgValue(1), 5);
    case item% = 0 then
        DlgEnable(ajUseCueCircles%, 2);
        DlgEnable(ajUseCueCircles%, 3);
        DlgEnable(ajUseCueCircles%, 4);
        DlgEnable(1-ajUseCueCircles%, 5);
    endcase
    return status%;
end




func AttaJoyTimingDialog%()
	DlgCreate("AttaJoy timing", 25, 10);
	DlgReal(1, "Max rdy time(s):", .01, 10);
	DlgReal(2, "Rdy FAIL pause time(s):", .01, 10);
	DlgReal(3, "Rdy BREAK pause time(s):", .01, 10);
    DlgReal(4, "Trng Success pause time(s):",  .01, 10);
    DlgReal(5, "Max acq time(s):", .01, 10);
	DlgReal(6, "Acq FAIL pause time(s):", .01, 10);
    DlgReal(7, "Max resp time(s):", .01, 10);
    DlgReal(8, "Correct resp pause time(s):",  .01, 10);
    DlgReal(9, "Incorrect resp pause time(s):",  .01, 10);
    DlgReal(10, "Fix break pause time(s):",  .01, 10);
    DlgReal(11, "Fix time after con chg(s):", 0, 10);
	DlgShow(ajMaxWaitForReadyTime, ajReadyFailPauseTime, ajReadyBreakPauseTime,
    ajTrainingSuccessPauseTime,
    ajMaxAcquisitionTime, ajAcquisitionFailPauseTime, ajMaxResponseTime, 
    ajCorrectResponsePauseTime, ajIncorrectResponsePauseTime, ajFixationBreakPauseTime, ajExtraFixationTime);
    return 1;
end


func AttaJoyElectrodeDialog%()
    WMCNPortDialog%("Wavemark/Cont ports", ajWavemark%[], ajContinuous%[]);
    return 1;
end

func AttaJoyBonusDialog%()
    DlgCreate("Bonus Rewards");
    DlgCheck(1, "Hold Fixation Mini-Reward");
    DlgReal(2, "Hold Fixation Fraction for Reward", 0, 1);
    DlgCheck(3, "Joystick Ready Mini-Reward");
    DlgInteger(4, "Joystick Ready Reward Size", 1, 10);
    DlgReal(5, "Joystick Ready Reward Delay(s)", 0, 1);
    DlgAllow(0xffff, 0,  AttaJoyBonusDialogChanged%);
    DlgShow(ajDoHoldFixationMiniReward%, ajHoldFixationMiniRewardFraction, ajDoJoystickReadyMiniReward%, ajJoystickReadyMiniRewardSize%, ajJoystickReadyMiniRewardDelay);
    return 1;
end

func AttaJoyBonusDialogChanged%(item%)
    docase
    case item% = 0 then
        DlgEnable(ajDoHoldFixationMiniReward%, 2);
        DlgEnable(ajDoJoystickReadyMiniReward%, 4, 5);
    case item% = 1 then
        DlgEnable(DlgValue(1), 2);
    case item% = 3 then
        DlgEnable(DlgValue(3), 4, 5);
    endcase
    return 1;
end


func AttaJoyTestingDialog%()
    DlgCreate("Shock Parameters");
    DlgCheck(1, "Always looking (TESTING ONLY)");
    DlgCheck(2, "Joystick always correct? (TESTING ONLY)");
    DlgCheck(3, "Force all trials shock? (TESTING ONLY)");
    DlgShow(ajAlwaysLooking%, ajJoystickAlwaysCorrect%, ajTestShockTrials%);
    return 1;
end

proc GetAttaJoyParameters()
    var key$;
    var stmp$;
    var i%;
    key$ := GetRegistryKey$(1) + "\\AttaJoy";
    ajNBlocks% := GetIntRegistryValue%(key$, "NBlocks", ajNBlocks%);
    ajNTrialsEachTypePerBlock% := GetIntRegistryValue%(key$, "NTrialsEachTypePerBlock", ajNTrialsEachTypePerBlock%);
    ajTrialTypesListIndex% := GetIntRegistryValue%(key$, "TrialTypesListIndex", ajTrialTypesListIndex%);
    ajTrainingType% := GetIntRegistryValue%(key$, "TrainingType", ajTrainingType%);
    ajRewardSize% := GetIntRegistryValue%(key$, "RewardSize", ajRewardSize%);
    ajCatchTrialPct := GetFloatRegistryValue(key$, "CatchTrialPct", ajCatchTrialPct);
    ajShowSingleStim% := GetIntRegistryValue%(key$, "ShowSingleStim", ajShowSingleStim%);
    ajAlternateCueTypeByBlock% := GetIntRegistryValue%(key$, "AlternateCueTypeByBlock", ajAlternateCueTypeByBlock%);
    ajContrastBase% := GetIntRegistryValue%(key$, "BaseContrast", ajContrastBase%);
    ajContrastUp% := GetIntRegistryValue%(key$, "UpContrast", ajContrastUp%);
    ajUseCueCircles% := GetIntRegistryValue%(key$, "UseCueCircles", ajUseCueCircles%);
    ajHoldFixation1Time := GetFloatRegistryValue(key$, "HoldFixation1Time", ajHoldFixation1Time);
    ajHoldFixation2Time := GetFloatRegistryValue(key$, "HoldFixation2Time", ajHoldFixation2Time);
    ajHoldFixation3Time := GetFloatRegistryValue(key$, "HoldFixation3Time", ajHoldFixation3Time);
    ajHoldFixationTime := GetFloatRegistryValue(key$, "HoldFixationTime", ajHoldFixationTime);
    ajFixationBreakPauseTime := GetFloatRegistryValue(key$, "FixationBreakPauseTime", ajFixationBreakPauseTime);
    ajHazardTimeMin := GetFloatRegistryValue(key$, "HazardTimeMin", ajHazardTimeMin);
    ajHazardTimeMean := GetFloatRegistryValue(key$, "HazardTimeMean", ajHazardTimeMean);
    ajHazardTimeMax := GetFloatRegistryValue(key$, "HazardTimeMax", ajHazardTimeMax);
	ajMaxWaitForReadyTime := GetFloatRegistryValue(key$, "MaxWaitForReadyTime", ajMaxWaitForReadyTime);
    ajReadyFailPauseTime := GetFloatRegistryValue(key$, "ReadyFailPauseTime", ajReadyFailPauseTime);
    ajReadyBreakPauseTime := GetFloatRegistryValue(key$, "ReadyBreakPauseTime", ajReadyBreakPauseTime);
    ajTrainingSuccessPauseTime := GetFloatRegistryValue(key$, "TrainingSuccessPauseTime", ajTrainingSuccessPauseTime);
    ajMaxAcquisitionTime := GetFloatRegistryValue(key$, "MaxAcquisitionTime", ajMaxAcquisitionTime);
    ajAcquisitionFailPauseTime := GetFloatRegistryValue(key$, "AcquisitionFailPauseTime", ajAcquisitionFailPauseTime);
    ajMaxResponseTime := GetFloatRegistryValue(key$, "MaxResponseTime", ajMaxResponseTime);
    ajCorrectResponsePauseTime := GetFloatRegistryValue(key$, "CorrectResponsePauseTime", ajCorrectResponsePauseTime);
    ajIncorrectResponsePauseTime := GetFloatRegistryValue(key$, "IncorrectResponsePauseTime", ajIncorrectResponsePauseTime);
    ajExtraFixationTime := GetFloatRegistryValue(key$, "ExtraFixationTime", ajExtraFixationTime);
    for i% := 0 to ajNPorts%-1 do
        ajWavemark%[i%] := GetIntRegistryValue%(key$, "Wavemark"+str$(i%), ajWavemark%[i%]);
        ajContinuous%[i%] := GetIntRegistryValue%(key$, "Continuous"+str$(i%), ajContinuous%[i%]);
    next
    ajDoHoldFixationMiniReward% := GetIntRegistryValue%(key$, "DoHoldFixationMiniReward", ajDoHoldFixationMiniReward%);
    ajHoldFixationMiniRewardFraction := GetFloatRegistryValue(key$, "HoldFixationMiniRewardFraction", ajHoldFixationMiniRewardFraction);
    ajDoJoystickReadyMiniReward% := GetIntRegistryValue%(key$, "DoJoystickReadyMiniReward", ajDoJoystickReadyMiniReward%);
    ajJoystickReadyMiniRewardSize% := GetIntRegistryValue%(key$, "JoystickReadyMiniRewardSize", ajJoystickReadyMiniRewardSize%);
    ajJoystickReadyMiniRewardDelay := GetFloatRegistryValue(key$, "JoystickReadyMiniRewardDelay", ajJoystickReadyMiniRewardDelay);
end

proc SaveAttaJoyParameters()
    var i%;
    var key$;
    var stmp$;
    key$ := GetRegistryKey$(1) + "\\AttaJoy";
    SetIntRegistryValue(key$, "NBlocks", ajNBlocks%);
    SetIntRegistryValue(key$, "NTrialsEachTypePerBlock", ajNTrialsEachTypePerBlock%);
    SetIntRegistryValue(key$, "TrialTypesListIndex", ajTrialTypesListIndex%);
    SetIntRegistryValue(key$, "TrainingType", ajTrainingType%);
    SetIntRegistryValue(key$, "RewardSize", ajRewardSize%);
    SetFloatRegistryValue(key$, "CatchTrialPct", ajCatchTrialPct);
    SetIntRegistryValue(key$, "ShowSingleStim", ajShowSingleStim%);
    SetIntRegistryValue(key$, "AlternateCueTypeByBlock", ajAlternateCueTypeByBlock%);
    SetIntRegistryValue(key$, "BaseContrast", ajContrastBase%);
    SetIntRegistryValue(key$, "UpContrast", ajContrastUp%);
    SetIntRegistryValue(key$, "UseCueCircles", ajUseCueCircles%);
    SetFloatRegistryValue(key$, "HoldFixation1Time", ajHoldFixation1Time);
    SetFloatRegistryValue(key$, "HoldFixation2Time", ajHoldFixation2Time);
    SetFloatRegistryValue(key$, "HoldFixation3Time", ajHoldFixation3Time);
    SetFloatRegistryValue(key$, "HoldFixationTime", ajHoldFixationTime);
    SetFloatRegistryValue(key$, "FixationBreakPauseTime", ajFixationBreakPauseTime);
    SetFloatRegistryValue(key$, "HazardTimeMin", ajHazardTimeMin);
    SetFloatRegistryValue(key$, "HazardTimeMean", ajHazardTimeMean);
    SetFloatRegistryValue(key$, "HazardTimeMax", ajHazardTimeMax);
	SetFloatRegistryValue(key$, "MaxWaitForReadyTime", ajMaxWaitForReadyTime);
    SetFloatRegistryValue(key$, "ReadyFailPauseTime", ajReadyFailPauseTime);
    SetFloatRegistryValue(key$, "ReadyBreakPauseTime", ajReadyBreakPauseTime);
    SetFloatRegistryValue(key$, "TrainingSuccessPauseTime", ajTrainingSuccessPauseTime);
    SetFloatRegistryValue(key$, "MaxAcquisitionTime", ajMaxAcquisitionTime);
    SetFloatRegistryValue(key$, "AcquisitionFailPauseTime", ajAcquisitionFailPauseTime);
    SetFloatRegistryValue(key$, "MaxResponseTime", ajMaxResponseTime);
    SetFloatRegistryValue(key$, "CorrectResponsePauseTime", ajCorrectResponsePauseTime);
    SetFloatRegistryValue(key$, "IncorrectResponsePauseTime", ajIncorrectResponsePauseTime);
    SetFloatRegistryValue(key$, "ExtraFixationTime", ajExtraFixationTime);
    for i% := 0 to ajNPorts%-1 do
        SetIntRegistryValue(key$, "Wavemark"+str$(i%), ajWavemark%[i%]);
        SetIntRegistryValue(key$, "Continuous"+str$(i%), ajContinuous%[i%]);
    next
    SetIntRegistryValue(key$, "DoHoldFixationMiniReward", ajDoHoldFixationMiniReward%);
    SetFloatRegistryValue(key$, "HoldFixationMiniRewardFraction", ajHoldFixationMiniRewardFraction);
    SetIntRegistryValue(key$, "DoJoystickReadyMiniReward", ajDoJoystickReadyMiniReward%);
    SetIntRegistryValue(key$, "JoystickReadyMiniRewardSize", ajJoystickReadyMiniRewardSize%);
    SetFloatRegistryValue(key$, "JoystickReadyMiniRewardDelay", ajJoystickReadyMiniRewardDelay);
end


func Looking%(x, y)
	'Determine if the eye position is within the fixation window
    var s% := 0;
    docase
    case ajAlwaysLooking% = 1 then
        s% := 1;
    case (Pow(x-FixationX, 2) + Pow(y-FixationY, 2)) <= Pow(WindowRadius, 2) then 
        s% := 1; 
    else 
        s% := 0; 
    endcase
    return s%;
end;

proc UpdateToolbarText(iLogWindowAlso%)

	var s$;
    s$ := Print$("N/Rdy/Acq/Fix/Haz/+(%)/-(%) = %d/%d/%d/%d/%d/%d/%d", ajCtrNTrials%, ajCtrNTrialsReady%, ajCtrNTrialsAcq%, ajCtrNTrialsFix%, ajCtrNTrialsChg%, ajCtrCorrect%, ajCtrIncorrect%);
	ToolbarText(s$);
    
    if iLogWindowAlso% <> 0 then
        PrintLog(s$);
    endif

end;
