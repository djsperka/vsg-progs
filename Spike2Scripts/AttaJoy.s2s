
#include "../../Spike2Util/TrialBlockGen.s2s"
#include "../../Spike2Util/ChannelUtilities.s2s"
#include "Usrey.s2s"
#include "UsreyGratings.s2s"
#include "UsreyFixationPoint.s2s"
#include "Joystick.s2s"

' Local config variables

var ajNBlocks% := 1;
var ajNTrialsEachTypePerBlock% := 10;
var ajDoReadyTraining% := 0;
var ajDoReadyFixTraining% := 0;
var ajDoReadyFixStimTraining% := 0;
var ajCatchTrialPct := 0;
var ajAlternateCueTypeByBlock% := 0;
var ajMaxWaitForReadyTime := 1.0;
var ajReadyFailPauseTime := 1.0;
var ajReadyBreakPauseTime := 1.0;
var ajMaxAcquisitionTime := 1.0;
var ajUseCueCircles% := 1;
var ajHoldFixationTime := 1.0;
var ajHoldFixation1Time := 1.0;
var ajHoldFixation2Time := 1.0;
var ajHoldFixation3Time := 1.0;
var ajFixationBreakPauseTime := 1.0;
var ajAcquisitionFailPauseTime := 1.0;
var ajTrainingSuccessPauseTime := 1.0;
var ajHazardTimeMin := 1.0;
var ajHazardTimeMean := 1.5;
var ajHazardTimeMax := 2.0;
var ajMaxResponseTime := 2.0;
var ajCorrectResponsePauseTime := 1.0;
var ajIncorrectResponsePauseTime := 1.0;
var ajRewardSize% := 1;
var ajUseBeep% := 1;
var ajContrastBase% := 75;
var ajContrastUp% := 100;
var ajContrastDown% := 50;
var ajAlwaysLooking% := 0;      ' Set to 1 in timing dialog. Will cause Looking% to always return 1. 
var ajTrialTypesListIndex% := 0;
var ajShowSingleStim% := 0;

' Counters

var ajCtrNTrials% := 0;
var ajCtrReadyFail% := 0;
var ajCtrReadyBreak% := 0;
var ajCtrIncorrect% := 0;
var ajCtrCorrect% := 0;
var ajCtrNRewards% := 0;
var ajCtrNTrialsReady% := 0;
var ajCtrNTrialsAcq% := 0;
var ajCtrNTrialsAcqFail% := 0;
var ajCtrNTrialsFix% := 0;
var ajCtrNTrialsFixBreak% := 0;
var ajCtrNTrialsStim% := 0;
var ajCtrNTrialsChg% := 0;

' Channel numbers for DAQ inputs

var ajChanEyeX%    := 11;
var ajChanEyeY%    := 12;
var ajChanJoy%     := 13;

' VSG trigger input channels

var ajChanVSGReady%    :=  20;
var ajChanFixpt%       :=  21;
var ajChanCircle%      :=  22;
var ajChanStimulus%    :=  23;
var ajChanContrastChg% :=  24;

' windows

var ajWindowData%;
var ajWindowXY%;

' display channels

var ajChanMonitor%;
var ajChanJoystickPos%;
var ajChanJoystickRangeL%;
var ajChanJoystickRangeC%;
var ajChanJoystickRangeR%;
var ajChanStimDisplay%;
var ajVCoeff;
var ajVConst;
var ajJoystickDisplayY;
var ajUnitCircleX[36];
var ajUnitCircleY[36];
var ajStimCircleX[36];
var ajStimCircleY[36];

' Controls

var ajIsPaused% := 0;
var ajStimHandle% := 0;
var ajTrialTypesList$[3];
var ajNTrialTypes%;
var ajTrialTypeIndex%;
var ajTrialFixptTypeKeys$[2];
var ajTrialChangeTypeKeys$[2];
var ajTrialFixptSampleKey$;
var ajTrialChangeSampleKey$;
var ajIsCatchTrial% := 0;
var ajTrialHazardTime := 1.0;
var ajReadyResponse% := JSRight%;
var ajCorrectResponse%;
var ajIncorrectResponse%;
var ajUniversalIntertrialTime;     ' time to wait between trials

' States - these constants define a particular state

const stateStartup%             :=  1;
const statePaused%              :=  2;
const stateTrialStart%          :=  3;
const stateBeep%                :=  4;
const stateWaitForReady%        :=  5;
const stateReadyFail%           :=  6;
const stateIntertrialWait%      :=  7;
const stateTrialCompleted%      :=  8;
const stateWaitForFixpt%        :=  9;
const stateReadyBreak%          :=  10;
const stateWaitForFixptOff%     :=  11;
const stateWaitForAcquisition%  :=  12;
const stateAcquisitionFail%     :=  13;
const stateHoldFixation%        :=  14;
const stateHoldFixation1%       :=  15;
const stateHoldFixation2%       :=  16;
const stateHoldFixation3%       :=  17;
const stateFixationBreak%       :=  18;
const stateWaitForCircle%       :=  19;
const stateWaitForCircleOff%    :=  20;
const stateWaitForStimOn%       :=  21;
const stateWaitHazardTime%      :=  22;
const stateWaitForContrastChange% :=  23;
const stateWaitForResponse%     :=  24;
const stateCorrectResponse%     :=  25;
const stateIncorrectResponse%   :=  26;
const stateQuit%                :=  27;
const stateDone%                :=  28;
const stateVSGWait%             :=  29;
const stateVSGConfirm%          :=  30;
const stateT1Success%           :=  31;
const stateT2Success%           :=  32;
const stateWaitForNeutral%      :=  33;
const stateT3Success%           :=  34;

var iState% := stateStartup%;              ' This holds the current state

var tNow:=0;		    ' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		    ' last time we checked for a trigger. 
var xEye, yEye;		    ' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		    ' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	    ' temp var for newly discovered trigger times
var doCorrectionTrial% := 0;    ' this is set to 1 when a trial fails and correction trials were requested
var isCorrectionTrial% := 0;    ' this is set to 1 when we are in a trial that is a correction trial
var tCircleOn := -1;

'===========================================================================================
'
' Script execution starts here. 
'
'===========================================================================================

LogInit(1);
InitJoystick(13);
ajTrialTypesList$[0] := "Both";
ajTrialTypesList$[1] := "Red";
ajTrialTypesList$[2] := "Green";

if AttaJoyDialog%() = 0 then
    halt;
endif


' Check a few values for reasonable-ness....
if ajHazardTimeMax < ajHazardTimeMean or ajHazardTimeMean < ajHazardTimeMin then
    Message("Must have hazard time max > mean > min!");
    halt;
endif

if ajDoReadyTraining% = 0 and ajTrialTypesListIndex% = 0 then
    ajNTrialTypes% := 2;
    ajTrialFixptTypeKeys$[0] := "F";
    ajTrialFixptTypeKeys$[1] := "G";
    ajTrialChangeTypeKeys$[0] := "C";
    ajTrialChangeTypeKeys$[1] := "D";
else
    ajNTrialTypes% := 1;
    docase
    case ajDoReadyTraining% = 1 then
        ajTrialFixptTypeKeys$[0] := "Z";
        ajTrialFixptTypeKeys$[1] := "Z";
        ajTrialChangeTypeKeys$[0] := "Z";
        ajTrialChangeTypeKeys$[1] := "Z";        
    case ajTrialTypesListIndex% = 1 then
        ajTrialFixptTypeKeys$[0] := "F";
        ajTrialFixptTypeKeys$[1] := "Z";
        ajTrialChangeTypeKeys$[0] := "C";
        ajTrialChangeTypeKeys$[1] := "Z";
    case ajTrialTypesListIndex% = 2 then
        ajTrialFixptTypeKeys$[0] := "G";
        ajTrialFixptTypeKeys$[1] := "Z";
        ajTrialChangeTypeKeys$[0] := "D";
        ajTrialChangeTypeKeys$[1] := "Z";
    endcase
endif        

' Init trial generator
tbgInit(ajNTrialTypes%, ajNTrialsEachTypePerBlock%, ajNBlocks%);

' Get fixation point parameters
GetFixationPointParameters();


' Sampling config
CreateSampleConfiguration();

' Prepare display windows, input channels, etc. 
InitializeWindows();

' Set up toolbar and launch
InitializeToolbar();




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration - Set up recording channels, dig input channels for VSG communication
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc CreateSampleConfiguration()
	var index;
    
	SampleClear(); 'Set standard sampling state
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 3);
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 1);
    SampleAutoName$(dataCellName$ + "_aj_000");
	SampleAutoFile(1);
    
	'Channel recording definitions
	SampleEvent(ajChanVSGReady%, 6, 2, 3600); 'Trigger channel, level
	SampleComment$(ajChanVSGReady%, "VSG Ready");
	SampleTitle$(ajChanVSGReady%, "VSG Ready");
    
	SampleEvent(ajChanFixpt%, 1, 2, 3600);
	SampleComment$(ajChanFixpt%, "Fixpt");
	SampleTitle$(ajChanFixpt%, "Fixpt");
    
	SampleEvent(ajChanCircle%, 3, 2, 3600);
	SampleComment$(ajChanCircle%, "Cue");
	SampleTitle$(ajChanCircle%, "Cue");
    
	SampleEvent(ajChanStimulus%, 2, 2, 3600);
	SampleComment$(ajChanStimulus%, "Stim");
	SampleTitle$(ajChanStimulus%, "Stim");    
    
	SampleEvent(ajChanContrastChg%, 4, 2, 3600);
	SampleComment$(ajChanContrastChg%, "Chg");
	SampleTitle$(ajChanContrastChg%, "Chg");
	
	SampleWaveform(ajChanJoy%, 13, 1000);
	SampleTitle$(ajChanJoy%, "Joy");
    
	SampleWaveform(ajChanEyeX%, 14, 1000);
	SampleTitle$(ajChanEyeX%, "Eye X");
	SampleWaveform(ajChanEyeY%, 15, 1000);
	SampleTitle$(ajChanEyeY%, "Eye Y");

    
	SampleSequencer(script$ + "AttaJoy.pls");
	SampleOptimise(2, 2, 2, 2, 50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling

end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
'	UpdateToolbarText();
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",Pause%);
	ToolbarSet(5,"Resume stimuli",Resume%);
	ToolbarSet(6,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeWindows - Open data file, set up windows for online display.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc InitializeWindows()
    var i%;
	var twopi;
    
    ' These set the max and min window dimensions. They are also used to scale the joystick 
    ' position to the xy display, so if you change the size of the window, do it by changing
    ' these vars!
    var xyXMin := -20;
    var xyXMax := 20;
    var xyYMin := -15;
    var xyYMax := 15;
    var lh, cl, ch, rl;
    ajJoystickDisplayY := -12;     ' y coord in xy window where joystick position is shown. 
    
	'Open the data sampling window
	ajWindowData% := FileNew(0,4);
	Window(0,48,100,95);
	View(ajWindowData%).WindowVisible(1);

	'Open an XY view to display eye position
	ajWindowXY% := FileNew(12);
	XRange(xyXMin, xyXMax);
	YRange(-2, xyYMin, xyYMax);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
	'Create a new channel in the XY view to show the monitor's location
	ajChanMonitor% := XYSetChan(0);
	XYColour(ajChanMonitor%, 13);
	XYDrawMode(ajChanMonitor%, 3, 1);
	XYJoin(ajChanMonitor%, 2);
	XYAddData(ajChanMonitor%, -9, -7);
	XYAddData(ajChanMonitor%, 9, -7);
	XYAddData(ajChanMonitor%, 9, 7);
	XYAddData(ajChanMonitor%, -9, 7);
    
    ' Set up joystick range numbers
    lh := GetJoystickLeftHigh();
    cl := GetJoystickCenterLow();
    ch := GetJoystickCenterHigh();
    rl := GetJoystickRightLow();
    
    ' We'll take the joystick voltage 'v' (which should be between 1 and 4volts) and 
    ' convert it for display in the xy window like this:
    ' x coord = v * rivVCoeff + rivVConst;
    
    ajVCoeff := (xyXMax - xyXMin)/3;
    ajVConst := -2.5 * ajVCoeff;
    
    ajChanJoystickRangeL% := XYSetChan(0);
    XYColour(ajChanJoystickRangeL%, 13);
    XYSize(ajChanJoystickRangeL%, 2);
    XYJoin(ajChanJoystickRangeL%, 1);
    XYDrawMode(ajChanJoystickRangeL%, 4, 3);
    XYAddData(ajChanJoystickRangeL%, xyXMin, ajJoystickDisplayY+1);
    XYAddData(ajChanJoystickRangeL%, lh * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    
    ajChanJoystickRangeC% := XYSetChan(0);
    XYColour(ajChanJoystickRangeC%, 13);
    XYSize(ajChanJoystickRangeC%, 2);
    XYJoin(ajChanJoystickRangeC%, 1);
    XYDrawMode(ajChanJoystickRangeC%, 4, 3);
    XYAddData(ajChanJoystickRangeC%, cl * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    XYAddData(ajChanJoystickRangeC%, ch * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    
    ajChanJoystickRangeR% := XYSetChan(0);
    XYColour(ajChanJoystickRangeR%, 13);
    XYSize(ajChanJoystickRangeR%, 2);
    XYJoin(ajChanJoystickRangeR%, 1);
    XYDrawMode(ajChanJoystickRangeR%, 4, 3);
    XYAddData(ajChanJoystickRangeR%, rl * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    XYAddData(ajChanJoystickRangeR%, xyXMax, ajJoystickDisplayY+1);
    
    
    ' this channel is for a symbol representing the actual joystick position
    ajChanJoystickPos% := XYSetChan(0);
    XYColour(ajChanJoystickPos%, 11);
    XYDrawMode(ajChanJoystickPos%, 1, 8);
    XYDrawMode(ajChanJoystickPos%, 2, 10);
    XYSize(ajChanJoystickPos%, -1);
    
    ' this channel is for displaying the stimulus
    ajChanStimDisplay% := XYSetChan(0);
    XYColour(ajChanStimDisplay%, 8);
    XYDrawMode(ajChanStimDisplay%, 2, 0);
    XYDrawMode(ajChanStimDisplay%, 3, 0);
    XYJoin(ajChanStimDisplay%, 2);
    XYSize(ajChanStimDisplay%, 36);
    
	twopi := 2.0*4.0*ATan(1.0);
	for i% := 0 to 35 do
		ajUnitCircleX[i%] := Cos(i% * twopi/36.0);
		ajUnitCircleY[i%] := Sin(i% * twopi/36.0);
	next;

    
end;

proc DisplayStim(iOn%)
    ' TODO
    
    return;
end

func IdleProcessing%()
	var iStatus% := 1;	
    var iLoop% := 0;        ' States can set this to 1 if we stay in state loop
    var joystickPosition%;
    var joystickVoltage;
    
	tNow := MaxTime();
    
    ' Get and display joystick voltage and position
    joystickPosition% := GetJoystickPosition%(joystickVoltage);
    View(ajWindowXY%).XYAddData(ajChanJoystickPos%, joystickVoltage * ajVCoeff + ajVConst, ajJoystickDisplayY);
    
    if tNow > 0.005 then
        xEye := ChanMeasure(ajChanEyeX%, 2, tNow, tNow-.005) * DegreesPerVoltX;
        yEye := ChanMeasure(ajChanEyeY%, 2, tNow-.001, tNow-.006) * DegreesPerVoltY;
        View(ajWindowXY%).XYAddData(1, xEye, yEye);
    endif
    
    
    repeat
        iLoop% := 0;
        docase 
        case iState% = stateStartup% then
            
            LogStatus("stateStartup", "Starting up.");
            ChangeStateTo(stateVSGWait%, tNow);
            iLoop% := 1;
            
        case iState% = stateVSGWait% then
            
            ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.

            tTrigger := NextTime(ajChanVSGReady%, tLast, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 0 then
                LogStatus("stateVSGWait", "Got leading edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateVSGConfirm%, tTrigger);                
                iLoop% := 1;
            endif;
            
        case iState% = stateVSGConfirm% then
            
            ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
            tTrigger := NextTime(ajChanVSGReady%, tLastTrigger, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 1 then                
                LogStatus("stateVSGConfirm", "Got trailing edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateTrialStart%, tTrigger);
                iLoop% := 1;
            endif;
            
        case iState% = stateTrialStart% then
            
            var s%;
            s% := PrepareTrial%();
            if s% = 1 then
                ajCtrNTrials% += 1;
                ChangeStateTo(stateWaitForNeutral%, tNow);
            else
                ChangeStateTo(stateDone%, tNow);
            endif
            iLoop% := 1;
            
        case iState% = stateWaitForNeutral% then
            
            if joystickPosition% = JSCenter% then
                LogStatus("stateWaitForNeutral", "Joystick in neutral. Proceed.");
                ChangeStateTo(stateBeep%, tNow);
                iLoop% := 0;
            endif
            
        case iState% = stateBeep% then
            
            if ajUseBeep% <> 0 then
                Sound("ding", 1);
            endif
            Yield(.5);
            ChangeStateTo(stateWaitForReady%, tNow);
            iLoop% := 1;
            
        case iState% = stateWaitForReady% then
            
            ' Wait for joystick to be positioned in the center. 
            docase
            case joystickPosition% = ajReadyResponse% then
                LogStatus("WaitForReady", "Joystick ready.");
                ajCtrNTrialsReady% += 1;
                if ajDoReadyTraining% = 0 then
                    SampleKey(ajTrialFixptSampleKey$);                   ' this is determined in PrepareTrial, depends on trial type
                    ChangeStateTo(stateWaitForFixpt%, tNow);
                else
                    ChangeStateTo(stateT1Success%, tNow);
                    iLoop% := 1;
                endif
            case tNow - tStateStart > ajMaxWaitForReadyTime then
                LogStatus("WaitForReady", "Ready wait time expired.");
                ChangeStateTo(stateReadyFail%, tNow);
            endcase
            iLoop% := 0;
            
        case iState% = stateT1Success% then
            
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajTrainingSuccessPauseTime;
            tbgTrialIndexCompleted(ajTrialTypeIndex%);
            ChangeStateTo(stateIntertrialWait%, tNow);
            iLoop% := 0;
            
        case iState% = stateReadyFail% then
            
            ajCtrReadyFail% += 1;
            ajUniversalIntertrialTime := ajReadyFailPauseTime;
            ChangeStateTo(stateIntertrialWait%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForFixpt% then
            
            ' Waiting for fixpt signal on channel ajChanFixpt%
            if FindRisingEdge%(ajChanFixpt%, tStateStart, tTrigger) = 0 then
				LogStatus("stateWaitForFixpt", "Fixpt is up.");
                DisplayStim(1); ' display fixpt and fixation window in xy view
				ChangeStateTo(stateWaitForAcquisition%, tTrigger);
			endif;
            iLoop% := 0;
            
        case iState% = stateWaitForAcquisition% then
            
            ' Waiting for eye to fall in fixation window. Joystick must remain in ready position.
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitForAcquisition", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) = 1 then
                LogStatus("stateWaitForAcquisition", "Eye in fixation window.");
                ajCtrNTrialsAcq% += 1;
                if ajUseCueCircles% then
                    ChangeStateTo(stateHoldFixation1%, tNow);
                else
                    ChangeStateTo(stateHoldFixation%, tNow);
                endif
            case tNow - tStateStart > ajMaxAcquisitionTime then
                LogStatus("stateWaitForAcquisition", "Acquisition time is up!");
                ajCtrNTrialsAcqFail% += 1;
                ChangeStateTo(stateAcquisitionFail%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateReadyBreak% then
            
            ajCtrReadyBreak% += 1;
            SampleKey("X");
            ajUniversalIntertrialTime := ajReadyBreakPauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateAcquisitionFail% then
            
            ajCtrNTrialsAcqFail% += 1;
            ajUniversalIntertrialTime := ajAcquisitionFailPauseTime;
            SampleKey("X");
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateHoldFixation% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateHoldFixation", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajHoldFixationTime then
                ajCtrNTrialsFix% += 1;
                if ajDoReadyFixTraining% = 0 then
                    LogStatus("stateHoldFixation", "Fixation held. Request stim up.");
                    SampleKey("S");
                    ChangeStateTo(stateWaitForStimOn%, tNow);
                else
                    LogStatus("stateHoldFixation", "Fixation held, trial complete.");
                    ChangeStateTo(stateT2Success%, tNow);
                endif
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateT2Success% then
            
            SampleKey("X");
            Yield();
            tbgTrialIndexCompleted(ajTrialTypeIndex%);
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajTrainingSuccessPauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateHoldFixation1% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateHoldFixation1", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation1", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajHoldFixation1Time then
                LogStatus("stateHoldFixation1", "Fixation held. Request circle up.");
                SampleKey("W");
                ChangeStateTo(stateWaitForCircle%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForCircle% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitForCircle", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForCircle", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanCircle%, tStateStart, tCircleOn) = 0 then
                LogStatus("stateWaitForCircle", "Circle up.");
                ChangeStateTo(stateHoldFixation2%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateHoldFixation2% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateHoldFixation2", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation2", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tCircleOn > ajHoldFixation2Time then
                LogStatus("stateHoldFixation2", "Fixation held. Request circle off.");
                SampleKey("w");
                ChangeStateTo(stateWaitForCircleOff%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForCircleOff% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitForCircleOff", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForCircleOff", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindFallingEdge%(ajChanCircle%, tStateStart, tTrigger) = 1 then
                LogStatus("stateWaitForCircleOff", "Circle off.");
                ChangeStateTo(stateHoldFixation3%, tTrigger);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateHoldFixation3% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateHoldFixation3", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation3", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajHoldFixation3Time then
                LogStatus("stateHoldFixation3", "Fixation held. Request stim up.");
                ajCtrNTrialsFix% += 1;
                if ajDoReadyFixTraining% = 0 then
                    LogStatus("stateHoldFixation3", "Fixation held. Request stim up.");
                    SampleKey("S");
                    ChangeStateTo(stateWaitForStimOn%, tNow);
                else
                    LogStatus("stateHoldFixation3", "Fixation held, trial complete.");
                    ChangeStateTo(stateT2Success%, tNow);
                endif
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateFixationBreak% then
            
            ajUniversalIntertrialTime := ajFixationBreakPauseTime;
            ajCtrNTrialsFixBreak% += 1;
            SampleKey("X");
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForStimOn% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitForStimOn", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForStimOn", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanStimulus%, tStateStart, tTrigger) = 0 then
                LogStatus("stateWaitForStimOn", "Stim up.");
                ChangeStateTo(stateWaitHazardTime%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitHazardTime% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitHazardTime", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitHazardTime", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajTrialHazardTime then
                if ajDoReadyFixStimTraining% = 0 then
                    LogStatus("stateWaitHazardTime", "Request stim contrast change.");
                    ajCtrNTrialsChg% += 1;
                    SampleKey(ajTrialChangeSampleKey$);
                    ChangeStateTo(stateWaitForContrastChange%, tNow);
                else
                    LogStatus("stateWaitHazardTime", "Fixation held, trial complete.");
                    ChangeStateTo(stateT3Success%, tNow);
                endif
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateT3Success% then
            
            SampleKey("X");
            Yield();
            tbgTrialIndexCompleted(ajTrialTypeIndex%);
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajTrainingSuccessPauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForContrastChange% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitForContrastChange", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForContrastChange", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanContrastChg%, tStateStart, tTrigger) = 0 then
                LogStatus("stateWaitForContrastChange", "Got contrast change.");
                ChangeStateTo(stateWaitForResponse%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForResponse% then
            
            iLoop% := 0;
            docase
                
                ' TODO Check with Marty!
                ' We allow fixation break once contrast change has occurred. 
                ' Note that tbgTrialCompleted is called above - not after response. 
'            case Looking%(xEye, yEye) <> 1 then
'                LogStatus("stateWaitForResponse", "Eye not in fixation window.");
'                ChangeStateTo(stateFixationBreak%, tNow);
            case joystickPosition% = JSLeft% then
                LogStatus("stateWaitForResponse", "Got response.");
                ChangeStateTo(stateCorrectResponse%, tNow);
            case tNow - tStateStart > ajMaxResponseTime then
                LogStatus("stateWaitForResponse", "Time's up!");
                ChangeStateTo(stateIncorrectResponse%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateCorrectResponse% then
            
            iLoop% := 0;
            ajCtrCorrect% += 1;
            tbgTrialIndexCompleted(ajTrialTypeIndex%);
            SampleKey("X");
            Yield();
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajCorrectResponsePauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            
        case iState% = stateIncorrectResponse% then
            
            iLoop% := 0;
            ajCtrIncorrect% += 1;
            tbgTrialIndexCompleted(ajTrialTypeIndex%);
            ajUniversalIntertrialTime := ajIncorrectResponsePauseTime;
            SampleKey("X");
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            
        case iState% = stateWaitForFixptOff% then
            
            iLoop% := 0;
            if FindFallingEdge%(ajChanFixpt%, tStateStart, tTrigger) = 1 then
                LogStatus("stateWaitForFixptOff", "Fixpt off.");
                ChangeStateTo(stateIntertrialWait%, tNow);
            else
                iLoop% := 0;
            endif
            
        case iState% = stateIntertrialWait% then
            
            ' Any states that exit to here should have set the universal intertrial wait time!
            iLoop% := 0;
            if tNow - tStateStart > ajUniversalIntertrialTime then
                ChangeStateTo(stateTrialCompleted%, tNow);
                iLoop% := 1;
            endif
            
        case iState% = stateTrialCompleted% then
            
            LogStatus("stateTrialCompleted", "Trial completed.");
            ChangeStateTo(stateTrialStart%, tNow);
            iLoop% := 1;
            UpdateToolbarText(0);
            
        case iState% = stateDone% then
            
            LogStatus("stateDone", "Reached done state. Calling Stop%()...\n");
            Stop%();
            iLoop% := 0;
            iStatus% := 0;
            
        else
            
            ' Unknown state!
            Message("Unknown state=" + str$(iState%));
            Stop%();
            halt;
            
        endcase;
    until iLoop% = 0;
    
	tLast := tNow;
	return iStatus%;
end;


proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;

proc DeliverReward(iNumRewards%)
    SampleSeqVar(1, iNumRewards%);
    SampleKey("R");
    return;
end

func Reward%()
    DeliverReward(1);
    return 1;
end


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	if ajStimHandle% > 0 then
        ProgKill(ajStimHandle%);
        while ProgStatus(ajStimHandle%) > 0 do
            Yield();
        wend
        ajStimHandle% := 0;
    endif
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    
    ' Dump results to log window
    UpdateToolbarText(1);
    
	' Disable idle process func
	ToolbarSet(0, "");

	' Tell stim app to shut down
	SampleKey("q");
	Yield(.1);
	SampleStop();

	if ajStimHandle% > 0 then
        ProgKill(ajStimHandle%);
        while ProgStatus(ajStimHandle%) > 0 do
            Yield();
        wend
        ajStimHandle% := 0;
    endif
    return 0;

end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    var cmdLine$;
    var h, contrast%, sf, tf, ori, cv$, pattern$, aperture$;
    var stimSpec$;
    var distSpec$;
    var fixSpec$;
    var extra$;
    
    ' Get stimulus, distractor and fixpt specs
    stimSpec$ := GetGratingParameters$("Stimulus");
    distSpec$ := GetGratingParameters$("Distractor1");
    fixSpec$ := GetFixationArg$();
    
    ' extra parameters
    extra$ := " -d " + GetDistanceToScreenMM$() + " -b gray -N -Q -t " + str$(ajContrastDown%) + "," + str$(ajContrastBase%) + "," + str$(ajContrastUp%);
    if ajUseCueCircles% = 1 then
        extra$ += " -Q -c 0.5";
    endif
    if ajShowSingleStim% = 1 then
        extra$ += " -S";
    endif
    
    ' Generate command line
    cmdLine$ := "cmd /k " + GetBinDir$(1) + "Attention " + fixSpec$ + extra$ + " -s " + stimSpec$ + " -g " + distSpec$;

    ' Start sampling
   	SampleStart(0);
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	LogInfo(cmdLine$+"\n");
	ajStimHandle% := ProgRun(cmdLine$, 1);
	if ajStimHandle% < 0 then 
        Message("Could not start stimulus."); 
        halt; 
    endif
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(1,0);
	ToolbarEnable(2,1);
	ToolbarEnable(4,1);
	View(ajWindowData%);
    return 1;
end;

func Pause%()
    LogInfo("Pause requested.");
    ajIsPaused% := 1;
    return 1;
end

func Resume%()
    LogInfo("Resume requested.");
    ajIsPaused% := 0;
    return 1;
end


' PrepareBlock
'
' Prepares variables etc used for driving a block of trials for this expt. 
' TODO 

proc PrepareBlock()
    LogInfo("Preparing block...");
' TODO     tbgInit(2, rivNTrialsEachTypePerBlock%, rivNBlocks%);
    return
end

' PrepareTrial
'
' Prepares variables etc used for driving a single trial

' TODO

func PrepareTrial%()
    var index%;
    var s% := 1;
    
    s% := tbgGetTrialIndex%(ajTrialTypeIndex%);
    LogInfo("Preparing trial... index " + str$(ajTrialTypeIndex%) + " s=" + str$(s%));
    ajIsCatchTrial% := 0;
    if s% = 1 and ajDoReadyTraining% = 0 and ajDoReadyFixTraining% = 0 then
            
        ' Generate hazard time
        repeat
            ajTrialHazardTime := RandExp(ajHazardTimeMean, ajHazardTimeMin);
            until ajTrialHazardTime <= ajHazardTimeMax;
        
        
        ' Catch trial?
        if ajShowSingleStim% = 0 and ajCatchTrialPct > 0 and Rand()*100 < ajCatchTrialPct then
            ajIsCatchTrial% := 1;
            LogInfo("Catch trial!");
        else
            ajIsCatchTrial% := 0;
        endif
        
    endif
        
    if ajIsCatchTrial% = 0 then
        ajTrialFixptSampleKey$ := ajTrialFixptTypeKeys$[ajTrialTypeIndex%];
        ajTrialChangeSampleKey$ := ajTrialChangeTypeKeys$[ajTrialTypeIndex%];
    else
        ajTrialFixptSampleKey$ := ajTrialFixptTypeKeys$[ajTrialTypeIndex%];
        ajTrialChangeSampleKey$ := ajTrialChangeTypeKeys$[1-ajTrialTypeIndex%];
    endif

    return s%;
end


func AttaJoyDialog%()
    var status% := 1;
    GetAttaJoyParameters();
    DlgCreate("AttaJoy Parameters");
    DlgGroup("Blocks/contrast/training", 1, 1, 40, 13);
	DlgInteger(1, "Number of Blocks:", 1, 1000, 20, 2);
	DlgInteger(2, "# each type/block:", 1, 1000, 20, 3);
    DlgList(3, "Types", "Both|Red|Green", 3, 20, 4);
    DlgCheck(4, "Ready training", 2, 5);
    DlgCheck(5, "Rdy/fix training", 2, 6);
    DlgCheck(6, "Rdy/fix/stim training", 2, 7);
	DlgInteger(7, "Reward size:", 1, 1000, 20, 8);
	DlgReal(8, "Catch Trial pct (0-100)", 0, 100, 20, 9);
	DlgCheck(9, "Show Single Stim", 2, 10);
	DlgCheck(10, "Alternate cue type by block", 2, 11);
	DlgInteger(11, "Base contrast(%)", 0, 100, 20, 12);
	DlgInteger(12, "Chg contrast(%)", 0, 100, 20, 13);
    
    DlgGroup("Fixation/Hazard", 1, 14, 40, 9);
    DlgCheck(13, "Use Cue Circles", 2, 15);
    DlgReal(14, "HoldFix time #1", 0.0, 100.0, 20, 16);
    DlgReal(15, "HoldFix time #2", 0.0, 100.0, 20, 17);
    DlgReal(16, "HoldFix time #3", 0.0, 100.0, 20, 18);
    DlgReal(17, "HoldFix time", 0.0, 100.0, 20, 19);
    DlgReal(18, "Hazard time (min)", 0.0, 100.0, 20, 20);
    DlgReal(19, "Hazard time (mean)", 0.0, 100.0, 20, 21);
    DlgReal(20, "Hazard time (max)", 0.0, 100.0, 20, 22);
    DlgButton(101, "Timing", AttaJoyTimingDialog%, 1, 23);
    
    DlgAllow(0, 0, AttaJoyDialogChanged%);

    status% := DlgShow(ajNBlocks%, ajNTrialsEachTypePerBlock%, ajTrialTypesListIndex%, 
                       ajDoReadyTraining%, ajDoReadyFixTraining%,
                       ajDoReadyFixStimTraining%, ajRewardSize%,
                       ajCatchTrialPct, ajShowSingleStim%, ajAlternateCueTypeByBlock%, 
                       ajContrastBase%, ajContrastUp%,
                       ajUseCueCircles%, ajHoldFixation1Time, ajHoldFixation2Time, ajHoldFixation3Time,
                       ajHoldFixationTime, ajHazardTimeMin, ajHazardTimeMean, ajHazardTimeMax);
    
    if status% = 1 then
        SaveAttaJoyParameters();
    endif
    return status%;
end



' Called when items in attention script dialog change. WARNING: The item #s are coded as constants
' If format of dialog changes then those constants should be changed. 

func AttaJoyDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = 4 then
        if DlgValue(4) = 1 then
            DlgValue(5, 0);
            DlgValue(6, 0);
        endif
    case item% = 5 then
        if DlgValue(5) = 1 then
            DlgValue(4, 0);
            DlgValue(6, 0);
        endif
    case item% = 6 then
        if DlgValue(6) = 1 then
            DlgValue(4, 0);
            DlgValue(5, 0);
        endif
    case item% = 13 then
        DlgEnable(DlgValue(13), 14);
        DlgEnable(DlgValue(13), 15);
        DlgEnable(DlgValue(13), 16);
        DlgEnable(1-DlgValue(13), 17);
    case item% = 0 then
        DlgEnable(ajUseCueCircles%, 14);
        DlgEnable(ajUseCueCircles%, 15);
        DlgEnable(ajUseCueCircles%, 16);
        DlgEnable(1-ajUseCueCircles%, 17);
    endcase
    return status%;
end


func AttaJoyTimingDialog%()
	DlgCreate("AttaJoy timing", 25, 10);
	DlgReal(1, "Max rdy time(s):", .01, 10);
	DlgReal(2, "Rdy FAIL pause time(s):", .01, 10);
	DlgReal(3, "Rdy BREAK pause time(s):", .01, 10);
    DlgReal(4, "Trng Success pause time(s):",  .01, 10);
    DlgReal(5, "Max acq time(s):", .01, 10);
	DlgReal(6, "Acq FAIL pause time(s):", .01, 10);
    DlgReal(7, "Max resp time(s):", .01, 10);
    DlgReal(8, "Correct resp pause time(s):",  .01, 10);
    DlgReal(9, "Incorrect resp pause time(s):",  .01, 10);
    DlgReal(10, "Fix break pause time(s):",  .01, 10);
    DlgCheck(11, "Always looking (TESTING ONLY)");
	DlgShow(ajMaxWaitForReadyTime, ajReadyFailPauseTime, ajReadyBreakPauseTime,
    ajTrainingSuccessPauseTime,
    ajMaxAcquisitionTime, ajAcquisitionFailPauseTime, ajMaxResponseTime, 
    ajCorrectResponsePauseTime, ajIncorrectResponsePauseTime, ajFixationBreakPauseTime, ajAlwaysLooking%);
    return 1;
end


proc GetAttaJoyParameters()
    var key$;
    var stmp$;
    key$ := GetRegistryKey$(1) + "\\AttaJoy";
    ajNBlocks% := GetIntRegistryValue%(key$, "NBlocks", ajNBlocks%);
    ajNTrialsEachTypePerBlock% := GetIntRegistryValue%(key$, "NTrialsEachTypePerBlock", ajNTrialsEachTypePerBlock%);
    ajTrialTypesListIndex% := GetIntRegistryValue%(key$, "TrialTypesListIndex", ajTrialTypesListIndex%);
    ajDoReadyTraining% := GetIntRegistryValue%(key$, "DoReadyTraining", ajDoReadyTraining%);
    ajDoReadyFixTraining% := GetIntRegistryValue%(key$, "DoReadyFixTraining", ajDoReadyFixTraining%);
    ajDoReadyFixStimTraining% := GetIntRegistryValue%(key$, "DoReadyFixStimTraining", ajDoReadyFixStimTraining%);
    ajRewardSize% := GetIntRegistryValue%(key$, "RewardSize", ajRewardSize%);
    ajCatchTrialPct := GetFloatRegistryValue(key$, "CatchTrialPct", ajCatchTrialPct);
    ajShowSingleStim% := GetIntRegistryValue%(key$, "ShowSingleStim", ajShowSingleStim%);
    ajAlternateCueTypeByBlock% := GetIntRegistryValue%(key$, "AlternateCueTypeByBlock", ajAlternateCueTypeByBlock%);
    ajContrastBase% := GetIntRegistryValue%(key$, "BaseContrast", ajContrastBase%);
    ajContrastUp% := GetIntRegistryValue%(key$, "UpContrast", ajContrastUp%);
    ajUseCueCircles% := GetIntRegistryValue%(key$, "UseCueCircles", ajUseCueCircles%);
    ajHoldFixation1Time := GetFloatRegistryValue(key$, "HoldFixation1Time", ajHoldFixation1Time);
    ajHoldFixation2Time := GetFloatRegistryValue(key$, "HoldFixation2Time", ajHoldFixation2Time);
    ajHoldFixation3Time := GetFloatRegistryValue(key$, "HoldFixation3Time", ajHoldFixation3Time);
    ajHoldFixationTime := GetFloatRegistryValue(key$, "HoldFixationTime", ajHoldFixationTime);
    ajFixationBreakPauseTime := GetFloatRegistryValue(key$, "FixationBreakPauseTime", ajFixationBreakPauseTime);
    ajHazardTimeMin := GetFloatRegistryValue(key$, "HazardTimeMin", ajHazardTimeMin);
    ajHazardTimeMean := GetFloatRegistryValue(key$, "HazardTimeMean", ajHazardTimeMean);
    ajHazardTimeMax := GetFloatRegistryValue(key$, "HazardTimeMax", ajHazardTimeMax);
	ajMaxWaitForReadyTime := GetFloatRegistryValue(key$, "MaxWaitForReadyTime", ajMaxWaitForReadyTime);
    ajReadyFailPauseTime := GetFloatRegistryValue(key$, "ReadyFailPauseTime", ajReadyFailPauseTime);
    ajReadyBreakPauseTime := GetFloatRegistryValue(key$, "ReadyBreakPauseTime", ajReadyBreakPauseTime);
    ajTrainingSuccessPauseTime := GetFloatRegistryValue(key$, "TrainingSuccessPauseTime", ajTrainingSuccessPauseTime);
    ajMaxAcquisitionTime := GetFloatRegistryValue(key$, "MaxAcquisitionTime", ajMaxAcquisitionTime);
    ajAcquisitionFailPauseTime := GetFloatRegistryValue(key$, "AcquisitionFailPauseTime", ajAcquisitionFailPauseTime);
    ajMaxResponseTime := GetFloatRegistryValue(key$, "MaxResponseTime", ajMaxResponseTime);
    ajCorrectResponsePauseTime := GetFloatRegistryValue(key$, "CorrectResponsePauseTime", ajCorrectResponsePauseTime);
    ajIncorrectResponsePauseTime := GetFloatRegistryValue(key$, "IncorrectResponsePauseTime", ajIncorrectResponsePauseTime);
end

proc SaveAttaJoyParameters()
    var key$;
    var stmp$;
    key$ := GetRegistryKey$(1) + "\\AttaJoy";
    SetIntRegistryValue(key$, "NBlocks", ajNBlocks%);
    SetIntRegistryValue(key$, "NTrialsEachTypePerBlock", ajNTrialsEachTypePerBlock%);
    SetIntRegistryValue(key$, "TrialTypesListIndex", ajTrialTypesListIndex%);
    SetIntRegistryValue(key$, "DoReadyTraining", ajDoReadyTraining%);
    SetIntRegistryValue(key$, "DoReadyFixTraining", ajDoReadyFixTraining%);
    SetIntRegistryValue(key$, "DoReadyFixStimTraining", ajDoReadyFixStimTraining%);
    SetIntRegistryValue(key$, "RewardSize", ajRewardSize%);
    SetFloatRegistryValue(key$, "CatchTrialPct", ajCatchTrialPct);
    SetIntRegistryValue(key$, "ShowSingleStim", ajShowSingleStim%);
    SetIntRegistryValue(key$, "AlternateCueTypeByBlock", ajAlternateCueTypeByBlock%);
    SetIntRegistryValue(key$, "BaseContrast", ajContrastBase%);
    SetIntRegistryValue(key$, "UpContrast", ajContrastUp%);
    SetIntRegistryValue(key$, "UseCueCircles", ajUseCueCircles%);
    SetFloatRegistryValue(key$, "HoldFixation1Time", ajHoldFixation1Time);
    SetFloatRegistryValue(key$, "HoldFixation2Time", ajHoldFixation2Time);
    SetFloatRegistryValue(key$, "HoldFixation3Time", ajHoldFixation3Time);
    SetFloatRegistryValue(key$, "HoldFixationTime", ajHoldFixationTime);
    SetFloatRegistryValue(key$, "FixationBreakPauseTime", ajFixationBreakPauseTime);
    SetFloatRegistryValue(key$, "HazardTimeMin", ajHazardTimeMin);
    SetFloatRegistryValue(key$, "HazardTimeMean", ajHazardTimeMean);
    SetFloatRegistryValue(key$, "HazardTimeMax", ajHazardTimeMax);
	SetFloatRegistryValue(key$, "MaxWaitForReadyTime", ajMaxWaitForReadyTime);
    SetFloatRegistryValue(key$, "ReadyFailPauseTime", ajReadyFailPauseTime);
    SetFloatRegistryValue(key$, "ReadyBreakPauseTime", ajReadyBreakPauseTime);
    SetFloatRegistryValue(key$, "TrainingSuccessPauseTime", ajTrainingSuccessPauseTime);
    SetFloatRegistryValue(key$, "MaxAcquisitionTime", ajMaxAcquisitionTime);
    SetFloatRegistryValue(key$, "AcquisitionFailPauseTime", ajAcquisitionFailPauseTime);
    SetFloatRegistryValue(key$, "MaxResponseTime", ajMaxResponseTime);
    SetFloatRegistryValue(key$, "CorrectResponsePauseTime", ajCorrectResponsePauseTime);
    SetFloatRegistryValue(key$, "IncorrectResponsePauseTime", ajIncorrectResponsePauseTime);
end


func Looking%(x, y)
	'Determine if the eye position is within the fixation window
    var s% := 0;
    docase
    case ajAlwaysLooking% = 1 then
        s% := 1;
    case (Pow(x-FixationX, 2) + Pow(y-FixationY, 2)) <= Pow(WindowRadius, 2) then 
        s% := 1; 
    else 
        s% := 0; 
    endcase
    return s%;
end;

proc UpdateToolbarText(iLogWindowAlso%)

	var s$;
    s$ := Print$("N/Rdy/Acq/Fix/Haz/+(%)/-(%) = %d/%d/%d/%d/%d/%d/%d", ajCtrNTrials%, ajCtrNTrialsReady%, ajCtrNTrialsAcq%, ajCtrNTrialsFix%, ajCtrNTrialsChg%, ajCtrCorrect%, ajCtrIncorrect%);
	ToolbarText(s$);
    
    if iLogWindowAlso% <> 0 then
        PrintLog(s$);
    endif

end;
