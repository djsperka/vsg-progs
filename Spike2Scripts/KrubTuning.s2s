' $Id: KrubTuning.s2s,v 1.7 2013-07-09 18:13:35 jeff Exp $
'
'

#include "KrubTuningDialogs.s2s"
#include "KrubRigParameters.s2s"
#include "KrubGratings.s2s"
#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/FileUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "../../Spike2Util/ChannelUtilities.s2s"

' tuning type-specific values
var tunFileLabel$ := "zzz";

' tuning daq parameters
var tunNChannels% := 1;  'where is this changed?  Setting to 1 to get a data channel
var tunColorIndex%;
var tunColor$[4];

' daq channels for triggers from vsg
var tunChanTrigger% := 11;
var tunChanVSGReady% := 12;

' prog handles
var tunHandleStim := -1;

' window handles
var tunWindowData%;
var tunResultXYWindow%[50];  'there won't be 50 channels

' data holders
var tunTotalSpikeCount[50][100];  'Let's assume a max of 50 channels and 100 timepoints, can't be integer due to later math
var tunTotalSeconds[50][100];
var tunBlankTotalSpikeCount[50];  'And another for the blank periods
var tunBlankSeconds[50];

' folder for stim files
var tunStimFolder$;



' Initializations

tunBGColor$[0] := "gray";
tunBGColor$[1] := "black";
tunBGColor$[2] := "white";

tunColor$[0] := "Black and white";
tunColor$[1] := "S cone isolating";
tunColor$[2] := "M cone isolating";
tunColor$[3] := "L cone isolating";

tunGratingParams$ := GetGratingParameters$("Stimulus");
tunStimFolder$ := GetDataPathRoot$() + "\\stim";

' TODO: Resize window?
'View(App(0)).Window(0,0,75,95);




'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
' Script starts here

' Initialize logging
LogInit(1);


' Get experimental parameters. 
' tunFileLabel$ is set here! 
if KrubTuningDialog%() = 0 then
    halt;
endif

if tuntypeSelected% = tuntypeNone% then
    Message("No tuning type selected!");
    halt;
endif

' Sampling config
CreateSampleConfiguration();

' Prepare display windows, input channels, etc. 
InitializeWindows();


	
ToolbarSet(1,"Quit",Quit%);
ToolbarSet(2,"Sample start",Start%);
ToolbarSet(3,"Sample stop", Stop%);
ToolbarEnable(3,0);
Toolbar("Go",1234);

' Oh no! Make sure sampling has stopped!
if SampleStatus() <> -1 then
    LogWarn("KrubTuning", "Toolbar exited and sampling status is " + str$(SampleStatus()) + ". Stopping sampling...");
    SampleStop();
    LogWarn("KrubTuning", "Sampling stopped.");
endif


proc CreateSampleConfiguration()
    
    var i%;
    var xy%;
    
	SampleClear(); 'Set standard sampling state
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 3);
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 1);
    SampleAutoName$(dataCellName$ + "_" + tunFileLabel$ + "_000");
	SampleAutoFile(1);

    'Channel recording definitions

    for i% := 1 to tunNChannels% do
        SampleWaveMark(i%, i%-1, 2000, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
        SampleTitle$(i%, "Spike " + Str$(i%-1));
    next

    for i% := 1 to tunNChannels% do
        SampleWaveform(i%+5, i%-1, 28000); ' chan, port, event rate, points, pre-trigger, rate
        SampleTitle$(i%+5, "WF " + Str$(i%-1));
    next

    SampleEvent(tunChanTrigger%, 1, 2, 1000); 
    SampleTitle$(tunChanTrigger%, "Terms");

    'Make textmark channel for easier data extraction
    SampleTextMark(200);  'Channel 30 is textmark channel 

    
    ' There is no sequencer script in use
	'SampleSequencer(script$ + "KrubTuning.pls");
    SampleOptimise(2, 2, 2, 2, 50);  'Set optimise mode (do this last)
    SampleMode(1); 'Continuous sampling
    
end;


proc InitializeWindows()
    var i%;
    var AutoCorr%;
    var tempTitle$;
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
    
    tunWindowData% := FileNew(0,4);
    View(tunWindowData%).WindowVisible(1);
    View(tunWindowData%).Window(0,33,100,100);
    
    ' Create results plot for each channel
    for i% := 1 to tunNChannels% do
        ' open xy window to display tuning results
        tunResultXYWindow%[i%] := FileNew(12);
        ' position in upper-right quadrant of screen
        Window(50, 0, 100, 50);  'adjust this?
        ' first channel is signal. specify color etc
        XYDrawMode(0,5,1);  '0 ignored, set automtic axis range mode, axes set to update with new data
        XYSort(1,1);  'sort by x-value
        XYJoin(1,1);  'Join, do not connect first to last
    '    WindowVisible(1);  
        XYColour(1,16); ' I have no idea what color 16 is
        ChanTitle$(1, "Signal");  'Sets title of channel 1
        XYSetChan(0); ' create second channel. The first channel is automatically created with the FileNew(12) call.
        XYColour(2,12); ' no idea what color 12 is either
        ChanTitle$(2, "Bkgd");  'Sets title of channel 2
        'Create labels
        ChanTitle$(0, "Spikes/s");  ' y axis label
        TuningCurveLabels(tuntypeSelected%);
        tempTitle$ := WindowTitle$();
        WindowTitle$(tempTitle$ + ", Electrode " + Str$(i%));
        WindowVisible(1);  'XY plot starts out invisible, make it visible
    next;
    
    SaveParameterFile();
end

proc SaveParameterFile()
    var handle;
    var filename$;
    
    filename$ := ReplaceFileExtension$(-1, "par");
    handle := FileOpen(filename$, 8, 1);
    if handle <0 then 
        Message("Could not create parameter file " + filename$);
    else
        LogInfo("TODO : Writing parameters to file " + filename$);
        FileClose();
    endif
    
    return;
end


' Make window title and axis labels for tuning curves.
' ttype% is the tuning type
' It is assumed that the xy window is the current view. 
proc TuningCurveLabels(ttype%)
    
    var minValue;
    var maxValue;
    
    minValue := tunParameterValues[min(tunParameterValues)];
    maxValue := tunParameterValues[max(tunParameterValues)];
    
	docase 
		case ttype% = tuntypeDom% then

			WindowTitle$("Contrast Tuning");
            XUnits$("Contrast (%)");
            XRange(minValue, maxValue);
			'XRange(tunContrastMinContrast, tunContrastMaxContrast);

		case ttype% = tuntypeOri% then

			WindowTitle$("Orientation Tuning");
            XUnits$("Orientation (degrees)");
            XRange(minValue, maxValue);
			'XRange(tunOriMinOrientation, tunOriMaxOrientation);

		case ttype% = tuntypeSF% then

			WindowTitle$("Spatial Frequency Tuning");
			XUnits$("Spatial Frequency");
            XRange(minValue, maxValue);
            'XRange(tunSpatialMinSF, tunSpatialMaxSF);
	
		case ttype% = tuntypeTF% then

			WindowTitle$("Temporal Frequency Tuning");
            XUnits$("Temporal Frequency");
            XRange(minValue, maxValue);
			'XRange(tunTemporalMinTF, tunTemporalMaxTF);

		case ttype% = tuntypeArea% then

			WindowTitle$("Aperture Area Tuning");
            XUnits$("Aperture Diameter");
            XRange(minValue, maxValue);
			'XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
		else

			Message("TuningCurveLabels Error - unknown value for tuntypeSelected%: " + Str$(ttype%));

	endcase;

end;

' Quit is used to exit the script entirely. 
' If there are any VSG apps running they should be stopped now. 
' All VSG apps should be triggered off if possible - that allows for clean
' handling of the lock. 
' Could check if app is running, display error message. 

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Quit%()
'   TODO: Check for running vsg app.
    return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

' Start is used to start sampling and launch the visual stim. 
' Start must take things from post-dialog (i.e. all parameters can 
' be assumed to be expt-ready, but live, daq-related values (updated in Idle%() ) - tStateStart, 
' iState%, etc.) have only been initialized, not used.
' Start should start sampling, initiate the idle function, 
' THEN launch the visual stim script. The order is important so that the "ready" triggers from the 
' stim will be picked up.

func Start%()
    var cmd$;
    var i%;
    var h%;
    var s$;
    var screenWidth;
    var x, y, w, h, contrast%, sf, tf, ori, mo$, pattern$, aperture$;
    var stimfile$, quitfile$;
    
    ' Start sampling
    SampleStart(0);
    View(tunWindowData%);    
    
    ' Set idle here - before vsg launches so we cannot miss the ready signal. 
    ToolbarEnable(3,1); ' stop
    ToolbarEnable(2,0); ' start
    ToolbarEnable(1,0); ' quit
    ToolbarSet(0, "", Idle%);
    
    ' Before generating command file, fetch the base grating parameters.
    ParseGratingParameters%(tunGratingParams$, x, y, w, h, contrast%, sf, tf, ori, mo$, pattern$, aperture$);
    
    ' Delete old stim file if there is one sitting there. 
    stimfile$ := tunStimFolder$ + "\\stim.txt";
    quitfile$ := tunStimFolder$ + "\\quit.txt";
    FileDelete(stimfile$);
    FileDelete(quitfile$);
    
    ' Open text file
    h% := FileOpen(stimfile$, 8, 1);
    if h% < 0 then
        LogError("Start", "Cannot open text file!");
        halt;
    endif
    
    ' Write header
    screenWidth := GetKrubScreenWidth%()/10.0;
    Print("header,%.1f,%s,%d,1,%d,%d,%d\n", screenWidth, GetAcuteDistanceToScreenMM$(), GetKrubMaskType%(), GetKrubTriggerSqPixels%(), GetKrubTriggerSqFrames%(), GetKrubBgColor%());
    
    ' Ready pulses (2)
    Print("ready,2\n");
    
    ' Stim/blank/blank for each stim 
    for i% := 0 to ((tunNSteps%+1)*tunNRepeats%)-1 do
        docase 
        case tuntypeSelected% = tuntypeOri% then
            s$ := EncodeGratingParameters$(x, y, w, h, contrast%, sf, tf, tunParameterValues[tunParameterIndices%[i%]], mo$, pattern$, aperture$);
        case tuntypeSelected% = tuntypeDom% then
            s$ := EncodeGratingParameters$(x, y, w, h, tunParameterValues[tunParameterIndices%[i%]], sf, tf, ori, mo$, pattern$, aperture$);
        case tuntypeSelected% = tuntypeSF% then
            s$ := EncodeGratingParameters$(x, y, w, h, contrast%, tunParameterValues[tunParameterIndices%[i%]], tf, ori, mo$, pattern$, aperture$);
        case tuntypeSelected% = tuntypeTF% then
            s$ := EncodeGratingParameters$(x, y, w, h, contrast%, sf, tunParameterValues[tunParameterIndices%[i%]], ori, mo$, pattern$, aperture$);
        else
            LogError("Start", "Unknown tuning curve type (" + str$(tuntypeSelected%) + ")");
            halt;
        endcase
        
        View(h%).Print("grating," + s$ + "," + str$(tunStimTime) + "\n");
        View(h%).Print("tblank," + str$(tunBlankTime) + "\n");
        View(h%).Print("tblank,0.5\n");
        
    next
    
    ' Close file
    FileClose();
    
    
    return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' Stop must stop applications and sampling nicely. Adjust toolbar to wait for "quit", stop Idle%(). 
' Generate quit file for the visual stim application. 

func Stop%()
    
    ' remove the idle process. 
    ToolbarSet(0, "");
    ToolbarEnable(1, 1);
    ToolbarEnable(3, 0);
    
    ' send the quit command before stopping sampling
    FileOpen(tunStimFolder$ + "\\abort.txt", 8, 1);
    FileClose();
    
    '   TODO 
    ' Generate a "stop" command file for matlab/psychtbx script
    
    SampleStop();

    return 1;
end; 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var tNow;               ' Set on entering this func. For this invocation it is the latest time sampled. 
var tLast;              ' This is tNow from the last time Idle%() was called. 
var tStateStart := -1;  ' Start time of current state
var tStimStart := -1;   ' Time of stim ON trig
var tBlankStart := -1;  ' Time of blankON trig
var tBlankEnd := -1;    ' time of blankOFF trig
var iStimCounter% := 0;
var iBlankCounter% := 0;
var tTrigger := -1;
var vTrigger;
var tLastTrigger := -1;
var tPulseWindowStart := -1;
var tPulseUp := -1;
var tPulseDn := -1;
const tReadyPulseTimeout := 15;


' states
const stateStartup%             :=  1;
const stateWaitForReadyPulse1%  :=  2;
const stateWaitForReadyPulse2%  :=  3;
const stateStartTuning%         :=  4;
const stateNoStim%              :=  5;
const stateStimON%              :=  6;
const stateBlankON%             :=  7;
const stateDone%                := 99;
var iState% := stateStartup%;              ' This holds the current state
var iDummy% := 0;

func Idle%()
    var status% := 1;
    var i%;
    View(tunWindowData%);
	tNow := MaxTime();
    
    docase 
    case iState% = stateStartup% then
        
        LogStatus("stateStartup", "Starting up.");
        ChangeStateTo(stateWaitForReadyPulse1%, tNow);
        
    case iState% = stateWaitForReadyPulse1% then
        
        ' Check for pulse, then for timeout
        
        docase 
        case FindPulseDown%(tunChanTrigger%, tStateStart, tPulseDn, tPulseUp) = 1 then
            ChangeStateTo(stateWaitForReadyPulse2%, tPulseUp);   ' start time in new state will be up time of first pulse
        case tNow-tStateStart > tReadyPulseTimeout then
            Message("Did not see first ready pulse from vis stim application. Check that it is running, and that the trigger device is ready.");
            ChangeStateTo(stateDone%, tNow);
        endcase
        
    case iState% = stateWaitForReadyPulse2% then
        
        ' Check for pulse, then for timeout
        docase 
        case FindPulseDown%(tunChanTrigger%, tStateStart, tPulseDn, tPulseUp) = 1 then
            ChangeStateTo(stateStartTuning%, tPulseUp);
        case tNow-tStateStart > tReadyPulseTimeout then
            Message("Did not see second ready pulse from vis stim application. Check that it is running, and that the trigger device is ready.");
            ChangeStateTo(stateDone%, tNow);
        endcase
        
    case iState% = stateStartTuning% then
        
        ' Issue sample key to start stim, then switch to looking for triggers
        LogStatus("stateStartTuning", "Ready for stim triggers.");
        'Yield(1.0);
        'SampleKey("s");
        ChangeStateTo(stateNoStim%, tNow);
        
    case iState% = stateNoStim% then
        
        ' Waiting for the first trig - which indicates the stim is on
        if FindPulseDown%(tunChanTrigger%, tStateStart, tStimStart, tPulseUp) = 1 then
            ChangeStateTo(stateNoStim%, tPulseUp);
            LogStatus("NoStim", "Pulse at " + str$(tPulseUp));
        ChangeStateTo(stateStimON%, tStimStart);
        SampleText("STIMON " + Str$(iStimCounter%+1),tStimStart); 'Record start time, which stimulus#
        endif
        
    case iState% = stateStimON% then
        
        ' Waiting for the second trig - which indicates the stim is off
        if FindPulseDown%(tunChanTrigger%, tStateStart, tBlankStart, tPulseUp) = 1 then
 '       if FindEvent%(tunChanTrigger%, tStimStart, tBlankStart) > 0 then
            ' TODO process spikes
            LogInfo("TODO: Process spikes for STIM " + str$(iStimCounter%) + " " + str$(tStimStart) + "-" + str$(tBlankStart) + " " + str$(tunParameterValues[tunParameterIndices%[iStimCounter%]]) + "\n");
            ' Plot data for this epoch, each channel
            for i% := 1 to tunNChannels% do
                tunTotalSpikeCount[i%][tunParameterIndices%[iStimCounter%]] := tunTotalSpikeCount[i%][tunParameterIndices%[iStimCounter%]]+View(tunWindowData%).Count(i%, tStimStart, tBlankStart);
                tunTotalSeconds[i%][tunParameterIndices%[iStimCounter%]] := tunTotalSeconds[i%][tunParameterIndices%[iStimCounter%]]+tBlankStart-tStimStart;
                'printlog("Total count is %d and total time is %f for a rate of %f\n",tunTotalSpikeCount[i%][tunParameterIndices%[iStimCounter%]],
                '         tunTotalSeconds[i%][tunParameterIndices%[iStimCounter%]],tunTotalSpikeCount[i%][tunParameterIndices%[iStimCounter%]]/tunTotalSeconds[i%][tunParameterIndices%[iStimCounter%]]);
                'printlog("Stim count is %d and index is %d and value is %f\n",iStimCounter%,tunParameterIndices%[iStimCounter%],tunParameterValues[tunParameterIndices%[iStimCounter%]]);
                if iStimCounter% > tunNSteps% then
                    View(tunResultXYWindow%[i%]).XYDelete(1,tunParameterIndices%[iStimCounter%],tunParameterIndices%[iStimCounter%]);
                    'View(tunResultXYWindow%[i%]).XYDelete(1,0,0);
                endif;
                View(tunResultXYWindow%[i%]).XYAddData(1,tunParameterValues[tunParameterIndices%[iStimCounter%]],tunTotalSpikeCount[i%][tunParameterIndices%[iStimCounter%]]/tunTotalSeconds[i%][tunParameterIndices%[iStimCounter%]]);
            next;
            ChangeStateTo(stateBlankON%, tBlankStart);
            SampleText("STIMOFF " + Str$(iStimCounter%+1),tBlankStart); 'Record off time, which stimulus#
            iStimCounter% += 1;
        endif
        
    case iState% = stateBlankON% then
        
        ' Waiting for the third trig - which indicates the blank is off
        'if FindEvent%(tunChanTrigger%, tBlankStart, tBlankEnd) > 0 then
        if FindPulseDown%(tunChanTrigger%, tStateStart, tBlankEnd, tPulseUp) = 1 then
             
            LogInfo("TODO: Process spikes for BLANK " + str$(iBlankCounter%) + " " + str$(tBlankStart) + "-" + str$(tBlankEnd) + "\n");
            for i% := 1 to tunNChannels% do
                tunBlankTotalSpikeCount[i%] := tunBlankTotalSpikeCount[i%]+View(tunWindowData%).Count(i%, tBlankStart, tBlankEnd);
                tunBlankSeconds[i%] := tunBlankSeconds[i%]+tBlankEnd-tBlankStart;
                'printlog("Blank count is %d and blank time is %f for a rate of %f\n",tunBlankTotalSpikeCount[i%],tunBlankSeconds[i%],tunBlankTotalSpikeCount[i%]/tunBlankSeconds[i%]);
                View(tunResultXYWindow%[i%]).XYDelete(2);
                View(tunResultXYWindow%[i%]).XYAddData(2,1,tunBlankTotalSpikeCount[i%]/tunBlankSeconds[i%]);
            next;
            
            iBlankCounter% += 1;            
            
            ' check whether all stim have been presented
            if iStimCounter% = (tunNSteps%+1) * tunNRepeats% then
                ChangeStateTo(stateDone%, tNow);
            else
                ChangeStateTo(stateNoStim%, tBlankEnd);
            endif
        endif
        
    case iState% = stateDone% then
        
        Stop%();
        status% := 1;
        
    else
        
        LogError("", "Unknown state " + str$(iState%));
        Stop%();
        status% := 0;
        
    endcase
    
    return status%;
end

proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'func SpikeRate(t1, t2, window%, chan%)
'    if t2-t1 <= 0 then
'        return -999999;     ' end time before or equal to start time
'    else
'        View(window%).Count(chan%, t1, t2)/(t2-t1);
'    endif
'end