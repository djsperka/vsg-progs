' $Id: Tuning.s2s,v 1.67 2013-07-10 18:14:37 jeff Exp $
' Update 11/8/11 Jeff, includes multi-juicer updates

const tunCVSID$ := "$Id: Tuning.s2s,v 1.67 2013-07-10 18:14:37 jeff Exp $";




' Hello again

#include "../../Spike2Util/ChannelUtilities.s2s"
#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "UsreyDAQ.s2s"
#include "TuningDialogs.s2s"
#include "UsreyGratings.s2s"
#include "UsreyFixationPoint.s2s"



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameChannel%;
var FrameSlaveChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;
var FixationPointSlaveChannel%;
var StimSlaveChannel%;

' xy windows for plotting (TuningWindow) and PSTH. 
var TuningWindow%[16];	' one for each wavemark channel
var PSTHWindow%[16];    ' used for f1 and f2. Will be made invisible when in use. 

' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window
var XYDotSize%[200];  'holds size of each dot for XY coordinate plot
var XYDataCount%[200];  'holds number of presentations at each XY coordinate
var XYSpikeRate[200];  'hold cumulative "rate" ( = rate on trial 1 + rate on trial 2 ...) at each XY coordinate

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;


var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 
var tStimSequence := -1;    ' time that stim sequence started; followed by pulses on frame channels
var tInterTrialTime := 0;	' Time spent waiting between trials (i.e. after screen is blank, but before fix point is presented)
'var iHoldCount% := 0;	' Counter of how many times we progress through the hold fixation state in the maintainence loop. Used to decide if "time out" is required. 
var tRise, tFall;
var tKludge := 0.06;    ' Add to Fixation time to account for stim sequence. Ugly hack, admittedly, but one does what one must. 


' Constants for states
const stateStartTrial%:=0;		' Start trial state
const stateWaitForFixPtOn%:=1;		' Waiting for fixation point return trigger (on)
const stateWaitForBlank%:=2;		' Waiting for fixation point return trigger (off)
const stateWaitForStimOn%:=3;		' Wait for stimulus return trigger (on)
const stateWaitForStimOff%:=4;		' Wait for stimulus return trigger (off)
const stateWaitForAcquisition%:=5;	' Waiting for subject to acquire fixation point
const stateHoldFixation%:=6;		' Holding fixation point
const stateAbort%:=7;			' Failed trial state
const stateMaintainFixation%:=8;	' Maintaining fixation (stim off period)
const stateInterTrialInterval%:=9;	' time out after failed trial
const stateVSGWait%:=10;		' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForStimTrigger% := 14; ' Rising edge indicating start of stim sequence
var iState% := stateVSGWait%;	' present state

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 

var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
var pulseFound%;


' Init logging
LogInit(1);

' Check if always looking flag is set. If so, issue a warning. 
if tunAlwaysLooking% = 1 then
    if Query("Always looking is SET. Unset?") = 1 then
        tunAlwaysLooking% := 0;
    endif
endif


' run parameters script....
tunContext$ := tunContextDAQ$;
tunType$ := tunTypeNone$;

GetTuningCurveScriptParameters();
iScript% := TuningCurveScriptDialog%();
if iScript% = 1 then
	if tunType$ = tunTypeNone$ then
		LogInfo("No tuning type selected, exit gracefully\n");
		Halt;
	else
		LogInfo("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ. DoRivalry = " + str$(tunDoRivalry%));
	endif;
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' When TF/CRG curve, don't do f1 and f2. 
' Also Dots. 
if tunType$ = tunTypeTemporal$ or tunType$ = tunTypeCRG$ or tunType$ = tunTypeDots$ then
    tunDoF12% := 0;
endif

' Read in CRG sequence file (SEQ) if doing contrast reversing grating, get length, make sure it's kosher
if tunType$ = tunTypeCRG$ then
    'Getting sequence lengths, number of flips, checking files against each other, if two
    tunCRGNSeq1% := CheckSeqFile%(tunCRGSeqFile$,tunCRGNFlips1%);
    if tunType1$ = tunTypeCRG$ then  'If secondary grating is CRG as well, read second grating
        tunCRGNSeq2% := CheckSeqFile%(tunCRGSeqFile2$,tunCRGNFlips2%);
        if tunCRGNSeq1% <> tunCRGNSeq2% then
            Message("ERROR!|The number of sequences must be the same in each file!");
            halt;
        endif;
        if tunCRGNFlips1% <> tunCRGNFlips2% then
            Message("ERROR!|The number of flips must be the same in each file!");
            halt;
        endif
        'if there is a CRG on both screens, set tunFixationDuration to 0; used in Idle processing to determine
        'when to advance the stimulus, don't want this value to interfere if it's not being used.
        tunFixationDuration := 0;   
    endif;
    
    'Calculate duration of stimulus
    tunCRGSecsPerSeq := tunCRGFramesPerFlip%*tunCRGNFlips1%/dataScreenHz;
    'printlog("duration of CRG stim is %f seconds\n",tunCRGSecsPerSeq);
    
    

endif;



' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 21;
YChannel% := 22;
FixationPointChannel% := 24;
StimChannel% := 25;
ReadyChannel% := 27;            ' Look for ready signal on port 2 (same as fixpt). 
FixationPointSlaveChannel% := 28;
StimSlaveChannel% := 29;
FrameChannel% := 19;
FrameSlaveChannel% := 20;

' Fetch electrode information. 
if UsePlexon% = 0 then
    tunNWavemarks% := GetWavemarkPorts%(tunWavemarkPorts%[]);
    tunNContinuous% := GetContinuousPorts%(tunContinuousPorts%[]);
else
    tunNWavemarks% := 13;  '13 wavemarks on the micro for plexon
    tunNContinuous% := 0;  'no continuous on the micro for plexon
    var i%;
    for i% := 0 to 12 do
        tunWavemarkPorts%[i%] := i%;
    next;
endif;


''Create sampling configuration
'CreateSampleConfiguration();
'
'
'' Get display windows ready
'InitializeWindows();
'
'tic := View(DataWindow%).BinSize(ReadyChannel%);
'
'' Prepare the toolbar buttons
'InitializeToolbar();



'If we are not using the Plexon (and thus linking the two 1401s together, just use the standard order of operations:
'1) create sampling configuration, 2) Initialize windows, 3) Initialize/run toolbar.
'However, if we are linking the 1401s we have to do this in a different order, because we have to open up the second
'instance of Spike 2 BEFORE setting up the sampling configuration/windows on the first instance.  Doing this in the
'wrong order results in a non-fatal error in the second Spike2 instance indicating that the file which is preparing
'to be recorded in the first instance cannot be accessed, despite no explicit attempt to access any such thing.
'Hence, for the Plexon setups, we first initialize the toolbar, which has a specialty button "Start Plexon".  StartPlexon%()
'launches the second instance and the associated script, and both scripts move forward independently to create their own
'sampling configuration, initialize their own windows and are ready to have sampling started.  Note well that sampling
'must be started on the POWER 1401 (the second, non-dominant instance of Spike2) FIRST and on the MICRO 1401 (the first, 
'dominant instance of Spike 2) SECOND.  Starting sampling on the Micro will run the VSG program (Fixstim) which gives
'the sampling trigger and sets the experiment in motion.
if UsePlexon% = 0 then
    CreateSampleConfiguration();

    ' Get display windows ready
    InitializeWindows();
    
    tic := View(DataWindow%).BinSize(ReadyChannel%);
    
    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



func IdleProcessing%()
	var iStatus% := 1;	
    var xval;
    var yval;
    var xind%;
    var yind%;
    
	tNow := View(DataWindow%).MaxTime();
    
    ' First time through (tLast<0) just update tLast. Crosstalk on vsg dig outputs leads to erroneous
    ' triggers. Maybe this will help. 
    if tLast < 0 then
        tLast := 1;
        return 1;
    endif
    
    
	xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
	yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastUpdate := tNow;
	endif

	docase 
    case iState% = stateVSGWait% then
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        'if View(DataWindow%).FindPulseUp%(ReadyChannel%, -1, tRise, tFall) = 1 then
        pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
        if pulseFound% = 1 then
            LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
            Yield(1.0);
            tLastTrigger := tFall;
            ChangeStateTo(stateStartTrial%, tFall);
        else
            if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                tLastTrigger := tFall;
            endif;
        endif;

    case iState% = stateStartTrial% then

        ' Start trial. Put up fixation point.
        LogStatus("StartTrial", "Request fixpt");
        SafeSampleKey("F");
        ChangeStateTo(stateWaitForFixPtOn%, tNow);
    
    case iState% = stateWaitForFixPtOn% then
    
        if View(DataWindow%).FindRisingEdge%(FixationPointChannel%, tLast, tTrigger) = 0 then
            ' Fixation point is up
            LogStatus("WaitForFixPtOn", "Fixpt on at " + str$(tTrigger) + "\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateWaitForAcquisition%, tTrigger);
            DrawStim(1);	' actually this draws the location of the fixpt.
'        else
 '           LogStatus("WaitForFixPtOn", "Waiting at " + str$(tLast));
        endif

    case iState% = stateWaitForAcquisition% then

        ' Waiting for eye to fall inside of fixation window
        if Looking%(xEye, yEye) = 1 then
            LogStatus("WaitForAcquisition", "Eye in fixation window; request stim");
            docase
            case TunType$ = tunTypeBoxODonuts$ or TunType$ = tunTypeCRG$ or TunType$ = tunTypeXYPos$ then
                GetPlotXYCoord(nTrialsCompleted%,xval,yval,xind%,yind%);  'fill xval, yval
                SampleText("T," + str$(xval) + ",T2," + str$(yval));  'Just a guess at what will work
            else
                SampleText("T," + str$(GetPlotXCoord(nTrialsCompleted%)));
            endcase;
            
            SafeSampleKey("S");
            'iHoldCount% := 0;  'disimplemented
            ChangeStateTo(stateWaitForStimTrigger%, tNow);
        else 
            if tNow - tStateStart > tunAcquisitionTime then
                ' failed to acquire target. 
                tInterTrialTime := tunAcqFailTime;
                LogStatus("WaitForAcquisition", "Failed.");
                ChangeStateTo(stateAbort%, tNow);
            endif
        endif

    case iState% = stateWaitForStimTrigger% then

        if View(DataWindow%).FindRisingEdge%(StimChannel%, tLast, tTrigger) = 0 then
            ' Fixation point is up
            LogStatus("WaitForStimTrigger", "Stim sequence started at " + str$(tTrigger));
            tStimOn := tTrigger;
            tStimSequence := tTrigger;      ' TODO remove tStimOn ref above - see stateWaitForStimOn
            tLastTrigger := tTrigger;
            ChangeStateTo(stateHoldFixation%, tTrigger);
        endif

        
    case iState% = stateWaitForStimOn% then
        
        ' Starting from tStimSequence, look for pulses in FrameChannel% and FrameSlaveChannel%
        LogStatus("WaitForStimOn", "NOT IMPLEMENTED!");
        
    case iState% = stateAbort% then

        ' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
        ' fixpt off. 
        SafeSampleKey("X");
        ChangeStateTo(stateWaitForBlank%, tNow);

    case iState% = stateWaitForBlank% then

        ' we just wait for fix point off signal in this case. 
        if View(DataWindow%).FindFallingEdge%(FixationPointChannel%, tLast, tTrigger) = 1 then
            ' Fixation point is off
            tLastTrigger := tTrigger;
            ChangeStateTo(stateInterTrialInterval%, tTrigger);
            DrawStim(0);	' actually this draws the location of the fixpt.
        endif

    case iState% = stateInterTrialInterval% then

        if tNow - tStateStart > tInterTrialTime then

            ChangeStateTo(stateStartTrial%, tNow);

        endif

    case iState% = stateHoldFixation% then

        if Looking%(xEye, yEye) = 0 then
            
            LogStatus("WaitForFixation", "Fixation broken, aborting trial.");
            'if iHoldCount% = 0 then     'disimplemented
            '    tInterTrialTime := tunTimeOutTime;
            'else
            '    tInterTrialTime := tunHoldFailTime;
            'endif
            tInterTrialTime := tunHoldFailTime; 'replaces disimplemented code directly above
            SampleText("-");
            ChangeStateTo(stateAbort%, tNow);

        else 
            'tunCRGSecsPerSeq will be 0 unless there is a CRG; tunFixationDuration will be 0 if both screens are CRG
            if tNow - tStateStart > tunFixationDuration + tKludge and tNow - tStateStart > tunCRGSecsPerSeq + tKludge then  

                'iHoldCount% += 1;  'disimplemented

                ' turn off stimulus and advance it
                SampleText("+");
                LogStatus("HoldFixation", "Turn off and advance stimulus.");
                
                ' djs If NoMaintain was chosen, then turn EVERYTHING off (stim and fixpt) now.
                ' Otherwise just turn off stim. 
                if tunUseMaintainMode% = 1 then
                    SafeSampleKey("s");
                else
                    SafeSampleKey("X");
                endif;
                
                Yield();
                
                ' Reward
                DefaultReward();
                
                ' Process Spikes
                docase
                case TunType$ = tunTypeBoxODonuts$ then
                    GetPlotXYCoord(nTrialsCompleted%,xval,yval,xind%,yind%);  'fill xval, yval
                    PlotSpikes2TunCurves(tStimOn, tNow, 1, xval, yind%);
                case TunType$ = tunTypeCRG$ then
                    GetPlotXYCoord(nTrialsCompleted%,xval,yval,xind%,yind%);  'fill xval, yval
                    PlotSpikes(tStimOn, tNow, 1, yval, nTrialsCompleted%);  'yes, yval
                case TunType$ = tunTypeXYPos$ then
                    GetPlotXYCoord(nTrialsCompleted%,xval,yval,xind%,yind%);  'fill xval, yval
                    PlotDots(tStimOn, tNow, xind%, yind%); 
                else
                    PlotSpikes(tStimOn, tNow, 1, GetPlotXCoord(nTrialsCompleted%), nTrialsCompleted%);
                endcase;                

                ' Now wait until stim is off
                ChangeStateTo(stateWaitForStimOff%, tNow);

            endif

        endif

    case iState% = stateWaitForStimOff% then

        if View(DataWindow%).FindFallingEdge%(StimChannel%, tLast, tTrigger) = 1 then
            ' Advance
            SafeSampleKey("a");

            tLastTrigger := tTrigger;
            ChangeStateTo(stateTrialCompleted%, tNow);
        endif

    case iState% = stateTrialCompleted% then
        
        nTrialsCompleted% += 1;         ' this state must be exited this time through!!!
        printlog("number of trials completed is %d\n",nTrialsCompleted%);
		ToolbarText(str$(nTrialsCompleted%) + "/" + str$(tunNValues%) + " trials completed.");        
		if nTrialsCompleted% = tunNValues% then
            ' We're all done - appears to not reward on final trial.  How chintzy!
            ChangeStateTo(stateDone%, tNow);
            Stop%();
            iStatus% := 0;
        else
            if tunUseMaintainMode% = 1 then
                ChangeStateTo(stateMaintainFixation%, tNow);
            else
                'tInterTrialTime := tunMaintainFailTime;
                tInterTrialTime := tunStdInterTrialTime;
                ChangeStateTo(stateInterTrialInterval%, tNow);
            endif
        endif
            
    case iState% = stateMaintainFixation% then

        if Looking%(xEye, yEye) = 0 then

            tInterTrialTime := tunMaintainFailTime;
    
            LogStatus("MaintainFixation", "Broken; aborting trial");
            ChangeStateTo(stateAbort%, tNow);

        else 
            if tNow - tStateStart > tunMaintainFixation then

                LogStatus("MaintainFixation", "success");
                
                if JuicerType% = 1 then  'open-high juicer, dispense based on ms
                    DeliverReward();
                else
                    if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
                        DeliverRewardNumber();
                    endif;
                endif;
                
                docase
                case TunType$ = tunTypeBoxODonuts$ or TunType$ = tunTypeCRG$ then
                    GetPlotXYCoord(nTrialsCompleted%,xval,yval,xind%,yind%);  'fill xval, yval
                    SampleText("T," + str$(xval) + ",T2," + str$(yval));  'Just a guess at what will work
                else
                    SampleText("T," + str$(GetPlotXCoord(nTrialsCompleted%)));
                endcase;
                
                SafeSampleKey("S");
                ChangeStateTo(stateWaitForStimTrigger%, tNow);

            endif 
        endif

    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;

	endcase;

	tLast := tNow;
	return iStatus%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
    if UsePlexon% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Juice%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    '	ToolbarSet(6,"Exp Parameters",AttentionScriptDialog%);
    ToolbarSet(6,"Select Wavemarks",SelectWavemarkDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
    if tunAlwaysLooking% = 1 then return 1; endif;
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Juice%()  'note that this function is only used for Toolbar-based juice delivery
    if JuicerType% = 1 then  'open-high juicer, dispense based on ms
        DeliverReward();
    else
        if JuicerType% = 2 then  'open-low juicer, dispense based on number of hits
            DeliverRewardNumber();
        endif;
    endif;
    return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



func GetPlotXCoord(nTrials%)  
    return tunValues[tunValuesIndices%[nTrials%]];
end;

func GetPlotXYCoord(nTrials%,&xval,&yval,&xind%,&yind%)  'new for Box O' Donuts
    xval := tun1Values[tun1ValuesIndices%[nTrials%]];
    yval := tun2Values[tun2ValuesIndices%[nTrials%]];
    xind% := tun1ValuesIndices%[nTrials%];  'at time of writing, xind is not used (may as well put it in)
    yind% := tun2ValuesIndices%[nTrials%];  'but yind is used in PlotSpikes2TunCurves
end;


proc PlotDots(t1,t2,xind%,yind%)
    var rate;
    var count% := 1;
    var i%;
    var j%;
    var k%;
    var ind%;
    var maxdot;
    var temp[200];  'this holds the average
    'get index to which channel is current
    ind% := yind% + (xind%*(tunXYPosNYSteps%+1));
    'for i% := 0 to tunNWavemarks%-1 do ...for now I want this to work for one electrode before trying to do multiples
    rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
    printlog("Current rate is %f\n",rate);
    XYSpikeRate[ind%] += rate;  'add in the current rate
    XYDataCount%[ind%] += 1;   'increment the counter
    'now determine the dot size - make 0 = 0, make biggest dot = 50
    ArrConst(temp[],XYSpikeRate[]);  'fill temp with "rate"
    ArrDiv(temp[],XYDataCount%[]);   'divide by number of trials at each point to get actual rate, divide by zero should be OK and just give no change (so still 0)
    maxdot := temp[Max(temp)];  'get value of maximum rate
    if maxdot > 0 then
        ArrConst(XYDotSize%[],temp[]);  'put actual rate into dot size variable 
        ArrMul(XYDotSize%,50/maxdot);   'multiply by factor to make max rate = 50
        printlog("Dotsize is %f\n",XYDotSize%);
        for j% := 0 to tunXYPosNXSteps% do
            for k% := 0 to tunXYPosNYSteps% do
                View(TuningWindow%[i%]).XYDrawMode(count%+1,2,XYDotSize%[count%-1]);  'set size of dots to proper size, I'm not sure why channel has to be count+1...?
                count% += 1;
            next;
        next;
    endif;

    'end;
end;


proc PlotSpikes(t1, t2, vOnOff%, x, index%)
	var rate;
    var i%;
    var tSweep;
    var fftData[16];        ' size of this array should be same as number of bins!
    
 '   x := tunValues[tunValuesIndices%[nTrials%]];
 '   ind% := tunValuesIndices%[nTrials%];
    
	for i% := 0 to tunNWavemarks%-1 do
		rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
		if rate >= 0 then
			if vOnOff% = 1 then
				' this is signal
                'PrintLog("%d Count %f\n", i%, rate*(t2-t1));
				View(TuningWindow%[i%]).XYAddData(1, x, rate);    ' channel 1 is data; channel 2 is background
			endif
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	    endif 
        
        if tunDoF12% = 1 and vOnOff% = 1 then
            ' Process for each cycle of the stimulus. A single cycle of the stim takes 1/tf
			View(PSTHWindow%[i%]);
			Process(t1, t2, 1, 1);
			for tSweep := t1+1/tunTF to t2-1/tunTF step 1/tunTF do 
				Process(tSweep, tSweep+1/tunTF, 0, 1);
			next
			ArrConst(fftData[], View(PSTHWindow%[i%]).[]);
			ArrFFT(fftData[], 4); 
            View(TuningWindow%[i%]).XYAddData(2, x, fftData[1]);
            View(TuningWindow%[i%]).XYAddData(3, x, fftData[2]);
            tunF1Sum[i%][index%] += fftData[1];
            tunF2Sum[i%][index%] += fftData[2];
        endif
        
	next
end;


proc PlotSpikes2TunCurves(t1, t2, vOnOff%, x, yind%)
	var rate;
    var i%;
        
	for i% := 0 to tunNWavemarks%-1 do
		rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
		if rate >= 0 then
			if vOnOff% = 1 then  'This apparently allows us to not update if we call the update function...weird...no matter, as it's hard coded to 1 in the call.
				' this is signal
                'PrintLog("%d Count %f\n", i%, rate*(t2-t1));
				View(TuningWindow%[i%]).XYAddData(yind%+1, x, rate);    'will plot different-colored "lines" based on yind% (I hope), must add 1 to yind% because first chan in XYplot is 1, not 0
			endif
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	    endif 
	next
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end





proc InitializeWindows()
    var i%;
    var WindowStep;
    var ch1%, ch2%;
    
    ' Get tf of stim
    tunTF := GetStimulusTF();
    
    ' Make spike2 use all of monitor 1
    View(App()).Window(0, 0, 100, 100, 1);
    
	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(0,48,50,95);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);
    
	' open xy window to display tuning results    
    if tunNWavemarks% > 0 then
        WindowStep := 100/tunNWavemarks%;
    endif
    for i% := 0 to tunNWavemarks%-1 do
        TuningWindow%[i%] := FileNew(12);
        Window(50, i%*WindowStep, 100, (i%+1)*WindowStep);
        ChanTitle$(0, "Spikes/s");
        TuningCurveLabels(tunWavemarkPorts%[i%]);
        WindowVisible(1);
        
        ' Create psth window if f1 and f2 analysis needed
        if tunDoF12% = 1 then
            
            ch1% := View(TuningWindow%[i%]).XYSetChan(0);   ' Used to plot f1
            XYColour(ch1%, 25);
            ch2% := View(TuningWindow%[i%]).XYSetChan(0);   ' used to plot f2
            XYColour(ch2%, 30);
            LogStatus("InitializeWindows", "Channel " + str$(i%+1) + " " + str$(ch1%) + " " + str$(ch2%));
            PSTHWindow%[i%] := View(DataWindow%).SetPSTH(i%+1, 16, 1 /(tunTF*16), 0, 0, 3);
            View(PSTHWindow%[i%]).WindowVisible(0);
        endif        
    next

	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 50, 47);
	XYColour(1,16);
	XYSize(1,-1);


	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iStimWindowChannel% := XYSetChan(0);
	XYColour(2,13);
	XYDrawMode(2,2,1);
	XYJoin(2,1);
	'Draw the fixation window
	XYAddData(2, FixWindowX[], FixWindowY[]);

	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);

	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(4,13);
	XYDrawMode(4,3,1);
	XYJoin(4,2);
	XYAddData(4,-9,-7);
	XYAddData(4,9,-7);
	XYAddData(4,9,7);
	XYAddData(4,-9,7);

end;

proc TuningCurveLabels(iport%)
    
    var i%;  'looping variables to set XY channels for XY position tuning plot
    var j%;
    var count%;
    
    var s$;
    s$ := "Port " + str$(iport%);
	docase
        
    case tunType$ = tunTypeDots$ then
        
        WindowTitle$("Dots, Orientation Tuning - " + s$);
        XUnits$("Orientation (degrees)");
        ChanTitle$(1, "Chan 1");
        XRange(tunDotsMinOrientation, tunDotsMaxOrientation);
        
    case tunType$ = tunTypeContrast$ then
        
        WindowTitle$("Contrast Tuning - " + s$);
        XUnits$("Contrast (%)");
        ChanTitle$(1, "Chan 1");
        XRange(tunContrastMinContrast, tunContrastMaxContrast);
        
    case tunType$ = tunTypeOrientation$ then
        
        WindowTitle$("Orientation Tuning - " + s$);
        XUnits$("Orientation (degrees)");
        ChanTitle$(1, "Chan 1");
        XRange(tunOriMinOrientation, tunOriMaxOrientation);
        
    case tunType$ = tunTypeSpatial$ then
        
        WindowTitle$("Spatial Frequency Tuning - " + s$);
        XUnits$("Spatial Frequency");
        ChanTitle$(1, "Chan 1");
        XRange(tunSpatialMinSF, tunSpatialMaxSF);
        
    case tunType$ = tunTypeTemporal$ then
        
        WindowTitle$("Temporal Frequency Tuning - " + s$);
        XUnits$("Temporal Frequency");
        ChanTitle$(1, "Chan 1");
        XRange(tunTemporalMinTF, tunTemporalMaxTF);
        
    case tunType$ = tunTypeArea$ then
        
        WindowTitle$("Aperture Area Tuning - " + s$);
        XUnits$("Aperture Diameter");
        ChanTitle$(1, "Chan 1");
        XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
    case tunType$ = tunTypeXPos$ then
        
        WindowTitle$("X Position Tuning - " + s$);
        XUnits$("X Position");
        ChanTitle$(1, "Chan 1");
        XRange(tunXPosMinXPos, tunXPosMaxXPos);
        
    case tunType$ = tunTypeXYPos$ then
        
        WindowTitle$("XY Position Tuning - " + s$);
        XTitle$("X Position");
        ChanTitle$(0,"Y Position");  'Not an intuitive way to change the y title: ChanTitle$(0,...)
        XRange(tunXYPosMinXPos-1, tunXYPosMaxXPos+1);
        YRange(-1,tunXYPosMinYPos-1, tunXYPosMaxYPos+1);  'again, X and Y not the same.  Grr.  -1 for all channels
        'set up channels, one for each point in the grid
        for i% := 0 to tunXYPosNXSteps% do
            for j% := 0 to tunXYPosNYSteps% do
                count% := XYSetChan(0,1); 'create a channel with only one data point, return
                XYAddData(count%,tun1Values[i%],tun2values[j%]);  'put in a data point at the correct x,y coordinate
                XYDrawMode(count%,1,0);  'set draw mode to dots
                XYDrawMode(count%,2,5);  'set size of dots to invisible, will change later
            next;
        next;
        
        
    case tunType$ = tunTypeDisparity$ then
        
        WindowTitle$("Disparity Tuning - " + s$);
        XUnits$("Disparity (deg)");
        ChanTitle$(1, "Chan 1");
        XRange(2*tunDisparityCenterXPos-tunDisparityMaxXPos, tunDisparityMaxXPos);
        
    case tunType$ = tunTypeDonut$ then
        
        WindowTitle$("Donut Area Tuning - " + s$);
        XUnits$("Outer Diameter");
        ChanTitle$(1, "Chan 1");
        XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
    case tunType$ = tunTypeBerliner$ then
        
        WindowTitle$("Berliner Procedure - " + s$);
        XUnits$("Stim Type");
        ChanTitle$(1, "Chan 1");
        XRange(0,5);
        
    case tunType$ = tunTypeBoxODonuts$ then  
        
        WindowTitle$("Box O' Donuts Procedure - " + s$);
        docase
        case tunType1$ = tunTypeContrast$ then
            XUnits$("Contrast (%)");
            XRange(tunContrastMinContrast, tunContrastMaxContrast);
        case tunType1$ = tunTypeOrientation$ then
            XUnits$("Orientation (degrees)");
            XRange(tunOriMinOrientation, tunOriMaxOrientation);
        case tunType1$ = tunTypeSpatial$ then
            XUnits$("Spatial Frequency");
            XRange(tunSpatialMinSF, tunSpatialMaxSF);
        case tunType1$ = tunTypeTemporal$ then
            XUnits$("Temporal Frequency");
            XRange(tunTemporalMinTF, tunTemporalMaxTF);
        case tunType1$ = tunTypeArea$ then
            XUnits$("Aperture Diameter");
            XRange(tunAreaMinDiam, tunAreaMaxDiam);
        case tunType1$ = tunTypeXPos$ then
            XUnits$("X Position");
            XRange(tunXPosMinXPos, tunXPosMaxXPos);
        endcase
        ChanTitle$(1, "Chan 1");
        
    case tunType$ = tunTypeCRG$ then  'I don't know if Ben will use this much, I'm going to go rogue and use the SECOND (tuning curve) for the X axis
        
        WindowTitle$("Contrast Reversing Grating Procedure - " + s$);
        docase
        case tunType1$ = tunTypeContrast$ then  'note that here tunType1$ is the SECOND...
            XUnits$("Contrast (%)");
            XRange(tunContrastMinContrast, tunContrastMaxContrast);
        case tunType1$ = tunTypeOrientation$ then
            XUnits$("Orientation (degrees)");
            XRange(tunOriMinOrientation, tunOriMaxOrientation);
        case tunType1$ = tunTypeSpatial$ then
            XUnits$("Spatial Frequency");
            XRange(tunSpatialMinSF, tunSpatialMaxSF);
        case tunType1$ = tunTypeTemporal$ then
            XUnits$("Temporal Frequency");
            XRange(tunTemporalMinTF, tunTemporalMaxTF);
        case tunType1$ = tunTypeArea$ then
            XUnits$("Aperture Diameter");
            XRange(tunAreaMinDiam, tunAreaMaxDiam);
        case tunType1$ = tunTypeXPos$ then
            XUnits$("X Position");
            XRange(tunXPosMinXPos, tunXPosMaxXPos);
        case tunType1$ = tunTypeBlank$ then
            XUnits$("Blank");
            XRange(-1, 1);
        case tunType1$ = tunTypeGratingOnly$ then
            XUnits$("Grating Off(0)/On(100)");
            XRange(0, 100);
        case tunType1$ = tunTypeCRG$ then
            XUnits$("CRG Secondary Off(0)/On(1)");
            XRange(0, 1);
        endcase
        ChanTitle$(1, "Chan 1");
        
    else
        
        Message("TuningCurveLabels Error - unknown value for tunType$: " + tunType$);
        
	endcase;
    
end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;
    var temp1$;
    var temp2$;
    var key$;
	SampleClear(); 'Set standard sampling state
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    
    docase
        
    case tunType$ = tunTypeDots$ then 
        'SampleAutoName$(dataCellName$ + "_dots_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_dots_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_dotMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "dot");
        endif;
        tunNAdvances% := tunDotsNSteps%;
        tunNRepeats% := tunDotsNRepeats%;
        GetRepeatedParameterProgression%(tunDotsNSteps%+1, tunDotsNRepeats%, tunValues[], tunValuesIndices%[], tunDotsMinOrientation, tunDotsMaxOrientation, 0, tunDotsProgression%);  'Note - linear spacing for orientation, not log
        tunNValues% := (tunDotsNSteps%+1)*tunDotsNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);        
    case tunType$ = tunTypeContrast$ then 
        'SampleAutoName$(dataCellName$ + "_con_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_con_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_conMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "con");
        endif;
        tunNAdvances% := tunContrastNSteps%;  'this...
        tunNRepeats% := tunContrastNRepeats%; '...and this are only used in a printlog statement
        GetRepeatedParameterProgression%(tunContrastNSteps%+1, tunContrastNRepeats%, tunValues[], tunValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, tunContrastProgression%);
        tunNValues% := (tunContrastNSteps%+1)*tunContrastNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeOrientation$ then 
        'SampleAutoName$(dataCellName$ + "_ori_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_ori_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_oriMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "ori");
        endif;
        tunNAdvances% := tunOriNSteps%;
        tunNRepeats% := tunOriNRepeats%;
        GetRepeatedParameterProgression%(tunOriNSteps%+1, tunOriNRepeats%, tunValues[], tunValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, tunOriProgression%);  'Note - linear spacing for orientation, not log
        tunNValues% := (tunOriNSteps%+1)*tunOriNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeSpatial$ then 
        'SampleAutoName$(dataCellName$ + "_spa_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_spa_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_spaMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "spa");
        endif;
        tunNAdvances% := tunSpatialNSteps%;
        tunNRepeats% := tunSpatialNRepeats%;
        GetRepeatedParameterProgression%(tunSpatialNSteps%+1, tunSpatialNRepeats%, tunValues[], tunValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, tunSpatialProgression%);        
        tunNValues% := (tunSpatialNSteps%+1)*tunSpatialNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeTemporal$ then 
        'SampleAutoName$(dataCellName$ + "_tem_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_tem_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_temMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "tem");
        endif;
        tunNAdvances% := tunTemporalNSteps%;
        tunNRepeats% := tunTemporalNRepeats%;
        GetRepeatedParameterProgression%(tunTemporalNSteps%+1, tunTemporalNRepeats%, tunValues[], tunValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 1, tunTemporalProgression%);
        tunNValues% := (tunTemporalNSteps%+1)*tunTemporalNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeArea$ then 
        'SampleAutoName$(dataCellName$ + "_area_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_area_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_areMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "are");
        endif;
        tunNAdvances% := tunAreaNSteps%;
        tunNRepeats% := tunAreaNRepeats%;
        GetRepeatedParameterProgression%(tunAreaNSteps%+1, tunAreaNRepeats%, tunValues[], tunValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
        tunNValues% := (tunAreaNSteps%+1)*tunAreaNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeXPos$ then 
        'SampleAutoName$(dataCellName$ + "_xpos_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_xpos_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_xpsMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "xps");
        endif;
        tunNAdvances% := tunXPosNSteps%;
        tunNRepeats% := tunXPosNRepeats%;
        GetRepeatedParameterProgression%(tunXPosNSteps%+1, tunXPosNRepeats%, tunValues[], tunValuesIndices%[], tunXPosMinXPos, tunXPosMaxXPos, 0, tunXPosProgression%);  'Note - linear spacing for position, not log
        tunNValues% := (tunXPosNSteps%+1)*tunXPosNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);   
    case tunType$ = tunTypeXYPos$ then 
        'SampleAutoName$(dataCellName$ + "_xypos_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_xypos_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_xypMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "xyp");
        endif;
        'for tun1, use X
        if tunXYPosNXSteps% = 0 then  'this allows for no x movement
            tun1Values[0] := tunXYPosMinXPos;
            tun1ValuesIndices%[0] := 1;
        else
            GetRepeatedParameterProgression%(tunXYPosNXSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunXYPosMinXPos, tunXYPosMaxXPos, 0, 0);
        endif;
        tun1NValues% := (tunXYPosNXSteps%+1);
        
        'for tun2, use Y
        if tunXYPosNYSteps% = 0 then  'this allows for no y movement
            tun2Values[0] := tunXYPosMinYPos;
            tun2ValuesIndices%[0] := 1;
        else
            GetRepeatedParameterProgression%(tunXYPosNYSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunXYPosMinYPos, tunXYPosMaxYPos, 0, 0);
        endif;
        tun2NValues% := (tunXYPosNYSteps%+1);       
        
        tunNRepeats% := tunXYPosNRepeats%;   
        tunNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
        tunNValues% := tun1NValues%*tun2NValues%*tunXYPosNRepeats%;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
        
        'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
        GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],tunXYPosProgression%,tunXYPosNRepeats%);         
        
        'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
        tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunXYPosNRepeats%, tun1Values[], tun1ValuesIndices%[]);
        tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunXYPosNRepeats%, tun2Values[], tun2ValuesIndices%[]);
        
        printlog("X values are %s\n",tun1ValuesStringified$);
        printlog("Y values are %s\n",tun2ValuesStringified$);
        tunValuesStringified$ := InterleaveStrings$(tun1ValuesStringified$,tun2ValuesStringified$);
        printlog("XY values are %s\n",tunValuesStringified$);
        
    case tunType$ = tunTypeDisparity$ then 
        'SampleAutoName$(dataCellName$ + "_disprity_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_disprity_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_disMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "dis");
        endif;
        tunNAdvances% := tunDisparityNSteps%;
        tunNRepeats% := tunDisparityNRepeats%;
        GetRepeatedSymmetricParameterProgression%(tunDisparityNSteps%+1, tunDisparityNRepeats%, tunValues[], tunValuesIndices%[], tunDisparityCenterXPos, tunDisparityMaxXPos, 0, tunDisparityProgression%);  'linear spacing only
        'GetRepeatedSymmetricParameterProgression%(tunDisparityNSteps%+1, tunDisparityNRepeats%, tunValues[], tunValuesIndices%[], tunDisparityCenterXPos, tunDisparityMaxXPos, 1-tunDisparityLinear%, tunDisparityProgression%);  'allow log spacing
        tunNValues% := (2*tunDisparityNSteps%+1)*tunDisparityNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);         
    case tunType$ = tunTypeDonut$ then 
        'SampleAutoName$(dataCellName$ + "_donut_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_donut_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_donMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "don");
        endif;
        tunNAdvances% := tunAreaNSteps%;
        tunNRepeats% := tunAreaNRepeats%;
        GetRepeatedParameterProgression%(tunAreaNSteps%+1, tunAreaNRepeats%, tunValues[], tunValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunDonutProgression%);
        tunNValues% := (tunAreaNSteps%+1)*tunAreaNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
        'PrintLog("nsteps %d nrepeats %d nvalues %d\n", tunAreaNSteps%, tunAreaNRepeats%, tunNValues%);
        'for i% := 0 to tunNValues%-1 do
        '    PrintLog("%d %f\n", i%, tunValues[tunValuesIndices%[i%]]);
        'next
    case tunType$ = tunTypeBerliner$ then 
        'SampleAutoName$(dataCellName$ + "_berliner_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_berliner_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_berMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "ber");
        endif;
        tunNAdvances% := tunBerlinerNSteps%-1;  'subtract one because tunBerlinerNSteps% is literal (that is, n stims)
        tunNRepeats% := tunBerlinerNRepeats%;
        GetRepeatedParameterProgression%(tunBerlinerNSteps%, tunBerlinerNRepeats%, tunValues[], tunValuesIndices%[], 1, tunBerlinerNSteps%, 0, tunBerlinerProgression%);
        tunNValues% := (tunBerlinerNSteps%)*tunBerlinerNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeBoxODonuts$ then
        
        'here we can do a GRPP for each of the two tuning curves (using one repeat, one repeat only) to get the values
        'then we have to randomize (or not) before stringifying
        docase
        case tuntype1$ = tunTypeContrast$ then
            GetRepeatedParameterProgression%(tunContrastNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, 0);
            tun1NValues% := (tunContrastNSteps%+1);
            temp1$ := "_con";
        case tuntype1$ = tunTypeOrientation$ then
            GetRepeatedParameterProgression%(tunOriNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, 0); 
            tun1NValues% := (tunOriNSteps%+1);    
            temp1$ := "_ori";            
        case tuntype1$ = tunTypeSpatial$ then
            GetRepeatedParameterProgression%(tunSpatialNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, 0);
            tun1NValues% := (tunSpatialNSteps%+1);
            temp1$ := "_spa";
        case tuntype1$ = tunTypeTemporal$ then
            GetRepeatedParameterProgression%(tunTemporalNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 1, 0);
            tun1NValues% := (tunTemporalNSteps%+1);
            temp1$ := "_tem";
        case tuntype1$ = tunTypeArea$ then
            GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
            tun1NValues% := (tunAreaNSteps%+1);
            temp1$ := "_area";
        case tuntype1$ = tunTypeXPos$ then
            GetRepeatedParameterProgression%(tunXPosNSteps%+1, 1, tun1Values[], tun1ValuesIndices%[], tunXPosMinXPos, tunXPosMaxXPos, 0, 0);
            tun1NValues% := (tunXPosNSteps%+1);
            temp1$ := "_xpos";
        endcase;
        
        docase
        case tuntype2$ = tunTypeContrast$ then
            GetRepeatedParameterProgression%(tunContrastNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, 0);
            tun2NValues% := (tunContrastNSteps%+1); 
            temp2$ := "_con";
        case tuntype2$ = tunTypeOrientation$ then
            GetRepeatedParameterProgression%(tunOriNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, 0);
            tun2NValues% := (tunOriNSteps%+1);  
            temp2$ := "_ori";            
        case tuntype2$ = tunTypeSpatial$ then
            GetRepeatedParameterProgression%(tunSpatialNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, 0);
            tun2NValues% := (tunSpatialNSteps%+1);
            temp2$ := "_spa";
        case tuntype2$ = tunTypeTemporal$ then
            GetRepeatedParameterProgression%(tunTemporalNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 1, 0);
            tun2NValues% := (tunTemporalNSteps%+1);
            temp2$ := "_tem";
        case tuntype2$ = tunTypeArea$ then
            GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
            tun2NValues% := (tunAreaNSteps%+1);
            temp2$ := "_area";
        case tuntype2$ = tunTypeXPos$ then
            GetRepeatedParameterProgression%(tunXPosNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunXPosMinXPos, tunXPosMaxXPos, 0, 0);
            tun2NValues% := (tunXPosNSteps%+1);
            temp2$ := "_xpos";
        endcase;
        
        'SampleAutoName$(dataCellName$ + "_boxodonuts" + temp1$ + temp2$ + "_000");        
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_boxodonuts" + temp1$ + temp2$ + "_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_boxodonuts" + temp1$ + temp2$ + "MICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "_boxodonuts" + temp1$ + temp2$);  'this is too long and shouldn't work, but it's always been like this and Ben hasn't complained...
        endif;
        
        tunNRepeats% := tunBoxODonutsNRepeats%;   
        tunNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
        tunNValues% := tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
        
        'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
        GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],tunBoxODonutsProgression%,tunBoxODonutsNRepeats%); 
        
        'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
        tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%, tun1Values[], tun1ValuesIndices%[]);
        tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunBoxODonutsNRepeats%, tun2Values[], tun2ValuesIndices%[]);
    case tunType$ = tunTypeCRG$ then
        
        'GetRepeatedParameterProgression%(n%, nr%, result[], indices%[], firstval, lastval, ilog%, irandom%)
        'Generate one list for the CRG on the "main" (rather than master/slave) screen
        GetRepeatedParameterProgression%(tunCRGNSeq1%,1,tun1Values[],tun1ValuesIndices%[],0,tunCRGNSeq1%-1,0,tunCRGProgression%);
        tun1NValues% := tunCRGNSeq1%;
        
        'Generate a second list for the tuning curve on the "secondary" (rather than master/slave) screen
        'Note the ugly mix of tuntype1$, temp2$, and tun2NValues%, etc., and then try to forget about it.  Not worth fixing.
        'All of these are the same as for Box O' Donuts except for CRG2, Blank (Static is treated as contrast)
        docase
        case tuntype1$ = tunTypeContrast$ then
            GetRepeatedParameterProgression%(tunContrastNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, 0);
            tun2NValues% := (tunContrastNSteps%+1); 
            temp2$ := "_con";
        case tuntype1$ = tunTypeOrientation$ then
            GetRepeatedParameterProgression%(tunOriNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, 0);
            tun2NValues% := (tunOriNSteps%+1);  
            temp2$ := "_ori";            
        case tuntype1$ = tunTypeSpatial$ then
            GetRepeatedParameterProgression%(tunSpatialNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, 0);
            tun2NValues% := (tunSpatialNSteps%+1);
            temp2$ := "_spa";
        case tuntype1$ = tunTypeTemporal$ then
            GetRepeatedParameterProgression%(tunTemporalNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 1, 0);
            tun2NValues% := (tunTemporalNSteps%+1);
            temp2$ := "_tem";
        case tuntype1$ = tunTypeArea$ then
            GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
            tun2NValues% := (tunAreaNSteps%+1);
            temp2$ := "_area";
        case tuntype1$ = tunTypeXPos$ then
            GetRepeatedParameterProgression%(tunXPosNSteps%+1, 1, tun2Values[], tun2ValuesIndices%[], tunXPosMinXPos, tunXPosMaxXPos, 1, 0);
            tun2NValues% := (tunXPosNSteps%+1);
            temp2$ := "_xpos";
        case tuntype1$ = tunTypeBlank$ then
            tun2NValues% := 1;
            temp2$ := "_blank";
        case tuntype1$ = tunTypeGratingOnly$ then
            GetRepeatedParameterProgression%(2, 1, tun2Values[], tun2ValuesIndices%[], 0, 100, 0, 0);
            tun2NValues% := 2;
            temp2$ := "_grat";
        case tuntype1$ = tunTypeCRG$ then
            'OK, the trick here is going to be in the StringifyProgression, and not here
            GetRepeatedParameterProgression%(2, 1, tun2Values[], tun2ValuesIndices%[], 0, 100, 0, 0);
            tun2NValues% := 2;
            temp2$ := "_crg";
        endcase;
        
        'SampleAutoName$(dataCellName$ + "_crg" + temp2$ + "_000"); 
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_crg" + temp2$ + "_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_crg" + temp2$ + "MICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "_crg" + temp2$);  'this is too long and shouldn't work, but it's always been like this and Ben hasn't complained...
        endif;
        
        tunNRepeats% := tunCRGNRepeats%;
        tunNAdvances% := tun1NValues%*tun2NValues%-1;  'this gives the correct number of advances
        tunNValues% := tun1NValues%*tun2NValues%*tunCRGNRepeats%;  'now used in idle loop instead of (tunNAdvances%+1)*tunNRepeats
        
        'Now we need to grid the values out into two appropriate tunValues and tunValuesIndices (the randomizer bit)
        GridStimuli(tun1Values[],tun2Values[],tun1NValues%,tun2NValues%,tun1ValuesIndices%[],tun2ValuesIndices%[],tunCRGProgression%,tunCRGNRepeats%);
        
        'StringifyProgression$ will work just fine on tun1/2Values and tun1/2ValuesIndices
        tun1ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunCRGNRepeats%, tun1Values[], tun1ValuesIndices%[]);
        if tuntype1$ = tunTypeCRG$ then 'but we need to call a "special" stringify function if CRG on secondary screen
            tun2ValuesStringified$ := StringifyProgressionCRG2$(tun1NValues%*tun2NValues%*tunCRGNRepeats%, tun2Values[], tun2ValuesIndices%[], tun1Values[], tun1ValuesIndices%[]);
        else
            tun2ValuesStringified$ := StringifyProgression$(tun1NValues%*tun2NValues%*tunCRGNRepeats%, tun2Values[], tun2ValuesIndices%[]);
        endif;
    else    
        'SampleAutoName$(dataCellName$ + "_tun_000");
        if UsePlexon% = 0 then
            SampleAutoName$(dataCellName$ + "_tun_000");  'NOTE: maximum of 13 characters!!!
        else
            SampleAutoName$(dataCellName$ + "_tunMICRO_000");  'NOTE: maximum of 13 characters!!!
            SetStringRegistryValue(key$, "pref", "tun");
        endif;
    endcase;
    
    
    SampleAutoFile(1);
    
    ' Text marks make extraction easier
    SampleTextMark(200);  'Channel 30 is textmark channel
    
	'Channel recording definitions
	SampleEvent(FixationPointChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixpt");
	SampleTitle$(FixationPointChannel%,"Fixpt");
	
	SampleEvent(StimChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
    ' djs Add channels to capture slave fixpt and stim onset
	SampleEvent(FixationPointSlaveChannel%, 6, 2, 3600); 'Trigger channel, level
	SampleComment$(FixationPointSlaveChannel%,"Fixpt-Slave");
	SampleTitle$(FixationPointSlaveChannel%,"Fixpt-Slave");
	
	SampleEvent(StimSlaveChannel%, 7, 2,3600); 'Trigger channel, level
	SampleComment$(StimSlaveChannel%,"Stim-Slave");
	SampleTitle$(StimSlaveChannel%,"Stim-Slave");
    
	SampleEvent(FrameChannel%, 0, 2, 3600);
	SampleComment$(FrameChannel%,"Frame");
	SampleTitle$(FrameChannel%,"Frame");
    
	SampleEvent(FrameSlaveChannel%, 4, 2, 3600);
	SampleComment$(FrameSlaveChannel%,"Frame-Slave");
	SampleTitle$(FrameSlaveChannel%,"Frame-Slave");
    
    
    
    ' Set up channels for sampling electrodes.
    if UsePlexon% = 1 then  'call Plexon setup function, this will ONLY set up the sampling configuration for the Micro1401 mark II.  The Power1401 will be set up from its own dedicated script in its dedicated Spike2 instance
        CreatePlexonSamplingConfiguration1824Micro(); 'Note that for right now the ONLY Plexon configuration is 18 WaveMark/24 LFP (maximal WMs for 24 LFPs, trust me)
    else
        ' Electrodes: wavemark/continuous
        ' 12/6/2010
        ' Wavemark channels will be channels # 1-N, waveform N+1 - N+1+M, where there are N wavemark channels
        ' and M waveform channels. 
        for i% := 0 to tunNWavemarks%-1 do
            SampleWaveMark(i% + 1, tunWavemarkPorts%[i%], 2000, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
            SampleTitle$(i% + 1, "WMrk " + str$(tunWavemarkPorts%[i%])); 
        next
        for i% := 0 to tunNContinuous%-1 do
            SampleWaveform(tunNWavemarks% + i% + 1, tunContinuousPorts%[i%], 20000);
            SampleTitle$(tunNWavemarks% + i% + 1, "Cont " + str$(tunContinuousPorts%[i%]));
        next
    endif;
    
        
	SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
	SampleTitle$(YChannel%,"Eye Y");
    
	SampleSequencer(script$ + "Tuning.pls");
	if UsePlexon% = 1 then  'Set optimise mode (do this last, so it's outside of the CreatePlexonSamplingConfiguration... functions)
        SampleOptimise(0,1,4,0,0,0,0);  'for the Micro 1401 mk II: manually set sampling timing, group channels with same ideal rate, micro1401, unused, unused, do not disable for compatibility, no burst mode
    else
        SampleOptimise(2,2,2,2,50);  'otherwise: full optimize timing, channels may have different rates, Power1401 (lowest common denominator, so eh), low usPerTime of 2, high usPerTime of 50
    endif;
	SampleMode(1); 'Continuous sampling
end;

' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, j%, m%;
    var chanToExport%[30];
    var fn$;
    var mylen%;
    
	' Disable idle process func
	ToolbarSet(0,"");

	' Tell stim app to shut down
    SafeSampleKey("X");
	SafeSampleKey("Q");
	Yield(.1);
	SampleStop();

	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend
'	ProgRun(bin$ + "\\ClearTrigger",0);
    
    'For some reason, Tuning never had Matlab export set up before the Plexon update...
    View(DataWindow%);
    ExportChanList(); 
    chanToExport%[1] := 30;  'channels to export go in elements 1:...'30 is the textmark channel
    chanToExport%[2] := 31;  '31 is the keyboard channel
    if UsePlexon% = 1 then  'use hardcoded Plexon values - 18 WaveMarks and 24 LFPs for now, on the micro it's 
        for i% := 0 to 12 do
            chanToExport%[i%+3] := i%+1;  'wavemark channels are in order
        next;
        chanToExport%[0] := 2+i%;  'total number of channels goes in element 0
    else
        for i% := 0 to NumWavemarkPorts% do
            chanToExport%[i%+3] := i%+1;  'wavemark channels are in order
        next;
        chanToExport%[0] := 2+i%;  'total number of channels goes in element 0
    endif;
    
    ExportChanList(0,view(datawindow%).maxtime(),chanToExport%[]);
    
    'Code for putting other various channels into the Matlab extraction, Ben doesn't want them but they will be useful for other code    
    ExportChanList(0,maxtime(),XChannel%);  'Eye position channel, X
    ExportChanList(0,maxtime(),YChannel%);  'Eye position channel, Y
    'for i% := 0 to NumWavemarkPorts%-1 do
    '    ExportChanList(0,maxtime(),i%+1);  'Wavemark channel(s)
    'next;
    
    
    fn$ := FileName$();  'get current file name
    mylen% := Len(fn$);
    fn$ := Left$(fn$,mylen%-4);
    fn$ := fn$ + ".mat";
    FileSaveAs(fn$,100,0,"",0,"UseSName=0"); 'Do not overwrite the .mat file - should have a different name and if it doesn't that is a red flag    
    
    
    
    
	' Write parameter file
	WriteParameterFile();

	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
	TotalRewards% += nTrialsCompleted%;
	SaveDailyTotals();
    
    ' Figure out max F1 values
    if tunDoF12% = 1 then
        for i% := 0 to tunNWavemarks%-1 do
            m% := Max(tunF1Sum[i%][]);
            LogStatus("F1 Max", "Channel " + str$(i%+1) + " Port " + str$(tunWavemarkPorts%[i%]) + " max F1 at x=" + str$(tunValues[m%]));
        next
    endif    

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var tempPrimary$;
    var tempSecondary$;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	Print("Background color           : %s\n", tunBackgroundColor$);

	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);

	' write stimulus parameters
	var Tstimstr$;
	var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
    var phase;
    Print("\nStimulus\n");  'Master grating
	Print("-------------------\n\n");
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
    Print("Inner Width (degrees)           : %s\n", Tstimiw$);
	Print("Inner Height (degrees)          : %s\n", Tstimih$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    Print("Initial Phase (degrees)         : %f\n", phase);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
    
    if tunDoRivalry% = 1 then  'Do slave grating only if we're using it
        Print("\Slave Stimulus\n");  'Slave grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("SlaveStimulus");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        Print("Width (degrees)                 : %s\n", Tstimw$);
        Print("Height (degrees)                : %s\n", Tstimh$);
        Print("Inner Width (degrees)           : %s\n", Tstimiw$);
        Print("Inner Height (degrees)          : %s\n", Tstimih$);
        Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
        Print("Temporal frequency              : %s\n", Tstimtf$);
        Print("Spatial frequency               : %s\n", Tstimsf$);
        Print("Orientation (degrees)           : %s\n", Tstimorientation$);
        Print("Initial Phase (degrees)         : %f\n", phase);
        Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
        Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
        Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);  
    endif;        
    
    
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

	'Print("Fixation time(s)       : %f\n", tunFixationDuration);  'cleaning these up!
	'Print("Maintain fixation (s)  : %f\n", tunMaintainFixation);
	'Print("Time out (s)           : %f\n", tunTimeOutTime);
	'Print("Acquisition time (s)   : %f\n", tunAcquisitionTime);
    Print("Stimulus Duration(s)   : %f\n", tunFixationDuration);
	Print("Maintain fixation (s)  : %f\n", tunMaintainFixation);
	Print("Time out (s)           : %f\n", tunHoldFailTime);
	Print("Acquisition time (s)   : %f\n", tunAcquisitionTime);

	Print("\nTuning parameters\n");
	Print("-------------------\n\n");
	docase 
		case tunType$ = tunTypeContrast$ then

			Print("Type:                  : Contrast\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");


		case tunType$ = tunTypeOrientation$ then

			Print("Type:                  : Orientation\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeSpatial$ then

			Print("Type:                  : Spatial Frequency\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");
	
		case tunType$ = tunTypeTemporal$ then

			Print("Type:                  : Temporal Frequency\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeArea$ then

			Print("Type:                  : Aperture Area\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
            Print("\n");
        
        case tunType$ = tunTypeXPos$ then

			Print("Type:                  : X Position\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunXPosMinXPos, tunXPosMaxXPos, tunXPosNSteps%, tunXPosNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
            Print("\n");
        
        case tunType$ = tunTypeXYPos$ then

			Print("Type:                  : XY Position\n");
            Print("MinX,MaxX,#XSteps,#Repeats: %f,%f,%d,%d\n", tunXYPosMinXPos, tunXYPosMaxXPos, tunXYPosNXSteps%, tunXPosNRepeats%);
            Print("MinY,MaxY,#YSteps,#Repeats: %f,%f,%d,%d\n", tunXYPosMinYPos, tunXYPosMaxYPos, tunXYPosNYSteps%, tunXPosNRepeats%);
            Print("XValues: " + tun1ValuesStringified$ + "\n");
            Print("YValues: " + tun2ValuesStringified$ + "\n");
            Print("\n");        
        
        case tunType$ = tunTypeDisparity$ then

			Print("Type:                  : Disparity\n");
			Print("Center,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunDisparityCenterXPos, tunDisparityMaxXPos, tunDisparityNSteps%, tunDisparityNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeDonut$ then

			Print("Type:                  : Donut Area\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
            Print("\n");
        
        case tunType$ = tunTypeBerliner$ then

			Print("Type:                  : Berliner Area\n");
			Print("Optimal,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunDonutOptimalDiam, tunBerlinerMaximalDiam, tunBerlinerNSteps%, tunBerlinerNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");
        
        case tunType$ = tunTypeBoxODonuts$ then

			Print("Type:                  : Box O' Donuts\n");
			Print("#Repeats: %d\n", tunBoxODonutsNRepeats%);
            Print("\n");
            docase 
                case tunType1$ = tunTypeContrast$ then
            
                Print("Type 1:                  : Contrast\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
                Print("Values: " + tun1ValuesStringified$ + "\n");
                Print("\n");
            
            
                case tunType1$ = tunTypeOrientation$ then
            
                Print("Type 1:                  : Orientation\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
                Print("Values: " + tun1ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeSpatial$ then
            
                Print("Type 1:                  : Spatial Frequency\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
                Print("Values: " + tun1ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeTemporal$ then
            
                Print("Type 1:                  : Temporal Frequency\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
                Print("Values: " + tun1ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeArea$ then
            
                Print("Type 1:                  : Aperture Area\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
                Print("Values: " + tun1ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeXPos$ then
            
                Print("Type 1:                  : X Position\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunXPosMinXPos, tunXPosMaxXPos, tunXPosNSteps%, tunXPosNRepeats%);
                Print("Values: " + tun1ValuesStringified$ + "\n");
                Print("\n");
            endcase
        
            docase 
                case tunType2$ = tunTypeContrast$ then
                
                Print("Type 2:                  : Contrast\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
            
                case tunType2$ = tunTypeOrientation$ then
            
                Print("Type 2:                  : Orientation\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType2$ = tunTypeSpatial$ then
            
                Print("Type 2:                  : Spatial Frequency\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType2$ = tunTypeTemporal$ then
            
                Print("Type 2:                  : Temporal Frequency\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType2$ = tunTypeArea$ then
            
                Print("Type 2:                  : Aperture Area\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
                
                case tunType2$ = tunTypeXPos$ then
            
                Print("Type 2:                  : X Position\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunXPosMinXPos, tunXPosMaxXPos, tunXPosNSteps%, tunXPosNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            endcase
        
        case tunType$ = tunTypeCRG$ then

			Print("Type:                  : Contrast Reversing Grating\n");
			Print("#Repeats: %d\n", tunCRGNRepeats%);
            Print("\n");
        
            if tunCRGOnSlave% = 0 then
                tempPrimary$ := "Master";
                tempSecondary$ := "Slave";
            else
                tempPrimary$ := "Slave";
                tempSecondary$ := "Master";
            endif;
        
                Print(tempPrimary$ + ":                  : CRG\n");
                Print("FramesPerFlip,#Repeats: %d,%d\n", tunCRGFramesPerFlip%, tunCRGNRepeats%);
                Print("SEQFile: " + tunCRGSeqFile$ + "\n");
                Print("Values: " + tun1ValuesStringified$ + "\n");
                Print("\n");        
        
            docase 
                case tunType1$ = tunTypeContrast$ then
            
                Print(tempSecondary$ + ":                  : Contrast\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
            
                case tunType1$ = tunTypeOrientation$ then
            
                Print(tempSecondary$ + ":                  : Orientation\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeSpatial$ then
            
                Print(tempSecondary$ + ":                  : Spatial Frequency\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeTemporal$ then
            
                Print(tempSecondary$ + ":                  : Temporal Frequency\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeArea$ then
            
                Print(tempSecondary$ + ":                  : Aperture Area\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeXPos$ then
            
                Print(tempSecondary$ + ":                  : X Position\n");
                Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunXPosMinXPos, tunXPosMaxXPos, tunXPosNSteps%, tunXPosNRepeats%);
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeBlank$ then
            
                Print(tempSecondary$ + ":                  : Blank\n");
                Print("\n");
            
                case tunType1$ = tunTypeGratingOnly$ then
            
                Print(tempSecondary$ + ":                  : Grating Only\n");
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
                case tunType1$ = tunTypeCRG$ then
            
                Print(tempSecondary$ + ":                  :CRG\n");
                Print("SEQFile: " + tunCRGSeqFile2$ + "\n");
                Print("Values: " + tun2ValuesStringified$ + "\n");
                Print("\n");
            
            endcase
        
        case tunType$ = tunTypeDots$ then
        
			Print("Type:                  : Dots\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunDotsMinOrientation, tunDotsMaxOrientation, tunDotsNSteps%, tunDotsNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");
		else

			Print("TuningCurve Error - unknown value for tunType$: %s\n", tunType$);

	endcase;

	' close parfile
	FileClose(0);

end;


' Gets the temporal freq of the current stimulus. 
' Make sure to call this only after all user dialogs have been completed (so you know that the stim parameters will not change)

func GetStimulusTF()
    var gr$;
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var cv$, pattern$, aperture$;
	gr$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    LogStatus("GetStimulusTF", "TF=" + str$(tf));
    return tf;
end


func StartPlexon%()
    
    
    'Start the Power1401!  This is a bit cumbersome, and I'm not sure it's transferable, but it's a start, perhaps.
    var fp$;  'to hold current file path
    var fp2$;  'to hold destination file path
    fp$ := FilePath$();  'get current file path
    printlog("%s\n",fp$);  'and tell the world what it was
    FilePathSet("F:/work/AlertRig/Spike2Scripts");  'change the file path
    fp2$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp2$);  'by telling the world about it (hint: it works)
    
    progrun("sonview.exe /M /u2 SetPlexonRecording1824OnPower1401.s2s");  'run the program, .s2s file is now on default path by design
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar, this may not work
    
    
    
    'These two functions are not done before initializing the toolbar in dual-1401 mode
    CreateSampleConfiguration();

    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar
    
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var cmdLine$;
    var Opener$;
    var ProgName$;
    var XHairArg$:="";  'Note that all variables are used to construct cmdLine$, if unused, must be empty
    var BGColor$;
    var Dist2Screen$;
    var TriggerPort$;
    var Verbose$:=" -v ";  'For now, verbose is always on
    var RefrLock$:="";
    var OffsetFile$:="";
    var StimDur$:="";
    var MGrat$:=" -s ";
    var SGrat$:=" -s ";
    var MGratParam$:="";
	var SGratParam$:="";
    var MasterIndicator$:="";  'Do not use Master Indicator
    var SlaveIndicator$:="";  'or Slave Indicator for fixstim, set if needed
    var KlugeArg$:=" -H ";  'this is for a Jerry-rigged "hole" in Box O' Donuts slave stimuli 
    var MValues$:="";
    var SValues$:="";   
    var S2Values$:="";  'won't be used except for Box O' Donuts 
    var KlugeValues$:="";  'this is for a Jerry-rigged "hole" in Box O' Donuts slave stimuli
    var key$;
    var i%;
    'var CRGPrimaryArg$;  'This is always "-R", hard code
    var CRGPrimaryValues$;
    var CRGSecondaryArg$;
    var CRGSecondaryValues$;
    
    
    
	
	'start sampling
    if UsePlexon% = 1 then
        SampleStart(1);  'set sampling to start on a trigger
    else
    	SampleStart(0); 'Start sampling now
    endif;
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    
    
    
    'Begin building the command line argument
    Opener$ := "cmd /k " + bin$;
    
    'Get grating parameters, do this first so we can clear the SGratParam$ if Slave monitor is unused
    if tunSetStationary% = 0 then
        ' Stimulus is always used
        MGratParam$ := GetGratingParameters$("Stimulus");
        ' Slave Stimulus is not always used, but get it anyway
        SGratParam$ := GetGratingParameters$("SlaveStimulus");
    else
        ' Stimulus is always used
        MGratParam$ := GetGratingParameters$("StatStimulus");
        ' Slave Stimulus is not always used, but get it anyway
        SGratParam$ := GetGratingParameters$("StatSlaveStimulus");
    endif;    
    
    'Set rivalry options
    if tunDoRivalry% = 0 then
        RefrLock$ := "";  'do not lock frame refresh
        ProgName$ := "\\fixstim.exe "; 'set program name for one VSG
        
        'I don't really like doing this (in principle these should start empty and be filled if they are being
        'used), but I'd have to do another "if tunSetStationary" statement, so this cuts down on total code
        SGrat$ := "";  'clear Slave grating indicator, we won't use it
        SGratParam$ := "";  'clear slave grating parameters, we won't use them
        
    else  'for rivalry (dualstim.exe), we need some extra commands that must be empty for a fixstim.exe call
        if tunNoCardSync% = 0 then
            RefrLock$ := " -K ";  'lock frame refresh on the two screens
        else
            RefrLock$ := "";  'do not lock frame refresh on the two screens
        endif;
        
        ProgName$ := "\\dualstim.exe "; 'set program name for dual VSG
        
        ' Fetch the offset filename
        key$ := GetRegistryKey$(1) + "\\Rivalry";
        OffsetFile$ := GetStringRegistryValue$(GetRegistryKey$(1), "OffsetFile", "file_not_found");
        OffsetFile$ := " -r " + OffsetFile$;
        
        ' Fetch the stimulus duration (in dualstim, stimoff is done by counting frames because of VSG frame synching)
        StimDur$ := " -t " + Str$(tunFixationDuration) + " ";  'add stimulus duration in seconds
        
        ' Set monitor indicators, required for Dualstim
        MasterIndicator$ := " -M ";  'master monitor indicator
        SlaveIndicator$ := " -V ";  'slave monitor indicator
    endif;
    
    'Fixation arguments are set by UsreyFixationPoint.s2s and need not be done here
    
    'Set crosshair options, if required
    'if tunUseXHairs% = 1 and (tunType$ = tunTypeBerliner$ or tunType$ = tunTypeDonut$) then 'Construct command line with crosshair argument, only for DUALSTIM, FIXSTIM won't do this (but now anything can be dualstim)
    if tunUseXHairs% = 1 and (tunDoRivalry% > 0) then 'Construct command line with crosshair argument, only for DUALSTIM, FIXSTIM won't do this
        'split XHairArg$ construction into two lines due to length
        'Note that XHair flag has changed to "-h" (from "-X") as of 1-20-12 jj
        XHairArg$ := " -h " + Str$(FixationX) + "," + Str$(FixationY) + "," + Str$(tunXHairInnerRadiusOffset) + "," + Str$(tunXHairMiddleRadiusOffset) + ","; 
        XHairArg$ := XHairArg$ + Str$(tunXHairOuterRadiusOffset) + "," + Str$(tunXHairNumGridDivisions%) + "," + Str$(tunXHairTicInnerOffset) + "," + Str$(tunXHairTicOuterOffset) + " ";
    endif;
    
    'Set background color
    BGColor$ := " -b " + tunBackgroundColor$;
    
    'Set distance to screen
    Dist2Screen$ := " -d " + GetDistanceToScreenMM$();
    
    'Set trigger port
    TriggerPort$ := " -p 2 ";  'This one's hard-coded for now
    
    'Turn on verbose
    Verbose$ := " -v ";
     
    'Get default tuning curve values - these may get changed!
    MValues$ := tunValuesStringified$;  
    
    'Run a case statement to do tuning-curve-specific stuff, this is simple except for Donuts, etc.
	docase 
    case tunType$ = tunTypeContrast$ then
        TunCurveMArg$ := " -C ";
        
        if tunDoRivalry% = 1 then
            TunCurveSArg$ := " -C ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;

    case tunType$ = tunTypeOrientation$ then
        TunCurveMArg$ := " -O ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ := " -O ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;

    case tunType$ = tunTypeSpatial$ then
        TunCurveMArg$ := " -S ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ := " -S ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;

    case tunType$ = tunTypeTemporal$ then
        TunCurveMArg$ := " -T ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ := " -T ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;

    case tunType$ = tunTypeArea$ then
        TunCurveMArg$ := " -A ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ :="  -A ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;
        
    case tunType$ = tunTypeXPos$ then
        TunCurveMArg$ := " -X ";

        if tunDoRivalry% = 1 then
            TunCurveSArg$ :="  -X ";  'Set slave to run same tuning curve...
            SValues$ := MValues$;  '...with same values as Master tuning curve
            'based on tunDualTuningType%, allows dual to produce tuning curve on both, only master, or only slave
            ClearMasterOrSlaveIfNecessary(SGrat$,SGratParam$,SlaveIndicator$,TunCurveSArg$,SValues$,MGrat$,MGratParam$,MasterIndicator$,TunCurveMArg$,MValues$);  
        endif;
        
    case tunType$ = tunTypeXYPos$ then
        tunCurveMArg$ := " -Z ";
        'tunDoRivalry cannot be 1 in this case because dualstim does not have this function
        
    case tunType$ = tunTypeDisparity$ then
        if tunDisparityOnMaster% = 1 then
            TunCurveMArg$ := " -X "; 'do disparity by moving master
            SGrat$ := " -g ";  'Change slave grating variable to -g because it doesn't change
            TunCurveSArg$ := "";  'clear the slave tuning curve argument
            SValues$ := "";  'clear the slave tuning curve values 
        else
            TunCurveSArg$ := " -X "; 'do disparity by moving slave
            SValues$ := MValues$;  'get values from "Master" tuning curve (assigned earlier)
            MGrat$ := " -g ";  'Change master grating variable to -g because it doesn't change
            TunCurveMArg$ := "";  'clear the master tuning curve argument
            MValues$ := "";  'clear the master tuning curve values
        endif;       
        
    case tunType$ = tunTypeDonut$ then
        
        TunCurveMArg$ := " -A ";  'Donuts do area on Master
        TunCurveSArg$ := " -H ";  'And "hole" stimuli on Slave
        
        ' The args for the stim must be constructed here. 
        var areaArg$, donutArg$;
        for i% := 0 to tunNValues%-1 do
            if tunValues[tunValuesIndices%[i%]] <= tunDonutOptimalDiam then
                areaArg$ += str$(tunValues[tunValuesIndices%[i%]]) + ",";
                donutArg$ += "0,0,";
            else
                areaArg$ += str$(tunDonutOptimalDiam) + ",";
                donutArg$ += str$(tunValues[tunValuesIndices%[i%]]) + "," + str$(tunDonutOptimalDiam) + ",";
            endif
        next
        areaArg$ := Left$(areaArg$, Len(areaArg$)-1);
        donutArg$ := Left$(donutArg$, Len(donutArg$)-1);
        
        'Now put the constructed stim sets into standard variables
        MValues$ := areaArg$;
        SValues$ := donutArg$;
        
    case tunType$ = tunTypeBerliner$ then
        
        TunCurveMArg$ := " -A ";  'Donuts do area on Master
        TunCurveSArg$ := " -H ";  'And "hole" stimuli on Slave
        
        ' The args for the stim must be constructed here. 
        var areaArgBerliner$, donutArgBerliner$; 
        for i% := 0 to tunNValues%-1 do
            docase
            case tunValues[tunValuesIndices%[i%]] = 1 then  'stim 1 is optimal center on master, no donut on slave
                areaArgBerliner$ += str$(tunDonutOptimalDiam) + ",";
                donutArgBerliner$ += "0,0,";
            case tunValues[tunValuesIndices%[i%]] = 2 then  'stim 2 is maximal center on master, no donut on slave
                areaArgBerliner$ += str$(tunBerlinerMaximalDiam) + ",";
                donutArgBerliner$ += "0,0,";   
            case tunValues[tunValuesIndices%[i%]] = 3 then  'stim 3 is optimal center on master, donut one step larger on slave
                areaArgBerliner$ += str$(tunDonutOptimalDiam) + ",";
                donutArgBerliner$ += str$(tunDonutOptimalDiamPlusOne) + "," + str$(tunDonutOptimalDiam) + ","; 
            case tunValues[tunValuesIndices%[i%]] = 4 then  'stim 4 is optimal center on master, maximal donut on slave
                areaArgBerliner$ += str$(tunDonutOptimalDiam) + ",";
                donutArgBerliner$ += str$(tunBerlinerMaximalDiam) + "," + str$(tunDonutOptimalDiam) + ",";   
            case tunValues[tunValuesIndices%[i%]] = 5 then  'stim 5 is optimal center on master, optimal center on slave
                areaArgBerliner$ += str$(tunDonutOptimalDiam) + ",";
                donutArgBerliner$ += str$(tunDonutOptimalDiam) + "," + str$(0) + ","; 
            case tunValues[tunValuesIndices%[i%]] = 6 then  'stim 6 is maximal center on master, maximal center on slave
                areaArgBerliner$ += str$(tunBerlinerMaximalDiam) + ",";
                donutArgBerliner$ += str$(tunBerlinerMaximalDiam) + "," + str$(0) + ",";      
            else
                Message("Error - unknown value for tunValues: " + str$(tunValues[tunValuesIndices%[i%]]));
                Halt;   
            endcase
        next
        areaArgBerliner$ := Left$(areaArgBerliner$, Len(areaArgBerliner$)-1);
        donutArgBerliner$ := Left$(donutArgBerliner$, Len(donutArgBerliner$)-1);
        
        'Now put the constructed stim sets into standard variables
        MValues$ := areaArgBerliner$;
        SValues$ := donutArgBerliner$;   
        
    case tunType$ = tunTypeBoxODonuts$ then
        'Set slave values, do this first because master values may be set to slave values
        TunCurveSArg$ := " -" + TunType1$ + " ";
        TunCurveS2Arg$ := " -" + TunType2$ + " ";
        SValues$ := tun1ValuesStringified$;
        S2Values$ := tun2ValuesStringified$;
        
        'Set master values, based on whether the master should vary with TunCurve1 on slave or not
        if tunMasterFollowsCurve1% = 0 then        
            MGrat$ := " -g ";  'Change master grating variable to -g because it doesn't change
            TunCurveMArg$ := "";  'clear the tuning curve argument
            MValues$ := "";  'clear the tuning curve values
        else
            'Do not change master grating variable to -G
            TunCurveMArg$ := TunCurveSArg$;  'Set master tuning curve argument same as slave 1
            MValues$ := SValues$;  'Set master tuning curve values same as slave 1
        endif;    
        
    case tunType$ = tunTypeCRG$ then
        'Assign Primary/Secondary screen values, Secondary tuning curve argument
        CRGPrimaryValues$ := Str$(tunCRGFramesPerFlip%) + "," + tunCRGSeqFile$ + "," + tun1ValuesStringified$;
        docase
        case tunType1$ = tunTypeContrast$ then
            CRGSecondaryArg$ := " -C ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeOrientation$ then
            CRGSecondaryArg$ := " -O ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeSpatial$ then
            CRGSecondaryArg$ := " -S ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeTemporal$ then
            CRGSecondaryArg$ := " -T ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeArea$ then
            CRGSecondaryArg$ := " -A ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
        case tunType1$ = tunTypeXPos$ then
            CRGSecondaryArg$ := " -X ";
            CRGSecondaryValues$ := tun2ValuesStringified$;
            
        case tunType1$ = tunTypeCRG$ then
            CRGSecondaryArg$ := " -R ";
            CRGSecondaryValues$ := Str$(tunCRGFramesPerFlip%) + "," + tunCRGSeqFile2$ + "," + tun2ValuesStringified$;
        'case tunType1$ = tunTypeBlank$ then  'Do nothing here, blank out values once we know which screen is which

        case tunType1$ = tunTypeGratingOnly$ then
            CRGSecondaryArg$ := " -C ";  'Yes, we do in fact treat it as contrast, the values should be 100 or 0 for on/off
            CRGSecondaryValues$ := tun2ValuesStringified$; 
        endcase;
        
        'Determine whether primary is master or slave screen, set master/slave values
        if tunCRGOnSlave% = 0 then 'primary on master
            TunCurveMArg$ := " -R ";
            TunCurveSArg$ := CRGSecondaryArg$;
            MValues$ := CRGPrimaryValues$;
            SValues$ := CRGSecondaryValues$;
            if tunType1$ = tunTypeBlank$ then
                TunCurveSArg$ := "";
                SValues$ := "";
                SGrat$ := " -n ";
                SGratParam$ := "";
                'SlaveIndicator$ := "";
            endif;
        else 'primary on slave
            TunCurveSArg$ := " -R ";
            TunCurveMArg$ := CRGSecondaryArg$;
            SValues$ := CRGPrimaryValues$;
            MValues$ := CRGSecondaryValues$;
            if tunType1$ = tunTypeBlank$ then
                TunCurveMArg$ := "";
                MValues$ := "";
                MGrat$ := " -n ";
                MGratParam$ := "";
                'MasterIndicator$ := "";
            endif;
        endif;
        
    case tunType$ = tunTypeDots$ then
        'Dots is a fairly different beast, we'll need to do thing a bit differently than the others
        'build different background gray level string
        BGColor$ := " -b " +  "(" + Str$(tunDotsBGR%) + "/" + Str$(tunDotsBGG%) + "/" + Str$(tunDotsBGB%) + ") ";
        TunCurveMArg$ := " -D ";  'Dots on Master
        'holding on to trigger port for now, maybe needs to be cleared?
        MGrat$ := "";  'but clearing MGrat$
        MGratParam$ := "";  'and MGratParam$
        MasterIndicator$ := "";  'and MasterIndicator$
        'then buidling the grating spec
        MValues$ := "(" + Str$(tunDotsFGR%) + "/" + Str$(tunDotsFGG%) + "/" + Str$(tunDotsFGB%) + ")," 
                  + Str$(tunDotsX) + "," + Str$(tunDotsY) + "," + Str$(tunDotsDiameter) + "," 
                  + Str$(tunDotsSpeed) + "," + Str$(tunDotsDensity) + "," + Str$(tunDotsSize%) + ",";
        MValues$ := MValues$ + tunValuesStringified$;
        
    else

        Message("Error - unknown value for tunType$: " + tunType$);
        Halt;

	endcase;
	
    

    'Build command line, any values that are unnecessary will be empty, so the build should work no matter what type of command line is required
    cmdLine$ := Opener$ + ProgName$ + FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + Verbose$; 'prelim stuff
    cmdLine$ := cmdLine$ + RefrLock$ + OffsetFile$ + StimDur$;  'Dual VSG stuff
    cmdLine$ := cmdLine$ + MasterIndicator$ + MGrat$ + MGratParam$ + TunCurveMArg$ + MValues$;  'Master grating stuff
    cmdLine$ := cmdLine$ + SlaveIndicator$ + SGrat$ + SGratParam$ + TunCurveSArg$ + SValues$;  'Slave grating stuff
    cmdLine$ := cmdLine$ + TunCurveS2Arg$ + S2Values$;  'Second slave parameters (for Box O' Donuts, more possible)
    'Note that building with empty defaults means if we don't fill something (e.g. DualInd$ for fixstim) all is OK
'    if tunUseHoleKluge% = 1 then
'        cmdLine$ := cmdLine$ + KlugeArg$ + KlugeValues$;
'    endif;
    
    
    
    ' Record initial text marks. The command line may need to be broken into pieces.
    ' For tuning: Version 6,7 are always box--o-donuts
    ' Version 8 is CRG.
    
    docase
    case tunType$ = tunTypeBoxODonuts$ then    
        if tunUseMaintainMode% = 1 then  'if fixation point stays on, extraction is version 6
            SampleText("Tuning,6," + str$(Len(cmdLine$)));
        else 'value is 0, fixation point goes off, extraction is version 7
            SampleText("Tuning,7," + str$(Len(cmdLine$)));
        endif;
    case tunType$ = tunTypeCRG$ then
        SampleText("Tuning,8," + str$(Len(cmdLine$)));
    else
        ' djs Always version 3. NO difference if maintainmode is used or not. 
        SampleText("Tuning,3," + str$(Len(cmdLine$)));
    endcase;
    
    SampleText(tunCVSID$);
    for i% := 1 to Len(cmdLine$) step 100 do
        SampleText(Mid$(cmdLine$, i%, 100));
    next
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n");
    printlog("num advances is %d and num repeats is %d\n",tunNAdvances%,tunNRepeats%);
	StimHandle% := ProgRun(cmdLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(5);
return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawStim
' 
' Draws stimulus in xy window (iDraw%==1) or blanks it (0). 
proc DrawStim(iDraw%)

	if iDraw% > 0 then
		var xstim, ystim;
		xstim := FixationX;
		ystim := FixationY;

		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLogProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a linear progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLinearProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (xmax -xmin)/nsteps%;
	for v := xmin to xmax+stepsize/2 step stepsize do
	'	PrintLog("Value=" + str$(v) + "\n");
		vec[i%] := v;
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
Func StringifyProgression$(n%, vec[], ind%[])
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
		s$ += str$(vec[ind%[i%]]);
	next
	return s$;
end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
' Here we will use a "reference" vector to determine whether to pass a value or not
' This is designed for the 2-screen CRG experiments.  The progression for the secondary screen will be
' a series of zeros and 100s.  If 0, we want the secondary screen to be blank, so we insert -1.  If non-zero,
' we want the secondary screen to have the same SEQfile index as the main screen, so we refer back to the
' main screen value.
Func StringifyProgressionCRG2$(n%, refvec[], refind%[], vec[], ind%[])
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
        if refvec[refind%[i%]] = 0 then
            s$ += str$(-1);
        else
            s$ += str$(vec[ind%[i%]]);
        endif;
	next
	return s$;
end;



func SelectWavemarkDialog%()
	var iReturn%:=1;
	var i%;
    var whichWaveMark% := 1;
	DlgCreate("Select Wavemark");
	DlgInteger(1, "Input Wavemark to view, -1 for all", -1, 256);  'max is based on highest possible wavemark value
    
	i% := DlgShow(whichWaveMark%);

	if i% = 1 then
		PrintLog("SelectWavemarkDialog - user hit OK\n");
        for i% := 0 to tunNWavemarks%-1 do  'for each wavemark channel
            View(DataWindow%).MarkMask(i%+1,0,0,-1);  'exclude all codes on layer 0
            View(DataWindow%).MarkMask(i%+1,0,1,whichWaveMark%);  'then include requested code (or all, if -1) on layer 0
        next;       
	endif;
	if i% = 0 then
		PrintLog("SelectWavemarkDialog - user hit Cancel\n");
	endif;
    'PrintLog("Return value is %d\n", iReturn%);  'always return 1, so don't bother reporting this
	return iReturn%;
end;


proc ClearMasterOrSlaveIfNecessary(&SGrat$,&SGratParam$,&SlaveIndicator$,&TunCurveSArg$,&SValues$,&MGrat$,&MGratParam$,&MasterIndicator$,&TunCurveMArg$,&MValues$)
    'Clear master/slave if there is only one tuning curve to do. 
    'Note that SlaveIndicator$ and MasterIndicator$ are no longer changed, but still in the subject line so I don't have to change everything else
    if tunDualTuningType% = 1 then        
        SGrat$ := " -n ";  'clear slave grating
        SGratParam$ := "";  'clear slave grating params
        'SlaveIndicator$ := "";  'clear slave indicator, don't do this anymore after change to Dualstim
        TunCurveSArg$ := "";  'clear the tuning curve argument
        SValues$ := "";  'clear the tuning curve values
    endif
    if tunDualTuningType% = 2 then        
        MGrat$ := " -n ";  'clear master grating
        MGratParam$ := "";  'clear master grating params
        'MasterIndicator$ := "";  'clear master indicator, don't do this anymore after change to Dualstim
        TunCurveMArg$ := "";  'clear the tuning curve argument
        MValues$ := "";  'clear the tuning curve values
    endif;
end;



func CheckSeqFile%(fileIn$,&nFlips%);
    var fh0%;
    var numRead%;
    var readLine$[2];
    var keepGoing% := 1;
    var nFlipsFirst%;
    var nFlipsSubsequent%;
    var loopedOnce%;
    var lineLength%;
    var expectStr%[50];
    var i%;
    var nCh%;  'number of characters
    var lineCount%;
    
    fh0%:=FileOpen(fileIn$,8,0);
    
    readsetup(""," ","","","	");
    
    while keepGoing% do
        'Read the next line in the file, return line and number of fields read
        numRead% := read(readLine$[0:2]);
        'And update the number of lines read
        lineCount% += 1;
        
        'Here we expect exactly one field per line, if there is more than one, this is an error, quit
        if numRead% > 1 then
            message("ERROR!!!|Expected exactly one field on line " + Str$(lineCount%) + ",\ngot " + Str$(numRead%) + " fields!");
            fileclose();  'close fh0%, the currently open file             
            halt;
        endif;
        
        'Get the number of flips in the line
        docase
        case loopedOnce% = 0 then
            nFlipsFirst% := Len(readLine$[0]);
            loopedOnce% := 1;  'don't do this again
        case numRead% >= 0 then 'Make sure all lines are the same length
            nFlipsSubsequent% := Len(readLine$[0]);
            if nFlipsFirst% <> nFlipsSubsequent% then
                message("ERROR!!!|On line " + Str$(lineCount%) + " expected " + Str$(nFlipsFirst%) + " flips,\ngot " + Str$(nFlipsSubsequent%) + "!");
                fileclose();  'close fh0%, the currently open file
                halt;
            endif;
        case numRead%<0 then
            keepGoing% := 0;
        endcase;    
        
        'Make sure there are nothing but zeros or ones
        for i% := 0 to len(readLine$[0])-1 do
            if mid$(readLine$[0],i%+1,1) <> "1" and mid$(readLine$[0],i%+1,1)  <> "0" then
                message("ERROR!!!|On line " + Str$(lineCount%) + " found unexpected character " + mid$(readLine$[0],i%+1,1) + "!");
                fileclose();  'close fh0%, the currently open file
                halt;
            endif;
        next;
        
    wend;    
    
    fileclose();  'close fh0%, the currently open file
    
    printlog("Successfully read file %s, contained %d lines with %d flips per line!\n",fileIn$,lineCount%-1,nFlipsFirst%);
    
    nFlips% := nFlipsFirst%;  'set nFlips%, which sets the flips variable sent in the call    
    
    return lineCount%-1;
    
end
