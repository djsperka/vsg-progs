' $Log: not supported by cvs2svn $
' Revision 1.17  2006/04/24 21:13:28  dan
' Added aperture area tuning function.
'
' Revision 1.1  2006/04/22 01:57:32  dan
' *** empty log message ***
'
' Revision 1.15  2006/04/15 03:32:19  dan
' Log progression implemented for contrast, sf, tf.
' Changed limits on sf, tf dialogs.
'
' Revision 1.14  2006/02/08 22:50:26  dan
' Corrected plot x coord bug.
'
' Revision 1.13  2006/02/08 22:30:20  dan
' Allow modification of xy axes during data aquisition
'
' Revision 1.12  2006/02/08 22:15:10  dan
' Multiple repeats will now plot x coords correctly. Now does modulo division so subsequent repeats plot at same x coords as the first.
'
' Revision 1.11  2005/12/07 22:16:14  dan
' *** empty log message ***
'
' Revision 1.10  2005/09/21 19:38:21  dan
' Correctly draws fixation window and fixpt location.
'
' Revision 1.9  2005/09/09 23:01:13  dan
' Fixed bug in VSG ready/confirm cycle, where the confirm trigger could be missed, leading to a stuck script, no stimuli, etc.
'
' Revision 1.8  2005/08/23 22:40:10  dan
' Added plot of tuning curves. Not entirely tested yet, and there are holes esp if there are multiple electrodes, but it'll do for now.
'
' Revision 1.7  2005/08/23 18:54:08  dan
' *** empty log message ***
'
' Revision 1.6  2005/08/17 00:28:08  dan
' Started work to add tuning curves to output.
'
' Revision 1.5  2005/08/01 23:01:14  dan
' Mods to tuning curve config dialogs. Added file naming, trial counting to tuning.
'
' Revision 1.4  2005/07/29 23:29:33  dan
' Nearly ready! SCripts ready for prime time, except tuning seems to have a bug in
' start% - probably with args.
'
' Revision 1.3  2005/07/27 21:50:14  dan
' Changed 'a' trigger to invert sense of the line it controls.
'
' Revision 1.2  2005/07/26 23:42:00  dan
' First working beta version. States are implemented. Needs tallying, display.
'
' Revision 1.1  2005/07/26 01:03:52  dan
' Mods to config.s2s for tuning script. Tuning script first add here.
'

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Get Current configuration START
'	
'	Fetch the current configuration from the registry and return it. 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func GetCurrentConfiguration$()
	var key$;
	var s$;
	key$:="AlertRig";
	Profile(key$, "CurrentConfiguration", "default", s$);
	return s$;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Get Current configuration END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Data parameters START
'
'	Vars that control where data is stored. 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var dataPathRoot$;		' base path for data storage
var dataDataSet$;		' folder under data path where data files placed
var dataCellName$;		' part of base name for all data files
var dataDataSetTextItem%;	' 

proc GetDataParameters()
	var stmp$;
	var key$;

	key$:="AlertRig\\Data";

	Profile(key$, "PathRoot", "C:\\Experiments", dataPathRoot$);
	Profile(key$, "DataSet", "", dataDataSet$);
	Profile(key$, "CellName", "", dataCellName$);
	return;
end;

proc SaveDataParameters()
	var stmp$;
	var key$;

	key$:="AlertRig\\Data";

	Profile(key$, "PathRoot", dataPathRoot$);
	Profile(key$, "DataSet", dataDataSet$);
	Profile(key$, "CellName", dataCellName$);
	return;
end;

func DataParametersDialog%()
	var i%;
	GetDataParameters();
	DlgCreate("Data Storage Parameters", 25, 10, 50);
	DlgText("Data root path: " + dataPathRoot$, 0, 1);
	dataDataSetTextItem% := DlgText("Data set name: " + dataDataSet$, 0, 2);
	DlgString(1, "Cell name:", 10, "", 0, 3);
        DlgButton(2, "New Data Set", NewDataSet%);
	i% := DlgShow(dataCellName$);
	if (i% = 1) then
		if Len(dataDataSet$) = 0 then
			Message("Must specify a data set (try the button!)");
		else
			if Len(dataCellName$) = 0 then
				Message("Must specify a cell name");
			else
				FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3, 1);
				SaveDataParameters();
			endif;
		endif;
	endif;
	return i%;
end;


func NewDataSet%()
	var d$;
	var i%;
	var dirs$[100];	' if there are ever more than 100 datasets in a single day there will be trouble
	d$ := Date$(2, 2, 3, 3, "-");
	PrintLog("NewDataSet: date string = " + d$ + "\n");

	' Change current dir to data path root, then get list of subdirs with this date string
	PrintLog("NewDataSet: dataPathRoot$=" + dataPathRoot$ + "\n");
	FilePathSet(dataPathRoot$, 0, 1);
	i% := FileList(dirs$, -2, d$ + "-??");
        PrintLog("NewDataSet: found " + str$(i%) + " dirs\n");

	' form new dataset name. The first will have "-01" appended, the second "-02", etc. 
	dataDataSet$ := Print$("%s-%02d", d$, i%+1);
	PrintLog("NewDataSet: dataset= " + dataDataSet$ + "\n");
	DlgValue$(dataDataSetTextItem%, "Data set name: " + dataDataSet$);
	return 1;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Data parameters END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var tunFixationDuration;	' Time required to hold fixation for reward (stim ON)
var tunMaintainFixation;	' Time required to hold fixation for reward (stim OFF)
var tunTimeOutTime;		' Time after break fixation
var tunAcquisitionTime;		' Time allowed to acquire fixation
var tunBackgroundColor$;	' background color for stim

' These will be set by the tuning curve choice
var tunNAdvances%;		' Number of times stim will advance during one repeat
var tunNRepeats%;		' Number of repeats

' This vector will hold the actual values to step through. Some are log steps, some are not. 
var tunValues[100];

' These are specific to the individual tuning curve types - orientation first
var tunOriNSteps%;		' # steps in orientation tuning curve
var tunOriNRepeats%;		' # repeats in ori tuning curve
var tunOriMinOrientation;	' min orientation
var tunOriMaxOrientation;	' max orientation
var tunOriProgression%;

' Contrast next
var tunContrastNSteps%;			' # steps in contrast tuning curve
var tunContrastNRepeats%;		' # repeats in contrast tuning curve
var tunContrastMinContrast;		' min contrast
var tunContrastMaxContrast;		' max contrast
var tunContrastProgression%;

' Spatial next
var tunSpatialNSteps%;			' # steps in spatial freq tuning curve
var tunSpatialNRepeats%;		' # repeats in spatial freq tuning curve
var tunSpatialMinSF;			' min SF
var tunSpatialMaxSF;			' max SF
var tunSpatialProgression%;

' Temporal next
var tunTemporalNSteps%;			' # steps in temporal tuning curve
var tunTemporalNRepeats%;		' # repeats in temporal tuning curve
var tunTemporalMinTF;		' min TF
var tunTemporalMaxTF;		' max TF
var tunTemporalProgression%;

' Area next
var tunAreaNSteps%;			' # steps in area tuning curve
var tunAreaNRepeats%;		' # repeats in area tuning curve
var tunAreaMinDiam;		' min diameter
var tunAreaMaxDiam;		' max diameter
var tunAreaProgression%;

const tunTypeNone$ := "None";
const tunTypeOrientation$ := "O";
const tunTypeContrast$ := "C";
const tunTypeSpatial$ := "S";
const tunTypeTemporal$ := "T";
const tunTypeArea$ := "A";
var tunType$:=tunTypeNone$;

const tunContextDAQ$ := "DAQ";
const tunContextConfig$ := "Config";
var tunContext$ := tunContextConfig$;

proc GetTuningCurveScriptParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";

	Profile(key$, "FixationDuration", "2.0", stmp$);
	tunFixationDuration := val(stmp$);
	Profile(key$, "MaintainFixation", "2.0", stmp$);
	tunMaintainFixation := val(stmp$);
	Profile(key$, "TimeOutTime", "2.0", stmp$);
	tunTimeOutTime := val(stmp$);
	Profile(key$, "AcquisitionTime", "2.0", stmp$);
	tunAcquisitionTime := val(stmp$);
	Profile(key$, "BackgroundColor", "gray", tunBackgroundColor$);
end;

proc SaveTuningCurveScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
	Profile(key$, "FixationDuration", str$(tunFixationDuration));
	Profile(key$, "MaintainFixation", str$(tunMaintainFixation));
	Profile(key$, "TimeOutTime", str$(tunTimeOutTime));
	Profile(key$, "AcquisitionTime", str$(tunAcquisitionTime));
	Profile(key$, "BackgroundColor", tunBackgroundColor$);
end;

proc GetTuningCurveOrientationParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";

	Profile(key$, "NSteps", 2, tunOriNSteps%);
	Profile(key$, "NRepeats", 1, tunOriNRepeats%);
	Profile(key$, "MinOrientation", "0", stmp$);
	tunOriMinOrientation := val(stmp$);
	Profile(key$, "MaxOrientation", "360", stmp$);
	tunOriMaxOrientation := val(stmp$);
end;

proc SaveTuningCurveOrientationParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";
	Profile(key$, "NSteps", tunOriNSteps%);
	Profile(key$, "NRepeats", tunOriNRepeats%);
	Profile(key$, "MinOrientation", str$(tunOriMinOrientation));
	Profile(key$, "MaxOrientation", str$(tunOriMaxOrientation));
end;

proc GetTuningCurveContrastParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";

	Profile(key$, "NSteps", 2, tunContrastNSteps%);
	Profile(key$, "NRepeats", 1, tunContrastNRepeats%);
	Profile(key$, "MinContrast", "0", stmp$);
	tunContrastMinContrast := val(stmp$);
	Profile(key$, "MaxContrast", "100", stmp$);
	tunContrastMaxContrast := val(stmp$);
end;

proc SaveTuningCurveContrastParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";
	Profile(key$, "NSteps", tunContrastNSteps%);
	Profile(key$, "NRepeats", tunContrastNRepeats%);
	Profile(key$, "MinContrast", str$(tunContrastMinContrast));
	Profile(key$, "MaxContrast", str$(tunContrastMaxContrast));
end;

proc GetTuningCurveSpatialParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";

	Profile(key$, "NSteps", 2, tunSpatialNSteps%);
	Profile(key$, "NRepeats", 1, tunSpatialNRepeats%);
	Profile(key$, "MinSF", "0.2", stmp$);
	tunSpatialMinSF := val(stmp$);
	Profile(key$, "MaxSF", "10", stmp$);
	tunSpatialMaxSF := val(stmp$);
end;

proc SaveTuningCurveSpatialParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";

	Profile(key$, "NSteps", tunSpatialNSteps%);
	Profile(key$, "NRepeats", tunSpatialNRepeats%);
	Profile(key$, "MinSF", str$(tunSpatialMinSF));
	Profile(key$, "MaxSF", str$(tunSpatialMaxSF));
end;

proc GetTuningCurveTemporalParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";

	Profile(key$, "NSteps", 2, tunTemporalNSteps%);
	Profile(key$, "NRepeats", 1, tunTemporalNRepeats%);
	Profile(key$, "MinTF", "0.1", stmp$);
	tunTemporalMinTF := val(stmp$);
	Profile(key$, "MaxTF", "10", stmp$);
	tunTemporalMaxTF := val(stmp$);
end;

proc SaveTuningCurveTemporalParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";

	Profile(key$, "NSteps", tunTemporalNSteps%);
	Profile(key$, "NRepeats", tunTemporalNRepeats%);
	Profile(key$, "MinTF", str$(tunTemporalMinTF));
	Profile(key$, "MaxTF", str$(tunTemporalMaxTF));
end;

proc GetTuningCurveAreaParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

	Profile(key$, "NSteps", 2, tunAreaNSteps%);
	Profile(key$, "NRepeats", 1, tunAreaNRepeats%);
	Profile(key$, "MinDiam", "1", stmp$);
	tunAreaMinDiam := val(stmp$);
	Profile(key$, "MaxDiam", "10", stmp$);
	tunAreaMaxDiam := val(stmp$);
end;

proc SaveTuningCurveAreaParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

	Profile(key$, "NSteps", tunAreaNSteps%);
	Profile(key$, "NRepeats", tunAreaNRepeats%);
	Profile(key$, "MinDiam", str$(tunAreaMinDiam));
	Profile(key$, "MaxDiam", str$(tunAreaMaxDiam));
end;




func TuningCurveOrientationDialog%()
	var iReturn%;
	var i%;
	GetTuningCurveOrientationParameters();
	DlgCreate("Run Orientation Tuning Curve");
	DlgInteger(1, "Number of Steps", 2, 100);
	DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min Orientation (deg)", 0, 360);
	DlgReal(4, "Max Orientation (deg)", 0, 360);
	DlgCheck(5, "Random Progression");
	i% := DlgShow(tunOriNSteps%, tunOriNRepeats%, tunOriMinOrientation, tunOriMaxOrientation, tunOriProgression%);

	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hit Cancel we don't.
	if i% = 1 then
		SaveTuningCurveOrientationParameters();
'		PrintLog("TuningCurveOrientationDialog - user hit OK\n");
		tunType$ := tunTypeOrientation$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 0;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveOrientationDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;



func TuningCurveContrastDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveContrastParameters();
	DlgCreate("Contrast Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 100);
	DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min Contrast (%)", 0.1, 100);
	DlgReal(4, "Max Contrast (%)", 0.1, 100);
	DlgCheck(5, "Random Progression");

	i% := DlgShow(tunContrastNSteps%, tunContrastNRepeats%, tunContrastMinContrast, tunContrastMaxContrast, tunContrastProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hit Cancel we don't.
	if i% = 1 then
		SaveTuningCurveContrastParameters();
'		PrintLog("TuningCurveContrastDialog - user hit OK\n");
		tunType$ := tunTypeContrast$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 0;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveContrastDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveSpatialDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveSpatialParameters();
	DlgCreate("Spatial Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 100);
	DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min SF", .01, 100);
	DlgReal(4, "Max SF", .01, 100);
	DlgCheck(5, "Random Progression");

	i% := DlgShow(tunSpatialNSteps%, tunSpatialNRepeats%, tunSpatialMinSF, tunSpatialMaxSF, tunSpatialProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hit Cancel we don't.
	if i% = 1 then
		SaveTuningCurveSpatialParameters();
'		PrintLog("TuningCurveSpatialDialog - user hit OK\n");
		tunType$ := tunTypeSpatial$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 0;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveSpatialDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveTemporalDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveTemporalParameters();
	DlgCreate("Temporal Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 100);
	DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min TF", 0, 100);
	DlgReal(4, "Max TF", 0, 100);
	DlgCheck(5, "Random Progression");

	i% := DlgShow(tunTemporalNSteps%, tunTemporalNRepeats%, tunTemporalMinTF, tunTemporalMaxTF, tunTemporalProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hit Cancel we don't.
	if i% = 1 then
		SaveTuningCurveTemporalParameters();
'		PrintLog("TuningCurveTemporalDialog - user hit OK\n");
		tunType$ := tunTypeTemporal$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 0;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveTemporalDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveAreaDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveAreaParameters();
	DlgCreate("Area Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 100);
	DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");

	i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hit Cancel we don't.
	if i% = 1 then
		SaveTuningCurveAreaParameters();
'		PrintLog("TuningCurveTemporalDialog - user hit OK\n");
		tunType$ := tunTypeArea$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 0;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveTemporalDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;



' TuningCurveScriptDialog
' This dialog uses two global variables, tunContext$ and tunType$. 
' Set tunContext$ = tunContextConfig$ to run in the config scripts. The dialog and its children (TuningCurveOrientationDialog, etc)
' will behave as expected, allowing the user to set parameters and saving them in the registry. 
' Set tunContext$ = tunContextDAQ$ to run in a DAQ script. In this context you must check the return value of the dialog and (possibly)
' the value of tunType$.
' If the user hits Cancel in the main dialog, the return value is 0. If the user selects a subdialog and hits OK, the return value will be
' 1 and the value of tunType$ will be one of (tunTypeOrientation$, tunTypeContrast$, tunTypeSpatial$, tunTypeTemporal$). Here, proceed directly
' to DAQ. If the user Hits Cancel from the subdialog, then they return to the main dialog. If they hit OK from the main dialog, then the return 
' value is 1, but tunType$ = tunTypeNone$. 


func TuningCurveScriptDialog%()
	var i%;
	var iReturn%;
	GetTuningCurveScriptParameters();
	var bcl$[3];
	var ibcl%:=0;
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
	for i%:=0 to 2 do
		if tunBackgroundColor$ = bcl$[i%] then
			ibcl% := i%;
		endif
	next;

	DlgCreate("Tuning Curve Parameters", 50, 10);
	DlgGroup("Common Parameters", 0, 1, 40, 6);
	DlgReal(1, "Acquisition time(s):", 1, 1000, 20, 2);
	DlgReal(2, "Fixation duration(s):", .1, 10, 20, 3);
	DlgReal(3, "Maintain fixation(s):", .1, 10, 20, 4);
	DlgReal(4, "Time out time(s):", .01, 10, 20, 5);
	DlgList(5, "Background color:", bcl$, 3, 20, 6);
	DlgGroup("Individual Tuning Curve Types", 0, 7, 40, 6);
	DlgButton(6, "Orientation", TuningCurveOrientationDialog%, 1, 8);
	DlgButton(7, "Contrast", TuningCurveContrastDialog%, 1, 9);
	DlgButton(8, "Spatial Freq", TuningCurveSpatialDialog%, 1, 10);
	DlgButton(9, "Temporal Freq", TuningCurveTemporalDialog%, 1, 11);
	DlgButton(10, "Area", TuningCurveAreaDialog%, 1, 12);

	i%:=DlgShow(tunAcquisitionTime, tunFixationDuration, tunMaintainFixation,
		tunTimeOutTime, ibcl%);

	PrintLog("Return val is " + str$(i%) + "\n");
	if i% = 1 then
		tunBackgroundColor$ := bcl$[ibcl%];
		SaveTuningCurveScriptParameters();
'		PrintLog("Tuning Curve Parameters dialog - user hit OK, tunType=" + tunType$ + "\n");
		if tunContext$ = tunContextDAQ$ then iReturn% := 0;
		else iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("Tuning Curve Parameters dialog - user hit Cancel, tunType=" + tunType$ + "\n");
		if tunContext$ = tunContextDAQ$ then 
			if tunType$ <> tunTypeNone$ then 
				iReturn% := 1;
				SaveTuningCurveScriptParameters();
			else iReturn% := 0;
		 	endif;
		else
			iReturn% := 2;		' The calling/main dialog would close if we returned 0
		endif;
	endif;
	return iReturn%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''










''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Fixation Point parameters START
'
'	These vars and funcs control the parameters for the fixation point stored in the registry. 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var WindowRadius;
var FixationX, FixationY;
var FixationColor$;
var iFixationColor%;
var FixationDiameter;
var FixationColorList$[3]; 
var FixationArg$;

proc GetFixationPointParameters()
	var stmp$;
	var key$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\FixationPoint";
	Profile(key$, "WindowRadius", "1", stmp$);
	WindowRadius := val(stmp$);

	Profile(key$, "FixationX", "0", stmp$);
	FixationX := val(stmp$);
	Profile(key$, "FixationY", "0", stmp$);
	FixationY := val(stmp$);
	Profile(key$, "FixationColor", "0", stmp$);
	iFixationColor% := val(stmp$);

	FixationColorList$[0]:="red"; 
	FixationColorList$[1]:="green"; 
	FixationColorList$[2]:="blue"; 
	FixationColor$ := FixationColorList$[iFixationColor%];

	Profile(key$, "FixationDiameter", "0.5", stmp$);
	FixationDiameter := val(stmp$);

	' Form the argument for applications. Convenience for passing args. 
	FixationArg$ := " -f " + str$(FixationX) + "," + str$(FixationY) + "," + str$(FixationDiameter) + "," + FixationColor$;
end;

proc SaveFixationPointParameters()
	var key$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\FixationPoint";
	Profile(key$, "WindowRadius", str$(WindowRadius));
	Profile(key$, "FixationX", str$(FixationX));
	Profile(key$, "FixationY", str$(FixationY));
	Profile(key$, "FixationColor", str$(iFixationColor%));
	Profile(key$, "FixationDiameter", str$(FixationDiameter));
end;


func FixationPointDialog%()

	var i%;
	GetFixationPointParameters();
	DlgCreate("Fixation parameters: " + GetCurrentConfiguration$(), 25, 10);
	DlgReal(1, "Fixation X:", -20, 20);
	DlgReal(2, "Fixation Y:", -20, 20);
	DlgReal(3, "Fixation diam:", .1, 5);
	DlgReal(4, "Window radius:", .1, 10);
	DlgList(5, "Color:", FixationColorList$[]);
	i% := DlgShow(FixationX, FixationY, FixationDiameter, WindowRadius, iFixationColor%);	

	' If user cancelled, reload params
	if i% = 0 then
		GetFixationPointParameters();
	else
		SaveFixationPointParameters();
	endif

	return 1;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Fixation Point parameters END
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Rig Daily Totals START
'
'	Control, display, reset daily totals for a rig.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


var TotalTrials%;
var TotalRewards%;
var TotalDate$;


proc GetDailyTotals()
	var key$;
	key$ := "AlertRig\\Daily";
	Profile(key$, "TotalDate", "", TotalDate$);
	Profile(key$, "TotalTrials", 0, TotalTrials%);
	Profile(key$, "TotalRewards", 0, TotalRewards%);

	' Get date string if needed
	if Len(TotalDate$) = 0 then
		TotalDate$ := GetDayString$();
		SaveDailyTotals();
	endif
end;

proc SaveDailyTotals()
	var key$;
	key$ := "AlertRig\\Daily";
	Profile(key$, "TotalDate", TotalDate$);
	Profile(key$, "TotalTrials", TotalTrials%);
	Profile(key$, "TotalRewards", TotalRewards%);
end;

func DailyTotalsDialog%()
	GetDailyTotals();
	DlgCreate("Daily Totals");
	DlgText("Date: " + TotalDate$, 0, 1);
	DlgText("Trials: " + str$(TotalTrials%), 0, 2);
	DlgText("Rewards: " + str$(TotalRewards%), 0, 3);
	DlgButton(2, "Reset", ResetDailyTotals%);
	DlgShow();
	return 1;
end;


func GetDayString$()
	return Date$(2, 1, 3, 2, "-");
end;


func ResetDailyTotals%()
	GetDailyTotals();
	TotalRewards%:=0;
	TotalTrials%:=0;
	TotalDate$:= GetDayString$();
	SaveDailyTotals();
        return 0;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Rig Daily Totals END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	DAQ Parameters START
'
'	Control of data acquisition parameters.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


var DistanceToScreenMM$;		' Distance to screen in MM
var DegreesPerVoltX;			' Conversion factor from ADC to visual degrees
var DegreesPerVoltY;			' Conversion factor from ADC to visual degrees
var EyeCoilSamplingFrequency%;		' Frequency to sample eye coil at
var NumberOfElectrodes%;		' Number of electrodes (i.e. wavemark inputs) in use
var JuicePerReward%;			' Number of juice squirts per reward


func DAQParametersDialog%()

	var iReturn%;
	var idist%;

	GetDAQParameters();

	idist% := val(DistanceToScreenMM$);
	DlgCreate("DAQ parameters: " + GetCurrentConfiguration$(), 25, 10);
	DlgInteger(1, "Number of Electrodes:", 1, 7, 0, 0, 1);
	DlgInteger(2, "Screen Distance (MM):", 1, 5000);
	DlgReal(3, "Degrees/Volt (X):", 0, 100);
	DlgReal(4, "Degrees/Volt (Y):", 0, 100);
	DlgInteger(5, "Eye Coil Sampling Freq (Hz):", 1, 20000);
	DlgInteger(6, "Juice per reward:", 0, 10, 0, 0, 1);
	iReturn% := DlgShow(NumberOfElectrodes%, idist%, DegreesPerVoltX, DegreesPerVoltY, EyeCoilSamplingFrequency%, JuicePerReward%);

	if iReturn% = 1 then
		DistanceToScreenMM$ := str$(idist%);
		SaveDAQParameters();
	endif
	return iReturn%;
end;




	
proc GetDAQParameters()
	var key$;
	var DegreesPerVoltX$, DegreesPerVoltY$;

	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\DAQ";
	Profile(key$, "DistanceToScreenMM", "850", DistanceToScreenMM$);	' will just pass this to stimulus app
	Profile(key$, "DegreesPerVoltX", "", DegreesPerVoltX$);
	Profile(key$, "DegreesPerVoltY", "", DegreesPerVoltY$);
	Profile(key$, "EyeCoilSamplingFrequency", 1000, EyeCoilSamplingFrequency%);
	Profile(key$, "NumberOfElectrodes", 1, NumberOfElectrodes%);
	Profile(key$, "JuicePerReward", 1, JuicePerReward%);
	DegreesPerVoltX := val(DegreesPerVoltX$);
	DegreesPerVoltY := val(DegreesPerVoltY$);

end;

proc SaveDAQParameters()
	var key$;
	var DegreesPerVoltX$, DegreesPerVoltY$;
	DegreesPerVoltX$ := str$(DegreesPerVoltX);
	DegreesPerVoltY$ := str$(DegreesPerVoltY);
	
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\DAQ";
	Profile(key$, "DistanceToScreenMM", DistanceToScreenMM$);
	Profile(key$, "DegreesPerVoltX", DegreesPerVoltX$);
	Profile(key$, "DegreesPerVoltY", DegreesPerVoltY$);
	Profile(key$, "EyeCoilSamplingFrequency", EyeCoilSamplingFrequency%);
	Profile(key$, "NumberOfElectrodes", NumberOfElectrodes%);
	Profile(key$, "JuicePerReward", JuicePerReward%);

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	DAQ Parameters END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




' Local file system variables. 
var bin$, script$;
bin$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2) + "..\\bin";	' Location of executables is ..\bin, relative to script dir
script$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2);	' folder containing this script

' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameTriggerChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;

' tuning curves
var TuningWindow%[8];	' one for each channel. There'd better not be more than 8 channels! 
' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Fetch parameters
GetDailyTotals();
GetDAQParameters();
GetFixationPointParameters();
GetDataParameters();

' Check for valid data file path
if Len(dataDataSet$) = 0 then
	Message("No data set is selected! Edit Data parameters...");
	' Might be nice to open the dialog here....
	halt;
endif

' run parameters script....
tunContext$ := tunContextDAQ$;
tunType$ := tunTypeNone$;

GetTuningCurveScriptParameters();
iScript% := TuningCurveScriptDialog%();
if iScript% = 1 then
	if tunType$ = tunTypeNone$ then
		PrintLog("No tuning type selected, exit gracefully\n");
		Halt;
	else
		PrintLog("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ\n");

		' Set path for new data files, and for those saved automatically
		FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
		FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
		docase
			case tunType$ = tunTypeContrast$ then 
				SampleAutoName$(dataCellName$ + "_con_000");
				tunNAdvances% := tunContrastNSteps%;
				tunNRepeats% := tunContrastNRepeats%;
				GetLogProgression(tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunValues);
			case tunType$ = tunTypeOrientation$ then 
				SampleAutoName$(dataCellName$ + "_ori_000");
				tunNAdvances% := tunOriNSteps%;
				tunNRepeats% := tunOriNRepeats%;
				GetLinearProgression(tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunValues);
			case tunType$ = tunTypeSpatial$ then 
				SampleAutoName$(dataCellName$ + "_spa_000");
				tunNAdvances% := tunSpatialNSteps%;
				tunNRepeats% := tunSpatialNRepeats%;
				GetLogProgression(tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunValues);
			case tunType$ = tunTypeTemporal$ then 
				SampleAutoName$(dataCellName$ + "_tem_000");
				tunNAdvances% := tunTemporalNSteps%;
				tunNRepeats% := tunTemporalNRepeats%;
				GetLogProgression(tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunValues);
			case tunType$ = tunTypeArea$ then 
				SampleAutoName$(dataCellName$ + "_area_000");
				tunNAdvances% := tunAreaNSteps%;
				tunNRepeats% := tunAreaNRepeats%;
				GetLogProgression(tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunValues);
			else
				SampleAutoName$(dataCellName$ + "_tun_000");
		endcase;

		SampleAutoFile(1);
		PrintLog("AutoFile status " + str$(SampleAutoFile()) + "\n");
	endif;
else
	PrintLog("User cancel - exit gracefully\n");
	Halt;
endif;





' Assign channel numbers for eye X,Y and trigger. 
XChannel% := NumberOfElectrodes%+1;
YChannel% := NumberOfElectrodes%+2;
FrameTriggerChannel% := NumberOfElectrodes%+3;
FixationPointChannel% := NumberOfElectrodes%+4;
StimChannel% := NumberOfElectrodes%+5;
StimChangeChannel% := NumberOfElectrodes%+6;
ReadyChannel% := NumberOfElectrodes%+7;
CreateSampleConfiguration();


' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
'	ToolbarSet(6,"Exp Parameters",AttentionScriptDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
	var i%;
	for i%:=1 to JuicePerReward% do Yield(.05); SampleKey("J"); next
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 


' Constants for states
const stateStartTrial%:=0;		' Start trial state
const stateWaitForFixPtOn%:=1;		' Waiting for fixation point return trigger (on)
const stateWaitForBlank%:=2;		' Waiting for fixation point return trigger (off)
const stateWaitForStimOn%:=3;		' Wait for stimulus return trigger (on)
const stateWaitForStimOff%:=4;		' Wait for stimulus return trigger (off)
const stateWaitForAcquisition%:=5;	' Waiting for subject to acquire fixation point
const stateHoldFixation%:=6;		' Holding fixation point
const stateAbort%:=7;			' Failed trial state
const stateMaintainFixation%:=8;	' Maintaining fixation (stim off period)
const stateInterTrialInterval%:=9;	' time out after failed trial
const stateVSGWait%:=10;		' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		' trial has been completed successfully
const stateDone%:=13;	
var iState% := stateVSGWait%;	' present state

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 

func IdleProcessing%()
	var iStatus% := 1;	
	tNow := MaxTime();

	xEye := ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
	yEye := ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastUpdate := tNow;
	endif


	docase 
		case iState% = stateVSGWait% then

			' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
			tTrigger := NextTime(ReadyChannel%, tLast, vTrigger);
			if tTrigger > tLastTrigger and vTrigger = 0 then
				PrintLog("state stateVSGWait: Got leading edge of trigger\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateVSGWaitConfirm%, tTrigger);
			endif;

		case iState% = stateVSGWaitConfirm% then

			' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
			tTrigger := NextTime(ReadyChannel%, tLastTrigger, vTrigger);
			if tTrigger > tLastTrigger and vTrigger = 1 then
				PrintLog("state stateVSGWaitConfirm: Got trailing edge of trigger\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateStartTrial%, tTrigger);
			endif;


		case iState% = stateStartTrial% then

			' Start trial. Put up fixation point.
			PrintLog("stateStartTrial: Send F key\n");
			SampleKey("F");
			ChangeStateTo(stateWaitForFixPtOn%, tTrigger);
		
		case iState% = stateWaitForFixPtOn% then

			PrintLog("stateWaitForFixPtOn: waiting.......\n");
			tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
			if tTrigger > tLast and vTrigger = 0 then
				' Fixation point is up
				PrintLog("stateWaitForFixPtOn: signal received. " + str$(tNow) + "\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateWaitForAcquisition%, tTrigger);
				DrawStim(1);	' actually this draws the location of the fixpt.
			endif

		case iState% = stateWaitForAcquisition% then

			' Waiting for eye to fall inside of fixation window
			if Looking%(xEye, yEye) = 1 then
				PrintLog("stateWaitForAcquisition: eye in fixation window, send S key.\n");
				SampleKey("S");
				ChangeStateTo(stateWaitForStimOn%, tNow);
			else 
				if tNow - tStateStart > tunAcquisitionTime then
					' failed to acquire target. 
					PrintLog("stateWaitForAcquisition: failed.\n");
					ChangeStateTo(stateAbort%, tNow);
				endif
			endif

		case iState% = stateWaitForStimOn% then

			tTrigger := NextTime(StimChannel%, tLast, vTrigger);
			if tTrigger > tLast and vTrigger = 0 then
				' Fixation point is up
				PrintLog("stateWaitForStimOn: stim is up.\n");
				tStimOn := tTrigger;
				tLastTrigger := tTrigger;
				ChangeStateTo(stateHoldFixation%, tTrigger);
			endif

			
		case iState% = stateAbort% then

			' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
			' fixpt off. 
			PrintLog("stateAbort: send X key.\n");
			SampleKey("X");
			ChangeStateTo(stateWaitForBlank%, tNow);

		case iState% = stateWaitForBlank% then

			' we just wait for fix point off signal in this case. 
			tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
			if tTrigger > tLast and vTrigger = 1 then
				' Fixation point is off
				PrintLog("stateWaitForBlank: Fix pt is off.\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateInterTrialInterval%, tTrigger);
				DrawStim(0);	' actually this draws the location of the fixpt.
			endif

		case iState% = stateInterTrialInterval% then

			if tNow - tStateStart > tunTimeOutTime then

				PrintLog("stateInterTrialInterval: time out is done.\n");
				ChangeStateTo(stateStartTrial%, tNow);

			endif

		case iState% = stateHoldFixation% then

			if Looking%(xEye, yEye) = 0 then
	       		
				PrintLog("stateWaitForFixation: outside fixation window, aborting trial.\n");
				ChangeStateTo(stateAbort%, tNow);

			else 

				if tNow - tStateStart > tunFixationDuration then

					' turn off stimulus and advance it
					PrintLog("stateWaitForFixation: successful trial. Turn off and advance stimulus.\n");
					SampleKey("s");
					Yield();
					SampleKey("a");
	
					' Reward
					Reward%();
	
					' Process spikes
					PlotSpikes(tStimOn, tNow, 1, GetPlotXCoord(nTrialsCompleted%));
					nTrialsCompleted% += 1;

					' Now wait until stim is off
					ChangeStateTo(stateWaitForStimOff%, tNow);

				endif

			endif

		case iState% = stateWaitForStimOff% then

			tTrigger := NextTime(StimChannel%, tLast, vTrigger);
			if tTrigger > tLast and vTrigger = 1 then
				' Fixation point is up
				PrintLog("stateWaitForStimOff: stimulus is off.\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateTrialCompleted%, tNow);
			endif

		case iState% = stateTrialCompleted% then

			if nTrialsCompleted% = (tunNAdvances%+1)*tunNRepeats% then
				' We're all done
				ChangeStateTo(stateDone%, tNow);
				Stop%();
				iStatus% := 0;
			else
				ChangeStateTo(stateMaintainFixation%, tNow);
			endif
				
		case iState% = stateMaintainFixation% then

			if Looking%(xEye, yEye) = 0 then
	       		
				PrintLog("stateMaintainFixation: outside fixation window, aborting trial.\n");
				ChangeStateTo(stateAbort%, tNow);

			else 
				if tNow - tStateStart > tunMaintainFixation then
	
					PrintLog("stateMaintainFixation: success.\n");
					Reward%();
					SampleKey("S");
					ChangeStateTo(stateWaitForStimOn%, tNow);
	
				endif 
			endif

		else
			
			' Unknown state!
			Message("Unknown state=" + str$(iState%));
			halt;

	endcase;

	tLast := tNow;
	return iStatus%;
end;


func GetPlotXCoord(nTrials%)
	var x;
	var n%;
	n% := nTrials% mod (tunNAdvances% + 1);
	x := tunValues[n%];
	PrintLog("Plot x " + str$(x) + "\n");
	return x;
end;

proc PlotSpikes(t1, t2, vOnOff%, x)
	var rate;
	var index%;
	for index% := 1 to NumberOfElectrodes% do
		rate := View(DataWindow%).Count(index%, t1, t2)/(t2-t1);
		if rate >= 0 then
			if vOnOff% = 1 then
				' this is signal
				View(TuningWindow%[index%-1]).XYAddData(index%, x, rate);
			endif
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	        endif 
	next
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end





proc InitializeWindows()

	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(0,48,50,95);
	View(DataWindow%).WindowVisible(1);

	' open xy window to display tuning results
	TuningWindow%[0] := FileNew(12);
	Window(50, 0, 100, 95);
	ChanTitle$(0, "Spikes/s");
	TuningCurveLabels();
	WindowVisible(1);


	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 50, 47);
	XYColour(1,16);
	XYSize(1,-1);


	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iStimWindowChannel% := XYSetChan(0);
	XYColour(2,13);
	XYDrawMode(2,2,1);
	XYJoin(2,1);
	'Draw the fixation window
	XYAddData(2, FixWindowX[], FixWindowY[]);

	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);

	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(4,13);
	XYDrawMode(4,3,1);
	XYJoin(4,2);
	XYAddData(4,-9,-7);
	XYAddData(4,9,-7);
	XYAddData(4,9,7);
	XYAddData(4,-9,7);

end;

proc TuningCurveLabels()


	docase 
		case tunType$ = tunTypeContrast$ then

			WindowTitle$("Contrast Tuning");
			XUnits$("Contrast (%)");
			ChanTitle$(1, "Chan 1");
			XRange(tunContrastMinContrast, tunContrastMaxContrast);

		case tunType$ = tunTypeOrientation$ then

			WindowTitle$("Orientation Tuning");
			XUnits$("Orientation (degrees)");
			ChanTitle$(1, "Chan 1");
			XRange(tunOriMinOrientation, tunOriMaxOrientation);

		case tunType$ = tunTypeSpatial$ then

			WindowTitle$("Spatial Frequency Tuning");
			XUnits$("Spatial Frequency");
			ChanTitle$(1, "Chan 1");
			XRange(tunSpatialMinSF, tunSpatialMaxSF);
	
		case tunType$ = tunTypeTemporal$ then

			WindowTitle$("Temporal Frequency Tuning");
			XUnits$("Temporal Frequency");
			ChanTitle$(1, "Chan 1");
			XRange(tunTemporalMinTF, tunTemporalMaxTF);

		case tunType$ = tunTypeArea$ then

			WindowTitle$("Aperture Area Tuning");
			XUnits$("Aperture Diameter");
			ChanTitle$(1, "Chan 1");
			XRange(tunAreaMinDiam, tunAreaMaxDiam);

		else

			Message("TuningCurveLabels Error - unknown value for tunType$: " + tunType$);

	endcase;

end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
	SampleClear(); 'Set standard sampling state
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit

	'Channel recording definitions
	SampleEvent(FrameTriggerChannel%,0,2,3600); 'Trigger channel, level
	SampleComment$(FrameTriggerChannel%,"Frame");
	SampleTitle$(FrameTriggerChannel%,"Frame");

	SampleEvent(FixationPointChannel%,1,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixation");
	SampleTitle$(FixationPointChannel%,"Fixation");
	
	SampleEvent(StimChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
	
	SampleEvent(StimChangeChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(StimChangeChannel%,"Stim Chg.");
	SampleTitle$(StimChangeChannel%,"Stim Chg.");
	
	SampleEvent(ReadyChannel%,6,2,3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");

	for index := 1 to NumberOfElectrodes% do
		SampleWaveMark(index,index-1,2000,34,15,28000); ' chan, port, event rate, points, pre-trigger, rate
		SampleTitle$(index,"Electrode_"+Str$(index)); 
	next
	
	SampleWaveform(XChannel%,14,1000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%,15,1000);
	SampleTitle$(YChannel%,"Eye Y");
	
	SampleSequencer(script$ + "Tuning.pls");
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;



' Get grating p[arameters from registry AlertRig\\(config)\\Gratings\\type$
func GetGratingParameters$(type$)
	var key$;
	var stmp$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\Gratings";
	Profile(key$, type$, "", stmp$);
	return stmp$;
end;


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()

	' Disable idle process func
	ToolbarSet(0,"");

	' Tell stim app to shut down
	SampleKey("Q");
	Yield(.1);
	SampleStop();

	ProgKill(StimHandle%);
'	ProgRun(bin$ + "\\ClearTrigger",0);

	' Write parameter file
	WriteParameterFile();

	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
	TotalRewards% += nTrialsCompleted%;
	SaveDailyTotals();


end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", DistanceToScreenMM$);
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
	Print("Number of electrodes       : %d\n", NumberOfElectrodes%);
	Print("Juices per reward          : %d\n", JuicePerReward%);
	Print("Background color           : %s\n", tunBackgroundColor$);

	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);

	' write stimulus parameters
	Print("\nStimulus\n");
	Print("-------------------\n\n");

	var Tstimstr$;
	var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
   Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);


	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

	Print("Fixation time(s)       : %f\n", tunFixationDuration);
	Print("Maintain fixation (s)  : %f\n", tunMaintainFixation);
	Print("Time out (s)           : %f\n", tunTimeOutTime);
	Print("Acquisition time (s)   : %f\n", tunAcquisitionTime);

	Print("\nTuning parameters\n");
	Print("-------------------\n\n");
	docase 
		case tunType$ = tunTypeContrast$ then

			Print("Type:                  : Contrast\n");
			Print("Min,Max,#Steps         : %f,%f,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%);
			Print("Values: " + StringifyProgression$(tunNAdvances%, tunValues) + "\n");
'			Tstepsize := (tunContrastMaxContrast - tunContrastMinContrast)/tunContrastNSteps%;
'			for i% := 0 to tunContrastNSteps% do
'				if i% > 0 then Print(", "); endif;
'				Print("%f", tunContrastMinContrast + i%*Tstepsize);
'			next;
			Print("\n");


		case tunType$ = tunTypeOrientation$ then

			Print("Type:                  : Orientation\n");
			Print("Min,Max,#Steps         : %f,%f,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%);
			Print("Values: " + StringifyProgression$(tunNAdvances%, tunValues) + "\n");
'			Print("Values: ");
'			Tstepsize := (tunOriMaxOrientation - tunOriMinOrientation)/tunOriNSteps%;
'			for i% := 0 to tunOriNSteps% do
'				if i% > 0 then Print(", "); endif;
'				Print("%f", tunOriMinOrientation + i%*Tstepsize);
'			next;
			Print("\n");

		case tunType$ = tunTypeSpatial$ then

			Print("Type:                  : Spatial Frequency\n");
			Print("Min,Max,#Steps         : %f,%f,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%);
			Print("Values: " + StringifyProgression$(tunNAdvances%, tunValues) + "\n");
'			Print("Values: ");
'			Tstepsize := (tunSpatialMaxSF - tunSpatialMinSF)/tunSpatialNSteps%;
'			for i% := 0 to tunSpatialNSteps% do
'				if i% > 0 then Print(", "); endif;
'				Print("%f", tunSpatialMinSF + i%*Tstepsize);
'			next;
			Print("\n");
	
		case tunType$ = tunTypeTemporal$ then

			Print("Type:                  : Temporal Frequency\n");
			Print("Min,Max,#Steps         : %f,%f,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%);
			Print("Values: " + StringifyProgression$(tunNAdvances%, tunValues) + "\n");
'			Print("Values: ");
'			Tstepsize := (tunTemporalMaxTF - tunTemporalMinTF)/tunTemporalNSteps%;
'			for i% := 0 to tunTemporalNSteps% do
'				if i% > 0 then Print(", "); endif;
'				Print("%f", tunTemporalMinTF + i%*Tstepsize);
'			next;
			Print("\n");

		case tunType$ = tunTypeArea$ then

			Print("Type:                  : Aperture Area\n");
			Print("Min,Max,#Steps         : %f,%f,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%);
			Print("Values: " + StringifyProgression$(tunNAdvances%, tunValues) + "\n");
'			Print("Values: ");
'			Tstepsize := (tunTemporalMaxTF - tunTemporalMinTF)/tunTemporalNSteps%;
'			for i% := 0 to tunTemporalNSteps% do
'				if i% > 0 then Print(", "); endif;
'				Print("%f", tunTemporalMinTF + i%*Tstepsize);
'			next;
			Print("\n");

		else

			Print("TuningCurve Error - unknown value for tunType$: %s\n", tunType$);

	endcase;





	' close parfile
	FileClose(0);

end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
	var FixationPoint$;
	var Extras$;
	var Tune$;
	var Distractors$:="";
	var Values$;
	
	SampleStart(0); 'Start sampling
	SampleKey("0");
	
	' Stimulus is always used
	Distractors$ := " -g " + GetGratingParameters$("Stimulus");
	Values$ := StringifyProgression$(tunNAdvances%, tunValues);	
	Extras$ := " -b " + tunBackgroundColor$ + " -d " + DistanceToScreenMM$;
	docase 
		case tunType$ = tunTypeContrast$ then

'			Tune$ := " -C " + str$(tunContrastMinContrast) + "," + str$(tunContrastMaxContrast) + "," + str$(tunContrastNSteps%);
			Tune$ := " -C " + Values$;

		case tunType$ = tunTypeOrientation$ then

'			Tune$ := " -O " + str$(tunOriMinOrientation) + "," + str$(tunOriMaxOrientation) + "," + str$(tunOriNSteps%);
			Tune$ := " -O " + Values$;

		case tunType$ = tunTypeSpatial$ then

'			Tune$ := " -S " + str$(tunSpatialMinSF) + "," + str$(tunSpatialMaxSF) + "," + str$(tunSpatialNSteps%);
			Tune$ := " -S " + Values$;
	
		case tunType$ = tunTypeTemporal$ then

'			Tune$ := " -T " + str$(tunTemporalMinTF) + "," + str$(tunTemporalMaxTF) + "," + str$(tunTemporalNSteps%);
			Tune$ := " -T " + Values$;

		case tunType$ = tunTypeArea$ then

			Tune$ := " -A " + Values$;

		else

			Message("Error - unknown value for tunType$: " + tunType$);
			Halt;

	endcase;
	
	'CommandLine$ := "cmd /c " + bin$ + "\\dAttention " + FixationArg$ + Extras$ + Distractors$;
	CommandLine$ := "cmd /k " + bin$ + "\\Tuning " + FixationArg$ + Extras$ + Distractors$ + Tune$;
	
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(CommandLine$+"\n");
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	'Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(.1);
return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawStim
' 
' Draws stimulus in xy window (iDraw%==1) or blanks it (0). 
proc DrawStim(iDraw%)

	if iDraw% > 0 then
		var xstim, ystim;
		xstim := FixationX;
		ystim := FixationY;

		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLogProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a linear progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLinearProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (xmax -xmin)/nsteps%;
	for v := xmin to xmax+stepsize/2 step stepsize do
	'	PrintLog("Value=" + str$(v) + "\n");
		vec[i%] := v;
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
Func StringifyProgression$(nsteps%, vec[])
	var s$;
	var i%;
	for i% := 0 to nsteps% do
		if i% > 0 then 
			s$ += ",";
		endif
		s$ += str$(vec[i%]);
	next
	return s$;
end;


