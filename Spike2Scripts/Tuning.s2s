' $Id: Tuning.s2s,v 1.34 2011-02-08 00:00:34 devel Exp $

#include "../../Spike2Util/ChannelUtilities.s2s"
#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "TuningDialogs.s2s"
#include "UsreyGratings.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var tunAlwaysLooking% := 1; ' If set eye signals ignored - subject presumed to be looking always. TESTING ONLY.

var tunFixationDuration := 2.0;	' Time required to hold fixation for reward (stim ON)
var tunMaintainFixation := 2.0;	' Time required to hold fixation for reward (stim OFF)
var tunAcquisitionTime := 1.0;		' Time allowed to acquire fixation
var tunBackgroundColor$ := "gray";	' background color for stim
var tunAcqFailTime := 2.0;			' Wait time after acquisition failure
var tunHoldFailTime := 2.0;			' Wait time after failure to hold fixation (not on the first time after acquisition)
var tunMaintainFailTime := 2.0;	' Wait time after breaking fixation during maintain phase
var tunTimeOutTime := 2.0;			' Wait time after failure to hold fixation (first time after acquisition)
var tunDoRivalry% := 0;          ' If checked, run for the rivalry rig

' These will be set by the tuning curve choice
var tunNAdvances%;		' Number of times stim will advance during one repeat
var tunNRepeats%;		' Number of repeats

' This vector will hold the actual values to step through. Some are log steps, some are not. 
' The Indices array is the order to step through the values with: tunValues[tunValuesIndices%[0]], tunValues[tunValuesIndices%[1]], ...
var tunValues[100];
var tunValuesIndices%[100]; 
var tunNValues%;
var tunValuesStringified$;



const tundlgOrientationButton% := 9;
const tundlgContrastButton% := 10;
const tundlgSpatialButton% := 11;
const tundlgTemporalButton% := 12;
const tundlgAreaButton% := 13;
const tundlgDonutButton% := 14;

' Wavemarks and continuous ports are specified elsewhere
var tunNWavemarks% := 0;
var tunWavemarkPorts%[16];
var tunNContinuous% := 0;
var tunContinuousPorts%[16];


proc GetTuningCurveScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
	tunFixationDuration := GetFloatRegistryValue(key$, "FixationDuration", tunFixationDuration);
	tunMaintainFixation := GetFloatRegistryValue(key$, "MaintainFixation", tunMaintainFixation);
    tunAcquisitionTime := GetFloatRegistryValue(key$, "AcquisitionTime", tunAcquisitionTime);
    tunAcqFailTime := GetFloatRegistryValue(key$, "AcqFailTime", tunAcqFailTime);
    tunHoldFailTime := GetFloatRegistryValue(key$, "HoldFailTime", tunHoldFailTime);
    tunMaintainFailTime := GetFloatRegistryValue(key$, "MaintainFailTime", tunMaintainFailTime);
    tunTimeOutTime := GetFloatRegistryValue(key$, "TimeOutTime", tunTimeOutTime);
    tunBackgroundColor$ := GetStringRegistryValue$(key$, "BackgroundColor", tunBackgroundColor$);
    tunDoRivalry% := GetIntRegistryValue%(key$, "DoRivalry", tunDoRivalry%);
end;

proc SaveTuningCurveScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
	SetFloatRegistryValue(key$, "FixationDuration", tunFixationDuration);
	SetFloatRegistryValue(key$, "MaintainFixation", tunMaintainFixation);
    SetFloatRegistryValue(key$, "AcquisitionTime", tunAcquisitionTime);
    SetFloatRegistryValue(key$, "AcqFailTime", tunAcqFailTime);
    SetFloatRegistryValue(key$, "HoldFailTime", tunHoldFailTime);
    SetFloatRegistryValue(key$, "MaintainFailTime", tunMaintainFailTime);
    SetFloatRegistryValue(key$, "TimeOutTime", tunTimeOutTime);
    SetStringRegistryValue(key$, "BackgroundColor", tunBackgroundColor$);
    SetIntRegistryValue(key$, "DoRivalry", tunDoRivalry%);
    PrintLog("Saved DoRivalry=%d\n", tunDoRivalry%);
end;


' TuningCurveScriptDialog
' This dialog uses two global variables, tunContext$ and tunType$. 
' Set tunContext$ = tunContextConfig$ to run in the config scripts. The dialog 
' and its children (TuningCurveOrientationDialog, etc) will behave as expected, 
' allowing the user to set parameters and saving them in the registry. Set 
' tunContext$ = tunContextDAQ$ to run in a DAQ script. In this context you 
' must check the return value of the dialog and (possibly) the value of 
' tunType$. If the user hits Cancel in the main dialog, the return value is 0. 
' If the user selects a subdialog and hits OK, the return value will be 1 and 
' the value of tunType$ will be one of (tunTypeOrientation$, tunTypeContrast$, 
' tunTypeSpatial$, tunTypeTemporal$). Here, proceed directly to DAQ. If the 
' user Hits Cancel from the subdialog, then they return to the main dialog. If 
' they hit OK from the main dialog, then the return value is 1, but 
' tunType$ = tunTypeNone$. 


func TuningCurveScriptDialog%()
	var i%;
	var iReturn%;
	GetTuningCurveScriptParameters();
	var bcl$[3];
	var ibcl%:=0;
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
	for i%:=0 to 2 do
		if tunBackgroundColor$ = bcl$[i%] then
			ibcl% := i%;
		endif
	next;

	DlgCreate("Tuning Curve Parameters", 50, 10);
	DlgGroup("Common Parameters", 0, 1, 40, 10);
	DlgReal(1, "Acquisition time(s):", 1, 1000, 20, 2);
	DlgReal(2, "Fixation duration(s):", .1, 10, 20, 3);
	DlgReal(3, "Maintain fixation(s):", .1, 10, 20, 4);
	DlgReal(4, "Acquisition fail time(s):", .01, 10, 20, 5);
	DlgReal(5, "Hold fixation failure time(s):", .01, 10, 20, 6);
	DlgReal(6, "Maintain fixation fail time(s):", .01, 10, 20, 7);
	DlgReal(7, "Time out time(s):", .01, 10, 20, 8);
	DlgList(8, "Background color:", bcl$, 3, 20, 9);
    DlgCheck(9, "Dual VSG rig", 2, 10);
	DlgGroup("Individual Tuning Curve Types", 0, 11, 40, 7);
	DlgButton(tundlgOrientationButton%, "Orientation", TuningCurveOrientationDialog%, 1, 12);
	DlgButton(tundlgContrastButton%, "Contrast", TuningCurveContrastDialog%, 1, 13);
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 1, 14);
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 1, 15);
	DlgButton(tundlgAreaButton%, "Area", TuningCurveAreaDialog%, 1, 16);
	DlgButton(tundlgDonutButton%, "Donuts!", TuningCurveDonutDialog%, 1, 17);
	
	i%:=DlgShow(tunAcquisitionTime, tunFixationDuration, tunMaintainFixation,
    tunAcqFailTime, tunHoldFailTime, tunMaintainFailTime, tunTimeOutTime, ibcl%, tunDoRivalry%);
    
    ' djs 4-1-09
    ' Spike2 v6 change. DlgShow will return the button number when a button on the dialog is hit and the corresponding
    ' function returns 0. In this case those buttons open the various tuning type sub dialogs (orientation, area, etc). 
    ' In the last version, DlgShow would return the same value that the subdialog's function returned, and the code here
    ' was set up to behave accordingly. When the user hits the Cancel button in the subdialog everything still remains
    ' the same. 
    
    ' djs 2-4-2011
    ' Spike2v6 bug (see TuningDialogs.s2s) workaround requires that the tuning type dialogs return something > 0. 
    ' That will mean that closing any of those dialogs will not cause the main dialog (this one) to close automatically. 
    ' When it did close automatically the return value from DlgShow above was the same as the button that caused
    ' the close. Now, that button is NOT causing the close, so the return value is going to be 1 (not the button number). 
    ' In addition, the return value from this function needs to change because we now assume that the user will have
    ' to hit OK on this dialog to start the experiment. Thus, make sure that the return value from this function is 1
    ' when user hits OK and 0 when user hits Cancel. Also, do not save script parameters when user hits Cancel.
    
    PrintLog("Tuning Curve Parameters Dialog - return from DlgShow is %d\n", i%);
    '	if i%=tundlgOrientationButton% or i%=tundlgContrastButton% or i%=tundlgSpatialButton% or i%=tundlgTemporalButton% or i%=tundlgAreaButton% then
    if i% = 1 then
		tunBackgroundColor$ := bcl$[ibcl%];
		SaveTuningCurveScriptParameters();
		if tunContext$ = tunContextDAQ$ then 
            iReturn% := 1;
		else iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		PrintLog("Tuning Curve Parameters dialog - user hit Cancel, tunType=" + tunType$ + "\n");
		if tunContext$ = tunContextDAQ$ then 
			if tunType$ <> tunTypeNone$ then 
				iReturn% := 0;
				'SaveTuningCurveScriptParameters();
			else iReturn% := 0;
		 	endif;
		else
			iReturn% := 2;		' The calling/main dialog would close if we returned 0
		endif;
	endif;
	return iReturn%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameTriggerChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;

' tuning curves
var TuningWindow%[16];	' one for each wavemark channel
' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Init logging
LogInit(1);

' Check if always looking flag is set. If so, issue a warning. 
if tunAlwaysLooking% = 1 then
    if Query("Always looking is SET. Unset?") = 1 then
        tunAlwaysLooking% := 0;
    endif
endif

' run parameters script....
tunContext$ := tunContextDAQ$;
tunType$ := tunTypeNone$;

GetTuningCurveScriptParameters();
iScript% := TuningCurveScriptDialog%();
if iScript% = 1 then
	if tunType$ = tunTypeNone$ then
		LogInfo("No tuning type selected, exit gracefully\n");
		Halt;
	else
		LogInfo("Tuning type \"" + tunType$ + "\" selected, proceed with DAQ. DoRivalry = " + str$(tunDoRivalry%));
	endif;
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;





' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 21;
YChannel% := 22;
FixationPointChannel% := 24;
StimChannel% := 25;
StimChangeChannel% := 26;
ReadyChannel% := 27;            ' Look for ready signal on port 2 (same as fixpt). 

' Fetch electrode information. 
tunNWavemarks% := GetWavemarkPorts%(tunWavemarkPorts%[]);
tunNContinuous% := GetContinuousPorts%(tunContinuousPorts%[]);

CreateSampleConfiguration();


' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
'	ToolbarSet(6,"Exp Parameters",AttentionScriptDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
    if tunAlwaysLooking% = 1 then return 1; endif;
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
	var i%;
	for i%:=1 to JuicePerReward% do Yield(.05); SampleKey("J"); next
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 
var tInterTrialTime := 0;	' Time spent waiting between trials (i.e. after screen is blank, but before fix point is presented)
var iHoldCount% := 0;	' Counter of how many times we progress through the hold fixation state in the maintainence loop. Used to decide if "time out" is required. 
var tRise, tFall;

' Constants for states
const stateStartTrial%:=0;		' Start trial state
const stateWaitForFixPtOn%:=1;		' Waiting for fixation point return trigger (on)
const stateWaitForBlank%:=2;		' Waiting for fixation point return trigger (off)
const stateWaitForStimOn%:=3;		' Wait for stimulus return trigger (on)
const stateWaitForStimOff%:=4;		' Wait for stimulus return trigger (off)
const stateWaitForAcquisition%:=5;	' Waiting for subject to acquire fixation point
const stateHoldFixation%:=6;		' Holding fixation point
const stateAbort%:=7;			' Failed trial state
const stateMaintainFixation%:=8;	' Maintaining fixation (stim off period)
const stateInterTrialInterval%:=9;	' time out after failed trial
const stateVSGWait%:=10;		' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		' trial has been completed successfully
const stateDone%:=13;	
var iState% := stateVSGWait%;	' present state

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 

func IdleProcessing%()
	var iStatus% := 1;	
	tNow := View(DataWindow%).MaxTime();
    
    ' First time through (tLast<0) just update tLast. Crosstalk on vsg dig outputs leads to erroneous
    ' triggers. Maybe this will help. 
    if tLast < 0 then
        tLast := tNow;
        return 1;
    endif
    
    
	xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
	yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastUpdate := tNow;
	endif

	docase 
    case iState% = stateVSGWait% then
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        if View(DataWindow%).FindPulseUp%(ReadyChannel%, -1, tRise, tFall) = 1 then
            LogStatus("VSGWait", "Got Ready Pulse from VSG");
            Yield(1.0);
            tLastTrigger := tFall;
            ChangeStateTo(stateStartTrial%, tFall);
        endif;

    case iState% = stateStartTrial% then

        ' Start trial. Put up fixation point.
        LogStatus("StartTrial", "Request fixpt");
        SampleKey("F");
        ChangeStateTo(stateWaitForFixPtOn%, tNow);
    
    case iState% = stateWaitForFixPtOn% then
    
        if View(DataWindow%).FindRisingEdge%(FixationPointChannel%, tLast, tTrigger) = 0 then
            ' Fixation point is up
            LogStatus("WaitForFixPtOn", "Fixpt on at " + str$(tTrigger) + "\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateWaitForAcquisition%, tTrigger);
            DrawStim(1);	' actually this draws the location of the fixpt.
'        else
 '           LogStatus("WaitForFixPtOn", "Waiting at " + str$(tLast));
        endif

    case iState% = stateWaitForAcquisition% then

        ' Waiting for eye to fall inside of fixation window
        if Looking%(xEye, yEye) = 1 then
            LogStatus("WaitForAcquisition", "Eye in fixation window; request stim");
            SampleKey("S");
            iHoldCount% := 0;
            ChangeStateTo(stateWaitForStimOn%, tNow);
        else 
            if tNow - tStateStart > tunAcquisitionTime then
                ' failed to acquire target. 
                tInterTrialTime := tunAcqFailTime;
                LogStatus("WaitForAcquisition", "Failed.");
                ChangeStateTo(stateAbort%, tNow);
            endif
        endif

    case iState% = stateWaitForStimOn% then

        if View(DataWindow%).FindRisingEdge%(StimChannel%, tLast, tTrigger) = 0 then
            ' Fixation point is up
            LogStatus("WaitForStimOn", "Stim is up at " + str$(tTrigger));
            tStimOn := tTrigger;
            tLastTrigger := tTrigger;
            ChangeStateTo(stateHoldFixation%, tTrigger);
        endif

        
    case iState% = stateAbort% then

        ' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
        ' fixpt off. 
        SampleKey("X");
        ChangeStateTo(stateWaitForBlank%, tNow);

    case iState% = stateWaitForBlank% then

        ' we just wait for fix point off signal in this case. 
        if View(DataWindow%).FindFallingEdge%(FixationPointChannel%, tLast, tTrigger) = 1 then
            ' Fixation point is off
            tLastTrigger := tTrigger;
            ChangeStateTo(stateInterTrialInterval%, tTrigger);
            DrawStim(0);	' actually this draws the location of the fixpt.
        endif

    case iState% = stateInterTrialInterval% then

        if tNow - tStateStart > tInterTrialTime then

            ChangeStateTo(stateStartTrial%, tNow);

        endif

    case iState% = stateHoldFixation% then

        if Looking%(xEye, yEye) = 0 then
            
            LogStatus("WaitForFixation", "Fixation broken, aborting trial.");
            if iHoldCount% = 0 then 
                tInterTrialTime := tunTimeOutTime;
            else
                tInterTrialTime := tunHoldFailTime;
            endif
            ChangeStateTo(stateAbort%, tNow);

        else 

            if tNow - tStateStart > tunFixationDuration then

                iHoldCount% += 1;

                ' turn off stimulus and advance it
                LogStatus("HoldFixation", "Turn off and advance stimulus.");
                SampleKey("s");
                Yield();
                
                ' Reward
                Reward%();
                
                ' Process spikes
                PlotSpikes(tStimOn, tNow, 1, GetPlotXCoord(nTrialsCompleted%));
                nTrialsCompleted% += 1;

                ' Now wait until stim is off
                ChangeStateTo(stateWaitForStimOff%, tNow);

            endif

        endif

    case iState% = stateWaitForStimOff% then

        if View(DataWindow%).FindFallingEdge%(StimChannel%, tLast, tTrigger) = 1 then
            ' Advance
            SampleKey("a");

            tLastTrigger := tTrigger;
            ChangeStateTo(stateTrialCompleted%, tNow);
        endif

    case iState% = stateTrialCompleted% then

        if nTrialsCompleted% = (tunNAdvances%+1)*tunNRepeats% then
            ' We're all done
            ChangeStateTo(stateDone%, tNow);
            Stop%();
            iStatus% := 0;
        else
            ChangeStateTo(stateMaintainFixation%, tNow);
        endif
            
    case iState% = stateMaintainFixation% then

        if Looking%(xEye, yEye) = 0 then

        tInterTrialTime := tunMaintainFailTime;
    
            LogStatus("MaintainFixation", "Broken; aborting trial");
            ChangeStateTo(stateAbort%, tNow);

        else 
            if tNow - tStateStart > tunMaintainFixation then

                LogStatus("MaintainFixation", "success");
                Reward%();
                SampleKey("S");
                ChangeStateTo(stateWaitForStimOn%, tNow);

            endif 
        endif

    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;

	endcase;

	tLast := tNow;
	return iStatus%;
end;


func GetPlotXCoord(nTrials%)
	var x;
	var n%;
	n% := nTrials% mod (tunNAdvances% + 1);
	x := tunValues[tunValuesIndices%[n%]];
	return x;
end;

proc PlotSpikes(t1, t2, vOnOff%, x)
	var rate;
	var index%; ' = i+1
    var i%;
	for i% := 0 to tunNWavemarks%-1 do
		rate := View(DataWindow%).Count(i%+1, t1, t2)/(t2-t1);
		if rate >= 0 then
			if vOnOff% = 1 then
				' this is signal
                'PrintLog("%d Count %f\n", i%, rate*(t2-t1));
				View(TuningWindow%[i%]).XYAddData(1, x, rate);    ' channel 1 is data; channel 2 is background
			endif
			' NOTE: IGNORING BACKGROUND HERE FOR THE TIME BEING. 
	    endif 
	next
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end





proc InitializeWindows()
    var i%;
    var WindowStep;
    
	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(0,48,50,95);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);

	' open xy window to display tuning results
    
    if tunNWavemarks% > 0 then
        WindowStep := 100/tunNWavemarks%;
    endif
    for i% := 0 to tunNWavemarks% do
        TuningWindow%[i%] := FileNew(12);
        Window(50, i%*WindowStep, 100, (i%+1)*WindowStep);
        ChanTitle$(0, "Spikes/s");
        TuningCurveLabels(tunWavemarkPorts%[i%]);
        WindowVisible(1);
    next

	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 50, 47);
	XYColour(1,16);
	XYSize(1,-1);


	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iStimWindowChannel% := XYSetChan(0);
	XYColour(2,13);
	XYDrawMode(2,2,1);
	XYJoin(2,1);
	'Draw the fixation window
	XYAddData(2, FixWindowX[], FixWindowY[]);

	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);

	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(4,13);
	XYDrawMode(4,3,1);
	XYJoin(4,2);
	XYAddData(4,-9,-7);
	XYAddData(4,9,-7);
	XYAddData(4,9,7);
	XYAddData(4,-9,7);

end;

proc TuningCurveLabels(iport%)

    var s$;
    s$ := "Port " + str$(iport%);
	docase 
		case tunType$ = tunTypeContrast$ then

			WindowTitle$("Contrast Tuning - " + s$);
			XUnits$("Contrast (%)");
			ChanTitle$(1, "Chan 1");
			XRange(tunContrastMinContrast, tunContrastMaxContrast);

		case tunType$ = tunTypeOrientation$ then

			WindowTitle$("Orientation Tuning - " + s$);
			XUnits$("Orientation (degrees)");
			ChanTitle$(1, "Chan 1");
			XRange(tunOriMinOrientation, tunOriMaxOrientation);

		case tunType$ = tunTypeSpatial$ then

			WindowTitle$("Spatial Frequency Tuning - " + s$);
			XUnits$("Spatial Frequency");
			ChanTitle$(1, "Chan 1");
			XRange(tunSpatialMinSF, tunSpatialMaxSF);
	
		case tunType$ = tunTypeTemporal$ then

			WindowTitle$("Temporal Frequency Tuning - " + s$);
			XUnits$("Temporal Frequency");
			ChanTitle$(1, "Chan 1");
			XRange(tunTemporalMinTF, tunTemporalMaxTF);

		case tunType$ = tunTypeArea$ then

			WindowTitle$("Aperture Area Tuning - " + s$);
			XUnits$("Aperture Diameter");
			ChanTitle$(1, "Chan 1");
			XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
		case tunType$ = tunTypeDonut$ then

			WindowTitle$("Donut Area Tuning - " + s$);
			XUnits$("Outer Diameter");
			ChanTitle$(1, "Chan 1");
			XRange(tunAreaMinDiam, tunAreaMaxDiam);
        
		else

			Message("TuningCurveLabels Error - unknown value for tunType$: " + tunType$);

	endcase;

end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;
	SampleClear(); 'Set standard sampling state
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    docase
        
    case tunType$ = tunTypeContrast$ then 
        SampleAutoName$(dataCellName$ + "_con_000");
        tunNAdvances% := tunContrastNSteps%;
        tunNRepeats% := tunContrastNRepeats%;
        GetRepeatedParameterProgression%(tunContrastNSteps%+1, tunContrastNRepeats%, tunValues[], tunValuesIndices%[], tunContrastMinContrast, tunContrastMaxContrast, 1, tunContrastProgression%);
        tunNValues% := (tunContrastNSteps%+1)*tunContrastNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeOrientation$ then 
        SampleAutoName$(dataCellName$ + "_ori_000");
        tunNAdvances% := tunOriNSteps%;
        tunNRepeats% := tunOriNRepeats%;
        GetRepeatedParameterProgression%(tunOriNSteps%+1, tunOriNRepeats%, tunValues[], tunValuesIndices%[], tunOriMinOrientation, tunOriMaxOrientation, 0, tunOriProgression%);
        tunNValues% := (tunOriNSteps%+1)*tunOriNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeSpatial$ then 
        SampleAutoName$(dataCellName$ + "_spa_000");
        tunNAdvances% := tunSpatialNSteps%;
        tunNRepeats% := tunSpatialNRepeats%;
        GetRepeatedParameterProgression%(tunSpatialNSteps%+1, tunSpatialNRepeats%, tunValues[], tunValuesIndices%[], tunSpatialMinSF, tunSpatialMaxSF, 1, tunSpatialProgression%);        
        tunNValues% := (tunSpatialNSteps%+1)*tunSpatialNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeTemporal$ then 
        SampleAutoName$(dataCellName$ + "_tem_000");
        tunNAdvances% := tunTemporalNSteps%;
        tunNRepeats% := tunTemporalNRepeats%;
        GetRepeatedParameterProgression%(tunTemporalNSteps%+1, tunTemporalNRepeats%, tunValues[], tunValuesIndices%[], tunTemporalMinTF, tunTemporalMaxTF, 1, tunTemporalProgression%);
        tunNValues% := (tunTemporalNSteps%+1)*tunTemporalNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeArea$ then 
        SampleAutoName$(dataCellName$ + "_area_000");
        tunNAdvances% := tunAreaNSteps%;
        tunNRepeats% := tunAreaNRepeats%;
        GetRepeatedParameterProgression%(tunAreaNSteps%+1, tunAreaNRepeats%, tunValues[], tunValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
        tunNValues% := (tunAreaNSteps%+1)*tunAreaNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
    case tunType$ = tunTypeDonut$ then 
        SampleAutoName$(dataCellName$ + "_donut_000");
        tunNAdvances% := tunAreaNSteps%;
        tunNRepeats% := tunAreaNRepeats%;
        GetRepeatedParameterProgression%(tunAreaNSteps%+1, tunAreaNRepeats%, tunValues[], tunValuesIndices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
        tunNValues% := (tunAreaNSteps%+1)*tunAreaNRepeats%;
        tunValuesStringified$ := StringifyProgression$(tunNValues%, tunValues, tunValuesIndices%);
        'PrintLog("nsteps %d nrepeats %d nvalues %d\n", tunAreaNSteps%, tunAreaNRepeats%, tunNValues%);
        'for i% := 0 to tunNValues%-1 do
        '    PrintLog("%d %f\n", i%, tunValues[tunValuesIndices%[i%]]);
        'next
    else
        SampleAutoName$(dataCellName$ + "_tun_000");
    endcase;

    SampleAutoFile(1);
    PrintLog("AutoFile status " + str$(SampleAutoFile()) + "\n");
    
	'Channel recording definitions

	SampleEvent(FixationPointChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixpt");
	SampleTitle$(FixationPointChannel%,"Fixpt");
	
	SampleEvent(StimChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
'	SampleEvent(StimChangeChannel%,3,2,3600); 'Trigger channel, level
'	SampleComment$(StimChangeChannel%,"Adv");
'	SampleTitle$(StimChangeChannel%,"Adv");
	
	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
    ' Electrodes: wavemark/continuous
    ' 12/6/2010
    ' Wavemark channels will be channels # 1-N, waveform N+1 - N+1+M, where there are N wavemark channels
    ' and M waveform channels. 
    for i% := 0 to tunNWavemarks%-1 do
		SampleWaveMark(i% + 1, tunWavemarkPorts%[i%], 2000, 34, 15, 28000); ' chan, port, event rate, points, pre-trigger, rate
		SampleTitle$(i% + 1, "WMrk " + str$(tunWavemarkPorts%[i%])); 
	next
    for i% := 0 to tunNContinuous%-1 do
        SampleWaveform(tunNWavemarks% + i% + 1, tunContinuousPorts%[i%], 20000);
        SampleTitle$(tunNWavemarks% + i% + 1, "Cont " + str$(tunContinuousPorts%[i%]));
    next
        
	'for index := 1 to NumberOfElectrodes% do
	'	SampleWaveMark(index,index-1,2000,34,15,28000); ' chan, port, event rate, points, pre-trigger, rate
	'	SampleTitle$(index,"Electrode_"+Str$(index)); 
	'next
	
	SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
	SampleTitle$(YChannel%,"Eye Y");
    
	SampleSequencer(script$ + "Tuning.pls");
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;





' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()

	' Disable idle process func
	ToolbarSet(0,"");

	' Tell stim app to shut down
	SampleKey("Q");
	Yield(.1);
	SampleStop();

	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend
'	ProgRun(bin$ + "\\ClearTrigger",0);

	' Write parameter file
	WriteParameterFile();

	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
	TotalRewards% += nTrialsCompleted%;
	SaveDailyTotals();


end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", DistanceToScreenMM$);
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Juices per reward          : %d\n", JuicePerReward%);
	Print("Background color           : %s\n", tunBackgroundColor$);

	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);

	' write stimulus parameters
	Print("\nStimulus\n");
	Print("-------------------\n\n");

	var Tstimstr$;
	var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
   Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);


	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

	Print("Fixation time(s)       : %f\n", tunFixationDuration);
	Print("Maintain fixation (s)  : %f\n", tunMaintainFixation);
	Print("Time out (s)           : %f\n", tunTimeOutTime);
	Print("Acquisition time (s)   : %f\n", tunAcquisitionTime);

	Print("\nTuning parameters\n");
	Print("-------------------\n\n");
	docase 
		case tunType$ = tunTypeContrast$ then

			Print("Type:                  : Contrast\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");


		case tunType$ = tunTypeOrientation$ then

			Print("Type:                  : Orientation\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunOriMinOrientation, tunOriMaxOrientation, tunOriNSteps%, tunOriNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeSpatial$ then

			Print("Type:                  : Spatial Frequency\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunSpatialMinSF, tunSpatialMaxSF, tunSpatialNSteps%, tunSpatialNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");
	
		case tunType$ = tunTypeTemporal$ then

			Print("Type:                  : Temporal Frequency\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunTemporalMinTF, tunTemporalMaxTF, tunTemporalNSteps%, tunTemporalNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeArea$ then

			Print("Type:                  : Aperture Area\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		case tunType$ = tunTypeDonut$ then

			Print("Type:                  : Donut Area\n");
			Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunAreaMinDiam, tunAreaMaxDiam, tunAreaNSteps%, tunAreaNRepeats%);
			Print("Values: " + tunValuesStringified$ + "\n");
			Print("\n");

		else

			Print("TuningCurve Error - unknown value for tunType$: %s\n", tunType$);

	endcase;





	' close parfile
	FileClose(0);

end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
	var FixationPoint$;
	var Extras$;
	var Tune$;
	var Stim$:="";
	var Values$;
    var Dual$;
    var key$;
    var offsetFilename$;
    var i%;
	
	SampleStart(0); 'Start sampling
	SampleKey("0");
    
	' Stimulus is always used
	Stim$ := " -s " + GetGratingParameters$("Stimulus");
	Values$ := tunValuesStringified$;
	Extras$ := " -b " + tunBackgroundColor$ + " -d " + DistanceToScreenMM$ + " -p 2 -v";
    if tunDoRivalry% = 0 then
        Dual$ := "";
    else
        ' Fetch the offset filename
        key$ := GetRegistryKey$(1) + "\\Rivalry";
        offsetFilename$ := GetStringRegistryValue$(GetRegistryKey$(1), "OffsetFile", "file_not_found");
        Dual$ := " -K -r " + offsetFilename$ + " -M ";
    endif
    
	docase 
    case tunType$ = tunTypeContrast$ then
        
        Tune$ := Dual$ + " -C " + Values$;

    case tunType$ = tunTypeOrientation$ then

        Tune$ := Dual$ + " -O " + Values$;

    case tunType$ = tunTypeSpatial$ then

        Tune$ := Dual$ + " -S " + Values$;

    case tunType$ = tunTypeTemporal$ then

        Tune$ := Dual$ + " -T " + Values$;

    case tunType$ = tunTypeArea$ then
        
        Tune$ := Dual$ + " -A " + Values$;
        
    case tunType$ = tunTypeDonut$ then
        
        ' The args for the stim must be constructed here. 
        var areaArg$, donutArg$;
        for i% := 0 to tunNValues%-1 do
            if tunValues[tunValuesIndices%[i%]] <= tunDonutOptimalDiam then
                areaArg$ += str$(tunValues[tunValuesIndices%[i%]]) + ",";
                donutArg$ += "0,0,";
            else
                areaArg$ += str$(tunDonutOptimalDiam) + ",";
                donutArg$ += str$(tunValues[tunValuesIndices%[i%]]) + "," + str$(tunDonutOptimalDiam) + ",";
            endif
        next
        areaArg$ := Left$(areaArg$, Len(areaArg$)-1);
        donutArg$ := Left$(donutArg$, Len(donutArg$)-1);
        'PrintLog("areaArg: %s\n", areaArg$);
        'PrintLog("donutArg: %s\n", donutArg$);
        Tune$ := Dual$ + " -A " + areaArg$ + " -V -H " + donutArg$;
        
    else

        Message("Error - unknown value for tunType$: " + tunType$);
        Halt;

	endcase;
	
	CommandLine$ := "cmd /k " + bin$ + "\\fixstim " + FixationArg$ + Extras$ + Stim$ + Tune$;
	
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(CommandLine$+"\n");
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(.1);
return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawStim
' 
' Draws stimulus in xy window (iDraw%==1) or blanks it (0). 
proc DrawStim(iDraw%)

	if iDraw% > 0 then
		var xstim, ystim;
		xstim := FixationX;
		ystim := FixationY;

		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLogProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Get a linear progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
Proc GetLinearProgression(xmin, xmax, nsteps%, vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (xmax -xmin)/nsteps%;
	for v := xmin to xmax+stepsize/2 step stepsize do
	'	PrintLog("Value=" + str$(v) + "\n");
		vec[i%] := v;
		i% := i% + 1;
	next;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
Func StringifyProgression$(n%, vec[], ind%[])
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
		s$ += str$(vec[ind%[i%]]);
	next
	return s$;
end;


