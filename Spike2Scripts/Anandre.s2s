' $Id: Anandre.s2s,v 1.2 2011-09-03 00:19:31 djsperka Exp $ 
'
' Anandre.s2s
'
' Does some filtering and downsampling on continuous record data. 
' Filter and downsampling parameters determined by Andre. I have
' tried to indicate where one can tweak the parameters. I also don't
' have any experience with the Spike2 filtering functions, so I 
' hope that I have reproduced the analysis that Andre asked for. 
'
' To run this analysis, open the data file and when it has focus, run this
' script. It takes a while and may consume all resources on your machine. 
' I've run this on a machine with 4GB of memory - I don't know the 
' minimum required. 
'
' Output is in the form of a Matlab ".mat" file, in same dir as the 
' data file, with same base filename. 
'
' Spike2 will appear to freeze while this is running. Be patient; large
' datafiles take a while. Haven't timed any, usually I run it and walk 
' away. Large files.....maybe 30 minutes? 

#include "../../Spike2Util/FileUtilities.s2s"



' These are the channels where we expect to find the 
' continuous record data. 
var lgnChannel% := 2;
var v1Channel% := 1;

' Filtering parameters. See the functions LFP% and MUA% below, and refer
' to Spike2 documentation for FiltCreate function. 
var lpFreq := 120;     ' low pass filter freq
var lpTRW := 70;
var bpLowFreq := 700;  ' band pass low freq
var bpHighFreq := 7000;  ' band pass hi freq
var bpTRW := 2.5;

var exportFilename$;
var xchans%[5];
xchans%[0] := 4;
var lgnLFPChannel%;
var lgnMUAChannel%;
var v1LFPChannel%;
var v1MUAChannel%;

' LGN LFP
xchans%[1] := LFP%(lgnChannel%, lpFreq, lpTRW, 0, MaxTime());
'xchans%[1] := LFP%(lgnChannel%, lpFreq, lpTRW, 0, 10);
ChanTitle$(xchans%[1], "LGN LFP");

' V1 LFP
xchans%[2] := LFP%(v1Channel%, lpFreq, lpTRW, 0, MaxTime());
'xchans%[2] := LFP%(v1Channel%, lpFreq, lpTRW, 0, 10);
ChanTitle$(xchans%[2], "V1 LFP");

' LGN MUA 
xchans%[3] := MUA%(lgnChannel%, bpTRW, bpLowFreq, bpHighFreq, lpFreq, lpTRW, 0, MaxTime());
'xchans%[3] := MUA%(lgnChannel%, bpTRW, bpLowFreq, bpHighFreq, lpFreq, lpTRW, 0, 10);
ChanTitle$(xchans%[3], "LGN MUA");

' V1 MUA
xchans%[4] := MUA%(v1Channel%, bpTRW, bpLowFreq, bpHighFreq, lpFreq, lpTRW, 0, MaxTime());
'xchans%[4] := MUA%(v1Channel%, bpTRW, bpLowFreq, bpHighFreq, lpFreq, lpTRW, 0, 10);
ChanTitle$(xchans%[4], "V1 MUA");

' Optimize and display filtered channels
Optimise(xchans%[]);
ChanShow(xchans%[]);


' Now export
ExportChanList();
ExportChanList(0, MaxTime(), xchans%[]);
exportFilename$ := ReplaceFileExtension$(0, ".mat");
PrintLog("Exporting %s\n", exportFilename$);
FileSaveAs(exportFilename$, 100, 1, "", 2, "");


func LFP%(ichan%, lpFreq, lpTRW, sTime, eTime)
    var ochan%;
    
    ' Low pass filter
    FiltCreate(-1, 2, lpTRW, lpFreq);
    ochan% := FiltApply(-1, 0, ichan%, sTime, eTime);

    ' Downsample to 1kHz
    PrintLog("Sampling frequency is %f, downsamp 1:%d\n", 1/Binsize(ochan%), Round(1/Binsize(ochan%)/1000.));
    ChanProcessAdd(ochan%, 5, Round(1/Binsize(ochan%)/1000.));
    
    return ochan%;
end

func MUA%(ichan%, bandTRW, bandLow, bandHigh, lpFreq, lpTRW, sTime, eTime)
    var ochan1%;
    var ochan2%;
    
    ' band pass filter
    FiltCreate(-1, 4, bandTRW, bandLow, bandHigh);
    ochan1% := FiltApply(-1, 0, ichan%, sTime, eTime);
    
    ' Rectify
    ChanProcessAdd(ochan1%, 0);
    
    ' Now do LFP process
    ochan2% := LFP%(ochan1%, lpFreq, lpTRW, sTime, eTime);
    
    return ochan2%;
end
