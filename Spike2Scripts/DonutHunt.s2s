

const tunCVSID$ := "$Id: DonutHunt.s2s,v 1.1 2012-07-30 16:51:17 jeff Exp $";


' Hello again
' Include all standard utilities, even if we don't use them (in case we modify for recording later)
#include "../../Spike2Util/ChannelUtilities.s2s"
#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "UsreyDAQ.s2s"
#include "DonutHuntDialogs.s2s"
#include "UsreyGratings.s2s"
#include "UsreyFixationPoint.s2s"


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Donut Hunt script START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		
var FrameChannel%;
var FrameSlaveChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;
var FixationPointSlaveChannel%;
var StimSlaveChannel%;
var ButtonChannel%;
var ButtonPort%;

' dummy vars
var iScript%;

'button stuff
var button1Press;
var button2Press;
var button1Release;
var button2Release;
var button1Thresh := 1.1;  'crossing level (downwards) for button 1, this is LEFT button
var button2Thresh := 2.0;  'crossing level (upwards) for button 2, this is RIGHT button
var buttonHysteresis := 0.05; 'how much noise we're allowing in the steady state voltage level; this may be high
var buttonMinTime := 0.005;  'five millisecond minimum
var buttonTime;  'the time of the most recent button event
var buttonStatus%;  'if 0, all buttons up, if 1, LEFT button currently pressed, if 2, RIGHT button currently pressed
var buttonDuringXHair%;
var buttonDuringSequence%;
var buttonError%;

var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 
var tStimSequence := -1;    ' time that stim sequence started; followed by pulses on frame channels
var tInterTrialTime := 0.2;	' Time spent waiting between trials (i.e. after screen is blank, but before fix point is presented) 
var tRise, tFall;
var tKludge := 0.06;    ' Add to Fixation time to account for stim sequence. Ugly hack, admittedly, but one does what one must. 


' Values for the "tuning curve"
var dhT1Values[1000];  'Value of randomized time between button press and stimulus onset
var dhLRValues[1000];  'Will be 0 for left and 1 for right, but DealStimuliToBlocks uses floats
var dhdContrastValues[1000];  'Change in contrast, will need to be integerized
var dhDonutDiamValues[1000];  'Donut Diameter values
var dhCenterOriValues[1000];  'Center orientation values
var dhNValues%;  'Number of total values, if greater than 1000, uh-oh
var dhStimulusIndices%[1000];  'like tunValuesIndices%[], random order to index the Values arrays; we only need one
var dhdContrastValuesStringified$;  
var dhDonutDiamValuesStringified$;
var dhCenterOriValuesStringified$;
var dhLRValuesStringified$;
var dhT1ValuesStringified$;




' Constants for states
const stateVSGWait%:=0;		        ' wait for vsg to send ready signal #1
const stateXHairUp%:=1;             ' have VSG put up the XHair to signal ready to initiate trial
const stateWaitForXHairOn%:= 2;     ' wait to make sure Xhair gets up
const stateWaitInitDown%:=3;        ' wait for initiation button press...
const stateWaitInitUpL%:=4;          ' wait for initiation button release
const stateWaitInitUpR%:=5;
const stateStartSequence%:=6;       ' start the trial sequence
const stateWaitOnsetTrigger%:=7;    ' wait for the stimulus onset trigger 
const stateWaitOffsetTrigger%:=8;   ' wait for the trigger indicating the sequence is over, starts response window
const stateWaitResponse%:=9;    ' wait for button press to indicate response, advance stimulus, etc.
const stateWaitRelease%:=10;     ' not timing critical, but make sure button is up before starting next trial
const stateDone%:=11;            ' get outta here!
const stateITI%:=12;             ' wait to put up next trial


var iState% := stateVSGWait%;	' present state

var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nCorrect%;
var pctCorrect;

var tic;  'Set a tick value equal to the duration of one clock tick in seconds, used to prevent finding
          'the same "pulse" twice
var pulseFound%;


' Init logging
LogInit(1);


' run parameters script....
'tunContext$ := tunContextDAQ$;  'I think we can excise these
'tunType$ := tunTypeNone$;

iScript% := DonutHuntMainDialog%();

if iScript% = 1 then
    LogInfo("Proceed with DAQ.\n");
else
	LogInfo("User cancel - exit gracefully\n");
	Halt;
endif;


' Assign channel numbers 
FixationPointChannel% := 24;
StimChannel% := 25;
ReadyChannel% := 27;            ' Look for ready signal on port 2 (same as fixpt). 
FixationPointSlaveChannel% := 28;
StimSlaveChannel% := 29;
FrameChannel% := 19;
FrameSlaveChannel% := 20;
ButtonChannel% := 1;
ButtonPort% := 5;  'This appears to be correct

'Create sampling configuration
'CreateSampleConfiguration();

'Create stimulus order
CreateStimulusOrder();  'this has previously been done within CreateSampleConfiguration

' Get display windows ready
'InitializeWindows();

'tic := View(DataWindow%).BinSize(ReadyChannel%);

' Prepare the toolbar buttons
InitializeToolbar();


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Donut Hunt script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var i%;
    var temp1$;
    var temp2$;
	SampleClear(); 'Set standard sampling state
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    SampleMode(1); 'Continuous sampling
    
    ' Set path for new data files, and for those saved automatically
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);  'automatic
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);  'new data files
    
    SampleAutoName$(dataCellName$ + "_donuthunt_000");  ' set datafile name
    SampleAutoFile(1);  'Set automatic data filing
    SampleTextMark(200);  'Set Channel 30 as textmark channel, 200 characters per
    
    'Channel recording definitions
	SampleEvent(FixationPointChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixpt");
	SampleTitle$(FixationPointChannel%,"Fixpt");
	
	SampleEvent(StimChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
    
	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
    ' djs Add channels to capture slave fixpt and stim onset
	SampleEvent(FixationPointSlaveChannel%, 6, 2, 3600); 'Trigger channel, level
	SampleComment$(FixationPointSlaveChannel%,"Fixpt-Slave");
	SampleTitle$(FixationPointSlaveChannel%,"Fixpt-Slave");
	
	SampleEvent(StimSlaveChannel%, 7, 2,3600); 'Trigger channel, level
	SampleComment$(StimSlaveChannel%,"Stim-Slave");
	SampleTitle$(StimSlaveChannel%,"Stim-Slave");
    
	SampleEvent(FrameChannel%, 0, 2, 3600);
	SampleComment$(FrameChannel%,"Frame");
	SampleTitle$(FrameChannel%,"Frame");
    
	SampleEvent(FrameSlaveChannel%, 4, 2, 3600);
	SampleComment$(FrameSlaveChannel%,"Frame-Slave");
	SampleTitle$(FrameSlaveChannel%,"Frame-Slave");
    
    
    'add waveform channel to analyze button events
    if ButtonPort% = 0 then
        message("Ben hain't told you which port that there button device thingy is on!");
    endif;
    SampleWaveform(ButtonChannel%,ButtonPort%,10000);  'Giving 0.1 ms resolution for now
    SampleComment$(ButtonChannel%,"Raw Button");
	SampleTitle$(ButtonChannel%,"Raw Button");
    
    SampleSequencer(script$ + "Tuning.pls");  'use tuning.pls?
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	
    
   
	
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateStimulusOrder()
    'This used to be done within CreateSampleConfiguration, but that didn't make a lot of sense to me
    'as there's really no connection between setting up a sampling configuration and getting the order
    'of the stimuli defined.  For this script, I'm breaking it free.
    
    var nExistingBlocks%;   
    var i%;
    var j%;  
    var Comma$:="";  'start empty
    
    'get number of values
    dhNValues% := 2*dhNContrastLevels%*dhNDonutDiameters%*dhNCoreOrientations%;
    
    for i% := 1 to dhNRepeats% do
        
        'reset nExistingBlocks% each time through
        nExistingBlocks% := 1;
        
        'Assign L/R
        nExistingBlocks% := DealStimuliToBlocks%(dhLRValues[],dhNValues%,nExistingBlocks%,2,0,1,0);
        'Assign contrast levels
        nExistingBlocks% := DealStimuliToBlocks%(dhdContrastValues[],dhNValues%,nExistingBlocks%,dhNContrastLevels%,dhMinDContrast,dhMaxDContrast,dhContrastLogProgression%);
        ArrAdd(dhdContrastValues[],dhCoreContrast);  'Put it in terms of absolute contrast, not change in contrast
        'Assign donut diameter values
        nExistingBlocks% := DealStimuliToBlocks%(dhDonutDiamValues[],dhNValues%,nExistingBlocks%,dhNDonutDiameters%,dhMinDonutDiameter,dhMaxDonutDiameter,dhDiameterLogProgression%);
        'Assign core orientation values
        nExistingBlocks% := DealStimuliToBlocks%(dhCenterOriValues[],dhNValues%,nExistingBlocks%,dhNCoreOrientations%,dhMinCoreOrientation,dhMaxCoreOrientation,0);
        
        if nExistingBlocks% <> dhNValues% then
            message("NValues (" + Str$(dhNValues%) + ") is not equal to total blocks created by DS2Bs (" + Str$(nExistingBlocks%) + ") Hmm!");
            halt();
        endif;
        
        'Assign T1 values
        Rand(dhT1Values[],dhRandStimDelay,dhMinStimDelay);  'dhT1Values[] is filled
        
        'Assign random indices - one size fits all, we will index each Values array with the same number by design
        Shuffle%(dhNValues%,dhStimulusIndices%[]);
        'This is the non-shuffled version, I don't think I even want to give Ben that option because it doesn't make sense (but useful for testing)
        'for j% := 0 to dhNValues%-1 do
        '    dhStimulusIndices%[j%] := j%;
        'next;
        
        'Set the Comma$ variable to have a comma in it for all rounds following the first one
        if i% > 1 then
            Comma$ := ",";
        endif;
        
        'I don't know if I need to stringify anything, and if so if it has to be done here...
        dhdContrastValuesStringified$ := dhdContrastValuesStringified$ + Comma$ + StringifyProgression$(dhNValues%, dhdContrastValues[], dhStimulusIndices%[]);
        dhDonutDiamValuesStringified$ := dhDonutDiamValuesStringified$ + Comma$ + StringifyProgression$(dhNValues%, dhDonutDiamValues[], dhStimulusIndices%[]);
        dhCenterOriValuesStringified$ := dhCenterOriValuesStringified$ + Comma$ + StringifyProgression$(dhNValues%, dhCenterOriValues[], dhStimulusIndices%[]);
        'dhLRValuesStringified$ := dhLRValuesStringified$ + Comma$ + StringifyProgressionLR$(dhNValues%, dhLRValues[], dhStimulusIndices%[]);  'this is L/R, not 0/1, dan's VSG uses 0/1 after all
        dhLRValuesStringified$ := dhLRValuesStringified$ + Comma$ + StringifyProgression$(dhNValues%, dhLRValues[], dhStimulusIndices%[]);  'this is 0/1
        dhT1ValuesStringified$ := dhT1ValuesStringified$ + Comma$ + StringifyProgression$(dhNValues%, dhT1Values[], dhStimulusIndices%[]);
        
    next;
    
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc InitializeWindows()

    ' Make spike2 use all of monitor 1
    View(App()).Window(0, 0, 100, 100, 1);
    
	'Open the data sampling window
	DataWindow% := FileNew(0,1);
	Window(0,48,50,95);
    XRange(0, 30);
	'View(DataWindow%).WindowVisible(1);  'redundant, I believe

end;







'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitializeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Pause stimuli",PauseStimuli%);
	ToolbarSet(4,"Resume stimuli",ResumeStimuli%);
	ToolbarSet(5,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(3,0);
	ToolbarEnable(4,0);
	Toolbar("Go",0x3ff);

end;





''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Much of this is yet to be completed
func Start%()
	var cmdLine$;
    var Opener$;
    var ProgName$;
    var XHairArg$:="";  'Note that all variables are used to construct cmdLine$, if unused, must be empty
    var BGColor$;
    var Dist2Screen$;
    var TriggerPort$;
    var Verbose$:=" -v ";  'For now, verbose is always on
    var RefrLock$:="";
    var OffsetFile$:="";
    var StimDur$:="";
    var MGrat$:=" -s ";
    var SGrat$:=" -s ";
    var MGratParam$:="";
	var SGratParam$:="";
    var MasterIndicator$:="";  'Do not use Master Indicator
    var SlaveIndicator$:="";  'or Slave Indicator for fixstim, set if needed
    var KlugeArg$:=" -H ";  'this is for a Jerry-rigged "hole" in Box O' Donuts slave stimuli 
    var MValues$:="";
    var SValues$:="";   
    var S2Values$:="";  'won't be used except for Box O' Donuts 
    var KlugeValues$:="";  'this is for a Jerry-rigged "hole" in Box O' Donuts slave stimuli
    var key$;
    var i%;
    'var CRGPrimaryArg$;  'This is always "-R", hard code
    var CRGPrimaryValues$;
    var CRGSecondaryArg$;
    var CRGSecondaryValues$;
    var specHandle%;
    var specFileName$:="D:\\work\\DonutHuntSpecFile.txt";
    'specFileName$:="E:\\DonutHuntSpecFile.txt";  'for testing, Jeff's computer
    var SpecFileArg$;
    var coreParam$;
    var donutParam$;
	
	SampleStart(0); 'Start sampling
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();  'Do this so that SafeSampleKey below doesn't open juicer
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    
    'Fetch all the grating parameters
    GetDonutHuntMainParameters(); 
    GetDonutHuntGratingParameters();
    GetDonutHuntXHairParameters();
    
    'open a file to write the trial-by-trial specs for the VSG
    specHandle% := FileOpen(specFileName$, 8, 1);
	' write info
    coreParam$ := GetGratingParameters$("Core");  'this grabs core 
    donutParam$ := GetGratingParameters$("Donut");  'this grabs donut
    if dhShowDonutOnMaster% = 1 then
        MGratParam$ := donutParam$;
        SGratParam$ := coreParam$;
    else
        SGratParam$ := donutParam$;
        MGratParam$ := coreParam$;
    endif;
    Print("%s\n",MGratParam$);  'master-stim-spec
    Print("%f,0,%f,0\n",-dhXOffset,dhXOffset);  'xL,yL,xR,yR master
    Print("%s\n",SGratParam$);  'slave-stim-spec
    Print("%f,0,%f,0\n",-dhXOffset,dhXOffset);  'xL,yL,xR,yR slave, same as master            
    Print("%f,%f,%f\n",dhDelayBeforeDContrast,dhDurAfterDContrast,dhCoreContrast);  't2,t3,contrast_base        t2,t3 in s
    Print("%s\n",dhT1ValuesStringified$); 't1_0,t1_1,t1_2,...           per-trial t1 values in seconds
    Print("%s\n",dhdContrastValuesStringified$);  'Cup_0,Cup_1,....           per-trial contrast-up values
    Print("%s\n",dhLRValuesStringified$);  'LR_0,LR_1,...               per-trial values for which stim on master screen changes contrast. 0(1) = Left(Right)
    Print("%s\n",dhCenterOriValuesStringified$);  'Ori_0,Ori_1,...              per-trial values for ori of gratings on master screen
    Print("%s\n",dhDonutDiamValuesStringified$);  'Diam_0,Diam_1,...       per-trial outer diameter values for donuts on slave screen
    ' close spec file
	FileClose(0);

    
    'halt();    'for testing, allows me to look at the output file, looks kosher
    
    
    
    'Begin building the command line argument
    Opener$ := "cmd /k " + bin$;
    
    'DonutHunt is always dual-screen
    'RefrLock$ := " -K ";  'lock frame refresh on the two screens
    RefrLock$ := "";  'Dan sez refresh lock probably doesn't matter
    
    ProgName$ := "\\dualstim.exe "; 'set program name for dual VSG
    
    ' Fetch the offset filename
    key$ := GetRegistryKey$(1) + "\\Rivalry";
    OffsetFile$ := GetStringRegistryValue$(GetRegistryKey$(1), "OffsetFile", "file_not_found");
    OffsetFile$ := " -r " + OffsetFile$;
    
    ' Fetch the stimulus duration (in dualstim, stimoff is done by counting frames because of VSG frame synching)
    StimDur$ := " -t 2.0 ";  'add aribitrary stimulus duration in seconds - for this experiment it will be ignored, but must be present   
    
    'Fixation arguments are set by UsreyFixationPoint.s2s and need not be done here
    
    'Set crosshair options
    'split XHairArg$ construction into two lines due to length
    XHairArg$ := " -h " + Str$(FixationX) + "," + Str$(FixationY) + "," + Str$(dhXHairInnerRadiusOffset) + "," + Str$(dhXHairMiddleRadiusOffset) + ","; 
    XHairArg$ := XHairArg$ + Str$(dhXHairOuterRadiusOffset) + "," + Str$(dhXHairNumGridDivisions%) + "," + Str$(dhXHairTicInnerOffset) + "," + Str$(dhXHairTicOuterOffset) + " ";
    
    'Set background color
    BGColor$ := " -b gray ";  'giving no option, always gray
    
    'Set distance to screen
    Dist2Screen$ := " -d " + GetDistanceToScreenMM$();
    
    'Set trigger port
    TriggerPort$ := " -p 2 ";  'hard-coded
    
    'Turn on verbose
    Verbose$ := " -v ";   
    
    'Set the Spec file
    SpecFileArg$ := " -P " + specFileName$;
    

    'Build command line, any values that are unnecessary will be empty, so the build should work no matter what type of command line is required
    cmdLine$ := Opener$ + " -a " + ProgName$ + FixationArg$ + XHairArg$ + BGColor$ + Dist2Screen$ + TriggerPort$ + Verbose$; 'prelim stuff
    cmdLine$ := cmdLine$ + RefrLock$ + OffsetFile$ + StimDur$;  'Dual VSG stuff
    cmdLine$ := cmdLine$ + SpecFileArg$;  'specification file

    ' Record initial text marks. The command line may need to be broken into pieces.
    ' For tuning: Version 6,7 are always box--o-donuts
    ' Version 8 is CRG.
    
'    docase
'    case tunType$ = tunTypeBoxODonuts$ then    
'        if tunUseMaintainMode% = 1 then  'if fixation point stays on, extraction is version 6
'            SampleText("Tuning,6," + str$(Len(cmdLine$)));
'        else 'value is 0, fixation point goes off, extraction is version 7
'            SampleText("Tuning,7," + str$(Len(cmdLine$)));
'        endif;
'    case tunType$ = tunTypeCRG$ then
'        SampleText("Tuning,8," + str$(Len(cmdLine$)));
'    else
'        ' djs Always version 3. NO difference if maintainmode is used or not. 
'        SampleText("Tuning,3," + str$(Len(cmdLine$)));
'    endcase;
    
    SampleText(tunCVSID$);
    for i% := 1 to Len(cmdLine$) step 100 do
        SampleText(Mid$(cmdLine$, i%, 100));
    next
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(cmdLine$+"\n");
    printlog("num advances is %d and num repeats is %d\n",dhNValues%,dhNRepeats%);
	StimHandle% := ProgRun(cmdLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(5);
    
return 1;
end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, j%, m%;
    
	' Disable idle process func
	ToolbarSet(0,"");

	' Tell stim app to shut down
    SafeSampleKey("X");
	SafeSampleKey("Q");
	Yield(.1);
	SampleStop();

	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend

	' Write parameter file
	WriteParameterFile();
    
    'I don't think we care to do this
'	' Increment daily totals and save then
'	TotalTrials% += nTrialsStarted%;
'	TotalRewards% += nTrialsCompleted%;
'	SaveDailyTotals();
    
   

end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(3,0);
ToolbarEnable(4,1);
return 1;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(3,1);
ToolbarEnable(4,0);
return 1;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var tempPrimary$;
    var tempSecondary$;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
    if dhShowDonutOnMaster% = 1 then
        Print("Core is on SLAVE, Donut is on MASTER\n");
    else
        Print("Core is on MASTER, Donut is on SLAVE\n");
    endif;


	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);
    
    ' write crosshair parameters
    Print("\nCrosshairs\n");
	Print("-------------------\n\n");
    Print("Inner radius offset        : %f\n",dhXHairInnerRadiusOffset);
    Print("Middle radius offset       : %f\n",dhXHairMiddleRadiusOffset);
    Print("Outer radius offset        : %f\n",dhXHairOuterRadiusOffset);
    Print("Number of grid divisions   : %d\n",dhXHairNumGridDivisions%);
    Print("Inner tick offset          : %f\n",dhXHairTicInnerOffset);
    Print("Outer tick offset          : %f\n",dhXHairTicOuterOffset);    
    
	' write stimulus parameters
    Print("\nCommon Grating Properties\n");  'Master grating
	Print("-------------------\n\n");
    
    Print("X Offset                   : %f\n",dhXOffset);
    Print("Spatial Frequency          : %f\n",dhSpatialFreq);
    Print("Temporal Frequency         : %f\n",dhTemporalFreq);
    Print("Initial Phase              : %d\n",dhInitialPhase%);
    Print("Donut Contrast             : %f\n",dhDonutContrast);
    Print("Base Core Contrast         : %f\n",dhCoreContrast);  'base
    Print("Core diameter              : %f\n",dhCoreDiameter);
    Print("Donut Orientation          : %f\n",dhDonutOrientation);
           
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");
    Print("Minimum stimulus delay     : %f\n",dhMinStimDelay);
    Print("Add'l rand stim delay      : %f\n",dhRandStimDelay);
    Print("Time before contrast change: %f\n",dhDelayBeforeDContrast);
    Print("Time after contrast change : %f\n",dhDurAfterDContrast);
    
    
	Print("\nTuning parameters\n");
	Print("-------------------\n\n");

    Print("Parameter                  : Contrast Change\n");
	Print("Min,Max,#Steps,LogIf1    : %f,%f,%d,%d\n", dhMinDContrast, dhMaxDContrast, dhNContrastLevels%, dhContrastLogProgression%);
	Print("Values: " + dhdContrastValuesStringified$ + "\n");
	Print("\n");
    
    Print("Parameter                  : Core Orientation\n");
    Print("Min,Max,#Steps             : %f,%f,%d\n", dhMinCoreOrientation, dhMaxCoreOrientation, dhNCoreOrientations%);
    Print("Values: " + dhCenterOriValuesStringified$ + "\n");
    Print("\n");
    
    Print("Parameter                  : Donut Outer Diameter Area\n");
    Print("Min,Max,#Steps,LogIf1    : %f,%f,%d,%d\n", dhMinDonutDiameter, dhMaxDonutDiameter, dhNDonutDiameters%, dhDiameterLogProgression%);
    Print("Values: " + dhDonutDiamValuesStringified$ + "\n");
    Print("\n");

    Print("L/R Values: " + dhLRValuesStringified$ + "\n");
    Print("\n");
    
	' close parfile
	FileClose(0);

end;
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func IdleProcessing%()
	var iStatus% := 1;	
    var xval;
    var yval;
    var xind%;
    var yind%;
    
	tNow := View(DataWindow%).MaxTime();
    
    ' First time through (tLast<0) just update tLast. Crosstalk on vsg dig outputs leads to erroneous
    ' triggers. Maybe this will help. 
    'if tLast < 0 then
    '    tLast := 1;
    '    return 1;
    'endif
    'Alternately, why not try this, which won't cause any issues with WhichButton%; above tLast could be greater than tNow
    if tNow < 1 then
        tLast := 1;
        return 1;
    endif;    
    
    'Check button state, from the time of the last button press/release until now.  Will only return one value.
    buttonError% := WhichButton%(buttonTime,tNow,buttonStatus%);
    
	docase 
    case iState% = stateVSGWait% then
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        'if View(DataWindow%).FindPulseUp%(ReadyChannel%, -1, tRise, tFall) = 1 then
        'Ignore any potential button activity while waiting for the VSG to sync up.
        pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+tic, tRise, tFall);
        if pulseFound% = 1 then
            LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
            Yield(1.0);
            tLastTrigger := tFall;
            ChangeStateTo(stateITI%, tFall);
        else
            if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                tLastTrigger := tFall;
            endif;
        endif;
        
    case iState% = stateITI% then 
        
        docase
        case buttonTime > -1 or buttonStatus% <> 0 or buttonError% = -1 then 'if there is an extraneous button press, flush button and return to ITI
            buttonError% := 0;  'erase any possible button error
            FlushButton(buttonTime,tNow,buttonStatus%);
            ChangeStateTo(stateITI%, tNow);  
        case pause% = 0 then  'This is the part on Sprockets when we pause
            'do nothing
        case tNow - tStateStart > tInterTrialTime then
            ChangeStateTo(stateXHairUp%, tNow);
        endcase;
        
        
    case iState% = stateXHairUp% then
        if buttonTime > -1 or buttonStatus% <> 0 or buttonError% = -1 then 'if there is an extraneous button press, flush button and return to ITI
            buttonError% := 0;  'erase any possible button error
            FlushButton(buttonTime,tNow,buttonStatus%);
            ChangeStateTo(stateITI%, tNow);
        else 
            ' Start trial. Put up crosshairs.
            LogStatus("StartTrial", "Request crosshairs");
            SafeSampleKey("F");
            ChangeStateTo(stateWaitForXHairOn%, tNow);
        endif;
        
        
    case iState% = stateWaitForXHairOn% then
        if buttonTime > -1 or buttonError% = -1 then  'note if a button is pressed, but let XHair come up since we've asked for it
            buttonError% := 0;  'erase any possible button error
            buttonDuringXHair% := 1;
        endif;
        if View(DataWindow%).FindRisingEdge%(FixationPointChannel%, tLast, tTrigger) = 0 then
            ' Fixation point is up
            LogStatus("WaitForXHairOn", "Crosshair on at " + str$(tTrigger) + "\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateWaitInitDown%, tTrigger);
        endif
        
        
    case iState% = stateWaitInitDown% then
        docase
        case buttonDuringXHair% = 1 or buttonError% = -1 then 'abort if button is pressed early or there is a button error
            buttonError% := 0;  'erase any possible button error
            buttonDuringXHair% := 0;  'reset
            SafeSampleKey("X");  'Removes XHair
            ChangeStateTo(stateITI%, tNow); 
        ' Otherwise wait for button press
        case buttonStatus% = 1 then  
            LogStatus("WaitInitDown", "Init Button Pressed (Left)");
            SampleText("Init Press Left",buttonTime);
            ChangeStateTo(stateWaitInitUpL%, tNow);
        case buttonStatus% = 2 then  
            LogStatus("WaitInitDown", "Init Button Pressed (Right)");
            SampleText("Init Press Right",buttonTime);
            ChangeStateTo(stateWaitInitUpR%, tNow);
        endcase        
        
        
    case iState% = stateWaitInitUpL% then
        docase
        case buttonError% = -1 then
            buttonError% := 0;  'erase any possible button error
            SafeSampleKey("X");  'Removes XHair
            ChangeStateTo(stateITI%, tNow);
        case buttonStatus% = 0 then
            ' Button is released
            LogStatus("WaitInitUpL", "Init Button Released (Left)");
            SampleText("Init Release Left",buttonTime);
            ChangeStateTo(stateStartSequence%, tNow);
        endcase;
        
        
    case iState% = stateWaitInitUpR% then
        docase
        case buttonError% = -1 then
            buttonError% := 0;  'erase any possible button error
            SafeSampleKey("X");  'Removes XHair
            ChangeStateTo(stateITI%, tNow);
        case buttonStatus% = 0 then
            ' Button is released
            LogStatus("WaitInitUpR", "Init Button Released (Right)");
            SampleText("Init Release Right",buttonTime);
            ChangeStateTo(stateStartSequence%, tNow);
        endcase;        
        
    case iState% = stateStartSequence% then
        if buttonTime > -1 or buttonError% = -1 then  'bail out if there's a button press after init but before we start
            buttonError% := 0;  'erase any possible button error
            SafeSampleKey("X");  'Removes XHair
            ChangeStateTo(stateITI%, tNow);
        endif;
        SafeSampleKey("S");
        ChangeStateTo(stateWaitOnsetTrigger%, tNow); 
        
        
    case iState% = stateWaitOnsetTrigger% then        
        if buttonTime > -1 or buttonError% = -1 then  'note if a button is pressed, but let sequence complete since we've asked for it
            buttonError% := 0;  'erase any possible button error
            buttonDuringSequence% := 1;
        endif;
        if View(DataWindow%).FindRisingEdge%(StimChannel%, tLast, tTrigger) = 0 then
            SampleText("T," + str$(GetContrastCondition(nTrialsCompleted%)));
            LogStatus("StartSequence", "Stim sequence started at " + str$(tTrigger));        
            tStimOn := tTrigger;
            tStimSequence := tTrigger;
            tLastTrigger := tTrigger;
            ChangeStateTo(stateWaitOffsetTrigger%, tNow);
        endif;
        

    case iState% = stateWaitOffsetTrigger% then
        if buttonTime > -1 or buttonError% = -1 then  'note if a button is pressed, but let sequence complete since we've asked for it
            buttonError% := 0;  'erase any possible button error
            buttonDuringSequence% := 1;
        endif;
        if View(DataWindow%).FindFallingEdge%(StimChannel%, tLast, tTrigger) = 1 then
            ' Stim is off
            tLastTrigger := tTrigger;
            ChangeStateTo(stateWaitResponse%, tTrigger);
        endif
        
        
    case iState% = stateWaitResponse% then
        docase
        case buttonDuringSequence% = 1 then
            buttonDuringSequence% := 0;
            SafeSampleKey("X");  'Removes XHair
            ChangeStateTo(stateITI%, tNow);
            LogStatus("Sequence", "Button during sequence! Trial aborted!");
        case buttonStatus% = 1 then    
            SafeSampleKey("a");  'advance stimulus
            SafeSampleKey("X");  'Removes XHair
            if dhLRValues[nTrialsCompleted%] = 0 then
                nCorrect% += 1;
                sampleText("Left Response (Correct)",buttonTime);
            else
                sampleText("Left Response (Wrong)",buttonTime);
            endif
            pctCorrect := round(1000*nCorrect%/nTrialsCompleted%)/10;
            nTrialsCompleted% += 1;
            printlog("number of trials completed is %d\n",nTrialsCompleted%);
            ToolbarText(str$(nTrialsCompleted%) + "/" + str$(dhNValues%) + " trials completed, " + Str$(pctCorrect) + "% correct.");
            ChangeStateTo(stateWaitRelease%, tNow);
        case buttonStatus% = 2 then    
            SafeSampleKey("a");  'advance stimulus
            SafeSampleKey("X");  'Removes XHair
            if dhLRValues[nTrialsCompleted%] = 1 then
                nCorrect% += 1;
                sampleText("Right Response (Correct)",buttonTime);
            else
                sampleText("Right Response (Wrong)",buttonTime);
            endif
            pctCorrect := round(1000*nCorrect%/nTrialsCompleted%)/10;
            nTrialsCompleted% += 1;
            printlog("number of trials completed is %d\n",nTrialsCompleted%);
            ToolbarText(str$(nTrialsCompleted%) + "/" + str$(dhNValues%) + " trials completed, " + Str$(pctCorrect) + "% correct.");
            ChangeStateTo(stateWaitRelease%, tNow);    
        endcase
        
        
    case iState% = stateWaitRelease% then

        if buttonStatus% = 0 then
            if nTrialsCompleted% = dhNValues% then
                ChangeStateTo(stateDone%, tNow);
            else
                ChangeStateTo(stateITI%, tNow);
            endif;
        endif
        
        
    case iState% = stateDone% then
        
        Stop%();
        iStatus% := 0;
        
        
    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;

	endcase;

	tLast := tNow;
	return iStatus%;
end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func WhichButton%(&startT,endT,&bStatus%)
	'Determine which button is pressed, if any
    'Read the button channel, of course
    'Note - another very ad-hoc function, which assumes lots of variables we know exist
    'Man, this function does a lot of stuff, hopefully it will all be useful 
    
    
    'Clear the button press arrays
    button1Press := -1;
    button2Press := -1;
    button1Release := -1;
    button2Release := -1;

    'Checks will return -1 if there are no events of that type
    'Check for button 1 (left) press
    button1Press := ChanSearch(ButtonChannel%,8,startT+tic,endT,button1Thresh,buttonHysteresis,buttonMinTime);
    
    'Check for button 1 (left) release
    button1Release := ChanSearch(ButtonChannel%,7,startT+tic,endT,button1Thresh,buttonHysteresis,buttonMinTime); 
    
    'Check for button 2 (right) press
    button2Press := ChanSearch(ButtonChannel%,7,startT+tic,endT,button2Thresh,buttonHysteresis,buttonMinTime);
    
    'Check for button 2 (right) release
    button2Release := ChanSearch(ButtonChannel%,8,startT+tic,endT,button2Thresh,buttonHysteresis,buttonMinTime);
    
    
    'Now do a whole bunch of checking to make sure there aren't any errors, update startT and bStatus% if necessary,
    'and hopefully return success
    'This is all nice and complicated, but thorough check and a response matrix of all possible press combos suggests
    'that every contingency is dealt with.  Even under most error conditions it returns a value.  I need to consider
    'what happens in the case that something goes wrong...a flush might not work depending on return values/states and
    'what is expected.
    docase
    case button1Press = -1 and button2Press = -1 and button1Release = -1 and button2Release = -1 then 'nothing happened on this check
        startT := -1;
        return 1;
    case bStatus% = 0 then  'initial status is no button pressed
        'check for either button press
        docase
        case button1Press = -1 and button2Press = -1 then  'no button pressed
            startT := -1;  'no change
            docase
            case button1Release > -1 then
                printlog("Error!  Button 1 release occurred without a recorded press!");
                startT := button1Release;  'fast-forward to time of "false" release
                return -1;
            case button2Release > -1 then
                printlog("Error!  Button 2 release occurred without a recorded press!");
                startT := button2Release;  'fast-forward to time of "false" release
                return -1;  
            else
                return 1;  'success, no change
            endcase
        case button1Press > -1 and button2Press > -1 then  'both buttons pressed!
            if button1Press < button2Press then
                bStatus% := 1;  'consider it a button 1 press
                startT := button1Press;
                docase 
                case button1Release > -1 and button1Release < button1Press then
                    printlog("Error!  Button 1 release occurred before Button 1 press when initial status was no button pressed!");
                    return -1;
                case button2Release > -1 and button2Release < button1Press then
                    printlog("Error!  Button 2 release occurred before Button 1 press when initial status was no button pressed!");
                    return -1;  
                else
                    return 1
                endcase;
            else  'button2Press > button1Press
                bStatus% := 2;  'consider it a button 2 press
                startT := button2Press;
                docase 
                case button1Release > -1 and button1Release < button2Press then
                    printlog("Error!  Button 1 release occurred before Button 2 press when initial status was no button pressed!");
                    return -1;
                case button2Release > -1 and button2Release < button2Press then
                    printlog("Error!  Button 2 release occurred before Button 2 press when initial status was no button pressed!");
                    return -1;  
                else
                    return 1
                endcase;
            endif;
        case button1Press > -1 then  'no button 2 press, would trigger prior case
            bStatus% := 1;  'consider it a button 1 press
            startT := button1Press;
            docase 
            case button1Release > -1 and button1Release < button1Press then
                printlog("Error!  Button 1 release occurred before Button 1 press when initial status was no button pressed!");
                return -1;
            case button2Release > -1 and button2Release < button1Press then
                printlog("Error!  Button 2 release occurred before Button 1 press when initial status was no button pressed!");
                return -1;  
            else
                return 1
            endcase;
        case button2Press > -1 then  'no button 1 press, would trigger prior case
            bStatus% := 2;  'consider it a button 2 press
            startT := button2Press;
            docase 
            case button1Release > -1 and button1Release < button2Press then
                printlog("Error!  Button 1 release occurred before Button 2 press when initial status was no button pressed!");
                return -1;
            case button2Release > -1 and button2Release < button2Press then
                printlog("Error!  Button 2 release occurred before Button 2 press when initial status was no button pressed!");
                return -1;  
            else
                return 1
            endcase;
        else
            printlog("Error - shouldn't ever get in here!"); 'logically all states should be accounted for, but just in case
            startT := max(button1Press,button2Press,button1Release,button2Release);  'just clear it all out
            docase  'And set the button status based on the last recorded event
            case startT = button1Release or startT = button2Release then
                bStatus% := 0;
            case startT = button1Press then
                bStatus% := 1;
            case startT = button2Press then
                bStatus% := 2;
            endcase;
            return -1;
        endcase;
            
    case bStatus% = 1 then  'initial status is LEFT button pressed
        'check for left button release
        docase
        case button1Release > -1 then
            bStatus% := 0;  'Button is released
            startT := button1Release;
        case button1Press > -1 or button2Press > -1 or button2Release > -1 then
            printlog("Error!  Recorded something other than button 1 release when button 1 believed to be pressed!");
            startT := max(button1Press,button2Press,button2Release);
            docase
            case startT = button1Press then
                bStatus% := 1;
            case startT = button2Press then
                bStatus% := 2;
            case startT = button2Release then
                bStatus% := 0;
            endcase;
            return -1;
        else
            startT := -1;  'no change            
        endcase;
        
        'check for crazy errors
        docase
        case button1Press > -1 and button1Press < button1Release then
            printlog("Error!  Button 1 press occurred before release when initial status was Button 1 down!");
            return -1;
        case button2Press > -1 and button2Press < button1Release then
            printlog("Error!  Button 2 press occurred before Button 1 release when initial status was Button 1 down!");
            return -1;
        case button2Release > -1 and button2Release < button1Release then   
            printlog("Error!  Button 2 release occurred before Button 1 release when initial status was Button 1 down!");
            return -1;
        case button1Release = -1 and (button1Press > -1 or button2Press > -1 or button2Release > -1) then
            printlog("Error!  Button 1 release expected, another event detected!");
            return -1;
        else
            return 1;  'success
        endcase;
    
    case bStatus% = 2 then  'initial status is RIGHT button pressed
        'check for right button release
        docase
        case button2Release > -1 then
            bStatus% := 0;  'Button is released
            startT := button2Release;
        case button1Press > -1 or button2Press > -1 or button1Release > -1 then
            printlog("Error!  Recorded something other than button 2 release when button 2 believed to be pressed!");
            startT := max(button1Press,button2Press,button1Release);
            docase
            case startT = button1Press then
                bStatus% := 1;
            case startT = button2Press then
                bStatus% := 2;
            case startT = button1Release then
                bStatus% := 0;
            endcase;
            return -1;
        else
            startT := -1;  'no change            
        endcase;
        
        'check for crazy errors
        docase
        case button2Press > -1 and button2Press < button2Release then
            printlog("Error!  Button 2 press occurred before release when initial status was Button 2 down!");
            return -1;
        case button1Press > -1 and button1Press < button2Release then
            printlog("Error!  Button 1 press occurred before Button 2 release when initial status was Button 2 down!");
            return -1;
        case button1Release > -1 and button1Release < button2Release then   
            printlog("Error!  Button 1 release occurred before Button 2 release when initial status was Button 2 down!");
            return -1;
        case button2Release = -1 and (button1Press > -1 or button2Press > -1 or button1Release > -1) then
            printlog("Error!  Button 2 release expected, another event detected!");
            return -1;
        else
            return 1;  'success
        endcase;
        
    endcase;
    

end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc FlushButton(&startT,endT,&bStatus%)
    'Used to flush out the status of the button until all button events are in the past relative to endT (typically tNow)
    'Useful in the case of a button error, to just clear out and start over
    while startT > -1 do
        WhichButton%(startT,endT,bStatus%);
    wend;
    'When this is done we will have no idea when the last event occured or necessarily what it was, but bStatus% 
    'ought to be correct for time endT and we will be ready to try reading the button again.
end


func GetContrastCondition(nTrials%)  
    return dhdContrastValues[dhStimulusIndices%[nTrials%]];
end;

' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Put a vector of numbers into a comma separated string
Func StringifyProgression$(n%, vec[], ind%[])
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
		s$ += str$(vec[ind%[i%]]);
	next
	return s$;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Turn a vector of 0/1 into a comma separated string of L/R
' This is about as adhoc of a function as you can get
' Not being clever about this - anything non-zero will give "R" but that won't ever happen BECAUSE THIS IS
' AS ADHOC OF A FUNCTION AS YOU CAN GET AND IF YOU TRY TO USE IT FOR ANYTHING OTHER THAN ITS INTENDED
' PURPOSE YOU ARE A FOOL and now on top of that it doesn't even get used here.
Func StringifyProgressionLR$(n%, vec[], ind%[])
	var s$;
	var i%;
	for i% := 0 to n%-1 do
		if i% > 0 then 
			s$ += ",";
		endif
        if vec[ind%[i%]] = 0 then
            s$ += "L";
        else
            s$ += "R";
        endif;
	next
	return s$;
end;
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;
