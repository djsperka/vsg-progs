' $Log: not supported by cvs2svn $
'

var ContrastState[10000];	' 0 (1) means contrast goes down (up) for a trial
var RandomDelay[10000];		' Contrast change is delayed by a random amount (0 < delay < RandomFixationOffset)

' User-input timing vars
var FixationDuration:=0;
var InterTrialTime:=0;
var GratingDelay:=0;
var ContrastDelay:=0;
var AnswerPointDelay:=0;
var RandomFixationOffset := 0;	' Maximum delay time

' Common parameters
var WindowRadius:=0;		' Fixation window radius (degrees)
var FixationX:=0;
var FixationY:=0;
var FixationPointDiameter:=1;
var FixationPointColor$;
var BackgroundColor$;
var JuicePerReward%:=0;

' Attention params
var NumberOfBlocks% := 1;	' Number of blocks to run. 1 block = 30 trials
var CatchTrialPercentage%:=0;
var BaseContrast%:=50;
var ContrastUp%:=80;
var ContrastDown%:=20;
var AnswerWindow:=1;		' Answer point window (degrees)


' Local file system variables. 
var bin$, script$;
bin$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2) + "..\\bin";	' Location of executables is ..\bin, relative to script dir
script$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2);	' folder containing this script

'Create and display the Toolbar, not yet activating the IdleProcessing function


'Toolbar and IdleProcessing variables
View(App(8)).WindowVisible(0);	'Hide the standard sample bar
ToolbarVisible(1);
ToolbarSet(1,"Sample start",Start%);
ToolbarSet(2,"Sample stop", Stop%);
ToolbarSet(3,"Juice",Juice%);
ToolbarSet(4,"Pause stimuli",PauseStimuli%);
ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
ToolbarEnable(2,0);
ToolbarEnable(4,0);
ToolbarEnable(5,0);
Toolbar("Go",12345);



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
var CommandLine$;
CommandLine$ :=bin$ + "\\NewAttention "+str$(FixationX)+" "+str$(FixationY)+" "+BackgroundColor$+" "
					+str$(FixationPointDiameter)+" "+str$(BaseContrast)+" "+str$(ContrastUp)+" "+str$(ContrastDown)+" "
					+str$(IncorrectBrightness)+" "
					+GratingOrSpot$[GratingOrSpotIndex%]+" "+str$(TargetX)+" "+str$(TargetY)+" "+str$(TargetOrientation)+" "
					+str$(TargetSF)+" "+str$(TargetTF)+" "+str$(TargetDiameter)+" "+str$(AnswerPointInitialBrightness)+" "
					+str$(AnswerPointFullBrightness)+" "+GratingColorList$[GratingColorIndex];
'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
'PrintLog(CommandLine$+"\n");
'halt;
SampleStart(0); 'Start sampling
PrintLog(CommandLine$);
StimHandle := ProgRun(CommandLine$,1);
if StimHandle <0 then Message("Could not start stimulus."); halt; endif
Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.

ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
ToolbarEnable(2,1);
ToolbarEnable(1,0);
View(DataWindow%);
return 1;
end; 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
SampleKey("X");
Yield(.1);
SampleStop();
ProgKill(StimHandle);
ProgRun(bin$ + "\\ClearTrigger",0); 
Message("Press OK to end program");
end;
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Juice%()
SampleKey("J");
return 1;
end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Answer%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-AnswerY,2)) <= Pow(AnswerWindow,2) then return 1; endif
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY+AnswerY,2)) <= Pow(AnswerWindow,2) then return -1; endif
	return 0;
end;
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func Reward%()
	for i:=1 to NumberOfRewards% do Yield(.05); SampleKey("J"); next
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func DetermineContrastChanges()
var BlockIndex%,Block[30],RandomBlock[30],RandomNumber;
ArrConst(Block[:15],-1);
ArrConst(Block[15:15],1);
ArrConst(RandomDelay[],0);


for index :=0 to (NumberOfBlocks% -1) do
	BlockIndex%:=0;
   ArrConst(RandomBlock[],0);
	while BlockIndex% < 30 do
		RandomNumber:=round(29*rand());
		if RandomBlock[RandomNumber] = 0 then 
			RandomBlock[RandomNumber] := Block[BlockIndex%];
			BlockIndex% := BlockIndex%+1;
		endif
	wend
	ArrConst(ContrastState[index*30:30],RandomBlock[]);
next

for index:=0 to (30*NumberOfBlocks% - 1) do
	if RandomFixationOffset > 0 then RandomDelay[index] := RandomFixationOffset*rand(); endif
next

return 1;
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var iState%:=0;		' present state
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times


func IdleProcessing%()

	tNow := MaxTime();

	xEye := ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
	yEye := ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastUpdate := tNow;
	endif


	docase 
		case iState% = 0 then

			' initial state on startup. 
			' Enter state 1

			SampleKey("F");
			iState% := 1;
			PrintLog("State 0 - Start new trial - stimulus trigger sent\n");

		case iState% = 1 then
	
			' Waiting for stimulus to be presented by vsg and trigger to return. 
			' NextTime returns a non-negative value whenever there is a TRANSITION. In that case, the 
			' value of 'vTrigger' returned is 1 (0) if the transition is high (low) to low (high). Maybe not
			' intuitive, but that's the way it is. 
			tTrigger := NextTime(TriggerChannel%,tLast,vTrigger);
			if tTrigger > tLastTrigger then

				if vTrigger = 0 then
		
					' Stimulus has been presented. Display stim location and window. Enter state 2
					DrawStim(1);
					iState% := 2;
					tStateStart := tTrigger;
					tLastTrigger := tTrigger;

				endif

			endif

		case iState% = 2 then

			if tNow-tStateStart < AcquisitionTime then
				
				' Acquisition happens when the eye falls within the fixation window.
				if InFixationWindow%(xEye, yEye) > 0 then

					PrintLog("State 2 - acquired target. tNow=" + str$(tNow) + " Enter state 3\n");
					iState% := 3;
					tStateStart := tNow;
	
				endif

			else

				' Failed. Turn off stim and try again.
				PrintLog("State 2 - acquisition failed. Enter state 4\n");
				iState% := 4;
				tStateStart := tNow;

			endif

		case iState% = 3 then

			' Waiting for fixation....
			if InFixationWindow%(xEye, yEye) <= 0 then

				iState% := 4;
				tStateStart := tNow;

			else

				if tNow - tStateStart >= FixationDuration then

					' Fixation. Reward. New trial.
					Reward%();
					iState% := 4;
					tStateStart := tNow;

				endif

			endif

		case iState% = 4 then

			' Turn off stimulus, enter state 5 - wait for stimulus off msg
			DrawStim(0);
			PrintLog("State 4 - turning off stimulus....\n");
			SampleKey("L");
			iState% := 5;
			tStateStart := tNow;

		case iState% = 5 then

			' Wait for stim to be off
			tTrigger := NextTime(TriggerChannel%,tLast,vTrigger);
			if tTrigger > tLast then

				if vTrigger = 1 then
		
					' Stimulus has been turned off by vsg. Enter state 6
					PrintLog("State 5 - Stim OFF trigger found. Enter state 6\n");
					iState% := 6;
					tStateStart := tTrigger;
					tLastTrigger := tTrigger;
	
				endif

			endif

		case iState% = 6 then

			' Inter-trial wait time
			if tNow - tStateStart > InterTrialTime then
	
				' Back to state 0
				PrintLog("State 6 - IT wait is done. Start new trial.\n");
				iState% := 0;
				tStateStart := tNow;
	
			endif

		else 

			' Unknown state!
			Message("Unknown state=" + str$(iState%));
			halt;

	endcase;

	tLast := tNow;






return 1;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetTodaysStats%();
Profile("AlertRig\\"+Monkey$,"TotalRewards",0,TodaysRewards);
Profile("AlertRig\\"+Monkey$,"TotalTrials",0,TodaysTrials);
Profile("AlertRig\\"+Monkey$,"Date","",RecordedDate$);
TodaysDate$ := Date$();
if TodaysDate$ <> RecordedDate$ then 
	Profile("AlertRig\\"+Monkey$,"TotalRewards",0);
	TodaysRewards :=0;
	Profile("AlertRig\\"+Monkey$,"TotalTrials",0);
	TodaysTrials :=0;
	Profile("AlertRig\\"+Monkey$,"Date",TodaysDate$);
endif
return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetLastUsedParameters%();

'Read the Windows registry to determine last used values for the experiment parameters
'Since registry values are either integers are strings, we store decimals as strings and convert them to decimals
var NumberOfRewards$;
var WindowRadius$, FixationX$, FixationY$, FixationDuration$, AcquisitionTime$;
var BlankDuration$;
var FixationPointDiameter$;

Profile("AlertRig\\"+Monkey$,"WindowRadius","1",WindowRadius$);
Profile("AlertRig\\"+Monkey$,"FixationX","0",FixationX$);
Profile("AlertRig\\"+Monkey$,"FixationY","0",FixationY$);
Profile("AlertRig\\"+Monkey$,"FixationDuration","1",FixationDuration$);
Profile("AlertRig\\"+Monkey$,"AcquisitionTime","1",AcquisitionTime$);
Profile("AlertRig\\"+Monkey$,"BlankDuration","2",BlankDuration$);
Profile("AlertRig\\"+Monkey$,"NumberOfBlocks",300,NumberOfBlocks%);
Profile("AlertRig\\"+Monkey$,"BackgroundColor","Grey",BackgroundColor$);
Profile("AlertRig\\"+Monkey$,"FixationPointDIameter",".1",FixationPointDiameter$);
Profile("AlertRig\\"+Monkey$,"NumberOfRewards",1,NumberOfRewards%);

'Convert strings to decimenals
WindowRadius := val(WindowRadius$);
FixationX := val(FixationX$);
FixationY := val(FixationY$);
FixationDuration := val(FixationDuration$);
AcquisitionTime := val(AcquisitionTime$);
BlankDuration := val(BlankDuration$);
FixationPointDiameter := val(FixationPointDiameter$);

return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SetLastUsedParameters%();	'Updates the registry record of the last used experimental parameters

'Since registry values are either integers are strings, we convert decimals to strings

Profile("AlertRig\\"+Monkey$,"WindowRadius",str$(WindowRadius));
Profile("AlertRig\\"+Monkey$,"FixationX",str$(FixationX));
Profile("AlertRig\\"+Monkey$,"FixationY",str$(FixationY));
Profile("AlertRig\\"+Monkey$,"FixationDuration",str$(FixationDuration));
Profile("AlertRig\\"+Monkey$,"AcquisitionTime",str$(AcquisitionTime));
Profile("AlertRig\\"+Monkey$,"BlankDuration",str$(BlankDuration));
Profile("AlertRig\\"+Monkey$,"NumberOfBlocks",NumberOfBlocks%);
Profile("AlertRig\\"+Monkey$,"BackgroundColor",BackgroundColor$);
Profile("AlertRig\\"+Monkey$,"FixationPointDIameter",str$(FixationPointDiameter));
Profile("AlertRig\\"+Monkey$,"NumberOfRewards",NumberOfRewards%);

return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetLastUsedFixationParameters%();

'Read the Windows registry to determine last used values for the experiment parameters
'Since registry values are either integers are strings, we store decimals as strings and convert them to decimals

var ContrastDelay$, BaseContrast$,ContrastUp$,ContrastDown$,TimeToAnswer$,IncorrectBrightness$;
var GratingOrSpotValue$,TargetX$,TargetY$;
var GratingDelay$,AnswerPointDelay$,AnswerWindow$;
var AnswerPointInitialBrightness$,AnswerPointFullBrightness$;
var RandomFixationOffset$;
Profile("AlertRig\\"+Monkey$,"ContrastDelay","1",ContrastDelay$);
Profile("AlertRig\\"+Monkey$,"BaseContrast","50",BaseContrast$);
Profile("AlertRig\\"+Monkey$,"ContrastUp","75",ContrastUp$);
Profile("AlertRig\\"+Monkey$,"ContrastDown","25",ContrastDown$);
Profile("AlertRig\\"+Monkey$,"TimeToAnswer","1",TimeToAnswer$);
Profile("AlertRig\\"+Monkey$,"IncorrectBrightness","0",IncorrectBrightness$);
Profile("AlertRig\\"+Monkey$,"GratingOrSpot","Grating",GratingOrSpotValue$);
Profile("AlertRig\\"+Monkey$,"TargetX","3",TargetX$);
Profile("AlertRig\\"+Monkey$,"TargetY","0",TargetY$);
Profile("AlertRig\\"+Monkey$,"GratingDelay","1",GratingDelay$);
Profile("AlertRig\\"+Monkey$,"AnswerPointDelay","1",AnswerPointDelay$);
Profile("AlertRig\\"+Monkey$,"AnswerWindow","1",AnswerWindow$);
Profile("AlertRig\\"+Monkey$,"RandomFixationOffset","0",RandomFixationOffset$);
Profile("AlertRig\\"+Monkey$,"AnswerPointInitialBrightness","100",AnswerPointInitialBrightness$);
Profile("AlertRig\\"+Monkey$,"AnswerPointFullBrightness","1",AnswerPointFullBrightness$);

if GratingOrSpotValue$="Grating" then GratingOrSpotIndex%:=0; endif
if GratingOrSpotValue$="Spot" then GratingOrSpotIndex%:=1; endif


'Convert strings to decimenals
ContrastDelay := val(ContrastDelay$);
BaseContrast := val(BaseContrast$);
ContrastUp := val(ContrastUp$);
ContrastDown := val(ContrastDown$);
TimeToAnswer := val(TimeToAnswer$);
IncorrectBrightness := val(IncorrectBrightness$);
TargetX := val(TargetX$);
TargetY := val(TargetY$);
GratingDelay := val(GratingDelay$);
AnswerPointDelay := val(AnswerPointDelay$);
AnswerWindow := val(AnswerWindow$);
AnswerPointInitialBrightness := val(AnswerPointInitialBrightness$);
AnswerPointFullBrightness := val(AnswerPointFullBrightness$);
RandomFixationOffset := val(RandomFixationOffset$);
return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SetLastUsedFixationParameters%();

'Since registry values are either integers are strings, we convert decimals to strings

Profile("AlertRig\\"+Monkey$,"ContrastDelay",str$(ContrastDelay));
Profile("AlertRig\\"+Monkey$,"BaseContrast",str$(BaseContrast));
Profile("AlertRig\\"+Monkey$,"ContrastUp",str$(ContrastUp));
Profile("AlertRig\\"+Monkey$,"ContrastDown",str$(ContrastDown));
Profile("AlertRig\\"+Monkey$,"TimeToAnswer",str$(TimeToAnswer));
Profile("AlertRig\\"+Monkey$,"IncorrectBrightness",str$(IncorrectBrightness));
Profile("AlertRig\\"+Monkey$,"GratingOrSpot",GratingOrSpot$[GratingOrSpotIndex%]);
Profile("AlertRig\\"+Monkey$,"TargetX",str$(TargetX));
Profile("AlertRig\\"+Monkey$,"TargetY",str$(TargetY));
Profile("AlertRig\\"+Monkey$,"GratingDelay",str$(GratingDelay));
Profile("AlertRig\\"+Monkey$,"AnswerPointDelay",str$(AnswerPointDelay));
Profile("AlertRig\\"+Monkey$,"AnswerWindow",str$(AnswerWindow));
Profile("AlertRig\\"+Monkey$,"RandomFixationOffset",str$(RandomFixationOffset));
Profile("AlertRig\\"+Monkey$,"AnswerPointInitialBrightness",str$(AnswerPointInitialBrightness));
Profile("AlertRig\\"+Monkey$,"AnswerPointFullBrightness",str$(AnswerPointFullBrightness));


return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetLastUsedGratingParameters%();

'Read the Windows registry to determine last used values for the experiment parameters
'Since registry values are either integers are strings, we store decimals as strings and convert them to decimals

var TargetOrientation$, TargetSF$, TargetTF$, TargetDiameter$;
Profile("AlertRig\\"+Monkey$,"TargetOrientation","0",TargetOrientation$);
Profile("AlertRig\\"+Monkey$,"TargetSF","1",TargetSF$);
Profile("AlertRig\\"+Monkey$,"TargetTF","2",TargetTF$);
Profile("AlertRig\\"+Monkey$,"TargetDiameter","2",TargetDiameter$);

'Convert strings to decimenals
TargetOrientation := val(TargetOrientation$);
TargetSF := val(TargetSF$);
TargetTF := val(TargetTF$);
TargetDiameter := val(TargetDiameter$);


return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SetLastUsedGratingParameters%();
'Since registry values are either integers are strings, we convert decimals to strings

Profile("AlertRig\\"+Monkey$,"TargetOrientation",str$(TargetOrientation));
Profile("AlertRig\\"+Monkey$,"TargetSF",str$(TargetSF));
Profile("AlertRig\\"+Monkey$,"TargetTF",str$(TargetTF));
Profile("AlertRig\\"+Monkey$,"TargetDiameter",str$(TargetDiameter));

return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func DetermineContrastChanges()
var BlockIndex%,Block[30],RandomBlock[30],RandomNumber;
ArrConst(Block[:15],-1);
ArrConst(Block[15:15],1);
ArrConst(RandomDelay[],0);


for index :=0 to (NumberOfBlocks% -1) do
	BlockIndex%:=0;
   ArrConst(RandomBlock[],0);
	while BlockIndex% < 30 do
		RandomNumber:=round(29*rand());
		if RandomBlock[RandomNumber] = 0 then 
			RandomBlock[RandomNumber] := Block[BlockIndex%];
			BlockIndex% := BlockIndex%+1;
		endif
	wend
	ArrConst(ContrastState[index*30:30],RandomBlock[]);
next

for index:=0 to (30*NumberOfBlocks% - 1) do
	if RandomFixationOffset > 0 then RandomDelay[index] := RandomFixationOffset*rand(); endif
next

return 1;
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ModifyDistractors()

	var dindex%,DistractorFile%;
	NumberOfDistractors% := Input("Display how many distractors?",5,0,5);
	DistractorFile% := FileOpen("c:\\AlertRig\\DistractorList",8,1);
	if DistractorFile% < 0 then Message("Could not create distractor file."); halt; endif
	if NumberOfDistractors% > 0 then
		var DistractorOrientation, DistractorSF, DistractorTF, DistractorDiameter, DistractorContrast,DistractorX,DistractorY;
		for dindex% := 1 to NumberOfDistractors% do 
			DlgCreate("Specify distractor "+str$(dindex%)+" properties");
			DlgReal(1,"Orienation: ",-360,360);
			DlgReal(2,"Spatial frequency: ",.01, 100);
			DlgReal(3,"Temporal frequency: ",0,100);
			DlgReal(4,"Diameter: (deg)",.1,10);
			DlgReal(5,"Contrast: (%)",0, 100);
			DlgReal(6,"X position: (deg)",-10,10);
			DlgReal(7,"Y position: (deg)",-10,10);
			DlgResponse := DlgShow(DistractorOrientation,DistractorSF,DistractorTF,DistractorDiameter,DistractorContrast,
											DistractorX,DistractorY);
			if DlgResponse < 0 then FileClose(DistractorFile%); halt; endif
			Print("%f %f %f %f %f %f %f\n",DistractorOrientation,DistractorSF,DistractorTF,DistractorDiameter,DistractorContrast,
					DistractorX,DistractorY);
		next
	endif
	if NumberOfDistractors% = 0 then Print("-1000"); endif
FileClose(DistractorFile%);

return 1;
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
var index;
SampleClear(); 'Set standard sampling state
SampleAutoFile(0); 'Enable automatic file naming
SampleAutoComment(0); 'Prompt for comment after sampling
SampleAutoCommit(60); 'Seconds between each file commit

'Channel recording definitions
SampleEvent(FixationPointChannel%,1,2,3600); 'Trigger channel, level
SampleComment$(FixationPointChannel%,"Fixation");
SampleTitle$(FixationPointChannel%,"Fixation");

SampleEvent(StimChannel%,2,2,3600); 'Trigger channel, level
SampleComment$(StimChannel%,"Stim");
SampleTitle$(StimChannel%,"Stim");

SampleEvent(AnswerPointChannel%,3,2,3600); 'Trigger channel, level
SampleComment$(AnswerPointChannel%,"Ans. Pt.");
SampleTitle$(AnswerPointChannel%,"Ans. Pt.");

SampleEvent(StimChangeChannel%,4,2,3600); 'Trigger channel, level
SampleComment$(StimChangeChannel%,"Stim Chg.");
SampleTitle$(StimChangeChannel%,"Stim Chg.");

SampleEvent(ConfounderChangeChannel%,5,2,3600); 'Trigger channel, level
SampleComment$(ConfounderChangeChannel%,"Catch trial");
SampleTitle$(ConfounderChangeChannel%,"Catch trial");

for index := 1 to NumberOfChannels% do
	SampleWaveMark(index,index-1,2000,34,15,28000); ' chan, port, event rate, points, pre-trigger, rate
	SampleTitle$(index,"Electrode_"+Str$(index)); 
next

SampleWaveform(XChannel%,14,1000);
SampleTitle$(XChannel%,"Eye X");
SampleWaveform(YChannel%,15,1000);
SampleTitle$(YChannel%,"Eye Y");

SampleSequencer(script$ + "Attention.pls");
SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
SampleMode(1); 'Continuous sampling
end;
