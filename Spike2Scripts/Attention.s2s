' $Log: not supported by cvs2svn $
' Revision 1.4  2005/03/18 19:37:14  dan
' Almost there!
'
' Revision 1.3  2005/03/11 01:13:12  dan
' Almost there!
'
' Revision 1.2  2005/03/09 01:06:48  dan
' Almost there!
'
' Revision 1.1  2005/03/01 00:30:02  dan
' New version to use with new attention application.
'
'



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Get Current configuration START
'	
'	Fetch the current configuration from the registry and return it. 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func GetCurrentConfiguration$()
	var key$;
	var s$;
	key$:="AlertRig";
	Profile(key$, "CurrentConfiguration", "default", s$);
	return s$;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Get Current configuration END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Data parameters START
'
'	Vars that control where data is stored. 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var dataPathRoot$;		' base path for data storage
var dataDataSet$;		' folder under data path where data files placed
var dataCellName$;		' part of base name for all data files
var dataDataSetTextItem%;	' 

proc GetDataParameters()
	var stmp$;
	var key$;

	key$:="AlertRig\\Data";

	Profile(key$, "PathRoot", "C:\\Experiments", dataPathRoot$);
	Profile(key$, "DataSet", "", dataDataSet$);
	Profile(key$, "CellName", "", dataCellName$);
	return;
end;

proc SaveDataParameters()
	var stmp$;
	var key$;

	key$:="AlertRig\\Data";

	Profile(key$, "PathRoot", dataPathRoot$);
	Profile(key$, "DataSet", dataDataSet$);
	Profile(key$, "CellName", dataCellName$);
	return;
end;

func DataParametersDialog%()
	var i%;
	GetDataParameters();
	DlgCreate("Data Storage Parameters", 25, 10, 50);
	DlgText("Data root path: " + dataPathRoot$, 0, 1);
	dataDataSetTextItem% := DlgText("Data set name: " + dataDataSet$, 0, 2);
	DlgString(1, "Cell name:", 10, "", 0, 3);
        DlgButton(2, "New Data Set", NewDataSet%);
	i% := DlgShow(dataCellName$);
	if (i% = 1) then
		if Len(dataDataSet$) = 0 then
			Message("Must specify a data set (try the button!)");
		else
			if Len(dataCellName$) = 0 then
				Message("Must specify a cell name");
			else
				FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 0, 1);
				SaveDataParameters();
			endif;
		endif;
	endif;
	return i%;
end;


func NewDataSet%()
	var d$;
	var i%;
	var dirs$[100];	' if there are ever more than 100 datasets in a single day there will be trouble
	d$ := Date$(2, 2, 3, 3, "-");
	PrintLog("NewDataSet: date string = " + d$ + "\n");

	' Change current dir to data path root, then get list of subdirs with this date string
	PrintLog("NewDataSet: dataPathRoot$=" + dataPathRoot$ + "\n");
	FilePathSet(dataPathRoot$, 0, 1);
	i% := FileList(dirs$, -2, d$ + "-??");
        PrintLog("NewDataSet: found " + str$(i%) + " dirs\n");

	' form new dataset name. The first will have "-01" appended, the second "-02", etc. 
	dataDataSet$ := Print$("%s-%02d", d$, i%+1);
	PrintLog("NewDataSet: dataset= " + dataDataSet$ + "\n");
	DlgValue$(dataDataSetTextItem%, "Data set name: " + dataDataSet$);
	return 1;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Data parameters END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Fixation Point parameters START
'
'	These vars and funcs control the parameters for the fixation point stored in the registry. 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var WindowRadius;
var FixationX, FixationY;
var FixationColor$;
var iFixationColor%;
var FixationDiameter;
var FixationColorList$[3]; 
var FixationArg$;

proc GetFixationPointParameters()
	var stmp$;
	var key$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\FixationPoint";
	Profile(key$, "WindowRadius", "1", stmp$);
	WindowRadius := val(stmp$);

	Profile(key$, "FixationX", "0", stmp$);
	FixationX := val(stmp$);
	Profile(key$, "FixationY", "0", stmp$);
	FixationY := val(stmp$);

	Profile(key$, "FixationColor", 0, iFixationColor%);

	FixationColorList$[0]:="red"; 
	FixationColorList$[1]:="green"; 
	FixationColorList$[2]:="blue"; 
	FixationColor$ := FixationColorList$[iFixationColor%];

	Profile(key$, "FixationDiameter", "0.5", stmp$);
	FixationDiameter := val(stmp$);

	' Form the argument for applications. Convenience for passing args. 
	FixationArg$ := " -f " + str$(FixationX) + "," + str$(FixationY) + "," + str$(FixationDiameter) + "," + FixationColor$;
end;

proc SaveFixationPointParameters()
	var key$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\FixationPoint";
	Profile(key$, "WindowRadius", str$(WindowRadius));
	Profile(key$, "FixationX", str$(FixationX));
	Profile(key$, "FixationY", str$(FixationY));
	Profile(key$, "FixationColor", iFixationColor%);
	Profile(key$, "FixationDiameter", str$(FixationDiameter));
end;


func FixationPointDialog%()

	var i%;
	GetFixationPointParameters();
	DlgCreate("Fixation parameters: " + GetCurrentConfiguration$(), 25, 10);
	DlgReal(1, "Fixation X:", -20, 20);
	DlgReal(2, "Fixation Y:", -20, 20);
	DlgReal(3, "Fixation diam:", .1, 5);
	DlgReal(4, "Window radius:", .1, 10);
	DlgList(5, "Color:", FixationColorList$[]);
	i% := DlgShow(FixationX, FixationY, FixationDiameter, WindowRadius, iFixationColor%);	

	' If user cancelled, reload params
	if i% = 0 then
		GetFixationPointParameters();
	else
		SaveFixationPointParameters();
	endif

	return 1;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Fixation Point parameters END
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Rig Daily Totals START
'
'	Control, display, reset daily totals for a rig.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


var TotalTrials%;
var TotalRewards%;
var TotalDate$;


proc GetDailyTotals()
	var key$;
	key$ := "AlertRig\\Daily";
	Profile(key$, "TotalDate", "", TotalDate$);
	Profile(key$, "TotalTrials", 0, TotalTrials%);
	Profile(key$, "TotalRewards", 0, TotalRewards%);

	' Get date string if needed
	if Len(TotalDate$) = 0 then
		TotalDate$ := GetDayString$();
		SaveDailyTotals();
	endif
end;

proc SaveDailyTotals()
	var key$;
	key$ := "AlertRig\\Daily";
	Profile(key$, "TotalDate", TotalDate$);
	Profile(key$, "TotalTrials", TotalTrials%);
	Profile(key$, "TotalRewards", TotalRewards%);
end;

func DailyTotalsDialog%()
	GetDailyTotals();
	DlgCreate("Daily Totals");
	DlgText("Date: " + TotalDate$, 0, 1);
	DlgText("Trials: " + str$(TotalTrials%), 0, 2);
	DlgText("Rewards: " + str$(TotalRewards%), 0, 3);
	DlgButton(2, "Reset", ResetDailyTotals%);
	DlgShow();
	return 1;
end;


func GetDayString$()
	return Date$(2, 1, 3, 2, "-");
end;


func ResetDailyTotals%()
	GetDailyTotals();
	TotalRewards%:=0;
	TotalTrials%:=0;
	TotalDate$:= GetDayString$();
	SaveDailyTotals();
        return 0;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Rig Daily Totals END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	DAQ Parameters START
'
'	Control of data acquisition parameters.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


var DistanceToScreenMM$;		' Distance to screen in MM
var DegreesPerVoltX;			' Conversion factor from ADC to visual degrees
var DegreesPerVoltY;			' Conversion factor from ADC to visual degrees
var EyeCoilSamplingFrequency%;		' Frequency to sample eye coil at
var NumberOfElectrodes%;		' Number of electrodes (i.e. wavemark inputs) in use
var JuicePerReward%;			' Number of juice squirts per reward


func DAQParametersDialog%()

	var iReturn%;
	var idist%;

	GetDAQParameters();

	idist% := val(DistanceToScreenMM$);
	DlgCreate("DAQ parameters: " + GetCurrentConfiguration$(), 25, 10);
	DlgInteger(1, "Number of Electrodes:", 1, 7, 0, 0, 1);
	DlgInteger(2, "Screen Distance (MM):", 1, 5000);
	DlgReal(3, "Degrees/Volt (X):", 0, 100);
	DlgReal(4, "Degrees/Volt (Y):", 0, 100);
	DlgInteger(5, "Eye Coil Sampling Freq (Hz):", 1, 20000);
	DlgInteger(6, "Juice per reward:", 0, 10, 0, 0, 1);
	iReturn% := DlgShow(NumberOfElectrodes%, idist%, DegreesPerVoltX, DegreesPerVoltY, EyeCoilSamplingFrequency%, JuicePerReward%);

	if iReturn% = 1 then
		DistanceToScreenMM$ := str$(idist%);
		SaveDAQParameters();
	endif
	return iReturn%;
end;




	
proc GetDAQParameters()
	var key$;
	var DegreesPerVoltX$, DegreesPerVoltY$;

	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\DAQ";
	Profile(key$, "DistanceToScreenMM", "850", DistanceToScreenMM$);	' will just pass this to stimulus app
	Profile(key$, "DegreesPerVoltX", "", DegreesPerVoltX$);
	Profile(key$, "DegreesPerVoltY", "", DegreesPerVoltY$);
	Profile(key$, "EyeCoilSamplingFrequency", 1000, EyeCoilSamplingFrequency%);
	Profile(key$, "NumberOfElectrodes", 1, NumberOfElectrodes%);
	Profile(key$, "JuicePerReward", 1, JuicePerReward%);
	DegreesPerVoltX := val(DegreesPerVoltX$);
	DegreesPerVoltY := val(DegreesPerVoltY$);

end;

proc SaveDAQParameters()
	var key$;
	var DegreesPerVoltX$, DegreesPerVoltY$;
	DegreesPerVoltX$ := str$(DegreesPerVoltX);
	DegreesPerVoltY$ := str$(DegreesPerVoltY);
	
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\DAQ";
	Profile(key$, "DistanceToScreenMM", DistanceToScreenMM$);
	Profile(key$, "DegreesPerVoltX", DegreesPerVoltX$);
	Profile(key$, "DegreesPerVoltY", DegreesPerVoltY$);
	Profile(key$, "EyeCoilSamplingFrequency", EyeCoilSamplingFrequency%);
	Profile(key$, "NumberOfElectrodes", NumberOfElectrodes%);
	Profile(key$, "JuicePerReward", JuicePerReward%);

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	DAQ Parameters END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' 	Attention script START
'
'	Vars that control the Attention script. 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var attNumberOfBlocks%;
var attCatchTrialPercentage;
var attBackgroundColor$;
var attContrastBase%;
var attContrastUp%;
var attContrastDown%;
var attFixationDuration;
var attAcquisitionTime;
var attInterTrialTime;
var attGratingDelay;
var attContrastDelay;
var attAnswerPointDelay;
var attRandomFixationOffset;
var attTimeToAnswer;
var attStimulusFlag%;			' Tells whether to use stimulus grating (used as a distractor) 
var attDistractor1Flag%; 			' Tells stim to use distractor1 (1) or not (0)
var attDistractor2Flag%; 			' Tells stim to use distractor1 (1) or not (0)
var attDistractor3Flag%; 			' Tells stim to use distractor1 (1) or not (0)
var attDistractor4Flag%; 			' Tells stim to use distractor1 (1) or not (0)

proc GetAttentionScriptParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Attention";

	Profile(key$, "NumberOfBlocks", 1, attNumberOfBlocks%);

	Profile(key$, "CatchTrialPercentage", "0.0", stmp$);
	attCatchTrialPercentage := val(stmp$);

	Profile(key$, "BackgroundColor", "gray", attBackgroundColor$);
	Profile(key$, "ContrastBase", 50, attContrastBase%);
	Profile(key$, "ContrastUp", 80, attContrastUp%);
	Profile(key$, "ContrastDown", 20, attContrastDown%);

	Profile(key$, "FixationDuration", "1.0", stmp$);
	attFixationDuration := val(stmp$);

	Profile(key$, "AcquisitionTime", "1.0", stmp$);
	attAcquisitionTime := val(stmp$);

	Profile(key$, "InterTrialTime", "1.0", stmp$);
	attInterTrialTime := val(stmp$);

	Profile(key$, "GratingDelay", "1.0", stmp$);
	attGratingDelay := val(stmp$);

	Profile(key$, "ContrastDelay", "1.0", stmp$);
	attContrastDelay := val(stmp$);

	Profile(key$, "AnswerPointDelay", "1.0", stmp$);
	attAnswerPointDelay := val(stmp$);

	Profile(key$, "RandomFixationOffset", "1.0", stmp$);
	attRandomFixationOffset := val(stmp$);

	Profile(key$, "TimeToAnswer", "1.0", stmp$);
	attTimeToAnswer := val(stmp$);

	Profile(key$, "UseStimulusFlag", 0, attStimulusFlag%);
	Profile(key$, "UseDistractor1Flag", 0, attDistractor1Flag%);
	Profile(key$, "UseDistractor2Flag", 0, attDistractor2Flag%);
	Profile(key$, "UseDistractor3Flag", 0, attDistractor3Flag%);
	Profile(key$, "UseDistractor4Flag", 0, attDistractor4Flag%);
end;

proc SaveAttentionScriptParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Attention";

	Profile(key$, "NumberOfBlocks", attNumberOfBlocks%);
	Profile(key$, "CatchTrialPercentage", str$(attCatchTrialPercentage));
	Profile(key$, "BackgroundColor", attBackgroundColor$);
	Profile(key$, "ContrastBase", attContrastBase%);
	Profile(key$, "ContrastUp", attContrastUp%);
	Profile(key$, "ContrastDown", attContrastDown%);
	Profile(key$, "FixationDuration", str$(attFixationDuration));
	Profile(key$, "AcquisitionTime", str$(attAcquisitionTime));
	Profile(key$, "InterTrialTime", str$(attInterTrialTime));
	Profile(key$, "GratingDelay", str$(attGratingDelay));
	Profile(key$, "ContrastDelay", str$(attContrastDelay));
	Profile(key$, "AnswerPointDelay", str$(attAnswerPointDelay));
	Profile(key$, "RandomFixationOffset", str$(attRandomFixationOffset));
	Profile(key$, "TimeToAnswer", str$(attTimeToAnswer));
	Profile(key$, "UseStimulusFlag", attStimulusFlag%);
	Profile(key$, "UseDistractor1Flag", attDistractor1Flag%);
	Profile(key$, "UseDistractor2Flag", attDistractor2Flag%);
	Profile(key$, "UseDistractor3Flag", attDistractor3Flag%);
	Profile(key$, "UseDistractor4Flag", attDistractor4Flag%);
end;

func AttentionScriptDialog%()
	var i%;
	var bcl$[3];
	var ibcl%:=0;
	GetAttentionScriptParameters();
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
	for i%:=0 to 2 do
		if attBackgroundColor$ = bcl$[i%] then
			ibcl% := i%;
		endif
	next;
	DlgCreate("Attention Training Parameters", 25, 10);
	DlgReal(1, "Fixation duration(s):", .01, 10);
	DlgReal(2, "Acquisition time(s):", .01, 10);
	DlgReal(3, "Intertrial time(s):", .01, 10);

	DlgReal(4, "Grating delay(s):", .01, 10);
	DlgReal(5, "Contrast delay(s):", .01, 10);
	DlgReal(6, "Answer point delay(s):", .01, 10);
	DlgReal(7, "Random fixation offset(s):", 0.0, 10.0);
	DlgReal(8, "Time to answer(s):", 0.01, 10.0);

	DlgInteger(9, "Number of Blocks:", 1, 1000);
	DlgReal(10, "Catch Trial pct(0-100)", 0, 100);
	DlgList(11, "Background color:", bcl$);
	DlgInteger(12, "Base contrast(%)", 0, 100);
	DlgInteger(13, "Up contrast(%)", 0, 100);
	DlgInteger(14, "Down contrast(%)", 0, 100);
	DlgCheck(15, "Use Confounder?");
	DlgCheck(16, "Use distractor 2?");
	DlgCheck(17, "Use distractor 3?");
	DlgCheck(18, "Use distractor 4?");
	i%:=DlgShow(attFixationDuration, attAcquisitionTime, attInterTrialTime, 
		attGratingDelay, attContrastDelay, attAnswerPointDelay, attRandomFixationOffset, attTimeToAnswer,
		attNumberOfBlocks%, attCatchTrialPercentage, ibcl%,
		attContrastBase%, attContrastUp%, attContrastDown%, 
		attDistractor1Flag%, attDistractor2Flag%, attDistractor3Flag%, attDistractor4Flag%);
	if i% = 1 then
		attBackgroundColor$ := bcl$[ibcl%];
		SaveAttentionScriptParameters();
	endif;
	return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Attention script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''









var ContrastState[10000];	' 0 (1) means contrast goes down (up) for a trial
var RandomDelay[10000];		' Contrast change is delayed by a random amount (0 < delay < RandomFixationOffset)

var AnswerWindow:=1;		' Answer point window (degrees)
var AnswerPointOffsetX:=0;	' Answer point X offset in degrees
var AnswerPointOffsetY:=5;	' Answer point Y offset in degrees

' Local file system variables. 
var bin$, script$;
bin$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2) + "..\\bin";	' Location of executables is ..\bin, relative to script dir
script$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2);	' folder containing this script

' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FixationPointChannel%;
var StimChannel%;
var AnswerPointChannel%;
var StimChangeChannel%;
var ConfounderChangeChannel%;
var ReadyChannel%;

' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view

' Per-trial parameters
var AnswerX, AnswerY;		' Each trial, this is the center of the CORRECT answer point. 





' Fetch parameters
GetDailyTotals();
GetDAQParameters();
GetFixationPointParameters();
GetAttentionScriptParameters();
GetDataParameters();

' Check for valid data file path
if Len(dataDataSet$) = 0 then
	Message("No data set is selected! Edit Data parameters...");
	' Might be nice to open the dialog here....
	halt;
else 
	' Set path for new data files
	FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
	SampleAutoName$(dataCellName$ + "_att_000");
	SampleAutoFile(1);
	PrintLog("AutoFile status " + str$(SampleAutoFile()) + "\n");
endif

' Assign channel numbers for eye X,Y and trigger. 
XChannel% := NumberOfElectrodes%+1;
YChannel% := NumberOfElectrodes%+2;
FixationPointChannel% := NumberOfElectrodes%+3;
StimChannel% := NumberOfElectrodes%+4;
StimChangeChannel% := NumberOfElectrodes%+5;
ConfounderChangeChannel% := NumberOfElectrodes%+6;
AnswerPointChannel% := NumberOfElectrodes%+7;
ReadyChannel% := NumberOfElectrodes%+8;
CreateSampleConfiguration();


' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();






'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
	ToolbarSet(6,"Exp Parameters",AttentionScriptDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",12345);

end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' The answer windows are located 'AnswerPointOffsetY' from the fixation point's location. 
' The direction of that offset is determined by ContrastChange[TrialNumber%] - if its +1 the 
' correct answer is above, if its -1 the correct answer is below. 

func Answer%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-AnswerY,2)) <= Pow(AnswerWindow,2) then return 1; endif
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY+AnswerY,2)) <= Pow(AnswerWindow,2) then return -1; endif
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
	var i%;
	for i%:=1 to JuicePerReward% do Yield(.05); SampleKey("J"); next
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Determine two sets of random numbers to drive this expt. 
' RandomDelay[] is an array of numbers, 0 <= RandomDelay[i] <= RandomFixationOffset. 
' For each trial, this is a random delay added to each of the delay vars: GratingDelay, ContrastDelay, 
' AnswerPointDelay. 
' ContrastState[] is an array of numbers, each is either 1 or -1. Each number determines the contrast
' change, up for +1, down for -1, on a given trial. 
' The goofy loop ensures that each "block" of 30 trials is equally balanced between up and down contrast
' changes. 

func DetermineContrastChanges()
var BlockIndex%,Block[30],RandomBlock[30],RandomNumber;
var index;
ArrConst(Block[:15],-1);
ArrConst(Block[15:15],1);
ArrConst(RandomDelay[],0);


for index :=0 to (attNumberOfBlocks% -1) do
	BlockIndex%:=0;
	ArrConst(RandomBlock[],0);
	while BlockIndex% < 30 do
		RandomNumber:=round(29*rand());
		if RandomBlock[RandomNumber] = 0 then 
			RandomBlock[RandomNumber] := Block[BlockIndex%];
			BlockIndex% := BlockIndex%+1;
		endif
	wend
	ArrConst(ContrastState[index*30:30],RandomBlock[]);
next

for index:=0 to (30*attNumberOfBlocks% - 1) do
	if attRandomFixationOffset > 0 then RandomDelay[index] := attRandomFixationOffset*rand(); endif
next

return 1;
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tFixationDone:=-1;	' time that fixation duration was achieved. Used to measure time to answer

' Constants for states
const stateStartTrial%:=0;	' Start trial state
const stateWaitForFixPt%:=1;	' Waiting for fixation point return trigger
const stateAcquire%:=2;		' Waiting for subject to acquire fixation point
const stateHoldFixation%:=3;	' Holding fixation point
const stateBreakFixation%:=4;	' Waiting for subject to break fixation
const stateAbort%:=5;		' Failed trial state
const stateWaitForAnswer%:=6;	' Fixation held, now awaiting answer
const stateCorrectAnswer%:=7;	' Right answer received
const stateIncorrectAnswer%:=8;	' Wrong answer received
const stateWaitForBlank%:=9;
const stateInterTrialInterval%:=10;
const stateVSGWait% := 11;
const stateVSGWaitConfirm% := 12;
var iState% := stateVSGWait%;	' present state

var AnswerPointsUp% :=0;	' Set to 1 after answer point key "A" is issued
var StimulusUp% :=0;		' Set to 1 after grating key "S" is issued
var ContrastChange% := 0;	' Set to 1 after ContrastChange key "C"/"D" is issued


var nTrialsStarted%:=0;
var nTrialsCorrect%:=0;
var nTrialsIncorrect%:=0;
var nTrialsAbort% :=0;		' Number of trials aborted before any answer given

func IdleProcessing%()

	tNow := MaxTime();

	xEye := ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
	yEye := ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastUpdate := tNow;
	endif


	docase 
		case iState% = stateVSGWait% then

			' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
			tTrigger := NextTime(ReadyChannel%, tLast, vTrigger);
			if tTrigger > tLastTrigger and vTrigger = 0 then
				PrintLog("state stateVSGWait: Got leading edge of trigger\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateVSGWaitConfirm%, tTrigger);
			endif;

		case iState% = stateVSGWaitConfirm% then

			' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
			tTrigger := NextTime(ReadyChannel%, tLast, vTrigger);
			if tTrigger > tLastTrigger and vTrigger = 1 then
				PrintLog("state stateVSGWaitConfirm: Got trailing edge of trigger\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateStartTrial%, tTrigger);
			endif;

		case iState% = stateStartTrial% then

			'StartTrial -- issue "F" to turn on fixation points. 
			' Enter state 1

			SampleKey("F");
			ChangeStateTo(stateWaitForFixPt%, tNow);
			PrintLog("State stateStartTrial - fixation trigger F sent. Entering state stateWaitForFixPt \n");

			' Initialize state loop vars
			AnswerPointsUp% :=0;
			StimulusUp% :=0;
			ContrastChange% := 0;
			tFixationDone := -1;

			' Increment trial counter. 
			nTrialsStarted% += 1;

		case iState% = stateWaitForFixPt% then
	
			' Waiting for fixation point return trigger from vsg. 
			' NextTime returns a non-negative value whenever there is a TRANSITION. In that case, the 
			' value of 'vTrigger' returned is 1 (0) if the transition is high (low) to low (high). Maybe not
			' intuitive, but that's the way it is. 
			tTrigger := NextTime(FixationPointChannel%,tLast,vTrigger);
			if tTrigger > tLastTrigger then

				if vTrigger = 0 then
		
					' Stimulus has been presented. Display stim location and window. Enter stateAcquire
'					DrawStim(1);
					ChangeStateTo(stateAcquire%, tTrigger);
					tLastTrigger := tTrigger;

				endif

			endif

		case iState% = stateAcquire% then

			if tNow-tStateStart < attAcquisitionTime then
				
				' Acquisition happens when the eye falls within the fixation window.
				if Looking%(xEye, yEye) = 1 then

					PrintLog("stateAcquire - acquired target. tNow=" + str$(tNow) + " Enter stateHoldFixation\n");
					ChangeStateTo(stateHoldFixation%, tNow);

					if (ContrastState[nTrialsStarted%-1]>0) then
						SampleKey("H");
					else
						SampleKey("L");
					endif
	
				endif

			else

				' Failed. Turn off stim and try again.
				PrintLog("stateAcquire - acquisition failed. Enter stateAbort\n");
				ChangeStateTo(stateAbort%, tNow);

			endif

		case iState% = stateHoldFixation% then

			' keep looking at the dot...
			if Looking%(xEye, yEye) = 1 then

				' In this state, we check the time and turn on the stimulus, answer points, contrast change when
				' appropriate. Note that we do NOT check for the return triggers on these -- this is in keeping with
				' the original version of this paradigm. I will change this eventually, but not in this first
				' rewrite. 

				if (tNow - tStateStart >= attAnswerPointDelay) and (AnswerPointsUp% = 0) then 
					SampleKey("A");
					AnswerPointsUp% := 1;
				endif

				if (tNow - tStateStart >= attGratingDelay) and (StimulusUp% = 0) then
					SampleKey("S");
					StimulusUp% := 1;
				endif

				if (tNow - tStateStart >= attContrastDelay) and (ContrastChange% = 0) then
					if (rand() <= attCatchTrialPercentage/100) then
						SampleKey("D");
					else
						SampleKey("C");
					endif
					ContrastChange% := 1;
					AnswerX := FixationX;
					AnswerY := FixationY + AnswerPointOffsetY * ContrastState[nTrialsStarted%-1];

				endif

				' This is the only condition that forces an exit! 
				' We use guard logic to ensure that the three changes above - contrast change, gratings up, answer points up, all 
				' have occurred before exiting this state! 
				' More logic should be employed to make certain that FixationDuration > AnswerPointDelay, ContrastDelay, GratingDelay! 

				if (tNow - tStateStart >= attFixationDuration and AnswerPointsUp% = 1 and StimulusUp% = 1 and ContrastChange% = 1) then
					ChangeStateTo(stateBreakFixation%, tNow);
					tFixationDone := tNow;
				endif;

			else

				ChangeStateTo(stateAbort%, tNow);

			endif;

		case iState% = stateBreakFixation% then

			' In this state, we just wait for the subject to break fixation. After that happens, turn off the stimuli. 
			if Looking%(xEye, yEye) = 0 then
				SampleKey("s");
				ChangeStateTo(stateWaitForAnswer%, tNow);
			else 
				if (tNow - tFixationDone) > attTimeToAnswer then
					ChangeStateTo(stateAbort%, tNow);
				endif
			endif

		case iState% = stateAbort% then

			' Issue X, count, wait for blank
			SampleKey("X");
			nTrialsAbort% += 1;
			ChangeStateTo(stateWaitForBlank%, tNow);

		case iState% = stateWaitForAnswer% then

			if (tNow - tFixationDone) > attTimeToAnswer then
				ChangeStateTo(stateAbort%, tNow);
			else
				' Check if an answer is being given....
				var iAnswer%;
				iAnswer% := Answer%(xEye, yEye);
				if iAnswer% = 1 then
					' Right answer
					ChangeStateTo(stateCorrectAnswer%, tNow);
				else 
					if iAnswer% = -1 then
						' Wrong answer
						ChangeStateTo(stateIncorrectAnswer%, tNow);
					endif
				endif
			endif

		case iState% = stateCorrectAnswer% then

			SampleKey("X");
			nTrialsCorrect% += 1;
			Reward%();
			ChangeStateTo(stateWaitForBlank%, tNow);

		case iState% = stateIncorrectAnswer% then

			SampleKey("X");
			nTrialsIncorrect% += 1;
			ChangeStateTo(stateWaitForBlank%, tNow);


		case iState% = stateWaitForBlank% then

			tTrigger := NextTime(FixationPointChannel%,tLast,vTrigger);
			if tTrigger > tLastTrigger then

				if vTrigger = 1 then
		
					ChangeStateTo(stateInterTrialInterval%, tTrigger);
					tLastTrigger := tTrigger;

				endif

			endif

		case iState% = stateInterTrialInterval% then

			' Inter-trial wait time
			if tNow - tStateStart > attInterTrialTime then
	
				' Back to state 0
				PrintLog("stateInterTrialInterval - IT wait is done. Start new trial.\n");
				iState% := stateStartTrial%;
				tStateStart := tNow;
	
			endif

		else 

			' Unknown state!
			Message("Unknown state=" + str$(iState%));
			halt;

	endcase;

	tLast := tNow;
	return 1;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	tStateStart := tStart;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end





proc InitializeWindows()

	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(-0.235849,52.746,97.2484,99.8856);
	View(DataWindow%).WindowVisible(1);

	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(-0.550314,0.114416,41.5094,52.746);
	XYColour(1,16);
	XYSize(1,-1);

	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iStimWindowChannel% := XYSetChan(0);
	XYColour(2,13);
	XYDrawMode(2,2,1);
	XYJoin(2,1);
	'Draw the fixation window
	XYAddData(2, FixWindowX[], FixWindowY[]);

	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);

	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(4,13);
	XYDrawMode(4,3,1);
	XYJoin(4,2);
	XYAddData(4,-9,-7);
	XYAddData(4,9,-7);
	XYAddData(4,9,7);
	XYAddData(4,-9,7);

end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
	SampleClear(); 'Set standard sampling state
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit

	'Channel recording definitions
	SampleEvent(FixationPointChannel%,1,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixation");
	SampleTitle$(FixationPointChannel%,"Fixation");
	
	SampleEvent(StimChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
	
	SampleEvent(AnswerPointChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(AnswerPointChannel%,"Ans. Pt.");
	SampleTitle$(AnswerPointChannel%,"Ans. Pt.");
	
	SampleEvent(StimChangeChannel%,4,2,3600); 'Trigger channel, level
	SampleComment$(StimChangeChannel%,"Stim Chg.");
	SampleTitle$(StimChangeChannel%,"Stim Chg.");
	
	SampleEvent(ConfounderChangeChannel%,5,2,3600); 'Trigger channel, level
	SampleComment$(ConfounderChangeChannel%,"Catch trial");
	SampleTitle$(ConfounderChangeChannel%,"Catch trial");

	SampleEvent(ReadyChannel%,6,2,3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");

	
	for index := 1 to NumberOfElectrodes% do
		SampleWaveMark(index,index-1,2000,34,15,28000); ' chan, port, event rate, points, pre-trigger, rate
		SampleTitle$(index,"Electrode_"+Str$(index)); 
	next
	
	SampleWaveform(XChannel%,14,1000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%,15,1000);
	SampleTitle$(YChannel%,"Eye Y");
	
	SampleSequencer(script$ + "Attention.pls");
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;



' Get grating p[arameters from registry AlertRig\\(config)\\Gratings\\type$
func GetGratingParameters$(type$)
	var key$;
	var stmp$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\Gratings";
	Profile(key$, type$, "", stmp$);
	return stmp$;
end;


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
var CommandLine$;
var FixationPoint$;
var Extras$;
var Distractors$:="";

SampleStart(0); 'Start sampling
SampleKey("0");
GetAttentionScriptParameters();
DetermineContrastChanges();

' Stimulus is always used
Distractors$ := " -s " + GetGratingParameters$("Stimulus");

' Distractor1 is used as the confounder. 
if attDistractor1Flag% = 1 then
	Extras$ := GetGratingParameters$("Distractor1");
	if Len(Extras$) = 0 then
		Message("Warning! Use distractor 1 flag is set, but distractor 1 grating is not configured!");
	else
		Distractors$ += " -c " + Extras$;
	endif
endif

if attDistractor2Flag% = 1 then
	Extras$ := GetGratingParameters$("Distractor2");
	if Len(Extras$) = 0 then
		Message("Warning! Use distractor 2 flag is set, but distractor 2 grating is not configured!");
	else
		Distractors$ += " -g " + Extras$;
	endif
endif

if attDistractor3Flag% = 1 then
	Extras$ := GetGratingParameters$("Distractor3");
	if Len(Extras$) = 0 then
		Message("Warning! Use distractor 3 flag is set, but distractor 3 grating is not configured!");
	else
		Distractors$ += " -g " + Extras$;
	endif
endif

if attDistractor4Flag% = 1 then
	Extras$ := GetGratingParameters$("Distractor4");
	if Len(Extras$) = 0 then
		Message("Warning! Use distractor 4 flag is set, but distractor 4 grating is not configured!");
	else
		Distractors$ += " -g " + Extras$;
	endif
endif

Extras$ := " -b " + attBackgroundColor$ + " -d " + DistanceToScreenMM$ + " -t " + str$(attContrastDown%) + "," + str$(attContrastBase%) + "," + str$(attContrastUp%);

'CommandLine$ := "cmd /c " + bin$ + "\\dAttention " + FixationArg$ + Extras$ + Distractors$;
CommandLine$ := bin$ + "\\dAttention " + FixationArg$ + Extras$ + Distractors$;

'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
PrintLog(CommandLine$+"\n");
StimHandle% := ProgRun(CommandLine$,1);
if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.

ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
ToolbarEnable(2,1);
ToolbarEnable(1,0);
ToolbarEnable(6,0);
ToolbarEnable(7,0);
View(DataWindow%);
Yield(.1);
return 1;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()

	' Disable idle process func
	ToolbarSet(0,"");

	' Tell stim app to shut down
	SampleKey("Q");
	Yield(.1);
	SampleStop();
	ProgKill(StimHandle%);
	ProgRun(bin$ + "\\ClearTrigger",0);

	' Increment daily totals and save then
	TotalTrials% += nTrialsStarted%;
	TotalRewards% += nTrialsCorrect%;
	SaveDailyTotals();

	' Save data file
'	View(DataWindow%);
'	if FileSave() <> 0 then
'		Message("WARNING! Data file not saved!!!");
'	endif

end;



