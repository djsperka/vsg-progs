' $Log: not supported by cvs2svn $
' Revision 1.1  2005/03/01 00:30:02  dan
' New version to use with new attention application.
'
'

var ContrastState[10000];	' 0 (1) means contrast goes down (up) for a trial
var RandomDelay[10000];		' Contrast change is delayed by a random amount (0 < delay < RandomFixationOffset)

' User-input timing vars
var AcquisitionTime:=0;
var FixationDuration:=0;
var InterTrialTime:=0;
var TimeToAnswer:=0;
var GratingDelay:=0;
var ContrastDelay:=0;
var AnswerPointDelay:=0;
var RandomFixationOffset := 0;	' Maximum delay time

' Rig-specific variables
var DegreesPerVoltX;	' Converts X eye coil volts to degrees
var DegreesPerVoltY;	' Converts Y eye coil volts to degrees
var DistanceToScreenMM$;	' Not used here, passed on to stimulus app
var EyeCoilSamplingFrequency%;


' Common parameters
var WindowRadius:=0;		' Fixation window radius (degrees)
var FixationX:=0;
var FixationY:=0;
var FixationPointDiameter:=1;
var FixationPointColor$;
var BackgroundColor$;
var JuicePerReward%:=0;

' Attention params
var NumberOfBlocks% := 1;	' Number of blocks to run. 1 block = 30 trials
var CatchTrialPercentage:=0;
var BaseContrast%:=50;
var ContrastUp%:=80;
var ContrastDown%:=20;
var AnswerWindow:=1;		' Answer point window (degrees)
var AnswerPointOffsetX:=0;	' Answer point X offset in degrees
var AnswerPointOffsetY:=5;	' Answer point Y offset in degrees

' Local file system variables. 
var bin$, script$;
bin$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2) + "..\\bin";	' Location of executables is ..\bin, relative to script dir
script$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2);	' folder containing this script

' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var TriggerChannel%;		' Channel for fixation point trigger
var StimHandle;			' handle for stimulus application
var DataWindow%;		' 
var XYWindow%;			' 
var XChannel%;
var YChannel%;

' Per-trial parameters
var AnswerX, AnswerY;		' Each trial, this is the center of the CORRECT answer point. 

'Create and display the Toolbar, not yet activating the IdleProcessing function


'Toolbar and IdleProcessing variables
View(App(8)).WindowVisible(0);	'Hide the standard sample bar
ToolbarVisible(1);
ToolbarSet(1,"Sample start",Start%);
ToolbarSet(2,"Sample stop", Stop%);
ToolbarSet(3,"Juice",Juice%);
ToolbarSet(4,"Pause stimuli",PauseStimuli%);
ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
ToolbarEnable(2,0);
ToolbarEnable(4,0);
ToolbarEnable(5,0);
Toolbar("Go",12345);



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
var CommandLine$;

'CommandLine$ :=bin$ + "\\NewAttention "+str$(FixationX)+" "+str$(FixationY)+" "+BackgroundColor$+" "
'					+str$(FixationPointDiameter)+" "+str$(BaseContrast)+" "+str$(ContrastUp)+" "+str$(ContrastDown)+" "
'					+str$(IncorrectBrightness)+" "
'					+GratingOrSpot$[GratingOrSpotIndex%]+" "+str$(TargetX)+" "+str$(TargetY)+" "+str$(TargetOrientation)+" "
'					+str$(TargetSF)+" "+str$(TargetTF)+" "+str$(TargetDiameter)+" "+str$(AnswerPointInitialBrightness)+" "
'					+str$(AnswerPointFullBrightness)+" "+GratingColorList$[GratingColorIndex];
'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
'PrintLog(CommandLine$+"\n");
'halt;
SampleStart(0); 'Start sampling
PrintLog(CommandLine$);
StimHandle := ProgRun(CommandLine$,1);
if StimHandle <0 then Message("Could not start stimulus."); halt; endif
Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.

ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
ToolbarEnable(2,1);
ToolbarEnable(1,0);
View(DataWindow%);
return 1;
end; 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
SampleKey("X");
Yield(.1);
SampleStop();
ProgKill(StimHandle);
ProgRun(bin$ + "\\ClearTrigger",0); 
Message("Press OK to end program");
end;
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Juice%()
SampleKey("J");
return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' The answer windows are located 'AnswerPointOffsetY' from the fixation point's location. 
' The direction of that offset is determined by ContrastChange[TrialNumber%] - if its +1 the 
' correct answer is above, if its -1 the correct answer is below. 

func Answer%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-AnswerY,2)) <= Pow(AnswerWindow,2) then return 1; endif
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY+AnswerY,2)) <= Pow(AnswerWindow,2) then return -1; endif
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc Reward()
	var i%;
	for i%:=1 to JuicePerReward% do Yield(.05); SampleKey("J"); next
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Determine two sets of random numbers to drive this expt. 
' RandomDelay[] is an array of numbers, 0 <= RandomDelay[i] <= RandomFixationOffset. 
' For each trial, this is a random delay added to each of the delay vars: GratingDelay, ContrastDelay, 
' AnswerPointDelay. 
' ContrastState[] is an array of numbers, each is either 1 or -1. Each number determines the contrast
' change, up for +1, down for -1, on a given trial. 
' The goofy loop ensures that each "block" of 30 trials is equally balanced between up and down contrast
' changes. 

func DetermineContrastChanges()
var BlockIndex%,Block[30],RandomBlock[30],RandomNumber;
var index;
ArrConst(Block[:15],-1);
ArrConst(Block[15:15],1);
ArrConst(RandomDelay[],0);


for index :=0 to (NumberOfBlocks% -1) do
	BlockIndex%:=0;
   ArrConst(RandomBlock[],0);
	while BlockIndex% < 30 do
		RandomNumber:=round(29*rand());
		if RandomBlock[RandomNumber] = 0 then 
			RandomBlock[RandomNumber] := Block[BlockIndex%];
			BlockIndex% := BlockIndex%+1;
		endif
	wend
	ArrConst(ContrastState[index*30:30],RandomBlock[]);
next

for index:=0 to (30*NumberOfBlocks% - 1) do
	if RandomFixationOffset > 0 then RandomDelay[index] := RandomFixationOffset*rand(); endif
next

return 1;
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var iState%:=0;		' present state
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tFixationDone:=-1;	' time that fixation duration was achieved. Used to measure time to answer

' Constants for states
const stateStartTrial%:=0;	' Start trial state
const stateWaitForFixPt%:=1;	' Waiting for fixation point return trigger
const stateAcquire%:=2;		' Waiting for subject to acquire fixation point
const stateHoldFixation%:=3;	' Holding fixation point
const stateBreakFixation%:=4;	' Waiting for subject to break fixation
const stateAbort%:=5;		' Failed trial state
const stateWaitForAnswer%:=6;	' Fixation held, now awaiting answer
const stateCorrectAnswer%:=7;	' Right answer received
const stateIncorrectAnswer%:=8;	' Wrong answer received
const stateWaitForBlank%:=9;
const stateInterTrialInterval%:=10;

var AnswerPointsUp% :=0;	' Set to 1 after answer point key "A" is issued
var StimulusUp% :=0;		' Set to 1 after grating key "S" is issued
var ContrastChange% := 0;	' Set to 1 after ContrastChange key "C"/"D" is issued

var TrialNumber% := -1;		' Tracks the trial number. Note that the first trial will be TrialNumber% := 0, 
				' so this can be used unaltered as an index into an array.
var countAbort% :=0;		' Number of trials aborted before any answer given
var countCorrect% := 0;		' Number of correct answers
var countIncorrect% := 0;	' Number of incorrect answers

func IdleProcessing%()

	tNow := MaxTime();

	xEye := ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
	yEye := ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastUpdate := tNow;
	endif


	docase 
		case iState% = stateStartTrial% then

			'StartTrial -- issue "F" to turn on fixation points. 
			' Enter state 1

			SampleKey("F");
			ChangeStateTo(stateWaitForFixPt%, tNow);
			PrintLog("State stateStartTrial - fixation trigger F sent. Entering state stateWaitForFixPt \n");

			' Initialize state loop vars
			AnswerPointsUp% :=0;
			StimulusUp% :=0;
			ContrastChange% := 0;
			tFixationDone := -1;

			' Increment trial counter. 
			TrialNumber% += 1;

		case iState% = stateWaitForFixPt% then
	
			' Waiting for fixation point return trigger from vsg. 
			' NextTime returns a non-negative value whenever there is a TRANSITION. In that case, the 
			' value of 'vTrigger' returned is 1 (0) if the transition is high (low) to low (high). Maybe not
			' intuitive, but that's the way it is. 
			tTrigger := NextTime(TriggerChannel%,tLast,vTrigger);
			if tTrigger > tLastTrigger then

				if vTrigger = 0 then
		
					' Stimulus has been presented. Display stim location and window. Enter stateAcquire
'					DrawStim(1);
					ChangeStateTo(stateAcquire%, tTrigger);
					tLastTrigger := tTrigger;

				endif

			endif

		case iState% = stateAcquire% then

			if tNow-tStateStart < AcquisitionTime then
				
				' Acquisition happens when the eye falls within the fixation window.
				if Looking%(xEye, yEye) = 1 then

					PrintLog("stateAcquire - acquired target. tNow=" + str$(tNow) + " Enter stateHoldFixation\n");
					ChangeStateTo(stateHoldFixation%, tNow);
	
				endif

			else

				' Failed. Turn off stim and try again.
				PrintLog("stateAcquire - acquisition failed. Enter stateAbort\n");
				ChangeStateTo(stateAbort%, tNow);

			endif

		case iState% = stateHoldFixation% then

			' keep looking at the dot...
			if Looking%(xEye, yEye) = 1 then

				' In this state, we check the time and turn on the stimulus, answer points, contrast change when
				' appropriate. Note that we do NOT check for the return triggers on these -- this is in keeping with
				' the original version of this paradigm. I will change this eventually, but not in this first
				' rewrite. 

				if (tNow - tStateStart >= AnswerPointDelay) and (AnswerPointsUp% = 0) then 
					SampleKey("A");
					AnswerPointsUp% := 1;
				endif

				if (tNow - tStateStart >= GratingDelay) and (StimulusUp% = 0) then
					SampleKey("S");
					StimulusUp% := 1;
				endif

				if (tNow - tStateStart >= ContrastDelay) and (ContrastChange% = 0) then
					if (rand() <= CatchTrialPercentage/100) then
						SampleKey("D");
					else
						SampleKey("C");
					endif
					ContrastChange% := 1;
					AnswerX := FixationX;
					AnswerY := FixationY + AnswerPointOffsetY * ContrastState[TrialNumber%];

				endif

				' This is the only condition that forces an exit! 
				' We use guard logic to ensure that the three changes above - contrast change, gratings up, answer points up, all 
				' have occurred before exiting this state! 
				' More logic should be employed to make certain that FixationDuration > AnswerPointDelay, ContrastDelay, GratingDelay! 

				if (tNow - tStateStart >= FixationDuration and AnswerPointsUp% = 1 and StimulusUp% = 1 and ContrastChange% = 1) then
					ChangeStateTo(stateBreakFixation%, tNow);
					tFixationDone := tNow;
				endif;

			else

				ChangeStateTo(stateAbort%, tNow);

			endif;

		case iState% = stateBreakFixation% then

			' In this state, we just wait for the subject to break fixation. After that happens, turn off the stimuli. 
			if Looking%(xEye, yEye) = 0 then
				SampleKey("s");
				ChangeStateTo(stateWaitForAnswer%, tNow);
			else 
				if (tNow - tFixationDone) > TimeToAnswer then
					ChangeStateTo(stateAbort%, tNow);
				endif
			endif

		case iState% = stateAbort% then

			' Issue X, count, wait for blank
			SampleKey("X");
			countAbort% += 1;
			ChangeStateTo(stateWaitForBlank%, tNow);

		case iState% = stateWaitForAnswer% then

			if (tNow - tFixationDone) > TimeToAnswer then
				ChangeStateTo(stateAbort%, tNow);
			else
				' Check if an answer is being given....
				var iAnswer%;
				iAnswer% := Answer%(xEye, yEye);
				if iAnswer% = 1 then
					' Right answer
					ChangeStateTo(stateCorrectAnswer%, tNow);
				else 
					if iAnswer% = -1 then
						' Wrong answer
						ChangeStateTo(stateIncorrectAnswer%, tNow);
					endif
				endif
			endif

		case iState% = stateCorrectAnswer% then

			SampleKey("X");
			countCorrect% += 1;
			Reward();
			ChangeStateTo(stateWaitForBlank%, tNow);

		case iState% = stateIncorrectAnswer% then

			SampleKey("X");
			countIncorrect% += 1;
			ChangeStateTo(stateWaitForBlank%, tNow);


		case iState% = stateWaitForBlank% then

			tTrigger := NextTime(TriggerChannel%,tLast,vTrigger);
			if tTrigger > tLastTrigger then

				if vTrigger = 1 then
		
					ChangeStateTo(stateInterTrialInterval%, tTrigger);
					tLastTrigger := tTrigger;

				endif

			endif

		case iState% = stateInterTrialInterval% then

			' Inter-trial wait time
			if tNow - tStateStart > InterTrialTime then
	
				' Back to state 0
				PrintLog("stateInterTrialInterval - IT wait is done. Start new trial.\n");
				iState% := stateStartTrial%;
				tStateStart := tNow;
	
			endif

		else 

			' Unknown state!
			Message("Unknown state=" + str$(iState%));
			halt;

	endcase;

	tLast := tNow;
	return 1;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	tStateStart := tStart;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetTodaysStats%();
'Profile("AlertRig\\"+Monkey$,"TotalRewards",0,TodaysRewards);
'Profile("AlertRig\\"+Monkey$,"TotalTrials",0,TodaysTrials);
'Profile("AlertRig\\"+Monkey$,"Date","",RecordedDate$);
'TodaysDate$ := Date$();
'if TodaysDate$ <> RecordedDate$ then 
'	Profile("AlertRig\\"+Monkey$,"TotalRewards",0);
'	TodaysRewards :=0;
'	Profile("AlertRig\\"+Monkey$,"TotalTrials",0);
'	TodaysTrials :=0;
'	Profile("AlertRig\\"+Monkey$,"Date",TodaysDate$);
'endif
return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetLastUsedParameters%();

'Read the Windows registry to determine last used values for the experiment parameters
'Since registry values are either integers are strings, we store decimals as strings and convert them to decimals
var NumberOfRewards$;
var WindowRadius$, FixationX$, FixationY$, FixationDuration$, AcquisitionTime$;
var BlankDuration$;
var FixationPointDiameter$;

Profile("AlertRig\\"+Monkey$,"WindowRadius","1",WindowRadius$);
Profile("AlertRig\\"+Monkey$,"FixationX","0",FixationX$);
Profile("AlertRig\\"+Monkey$,"FixationY","0",FixationY$);
Profile("AlertRig\\"+Monkey$,"FixationDuration","1",FixationDuration$);
Profile("AlertRig\\"+Monkey$,"AcquisitionTime","1",AcquisitionTime$);
Profile("AlertRig\\"+Monkey$,"BlankDuration","2",BlankDuration$);
Profile("AlertRig\\"+Monkey$,"NumberOfBlocks",300,NumberOfBlocks%);
Profile("AlertRig\\"+Monkey$,"BackgroundColor","Grey",BackgroundColor$);
Profile("AlertRig\\"+Monkey$,"FixationPointDIameter",".1",FixationPointDiameter$);
Profile("AlertRig\\"+Monkey$,"NumberOfRewards",1,NumberOfRewards%);

'Convert strings to decimenals
WindowRadius := val(WindowRadius$);
FixationX := val(FixationX$);
FixationY := val(FixationY$);
FixationDuration := val(FixationDuration$);
AcquisitionTime := val(AcquisitionTime$);
BlankDuration := val(BlankDuration$);
FixationPointDiameter := val(FixationPointDiameter$);

return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SetLastUsedParameters%();	'Updates the registry record of the last used experimental parameters

'Since registry values are either integers are strings, we convert decimals to strings

Profile("AlertRig\\"+Monkey$,"WindowRadius",str$(WindowRadius));
Profile("AlertRig\\"+Monkey$,"FixationX",str$(FixationX));
Profile("AlertRig\\"+Monkey$,"FixationY",str$(FixationY));
Profile("AlertRig\\"+Monkey$,"FixationDuration",str$(FixationDuration));
Profile("AlertRig\\"+Monkey$,"AcquisitionTime",str$(AcquisitionTime));
Profile("AlertRig\\"+Monkey$,"BlankDuration",str$(BlankDuration));
Profile("AlertRig\\"+Monkey$,"NumberOfBlocks",NumberOfBlocks%);
Profile("AlertRig\\"+Monkey$,"BackgroundColor",BackgroundColor$);
Profile("AlertRig\\"+Monkey$,"FixationPointDIameter",str$(FixationPointDiameter));
Profile("AlertRig\\"+Monkey$,"NumberOfRewards",NumberOfRewards%);

return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetLastUsedFixationParameters%();

'Read the Windows registry to determine last used values for the experiment parameters
'Since registry values are either integers are strings, we store decimals as strings and convert them to decimals

var ContrastDelay$, BaseContrast$,ContrastUp$,ContrastDown$,TimeToAnswer$,IncorrectBrightness$;
var GratingOrSpotValue$,TargetX$,TargetY$;
var GratingDelay$,AnswerPointDelay$,AnswerWindow$;
var AnswerPointInitialBrightness$,AnswerPointFullBrightness$;
var RandomFixationOffset$;
Profile("AlertRig\\"+Monkey$,"ContrastDelay","1",ContrastDelay$);
Profile("AlertRig\\"+Monkey$,"BaseContrast","50",BaseContrast$);
Profile("AlertRig\\"+Monkey$,"ContrastUp","75",ContrastUp$);
Profile("AlertRig\\"+Monkey$,"ContrastDown","25",ContrastDown$);
Profile("AlertRig\\"+Monkey$,"TimeToAnswer","1",TimeToAnswer$);
Profile("AlertRig\\"+Monkey$,"IncorrectBrightness","0",IncorrectBrightness$);
Profile("AlertRig\\"+Monkey$,"GratingOrSpot","Grating",GratingOrSpotValue$);
Profile("AlertRig\\"+Monkey$,"TargetX","3",TargetX$);
Profile("AlertRig\\"+Monkey$,"TargetY","0",TargetY$);
Profile("AlertRig\\"+Monkey$,"GratingDelay","1",GratingDelay$);
Profile("AlertRig\\"+Monkey$,"AnswerPointDelay","1",AnswerPointDelay$);
Profile("AlertRig\\"+Monkey$,"AnswerWindow","1",AnswerWindow$);
Profile("AlertRig\\"+Monkey$,"RandomFixationOffset","0",RandomFixationOffset$);
Profile("AlertRig\\"+Monkey$,"AnswerPointInitialBrightness","100",AnswerPointInitialBrightness$);
Profile("AlertRig\\"+Monkey$,"AnswerPointFullBrightness","1",AnswerPointFullBrightness$);

if GratingOrSpotValue$="Grating" then GratingOrSpotIndex%:=0; endif
if GratingOrSpotValue$="Spot" then GratingOrSpotIndex%:=1; endif


'Convert strings to decimenals
ContrastDelay := val(ContrastDelay$);
BaseContrast := val(BaseContrast$);
ContrastUp := val(ContrastUp$);
ContrastDown := val(ContrastDown$);
TimeToAnswer := val(TimeToAnswer$);
IncorrectBrightness := val(IncorrectBrightness$);
TargetX := val(TargetX$);
TargetY := val(TargetY$);
GratingDelay := val(GratingDelay$);
AnswerPointDelay := val(AnswerPointDelay$);
AnswerWindow := val(AnswerWindow$);
AnswerPointInitialBrightness := val(AnswerPointInitialBrightness$);
AnswerPointFullBrightness := val(AnswerPointFullBrightness$);
RandomFixationOffset := val(RandomFixationOffset$);
return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SetLastUsedFixationParameters%();

'Since registry values are either integers are strings, we convert decimals to strings

Profile("AlertRig\\"+Monkey$,"ContrastDelay",str$(ContrastDelay));
Profile("AlertRig\\"+Monkey$,"BaseContrast",str$(BaseContrast));
Profile("AlertRig\\"+Monkey$,"ContrastUp",str$(ContrastUp));
Profile("AlertRig\\"+Monkey$,"ContrastDown",str$(ContrastDown));
Profile("AlertRig\\"+Monkey$,"TimeToAnswer",str$(TimeToAnswer));
Profile("AlertRig\\"+Monkey$,"IncorrectBrightness",str$(IncorrectBrightness));
Profile("AlertRig\\"+Monkey$,"GratingOrSpot",GratingOrSpot$[GratingOrSpotIndex%]);
Profile("AlertRig\\"+Monkey$,"TargetX",str$(TargetX));
Profile("AlertRig\\"+Monkey$,"TargetY",str$(TargetY));
Profile("AlertRig\\"+Monkey$,"GratingDelay",str$(GratingDelay));
Profile("AlertRig\\"+Monkey$,"AnswerPointDelay",str$(AnswerPointDelay));
Profile("AlertRig\\"+Monkey$,"AnswerWindow",str$(AnswerWindow));
Profile("AlertRig\\"+Monkey$,"RandomFixationOffset",str$(RandomFixationOffset));
Profile("AlertRig\\"+Monkey$,"AnswerPointInitialBrightness",str$(AnswerPointInitialBrightness));
Profile("AlertRig\\"+Monkey$,"AnswerPointFullBrightness",str$(AnswerPointFullBrightness));


return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetLastUsedGratingParameters%();

'Read the Windows registry to determine last used values for the experiment parameters
'Since registry values are either integers are strings, we store decimals as strings and convert them to decimals

var TargetOrientation$, TargetSF$, TargetTF$, TargetDiameter$;
Profile("AlertRig\\"+Monkey$,"TargetOrientation","0",TargetOrientation$);
Profile("AlertRig\\"+Monkey$,"TargetSF","1",TargetSF$);
Profile("AlertRig\\"+Monkey$,"TargetTF","2",TargetTF$);
Profile("AlertRig\\"+Monkey$,"TargetDiameter","2",TargetDiameter$);

'Convert strings to decimenals
TargetOrientation := val(TargetOrientation$);
TargetSF := val(TargetSF$);
TargetTF := val(TargetTF$);
TargetDiameter := val(TargetDiameter$);


return 1;
end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func SetLastUsedGratingParameters%();
'Since registry values are either integers are strings, we convert decimals to strings

Profile("AlertRig\\"+Monkey$,"TargetOrientation",str$(TargetOrientation));
Profile("AlertRig\\"+Monkey$,"TargetSF",str$(TargetSF));
Profile("AlertRig\\"+Monkey$,"TargetTF",str$(TargetTF));
Profile("AlertRig\\"+Monkey$,"TargetDiameter",str$(TargetDiameter));

return 1;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ModifyDistractors()

	var dindex%,DistractorFile%;
	NumberOfDistractors% := Input("Display how many distractors?",5,0,5);
	DistractorFile% := FileOpen("c:\\AlertRig\\DistractorList",8,1);
	if DistractorFile% < 0 then Message("Could not create distractor file."); halt; endif
	if NumberOfDistractors% > 0 then
		var DistractorOrientation, DistractorSF, DistractorTF, DistractorDiameter, DistractorContrast,DistractorX,DistractorY;
		for dindex% := 1 to NumberOfDistractors% do 
			DlgCreate("Specify distractor "+str$(dindex%)+" properties");
			DlgReal(1,"Orienation: ",-360,360);
			DlgReal(2,"Spatial frequency: ",.01, 100);
			DlgReal(3,"Temporal frequency: ",0,100);
			DlgReal(4,"Diameter: (deg)",.1,10);
			DlgReal(5,"Contrast: (%)",0, 100);
			DlgReal(6,"X position: (deg)",-10,10);
			DlgReal(7,"Y position: (deg)",-10,10);
			DlgResponse := DlgShow(DistractorOrientation,DistractorSF,DistractorTF,DistractorDiameter,DistractorContrast,
											DistractorX,DistractorY);
			if DlgResponse < 0 then FileClose(DistractorFile%); halt; endif
			Print("%f %f %f %f %f %f %f\n",DistractorOrientation,DistractorSF,DistractorTF,DistractorDiameter,DistractorContrast,
					DistractorX,DistractorY);
		next
	endif
	if NumberOfDistractors% = 0 then Print("-1000"); endif
FileClose(DistractorFile%);

return 1;
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
var index;
SampleClear(); 'Set standard sampling state
SampleAutoFile(0); 'Enable automatic file naming
SampleAutoComment(0); 'Prompt for comment after sampling
SampleAutoCommit(60); 'Seconds between each file commit

'Channel recording definitions
SampleEvent(FixationPointChannel%,1,2,3600); 'Trigger channel, level
SampleComment$(FixationPointChannel%,"Fixation");
SampleTitle$(FixationPointChannel%,"Fixation");

SampleEvent(StimChannel%,2,2,3600); 'Trigger channel, level
SampleComment$(StimChannel%,"Stim");
SampleTitle$(StimChannel%,"Stim");

SampleEvent(AnswerPointChannel%,3,2,3600); 'Trigger channel, level
SampleComment$(AnswerPointChannel%,"Ans. Pt.");
SampleTitle$(AnswerPointChannel%,"Ans. Pt.");

SampleEvent(StimChangeChannel%,4,2,3600); 'Trigger channel, level
SampleComment$(StimChangeChannel%,"Stim Chg.");
SampleTitle$(StimChangeChannel%,"Stim Chg.");

SampleEvent(ConfounderChangeChannel%,5,2,3600); 'Trigger channel, level
SampleComment$(ConfounderChangeChannel%,"Catch trial");
SampleTitle$(ConfounderChangeChannel%,"Catch trial");

for index := 1 to NumberOfChannels% do
	SampleWaveMark(index,index-1,2000,34,15,28000); ' chan, port, event rate, points, pre-trigger, rate
	SampleTitle$(index,"Electrode_"+Str$(index)); 
next

SampleWaveform(XChannel%,14,1000);
SampleTitle$(XChannel%,"Eye X");
SampleWaveform(YChannel%,15,1000);
SampleTitle$(YChannel%,"Eye Y");

SampleSequencer(script$ + "Attention.pls");
SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
SampleMode(1); 'Continuous sampling
end;
