' $Id: Attention.s2s,v 1.37 2013-01-23 22:41:02 jeff Exp $
'
#include "../../Spike2Util/UsreyUtil.s2s"
#include "AttentionExtractFunctions.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' 	Attention script dialog START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'	Vars that control the Attention script. 

var attNumberOfBlocks%;
var attTrialsPerBlock%;
var attEasyTrialsPerBlock%;
var attCatchTrialPercentage;
var attBackgroundColor$;
var attBackgroundRed% := 0;
var attBackgroundGreen% := 0;
var attBackgroundBlue% := 0;
var attBackgroundFromRed% := 0;
var attBackgroundFromGreen% := 0;
var attBackgroundFromBlue% := 0;
var attBackgroundToRed% := 0;
var attBackgroundToGreen% := 0;
var attBackgroundToBlue% := 0;
var attAnswerPointDiameter := 0.05;
var attAnswerPointOffset := 5.0;
var attAnswerPointWindowRadius := 2.0;
var attContrastBase%;
var attMaxContChange;
var attMinContChange;
var attNContLevels%;
var attContrastList[20];        'max of 20 (10 up, 10 down) contrast levels
var attFixationTime;
'var attWhitePointTime;          ' xxxxx
var attFixationCueMinTime;      ' xxxxx
var attFixationCueMaxTime;      ' xxxxx
var attHazardMinTime;
var attHazardExpMeanTime;
var attHazardCutoffTime;
var attAcquisitionTime;
var attInterTrialTime;
var attTimeToAnswer;
var attAbortWaitTime;
var attBlockAlternate%;
var attNoBlockRand%;  'if 1, don't do blocked randomization
var attTrainingContrastCheck%:=0;
var attTrainingContrastPct%:=0;
var randBlockOrderVar%;     'this will be 0 or 1, and will determine whether we start attend-toward or attend-away
randBlockOrderVar% := round(rand()); 'just set it right now

var attCustomGratingColorCheck%;
var attCustomGratingColorStimFrom%[3];
var attCustomGratingColorStimTo%[3];
var attCustomGratingColorDistractorFrom%[3];
var attCustomGratingColorDistractorTo%[3];

var attLollipopCheck%;
var attCueLinePct;
var attCircleDiameterDiff;
var attLollipopContrast%;
var attLollipopStickContrast%;
var attCueLineGap;

' Counter vars for attention script
var attCountAllTrials% := 0;
var attCountAllTrialsCorrect% := 0;
var attCountAllTrialsIncorrect% := 0;
var attCountAllTrialsAbort% := 0;
var attCountTowardTrials% := 0;
var attCountTowardTrialsCorrect% := 0;
var attCountTowardTrialsIncorrect% := 0;
var attCountTowardTrialsAbort% := 0;
var attCountAwayTrials% := 0;
var attCountAwayTrialsCorrect% := 0;
var attCountAwayTrialsIncorrect% := 0;
var attCountAwayTrialsAbort% := 0;

' constants for dialog and check function - start with 10 because there are 9 dialog entries prior
' sure, it would be great if all the dialog numbers were done like this, but they ain't, and time is time
const attdlgTrainingContrastCheck% := 12;
const attdlgTrainingContrastPct% := 13;
const attdlgLollipopCheck% := 14;
const attdlgCueLinePct% := 15;
const attdlgCircleDiameterDiff% := 16;
const attdlgLollipopContrast% := 17;
const attdlgLollipopStickContrast% := 18;
const attdlgLollipopStickGap := 19;

' constants for timing dialog
const atttimingdlgFixationCueMinTime% := 2;
const atttimingdlgFixationCueMaxTime% := 3;
const atttimingdlgHazardMinTime% := 4;
const atttimingdlgHazardExpMeanTime% := 5;
const atttimingdlgHazardCutoffTime% := 6;

' constants for color dialog
var attdlgColorIndexGray% := 0;
var attdlgColorIndexBlack% := 1;
var attdlgColorIndexWhite% := 2;
var attdlgColorIndexCustom% := 3;
var attcolorsdlgBackgroundColor% := 1;
var attcolorsdlgBackgroundRed% := 2;
var attcolorsdlgBackgroundGreen% := 3;
var attcolorsdlgBackgroundBlue% := 4;
var attcolorsdlgCustomGratingColorCheck% := 5;
var attcolorsdlgCustomGratingColorStimFromRed% := 6;
var attcolorsdlgCustomGratingColorStimFromGreen% := 7;
var attcolorsdlgCustomGratingColorStimFromBlue% := 8;
var attcolorsdlgCustomGratingColorStimToRed% := 9;
var attcolorsdlgCustomGratingColorStimToGreen% := 10;
var attcolorsdlgCustomGratingColorStimToBlue% := 11;
var attcolorsdlgCustomGratingColorDistractorFromRed% := 12;
var attcolorsdlgCustomGratingColorDistractorFromGreen% := 13;
var attcolorsdlgCustomGratingColorDistractorFromBlue% := 14;
var attcolorsdlgCustomGratingColorDistractorToRed% := 15;
var attcolorsdlgCustomGratingColorDistractorToGreen% := 16;
var attcolorsdlgCustomGratingColorDistractorToBlue% := 17;

'variables for Henry's tuning curve version
const attMaxTrl% := 1000;
var attTrialOrder%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the test trials
var attCatchTrialOrder%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the catch trials
var attTrial[attMaxTrl%];       'this variable is really only here because GetRepeatedParameterProgression wants to fill it; we will ignore it
var attCurrTrialIndex%;         'We'll need to keep track of the current trial index
var attContrastList%[attMaxTrl%];  'A list of which contrast is being used on each trial, filled by CreateContrastList
var attUpDownList%[attMaxTrl%];    '1 if using increase in contrast, -1 if using decrease on each trial, filled by CreateContrastList
var attValidList%[attMaxTrl%];     '1 if valid, 0 if catch trial, filled by CreateContrastList
var thisContrast%;                 'for sampletexty stuff

proc GetAttentionScriptParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Attention";
    
	Profile(key$, "NumberOfBlocks", 1, attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", 1, attTrialsPerBlock%);
    Profile(key$, "EasyTrialsPerBlock", 1, attEasyTrialsPerBlock%);
	Profile(key$, "CatchTrialPercentage", "0.0", stmp$);
	attCatchTrialPercentage := val(stmp$);
	Profile(key$, "BlockAlternate", 1, attBlockAlternate%);
    Profile(key$, "NoBlockRand", 1, attNoBlockRand%);
	Profile(key$, "TrainingContrastCheck", 0, attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", 0, attTrainingContrastPct%);
	Profile(key$, "BackgroundColor", "gray", attBackgroundColor$);
    
    if InStr(attBackgroundColor$, "(") = 1 then
        if ParseColor%(attBackgroundColor$, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%) <> 0 then
            attBackgroundColor$ := "gray";
        endif
    endif
    
    Profile(key$, "ContrastBase", 50, attContrastBase%);
	'Profile(key$, "ContrastMax", 80, attMaxContChange);  ;now reals, have to do pull a string and convert
	'Profile(key$, "ContrastMin", 20, attMinContChange);
    Profile(key$, "NContrastLevels", 20, attNContLevels%);
    
    
    Profile(key$, "ContrastMax", "1", stmp$);
	attMaxContChange := val(stmp$);
    
    Profile(key$, "ContrastMin", "1", stmp$);
	attMinContChange := val(stmp$);
    
	Profile(key$, "AnswerPointDiameter", "0.5", stmp$);
	attAnswerPointDiameter := val(stmp$);
    
	Profile(key$, "AnswerPointOffset", "5.0", stmp$);
	attAnswerPointOffset := val(stmp$);
    
	Profile(key$, "AnswerPointWindowRadius", "2.0", stmp$);
	attAnswerPointWindowRadius := val(stmp$);
    
	Profile(key$, "FixationCueMinTime", "1.0", stmp$);
	attFixationCueMinTime := val(stmp$);
    
	Profile(key$, "FixationCueMaxTime", "1.0", stmp$);
	attFixationCueMaxTime := val(stmp$);
    
    '	Profile(key$, "WhitePointTime", "1.0", stmp$);
    '	attWhitePointTime := val(stmp$);
    
	Profile(key$, "HazardMinTime", "0.5", stmp$);
	attHazardMinTime := val(stmp$);
    
	Profile(key$, "HazardExpMeanTime", "1.0", stmp$);
	attHazardExpMeanTime := val(stmp$);
    
   	Profile(key$, "HazardCutoffTime", "5.0", stmp$);
	attHazardCutoffTime := val(stmp$);
    
	Profile(key$, "AcquisitionTime", "1.0", stmp$);
	attAcquisitionTime := val(stmp$);
    
	Profile(key$, "InterTrialTime", "1.0", stmp$);
	attInterTrialTime := val(stmp$);
    
	Profile(key$, "TimeToAnswer", "1.0", stmp$);
	attTimeToAnswer := val(stmp$);
    
	Profile(key$, "AbortWaitTime", "1.0", stmp$);
	attAbortWaitTime := val(stmp$);
    
    Profile(key$, "CustomGratingColorsCheck", 0, attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", 0, attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", 0, attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", 0, attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", 255, attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", 255, attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", 255, attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", 0, attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", 0, attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", 0, attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", 255, attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", 255, attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", 255, attCustomGratingColorDistractorTo%[2]);
    
	Profile(key$, "LollipopCheck", 0, attLollipopCheck%);
	Profile(key$, "CueLinePct", "100.0", stmp$);
    attCueLinePct := val(stmp$);
    Profile(key$, "CircleDiameterDiff", "0.1", stmp$);
    attCircleDiameterDiff := val(stmp$);
    Profile(key$, "LollipopContrast", 100, attLollipopContrast%);
    Profile(key$, "LollipopStickContrast", 100, attLollipopStickContrast%);
	Profile(key$, "CueLineGap", "0.5", stmp$);
    attCueLineGap := val(stmp$);
    
end;

proc SaveAttentionScriptParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Attention";
    
	Profile(key$, "NumberOfBlocks", attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", attTrialsPerBlock%);
    Profile(key$, "EasyTrialsPerBlock", attEasyTrialsPerBlock%);
	Profile(key$, "CatchTrialPercentage", str$(attCatchTrialPercentage));
	Profile(key$, "BlockAlternate", attBlockAlternate%);
    Profile(key$, "NoBlockRand", attNoBlockRand%);
	Profile(key$, "TrainingContrastCheck", attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", attTrainingContrastPct%);
	Profile(key$, "BackgroundColor", attBackgroundColor$);
	Profile(key$, "ContrastBase", attContrastBase%);
	Profile(key$, "ContrastMax", str$(attMaxContChange));
	Profile(key$, "ContrastMin", str$(attMinContChange));
    Profile(key$, "NContrastLevels", attNContLevels%);
	Profile(key$, "FixationCueMinTime", str$(attFixationCueMinTime));
	Profile(key$, "FixationCueMaxTime", str$(attFixationCueMaxTime));
    '	Profile(key$, "WhitePointTime", str$(attWhitePointTime));
	Profile(key$, "HazardMinTime", str$(attHazardMinTime));
	Profile(key$, "HazardExpMeanTime", str$(attHazardExpMeanTime));
    Profile(key$, "HazardCutoffTime", str$(attHazardCutoffTime));
	Profile(key$, "AcquisitionTime", str$(attAcquisitionTime));
	Profile(key$, "AbortWaitTime", str$(attAbortWaitTime));
	Profile(key$, "InterTrialTime", str$(attInterTrialTime));
	Profile(key$, "TimeToAnswer", str$(attTimeToAnswer));
	Profile(key$, "AnswerPointDiameter", str$(attAnswerPointDiameter));
	Profile(key$, "AnswerPointOffset", str$(attAnswerPointOffset));
	Profile(key$, "AnswerPointWindowRadius", str$(attAnswerPointWindowRadius));
    Profile(key$, "CustomGratingColorsCheck", attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", attCustomGratingColorDistractorTo%[2]);
    
	Profile(key$, "LollipopCheck", attLollipopCheck%);
	Profile(key$, "CueLinePct", str$(attCueLinePct));
    Profile(key$, "CircleDiameterDiff", str$(attCircleDiameterDiff));
    Profile(key$, "LollipopContrast", attLollipopContrast%);
    Profile(key$, "LollipopContrast", attLollipopContrast%);
    Profile(key$, "LollipopStickContrast", attLollipopStickContrast%);
	Profile(key$, "CueLineGap", str$(attCueLineGap));
    
end;

func AttentionScriptDialog%()
	var i%;
    var tempNBlocks%;
    var tempTotal;  'friggin integer math
	GetAttentionScriptParameters();
    
	DlgCreate("Attention Training Parameters", 25, 10);
    DlgGroup("Blocks, contrast", 1, 1, 34, 14);
	DlgInteger(1, "Number of Blocks:", 1, 1000, 22, 2);
	DlgInteger(2, "Reg. Trials per block:", 1, 1000, 22, 3);
    DlgInteger(3, "Easy Trials per block:", 1, 1000, 22, 4);
	DlgReal(4, "Catch Trial pct (0-100)", 0, 100, 22, 5);
	DlgCheck(5, "Alternate cue type by block", 2, 6);
    DlgCheck(6, "Do NOT randomize by block", 2,7);
    DlgInteger(7, "Base contrast (%)", 0, 100, 22, 8);
	DlgReal(8, "Max dContrast (oct)", 0, 10, 22, 9);
	DlgReal(9, "Min dContrast (oct)", 0, 10, 22, 10);
    DlgInteger(10, "N contrast levels", 1, 10, 22, 11);
    DlgReal(11, "Ans. window rad. (deg)", 0.01, 10, 22, 12);
	DlgCheck(attdlgTrainingContrastCheck%, "Training Contrast", 2, 13);
	DlgInteger(attdlgTrainingContrastPct%, "Training Contrast(%)", 0, 100, 22, 14);
    DlgButton(2, "Colors", ColorsDialog%, 1, 15);
    DlgButton(3, "Timing", TimingDialog%, 1, 16);
    DlgGroup("Lollipops", 1, 18, 34, 7);
    DlgCheck(attdlgLollipopCheck%, "Use lollipop cues", 2, 19);
    DlgReal(attdlgCueLinePct%, "Cue line %", 0, 100, 22, 20);
    DlgReal(attdlgCircleDiameterDiff%, "Circle diameter diff", 0, 10, 22, 21);
    DlgInteger(attdlgLollipopContrast%, "Lollipop contrast", 0, 100, 22, 22);
    DlgInteger(attdlgLollipopStickContrast%, "Stick contrast", 0, 100, 22, 23);
    DlgReal(attdlgLollipopStickGap, "Lollipop stick gap", 0, 10, 22, 24);
    DlgAllow(0, 0, AttentionScriptDialogChanged%);
	i%:=DlgShow(attNumberOfBlocks%, attTrialsPerBlock%, attEasyTrialsPerBlock%, attCatchTrialPercentage,
    attBlockAlternate%, attNoBlockRand%, attContrastBase%, attMaxContChange, attMinContChange, attNContLevels%,
    attAnswerPointWindowRadius, attTrainingContrastCheck%, attTrainingContrastPct%, 
    attLollipopCheck%, attCueLinePct, attCircleDiameterDiff, 
    attLollipopContrast%, attLollipopStickContrast%, attCueLineGap);
	if i% = 1 then
        '	attBackgroundColor$ := bcl$[ibcl%];
		SaveAttentionScriptParameters();
        
        'get contrast list
        if attNContLevels% > 1 then
            GetLogProgression(attContrastBase%*(pow(2,attMinContChange)),attContrastBase%*(pow(2,attMaxContChange)),attNContLevels%-1,attContrastList[0:attNContLevels%]);  'levels above base
            GetLogProgression(attContrastBase%/(pow(2,attMaxContChange)),attContrastBase%/(pow(2,attMinContChange)),attNContLevels%-1,attContrastList[attNContLevels%:attNContLevels%]);  'levels below base, in *ascending* order
            round(attContrastList[]);  'we can only use integer values in the VSG call
        else
            'if only one value is requested, this will crash GetLogProgression, so just do it manually
            attContrastList[0] := attContrastBase%*(pow(2,attMaxContChange));
            attContrastList[1] := attContrastBase%/(pow(2,attMaxContChange));
            message("Note that only one contrast level was requested, using MAX as actual value!");
        endif;
        
        'printlog("%f\n",attContrastList[]);
        
        'get number of trials to run, which is hypothetical "max" number for both test trials and catch trials regardless of catch/test percentage
        tempTotal := attNumberOfBlocks%*attTrialsPerBlock%;  'total number of non-"easy" trials
        tempNBlocks% := ceil(tempTotal/(attNContLevels%*2));  'total number of times we have to repeat the tuning curve to reach the total number of trials
        
        if attNoBlockRand% = 0 then
            'get trial order, attTrialOrder%[] will hold indices into attContrastList[] for all trials
            GetRepeatedParameterProgression%(attNContLevels%*2,tempNBlocks%,attTrial[],attTrialOrder%[],0,(attNContLevels%*2)-1,0,1);
        else 'Henry sez just do true random
            Rand(attTrialOrder%[0:attNContLevels%*2*tempNBlocks%],(attNContLevels%*2));
        endif;        

        'repeat for attCatchTrialOrder%[], we can even make it the same length, who cares that we can't get through them all
        GetRepeatedParameterProgression%(attNContLevels%*2,tempNBlocks%,attTrial[],attCatchTrialOrder%[],0,(attNContLevels%*2)-1,0,1);
        
        
        'Commented out - useful for testing the creation of the trial order
        'var Contrast$;
        'CreateContrastList(Contrast$,attContrastList%,attValidList%,attUpDownList%);
        'var specFileName$:="E:\\AttentionSpecFile.txt";
        'var specHandle%;
        'specHandle% := FileOpen(specFileName$, 8, 1);
        ''print to spec file
        'Print("%s",Contrast$);  'file should be everything starting from FixationArg$ on
        ''close spec file
        'FileClose(0);
        'printlog("Contrast list is %d\n",attContrastList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("Valid list is %d\n",attValidList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("UpDown list is %d\n",attUpDownList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("contrasts are %d\n",attContrastList[]);
        'halt();
	endif;
	return i%;
end;


func ParseColor%(s$, &r%, &g%, &b%)
    var status% := -1;
    var n;
    ReadSetup("", "/(", "(", ")");
    n := ReadStr(s$, r%, g%, b%);
    ReadSetup();
    if n = 3 then
        status% := 0;
    endif
    return status%;
end

func EncodeColor$(r%, g%, b%)
    var s$;
    s$ := Print$("(%d/%d/%d)", r%, g%, b%);
    return s$;
end


' Called when items in attention script dialog change. WARNING: The item #s are coded as constants
' If format of dialog changes then those constants should be changed. 

func AttentionScriptDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = attdlgTrainingContrastCheck% then
        DlgEnable(DlgValue(attdlgTrainingContrastCheck%), attdlgTrainingContrastPct%);
    case item% = attdlgLollipopCheck% then
        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgCircleDiameterDiff%);
        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgCueLinePct%);
        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgLollipopContrast%);
    case item% = 0 then
        DlgEnable(attTrainingContrastCheck%, attdlgTrainingContrastPct%);
        DlgEnable(attLollipopCheck%, attdlgCircleDiameterDiff%);
        DlgEnable(attLollipopCheck%, attdlgCueLinePct%);
        DlgEnable(attLollipopCheck%, attdlgLollipopContrast%);
    endcase
    return status%;
end


func TimingDialog%()
    var i%;
    
	DlgCreate("Attention timing", 25, 10);
	DlgReal(1, "Acquisition time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMinTime%, "Fixation cue min time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMaxTime%, "Fixation cue max time(s):", .01, 10);
	DlgReal(atttimingdlgHazardMinTime%, "Hazard min time(s):", 0, 10);
	DlgReal(atttimingdlgHazardExpMeanTime%, "Hazard exp mean time(s):", 0, 10);
	DlgReal(atttimingdlgHazardCutoffTime%, "Hazard cutoff time(s):", 0, 10);
	DlgReal(7, "Time to answer(s):", 0.01, 10.0);
	DlgReal(8, "Intertrial time(s):", .01, 10);
	DlgReal(9, "Abort wait time(s):", .01, 10);
    
    DlgAllow(0, 0, TimingDialogChanged%);
	i%:=DlgShow(attAcquisitionTime, attFixationCueMinTime, attFixationCueMaxTime, 
    attHazardMinTime, attHazardExpMeanTime, attHazardCutoffTime, attTimeToAnswer, 
    attInterTrialTime, attAbortWaitTime);
    return 1;
end


func TimingDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = atttimingdlgFixationCueMinTime% or item% = atttimingdlgFixationCueMaxTime% then
        ' max >= min
        if DlgValue(atttimingdlgFixationCueMinTime%) > DlgValue(atttimingdlgFixationCueMaxTime%) then
            status% := 0;
            Message("Fixation cue min time cannot be greater than max time!");
        endif
    case item% = atttimingdlgHazardMinTime% or item% = atttimingdlgHazardExpMeanTime% or item% = atttimingdlgHazardCutoffTime% then
        ' max >= min
        if DlgValue(atttimingdlgHazardMinTime%) > DlgValue(atttimingdlgHazardExpMeanTime%)  or DlgValue(atttimingdlgHazardExpMeanTime%) > DlgValue(atttimingdlgHazardCutoffTime%) then
            status% := 0;
            Message("Hazard min time <= Hazard mean time <= Hazard cutoff time");
        endif
    endcase
    return status%;
end


func ColorsDialog%()
	var i%;
	var bcl$[4];
	var ibcl%:=0;
	GetAttentionScriptParameters();
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
    bcl$[3] := "custom";
    if InStr(attBackgroundColor$, "(") = 1 then
        ibcl% := attdlgColorIndexCustom%;
    else
        ibcl% := 2;
        for i%:=0 to 2 do
            if attBackgroundColor$ = bcl$[i%] then
                ibcl% := i%;
            endif
        next;
    endif
    
	DlgCreate("Attention colors", 25, 10);
    DlgAllow(0, 0, ColorsDialogChanged%);
	DlgList(1, "Background color:", bcl$);
    DlgInteger(2, "Background red (0-255)", 0, 255);
    DlgInteger(3, "Background green (0-255)", 0, 255);
    DlgInteger(4, "Background blue (0-255)", 0, 255);
    DlgCheck(attcolorsdlgCustomGratingColorCheck%, "Custom grating colors");
    DlgGroup("Stimulus", 1, 6, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromRed%, "From Red (0-255)", 0, 255, 20, 7);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromGreen%, "From Green (0-255)", 0, 255, 20, 8);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromBlue%, "From Blue (0-255)", 0, 255, 20, 9);
    DlgInteger(attcolorsdlgCustomGratingColorStimToRed%, "To Red (0-255)", 0, 255, 20, 10);
    DlgInteger(attcolorsdlgCustomGratingColorStimToGreen%, "To Green (0-255)", 0, 255, 20, 11);
    DlgInteger(attcolorsdlgCustomGratingColorStimToBlue%, "To Blue (0-255)", 0, 255, 20, 12);
    DlgGroup("Distractor", 1, 13, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromRed%, "From Red (0-255)", 0, 255, 20, 14);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromGreen%, "From Green (0-255)", 0, 255, 20, 15);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromBlue%, "From Blue (0-255)", 0, 255, 20, 16);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToRed%, "To Red (0-255)", 0, 255, 20, 17);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToGreen%, "To Green (0-255)", 0, 255, 20, 18);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToBlue%, "To Blue (0-255)", 0, 255, 20, 19);
	i% := DlgShow(ibcl%, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%, 
    attCustomGratingColorCheck%, 
    attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2], 
    attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2], 
    attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2], 
    attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);
    
	' If user cancelled, reload params
	if i% = 1 then
        if ibcl% = attdlgColorIndexCustom% then
            attBackgroundColor$ := EncodeColor$(attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%);
        else
            attBackgroundColor$ := bcl$[ibcl%];
        endif
	endif
    
	return 1;
end;

func ColorsDialogChanged%(item%)
    var status% := 1;
    if item% = 0 or item% = attcolorsdlgBackgroundColor% then
        if DlgValue(attcolorsdlgBackgroundColor%) = 3 then
            DlgEnable(1, attcolorsdlgBackgroundRed%);
            DlgEnable(1, attcolorsdlgBackgroundGreen%);
            DlgEnable(1, attcolorsdlgBackgroundBlue%);
        else
            DlgEnable(0, attcolorsdlgBackgroundRed%);
            DlgEnable(0, attcolorsdlgBackgroundGreen%);
            DlgEnable(0, attcolorsdlgBackgroundBlue%);
        endif
    endif
    
    if item% = 0 or item% = attcolorsdlgCustomGratingColorCheck% then
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToBlue%);
    endif
    
    return status%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Attention script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''






' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameTriggerChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;

' tuning curves
var TuningWindow%[8];	' one for each channel. There'd better not be more than 8 channels! 
' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iAnswerWindowChannel1%;  'channel number for answer window display in xy window
var iAnswerWindowChannel2%;  'etc.

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Check for valid data file path
if Len(dataDataSet$) = 0 then
	Message("No data set is selected! Edit Data parameters...");
	' Might be nice to open the dialog here....
	halt;
endif



' run parameters script....
GetAttentionScriptParameters();
iScript% := AttentionScriptDialog%();
if iScript% = 1 then
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    SampleAutoName$(dataCellName$ + "_atn_000");
    SampleAutoFile(1);
else
	PrintLog("User cancel - exit gracefully\n");
	Halt;
endif;





' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 21;
YChannel% := 22;
FrameTriggerChannel% := 23;
FixationPointChannel% := 24;
StimChannel% := 25;
StimChangeChannel% := 26;
ReadyChannel% := 27;
CreateSampleConfiguration();


' Initialize extraction
'AttentionExtractInit%(-1, "");

' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' UpdateToolbarText - Print tallies of trials in toolbar
'

proc UpdateToolbarText()
    
	var s$;
	var allpct$ := "--";
	var towpct$ := "--";
    var awapct$ := "--";
    var num, den, pct;
    
    if (attCountAllTrials% > 0) then
        num := attCountAllTrialsCorrect%;
        den := attCountAllTrials%;
        pct := num/den*100;
		allpct$ := print$("%2.0f", pct);
	endif
	if (attCountTowardTrials% > 0) then
        num := attCountTowardTrialsCorrect%;
        den := attCountTowardTrials%;
        pct := num/den*100;
		towpct$ := print$("%2.0f", pct);
	endif
	if (attCountAwayTrials% > 0) then
        num := attCountAwayTrialsCorrect%;
        den := attCountAwayTrials%;
        pct := num/den*100;
		awapct$ := print$("%2.0f", pct);
	endif
	s$ := Print$("Tallies count/correct/incorrect/aborted (correct%%): ALL %d/%d/%d/%d (%s%%) TOWARD %d/%d/%d/%d (%s%%) AWAY %d/%d/%d/%d (%s%%)", 
    attCountAllTrials%, attCountAllTrialsCorrect%, attCountAllTrialsIncorrect%, attCountAllTrialsAbort%, allpct$,
    attCountTowardTrials%, attCountTowardTrialsCorrect%, attCountTowardTrialsIncorrect%, attCountTowardTrialsAbort%, towpct$,
    attCountAwayTrials%, attCountAwayTrialsCorrect%, attCountAwayTrialsIncorrect%, attCountAwayTrialsAbort%, awapct$);
    
	ToolbarText(s$);
    
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	UpdateToolbarText();
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    '	ToolbarSet(6,"Exp Parameters",%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);
    
end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Answer%(EyePosX, EyePosY)
    var ans% := 0;
    var ansptRadius;
    ansptRadius := Pow(attAnswerPointWindowRadius,2);
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-(FixationY+attAnswerPointOffset),2)) <= ansptRadius then ans% := 1; endif
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-(FixationY-attAnswerPointOffset),2)) <= ansptRadius then ans% := -1; endif
	return ans%;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
    DefaultReward();
    'No sample text, just use 'R' from keyboard channel
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 

' Constants for states
const stateStartTrial%:=0;		        ' Start trial state
const stateWaitForWhitePointOn%:=20;    ' Waiting for fixation white point
const stateWhitePointFixation%:=21;     ' white point up, remain fixation
const stateWaitForFixPtOn%:=1;		    ' Waiting for fixation/cue point return trigger (on)
const stateHoldFixationToStimOn%:=2;		    ' Maintaining fixation with cue color point and lollipops up
const stateWaitForStimOn%:=3;		    ' Wait for stimulus return trigger (on)
const stateWaitForContrastChange%:=4;	' Wait for indication that contrast change has happened
const stateWaitForAcquisition%:=5;	    ' Waiting for subject to acquire fixation point
const stateHoldFixationToCC%:=6;		    ' Holding fixation point
const stateAbort%:=7;			        ' Failed trial state
const stateWaitForAnswer%:=8;			' waiting for answer
const stateAbortWait%:=9;	            ' time out after failed trial
const stateVSGWait%:=10;		        ' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		    ' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		    ' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForBlank%:=14;
const stateBlockCompleted%:=16;
const stateStartBlock%:=17;
const stateTrialCompletedWaitForBlank% := 18;
const stateTrialCompletedPause% := 19;
const stateNoResponse% := 20;
var iState% := stateVSGWait%;	' present state

const trialtypeAttendToward% := 100;
const trialtypeAttendAway% := 101;
var trialType%;
var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 
var nBlocksCompleted%:=0;
var iAnswer%;
var isStimDistractorOff% := 0;
var trialCatch%;
var trialContrastUpDown%;
var trialHazardFunctionTime;

func IdleProcessing%()
    'var getPreciseTiming := 1;
	var iStatus% := 1;	
    
    'while getPreciseTiming = 1 do 
    
    'getPreciseTiming := 0;  'don't get precise timing unless we ask to (if 0, return control to windows after each idle loop iteration)
    
    tNow := MaxTime();
    
    xEye := ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
    yEye := ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;
    
    ' Don't update display every time....
    if tNow-tLastUpdate > .005 then
        View(XYWindow%).XYAddData(1,xEye,yEye);
        tLastUpdate := tNow;
    endif
    
    
    docase 
    case iState% = stateVSGWait% then
        
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        tTrigger := NextTime(ReadyChannel%, tLast, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 0 then
            PrintLog("state stateVSGWait: Got leading edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateVSGWaitConfirm%, tTrigger);
        endif;
        
    case iState% = stateVSGWaitConfirm% then
        
        ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
        tTrigger := NextTime(ReadyChannel%, tLastTrigger, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 1 then
            PrintLog("state stateVSGWaitConfirm: Got trailing edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateStartBlock%, tTrigger);
        endif;
        
        
    case iState% = stateStartBlock% then
        
        PrepareBlock();
        ChangeStateTo(stateStartTrial%, tNow);
        
    case iState% = stateStartTrial% then
        
        ' Start trial. Put up fixation point.
        UpdateToolbarText();
        PrepareTrial();
        attCountAllTrials% += 1;
        'SafeSampleKey("W");
        docase
        case trialType% = trialtypeAttendToward% then
            'PrintLog("stateWhitePointFixation: Request cue F - AttendToward\n");
            PrintLog("Request cue F - AttendToward\n");
            SafeSampleKey("F");
            attCountTowardTrials% += 1;
        case trialType% = trialtypeAttendAway% then
            'PrintLog("stateWhitePointFixation: Request cue G - AttendAway\n");
            PrintLog("Request cue G - AttendAway\n");
            SafeSampleKey("G");
            attCountAwayTrials% += 1;
        else
            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
        endcase
        ChangeStateTo(stateWaitForFixPtOn%, tNow);
        
        
    case iState% = stateWaitForFixPtOn% then
        tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        if tTrigger > tLast then
            ' Fixation point is up
            PrintLog("stateWaitForFixPtOn: signal received. " + str$(tTrigger) + "\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateWaitForAcquisition%, tTrigger);
            if trialType% = trialtypeAttendToward% then
                SampleText("Fixation point on, Attend Toward",tTrigger);
            else
                SampleText("Fixation point on, Attend Away",tTrigger);
            endif;
            DrawStim(1);	' actually this draws the location of the fixpt.
        endif
        
        
    case iState% = stateWaitForAcquisition% then
        'getPreciseTiming := 1;
        ' Waiting for eye to fall inside of fixation window
        if Looking%(xEye, yEye) = 1 then
            PrintLog("stateWaitForAcquisition: eye in fixation window.\n");
            'ChangeStateTo(stateWhitePointFixation%, tNow);
            ChangeStateTo(stateHoldFixationToStimOn%, tNow);
            SampleText("Fixation Acquired",tNow);
            'getPreciseTiming := 0;
        else 
            if tNow - tStateStart > attAcquisitionTime then
                PrintLog("stateWaitForAcquisition: failed.\n");
                ChangeStateTo(stateAbort%, tNow);
                'getPreciseTiming := 0;
            endif
        endif
        
        
    case iState% = stateHoldFixationToStimOn% then
        
        ' Eye must remain inside of fixation window
        if Looking%(xEye, yEye) = 1 then
            if tNow - tStateStart > attFixationTime then
                PrintLog("stateHoldFixationToStimOn: Success. Gratings up...\n");
                SafeSampleKey("S");
                ChangeStateTo(stateWaitForStimOn%, tNow);
            endif
        else 
            PrintLog("stateHoldFixationToStimOn: failed.\n");
            ChangeStateTo(stateAbort%, tNow);
        endif
        
    case iState% = stateWaitForStimOn% then
        tTrigger := NextTime(StimChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        if tTrigger > tLast and vTrigger = 0 then
            ' gratings et al are up
            PrintLog("stateWaitForStimOn: stim is up.\n");
            tStimOn := tTrigger;
            tLastTrigger := tTrigger;
            ChangeStateTo(stateHoldFixationToCC%, tTrigger);
            SampleText("Stimulus on, Base contrast " + Str$(attContrastBase%) + ", hazard dur " + Str$(trialHazardFunctionTime),tTrigger);
        endif
        
        
    case iState% = stateAbort% then
        
        ' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
        ' fixpt off. 
        PrintLog("stateAbort: send X key.\n");
        SafeSampleKey("X");
        
        view(XYWindow%).XYColour(iAnswerWindowChannel1%,13);  'Force up answer window to blue
        view(XYWindow%).XYColour(iAnswerWindowChannel2%,13);  'Force down answer window to blue
        
        ' tally up aborted trials
        attCountAllTrialsAbort% += 1;
        docase
        case trialType% = trialtypeAttendToward% then
            attCountTowardTrialsAbort% += 1;
        case trialType% = trialtypeAttendAway% then
            attCountAwayTrialsAbort% += 1;
        else 
            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
        endcase
        
        ' move on
        ChangeStateTo(stateWaitForBlank%, tNow);
        
    case iState% = stateWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        'if tTrigger > tLast and vTrigger = 1 then
        if tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateAbortWait%, tTrigger);
            DrawStim(0);	' actually this draws the location of the fixpt.
        endif
        
    case iState% = stateAbortWait% then
        
        if tNow - tStateStart > attAbortWaitTime then
            
            PrintLog("stateAbortWait: time out is done.\n");
            ChangeStateTo(stateStartTrial%, tNow);
            
        endif
        
    case iState% = stateHoldFixationToCC% then
        
        if Looking%(xEye, yEye) = 0 then
            
            PrintLog("stateHoldFixationToCC: outside fixation window, aborting trial.\n");
            ChangeStateTo(stateAbort%, tNow);
            SampleText("Fixation broken, trial aborted");
            
        else 
            
            if (tNow - tStateStart) > (trialHazardFunctionTime) then
                
                ' turn off stimulus and advance it
                PrintLog("stateHoldFixationToCC: request contrast change\n");
                docase
                case trialType% = trialtypeAttendToward% then
                    if trialContrastUpDown% > 0 then
                        if trialCatch% = 0 then
                            SafeSampleKey("C");
                        else
                            SafeSampleKey("D");
                        endif
                    else
                        if trialCatch% = 0 then
                            SafeSampleKey("c");
                        else
                            SafeSampleKey("d");
                        endif
                    endif
                case trialType% = trialtypeAttendAway% then
                    if trialContrastUpDown% > 0 then
                        if trialCatch% = 0 then
                            SafeSampleKey("D");
                        else
                            SafeSampleKey("C");
                        endif
                    else
                        if trialCatch% = 0 then
                            SafeSampleKey("d");
                        else
                            SafeSampleKey("c");
                        endif
                    endif
                else
                    PrintLog("ERROR! Unknown blocktype!!!\n");
                endcase;
                
                
                ' Now wait until contrast change trigger is received
                ChangeStateTo(stateWaitForContrastChange%, tNow);
                
            endif
            
        endif
        
    case iState% = stateWaitForContrastChange% then
        tTrigger := NextTime(StimChangeChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        if tTrigger > tLast and vTrigger = 0 then
            PrintLog("stateWaitForContrastChange: got it.\n");
            tLastTrigger := tTrigger;
            isStimDistractorOff% := 0;
            ChangeStateTo(stateWaitForAnswer%, tNow);
            docase
            case trialType% = trialtypeAttendToward% then
                if trialContrastUpDown% > 0 then
                    view(XYWindow%).XYColour(iAnswerWindowChannel1%,16);  'Change up answer window to red
                    if trialCatch% = 0 then
                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Toward",tTrigger);
                    else
                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Toward (catch)",tTrigger);
                    endif
                else
                    view(XYWindow%).XYColour(iAnswerWindowChannel2%,16);  'Change down answer window to red
                    if trialCatch% = 0 then
                        Sampletext("Contrast Change Down, Level " + Str$(thisContrast%) + ", Attend Toward",tTrigger);
                    else
                        Sampletext("Contrast Change Down, Level " + Str$(thisContrast%) + ", Attend Toward (catch)",tTrigger);
                    endif
                endif
            case trialType% = trialtypeAttendAway% then
                if trialContrastUpDown% > 0 then
                    view(XYWindow%).XYColour(iAnswerWindowChannel1%,16);  'Change up answer window to red
                    if trialCatch% = 0 then
                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Away",tTrigger);
                    else
                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Away (catch)",tTrigger);
                    endif
                else
                    view(XYWindow%).XYColour(iAnswerWindowChannel2%,16);  'Change down answer window to red
                    if trialCatch% = 0 then
                        Sampletext("Contrast Change Down, Level " + Str$(thisContrast%) + ", Attend Away",tTrigger);
                    else
                        Sampletext("Contrast Change Down, Level " + Str$(thisContrast%) + ", Attend Away (catch)",tTrigger);
                    endif
                endif
            else
                PrintLog("ERROR! Unknown blocktype!!!\n");
            endcase;
        else    
            if Looking%(xEye, yEye) = 0 then
                PrintLog("stateWaitForContrastChange: outside fixation window before contrast change, aborting trial.\n");
                ChangeStateTo(stateAbort%, tNow);
                SampleText("Fixation broken, trial aborted"); 
            endif;            
        endif;
        
    case iState% = stateWaitForAnswer% then
        'getPreciseTiming := 1;  'we need precise timing here, stay in while loop until we get eye movements we expect
        if tNow - tStateStart > attTimeToAnswer then
            SafeSampleKey("X");  'turn off animation
            PrintLog("stateWaitForAnswer: timed out\n");
            ChangeStateTo(stateNoResponse%, tNow);
        else
            ' When fixation is first broken we turn off the stim and distractor. 
            ' That test is done separately from the test for an answer. Also set up 
            ' a var to tell us whether the stim has been turned off. 
            if isStimDistractorOff% = 0 then
                if Looking%(xEye, yEye) = 0 then
                    SafeSampleKey("s");
                    SampleText("Fixation broken during response window",tNow);
                    PrintLog("stateWaitForAnswer: fix broken - turn off stim\n");
                    isStimDistractorOff% := 1;
                endif
            endif
            
            iAnswer% := Answer%(xEye, yEye);
            if iAnswer% = 1 or iAnswer% = -1 then
                ' Got an answer. Record marker for correct/incorrect answer
                if iAnswer% = trialContrastUpDown% then
                    ' Correct answer
                    attCountAllTrialsCorrect% += 1;
                    'SampleText("+");
                    docase
                    case trialType% = trialtypeAttendToward% and trialContrastUpDown% = 1 then
                        attCountTowardTrialsCorrect% += 1;
                        SampleText("Correct, Attend Toward, Contrast Up",tNow);
                    case trialType% = trialtypeAttendAway% and trialContrastUpDown% = 1 then
                        attCountAwayTrialsCorrect% += 1;
                        SampleText("Correct, Attend Away, Contrast Up",tNow);
                    case trialType% = trialtypeAttendToward% and trialContrastUpDown% = -1 then
                        attCountTowardTrialsCorrect% += 1;
                        SampleText("Correct, Attend Toward, Contrast Down",tNow);
                    case trialType% = trialtypeAttendAway% and trialContrastUpDown% = -1 then
                        attCountAwayTrialsCorrect% += 1;
                        SampleText("Correct, Attend Away, Contrast Down",tNow);
                    else
                        PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                    endcase
                    'getPreciseTiming := 0;
                    Reward%();
                else
                    'SampleText("-");
                    attCountAllTrialsIncorrect% += 1;
                    docase
                    case trialType% = trialtypeAttendToward% and trialContrastUpDown% = 1 then
                        attCountTowardTrialsIncorrect% += 1;
                        SampleText("Incorrect, Attend Toward, Contrast Up",tNow);
                    case trialType% = trialtypeAttendAway% and trialContrastUpDown% = 1 then
                        attCountAwayTrialsIncorrect% += 1;
                        SampleText("Incorrect, Attend Away, Contrast Up",tNow);
                    case trialType% = trialtypeAttendToward% and trialContrastUpDown% = -1 then
                        attCountTowardTrialsIncorrect% += 1;
                        SampleText("Incorrect, Attend Toward, Contrast Down",tNow);
                    case trialType% = trialtypeAttendAway% and trialContrastUpDown% = -1 then
                        attCountAwayTrialsIncorrect% += 1;
                        SampleText("Incorrect, Attend Away, Contrast Down",tNow);
                    else
                        PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                    endcase
                    'getPreciseTiming := 0;
                    Yield(.01);    ' necessary so that the SampleText and SafeSampleKey below don't land on the same time (makes extraction difficult)
                endif
                
                SafeSampleKey("X");
                ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
            endif
        endif
        
    case iState% = stateTrialCompletedWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        'if tTrigger > tLast and vTrigger = 1 then
        if tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateTrialCompleteWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            'advance
            SafeSampleKey("a");
            ChangeStateTo(stateTrialCompletedPause%, tTrigger);
            DrawStim(0);	' actually this draws the location of the fixpt.
        endif
        
    case iState% = stateNoResponse% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        'if tTrigger > tLast and vTrigger = 1 then
        if tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateTrialNoResponse: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            'advance
            SafeSampleKey("a");
            ChangeStateTo(stateTrialCompletedPause%, tTrigger);
            DrawStim(0);	' actually this draws the location of the fixpt.
        endif        
        
    case iState% = stateTrialCompletedPause% then
        
        if tNow - tStateStart > attInterTrialTime then
            
            PrintLog("stateTrialCompletedPause: time out is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
            
        endif
        
        
        
    case iState% = stateTrialCompleted% then
        view(XYWindow%).XYColour(iAnswerWindowChannel1%,13);  'Force up answer window to blue
        view(XYWindow%).XYColour(iAnswerWindowChannel2%,13);  'Force down answer window to blue
        PrintLog("Trial completed.\n");
        nTrialsCompleted% += 1;
        attCurrTrialIndex% += 1;
        if nTrialsCompleted% = attTrialsPerBlock%+attEasyTrialsPerBlock% then
            ChangeStateTo(stateBlockCompleted%, tNow);
        else
            ChangeStateTo(stateStartTrial%, tNow);
        endif
        
    case iState% = stateBlockCompleted% then
        
        PrintLog("Block completed.\n");
        nBlocksCompleted% := nBlocksCompleted% + 1;
        if nBlocksCompleted% = attNumberOfBlocks% then
            ChangeStateTo(stateDone%, tNow);
            Stop%();
            iStatus% := 0;
        else
            ChangeStateTo(stateStartBlock%, tNow);
        endif
        
    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;
        
    endcase;
    
    tLast := tNow;
    'wend;
    
	return iStatus%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareTrial()
    
	PrintLog("Prepare trial: ");
    
	if attBlockAlternate% = 0 then
		if (Rand() < 0.5) then
			trialType% := trialtypeAttendToward%;
			PrintLog("Trial type: attend-toward\n");
		else
			trialType% := trialtypeAttendAway%;
			PrintLog("Trial type: attend-away\n");
		endif
	else
		if trialType% = trialtypeAttendToward% then
			PrintLog("Trial type: attend-toward (for this entire block)\n");
		else
			PrintLog("Trial type: attend-away (for this entire block)\n");
		endif
	endif
    
    ' Fixation time consists of "white point time" + "fixation time". Fixation time is a random number between 
    ' attFixationMinTime and attFixationMaxTime. 
    attFixationTime := Rand(attFixationCueMaxTime - attFixationCueMinTime, attFixationCueMinTime);
    PrintLog("Fixation time " + str$(attFixationTime) + "\n");
	
    if nTrialsCompleted% < attEasyTrialsPerBlock% then  'it's an "easy" trial, give minimum hazard time
        
        'Set hazard time to minimum on "easy" trials
        trialHazardFunctionTime := attHazardMinTime;
        
    else  'do a regular trial, get random hazard time

        ' hazard function - compute time from fixation to contrast change. Make sure hazard time is not greater than cutoff time.
        trialHazardFunctionTime := RandExp(attHazardExpMeanTime, attHazardMinTime);
        if trialHazardFunctionTime > attHazardCutoffTime then
            trialHazardFunctionTime := attHazardCutoffTime;
        endif

    endif;
    
    'Determine if trial is catch trial
    trialCatch% := 1-attValidList%[attCurrTrialIndex%];
    if trialCatch% = 1 then
        PrintLog("CATCH\n");
    endif;
    
    'Determine if contrast is up or down
    trialContrastUpDown% := attUpDownList%[attCurrTrialIndex%];
    
    'Record actual contrast level on this trial
    thisContrast% := attContrastList%[attCurrTrialIndex%];
    
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareBlock()
	PrintLog("Preparing block: ");
	' when blocksCompleted% is even, this is attend-toward
	' Modified: The above is done only when attBlockAlternate% is non zero. Otherwise its random trial-by-trial 
	' cue type. 
	if attBlockAlternate% <>0 then
		if ((nBlocksCompleted%+randBlockOrderVar%) mod 2) = 0 then
			trialType% := trialtypeAttendToward%;
			PrintLog("Attend-toward ");
		else
			trialType% := trialtypeAttendAway%;
			PrintLog("Attend-away ");
		endif
	else
		PrintLog("Attend-toward/away done on a trial-by-trial basis.");
	endif
	PrintLog("\n");
    'reset block-specific variables
	ntrialsCompleted% := 0;
	nTrialsStarted% := 0;
	nTrialsAborted% :=0;		' 
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
    Pause% :=1;
    ToolbarEnable(4,0);
    ToolbarEnable(5,1);
    return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
    Pause% :=0;
    ToolbarEnable(4,1);
    ToolbarEnable(5,0);
    return 1;
end





proc InitializeWindows()
    
	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(0,48,100,95);
	View(DataWindow%).WindowVisible(1);
    
	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
    
	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;
    
	'Create a new channel in the XY view to display the fixation window
	iStimWindowChannel% := XYSetChan(0);
	XYColour(iStimWindowChannel%,13);
	XYDrawMode(iStimWindowChannel%,2,1);
	XYJoin(iStimWindowChannel%,1);
	'Draw the fixation window
	XYAddData(iStimWindowChannel%, FixWindowX[], FixWindowY[]);
    
    'Create new channels in the XY view to display the answer windows
    'reuse FixationX, FixationY
    'First window
    for index% := 0 to 35 do
        FixWindowX[index%] := FixationX + attAnswerPointWindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + attAnswerPointOffset + attAnswerPointWindowRadius * Sin(index% * twopi/36.0);
	next;
    iAnswerWindowChannel1% := XYSetChan(0);
    XYColour(iAnswerWindowChannel1%,13);
	XYDrawMode(iAnswerWindowChannel1%,2,1);
	XYJoin(iAnswerWindowChannel1%,1);
	'Draw the answer window
	XYAddData(iAnswerWindowChannel1%, FixWindowX[], FixWindowY[]);
    
    'Second window
    for index% := 0 to 35 do
		FixWindowY[index%] := FixationY - attAnswerPointOffset + attAnswerPointWindowRadius * Sin(index% * twopi/36.0);
	next;
    iAnswerWindowChannel2% := XYSetChan(0);
    XYColour(iAnswerWindowChannel2%,13);
	XYDrawMode(iAnswerWindowChannel2%,2,1);
	XYJoin(iAnswerWindowChannel2%,1);
	'Draw the answer window
	XYAddData(iAnswerWindowChannel2%, FixWindowX[], FixWindowY[]);
    
	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);
    
	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%,13);
	XYDrawMode(iMonitorChannel%,3,1);
	XYJoin(iMonitorChannel%,2);
	XYAddData(iMonitorChannel%,-9,-7);
	XYAddData(iMonitorChannel%,9,-7);
	XYAddData(iMonitorChannel%,9,7);
	XYAddData(iMonitorChannel%,-9,7);
    
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
    '	SampleClear(); 'Set standard sampling state
    '	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
	'Channel recording definitions
	SampleEvent(FrameTriggerChannel%,0,2,3600); 'Trigger channel, level
	SampleComment$(FrameTriggerChannel%,"Frame");
	SampleTitle$(FrameTriggerChannel%,"Frame");
    
 	SampleEvent(FixationPointChannel%,1,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixation");
	SampleTitle$(FixationPointChannel%,"Fixation");
	
	SampleEvent(StimChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
	
	SampleEvent(StimChangeChannel%,4,2,3600); 'Trigger channel, level
	SampleComment$(StimChangeChannel%,"Stim Chg.");
	SampleTitle$(StimChangeChannel%,"Stim Chg.");
	
	SampleEvent(ReadyChannel%,6,2,3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
    ' Set up channels for sampling electrodes.
    CreateElectrodeSamplingConfiguration(1, 11);
	
	SampleWaveform(XChannel%,14,1000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%,15,1000);
	SampleTitle$(YChannel%,"Eye Y");
    
	SampleWaveform(NumberOfElectrodes%+10, 6, 1000);
	SampleTitle$(NumberOfElectrodes%+10, "PD");
    
	SampleTextMark(200);  'increase number of allowed characters, 1 is so stingy!
    
	SampleSequencer(script$ + "Attention.pls");
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;



' Get grating p[arameters from registry AlertRig\\(config)\\Gratings\\type$
func GetGratingParameters$(type$)
	var key$;
	var stmp$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\Gratings";
	Profile(key$, type$, "", stmp$);
	return stmp$;
end;

' Replace the color vector spec in a grating with the specified value
func ReplaceGratingColorVector$(gspec$, cvspec$)
    var s$;
    var i1%, i2%;
    var index%:=0;
    var i%;
    ' i1% and i2% are the index positions of the 8th and 9th commas
    PrintLog(gspec$ + "\n");
    for i% := 1 to 7 do
        index% := InStr(gspec$, ",", index%+1);
        PrintLog("%d index %d\n", i%, index%);
    next;
    i1% := InStr(gspec$, ",", index%+1);
    i2% := InStr(gspec$, ",", i1%+1);
    s$ := Mid$(gspec$, 1, i1%) + cvspec$ + Mid$(gspec$, i2%);
    PrintLog(s$ + "\n");
    return s$;
end


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, mylen%;
    var fn$;
    
	' Disable idle process func
	ToolbarSet(0,"");
    
	' Tell stim app to shut down
	SafeSampleKey("q");
	Yield(.1);
	SampleStop();
    
	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend
    
    View(DataWindow%);
    ExportChanList();
    ExportChanList(0,maxtime(),30);  '30 is the textmark channel
    ExportChanList(0,maxtime(),31);  '31 is the keyboard channel
    
    'Code for putting other various channels into the Matlab extraction, Ben doesn't want them but they will be useful for other code    
    '    ExportChanList(0,maxtime(),XChannel%);  'Eye position channel, X
    '    ExportChanList(0,maxtime(),YChannel%);  'Eye position channel, Y
    for i% := 0 to NumWavemarkPorts%-1 do
        ExportChanList(0,maxtime(),i%+1);  'Wavemark channel(s)
    next;
    
    
    fn$ := FileName$();  'get current file name
    mylen% := Len(fn$);
    fn$ := Left$(fn$,mylen%-4);
    fn$ := fn$ + ".mat";
    FileSaveAs(fn$,100,0,"",0,"UseSName=0"); 'Do not overwrite the .mat file - should have a different name and if it doesn't that is a red flag    
    
    
    ' update statistics
    'AttentionExtract%(-1, -1);
    
	'ProgRun(bin$ + "\\ClearTrigger",0);
    
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
	var Extras$;
	var Tune$;
	var Stim$:="";
	var Contrast$;
    var ttemp;
    var stimSpec$;
    var distSpec$;
    var lolSpec$;
    var x;
    var i%;
    var specFileName$:="F:\\work\\AttentionSpecFile.txt";
    var specHandle%;
	
	SampleStart(0); 'Start sampling
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    ttemp := View(DataWindow%).MaxTime();
    Yield();
    tLast := View(DataWindow%).MaxTime();
    PrintLog("ttemp " + str$(ttemp) + " tlast " + str$(tLast) + "\n");
    
    stimSpec$ := GetGratingParameters$("Stimulus");
    distSpec$ := GetGratingParameters$("Distractor1");
    if attCustomGratingColorCheck% = 1 then
        var f$, t$;
        f$ := EncodeColor$(attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2]);
        stimSpec$ := ReplaceGratingColorVector$(stimSpec$, f$ + "-" + t$);
        f$ := EncodeColor$(attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);
        distSpec$ := ReplaceGratingColorVector$(distSpec$, f$ + "-" + t$);
    endif
    if attLollipopCheck% = 1 then
        lolSpec$ := " -L -c " + str$(attCircleDiameterDiff) + " -p " + str$(attLollipopContrast%) + " -l " + str$(attCueLinePct/100) + " -G " + str$(attCueLineGap) + " -P " + str$(attLollipopStickContrast%);
    else
        lolSpec$ := "";
    endif
    
	Stim$ := " -g " + distSpec$ + " -s " + stimSpec$;  
	'Contrast$ := " -t " + str$(round(attContrastBase%/pow(2,attMinContChange))) + "," + str$(attContrastBase%) + "," + str$(round(attContrastBase%*pow(2,attMaxContChange)));  'this will change once tuning curves are in, at least a bit
	CreateContrastList(Contrast$,attContrastList%,attValidList%,attUpDownList%);  'Fills Contrast$ with the big ol' list, plus some vars to make it easier on us all 
    Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$() + " -A " + str$(attAnswerPointOffset) + " -D " + str$(attAnswerPointDiameter) + lolSpec$;
    if attTrainingContrastCheck% = 1 then
        Extras$ := Extras$ + " -T " + str$(attTrainingContrastPct%);
    endif
    
    'Hardcode the choice points to be red no matter what
    'Turns out that for the attention program the color in the fixation argument sets the color of the choice
    'points but that the actual fixation point is set differently.  FixationArg$ is created at the outset of
    'the script, but here I'm overriding the value to make the choice points always red.
    FixationArg$ := " -f " + str$(FixationX) + "," + str$(FixationY) + "," + str$(FixationDiameter) + ",red";
	
	'CommandLine$ := "cmd /c " + bin$ + "\\dAttention " + FixationArg$ + Extras$ + Distractors$;
	'CommandLine$ := "cmd /k " + bin$ + "\\Attention " + FixationArg$ + Extras$ + Stim$ + Contrast$;
    CommandLine$ := "cmd /k " + bin$ + "\\Attention -F " + specFileName$;
    
    'open a file to write the trial-by-trial specs for the VSG
    specHandle% := FileOpen(specFileName$, 8, 1);
    'print to spec file
    Print("%s %s %s %s",FixationArg$,Extras$,Stim$,Contrast$);  'file should be everything starting from FixationArg$ on
    'close spec file
	FileClose(0);
    
    'Print the parameters
    for i% := 1 to Len(CommandLine$) step 100 do
        SampleText(Mid$(CommandLine$, i%, 100));
    next
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(CommandLine$+"\n");
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	'Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(.1);
    return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawStim
' 
' Draws stimulus in xy window (iDraw%==1) or blanks it (0). 
proc DrawStim(iDraw%)
    
	if iDraw% > 0 then
		var xstim, ystim;
		xstim := FixationX;
		ystim := FixationY;
        
		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif
    
end;




'
'
'===== GetLogProgression =====

' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
' There will be a total of nsteps%+1 values entered into vec[], vec[0] will be xmin, vec[nsteps%] will be xmax
Proc GetLogProgression(xmin, xmax, nsteps%, &vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		'PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;

'
'
'======= CreateContrastList =======
'Fill input variable c$ with the long-form contrast specifier for the Attention experiment
'and cList%[] with the actual contrast to be used on each trial
'and vList%[] with ones if valid and zeros for each trial
'and udList%[] with 1 if contrast change is increase and -1 if contrast change is decrease
'Creating all of these here (including easy trials) allows us to just blast through once we get to the actual experiment
'without too much counting going on.
Proc CreateContrastList(&c$,cList%[],&vList%[],&udList%[])
    var i%;
    var j%;
    var stdCount%;  'a counter for standard (i.e. "valid") trials, index into attTrialOrder%[]
    var catchCount%;  'a counter for catch trials
    var totalCount%;  'the current index of the xList% variables
    
    c$ := " -t ";
    
    for i% := 1 to attNumberOfBlocks% do
        for j% := 1 to attTrialsPerBlock%+attEasyTrialsPerBlock% do
            if j% <= attEasyTrialsPerBlock% then
                vList%[totalCount%] := 1;  'all easy trials are valid
                if (Rand() < 0.5) then
                    udList%[totalCount%] := 1;  'up contrast
                    cList%[totalCount%] := attContrastList[attNContLevels%-1];  'fill cList%[] with the highest contrast
                    c$ := c$ + "0," + Str$(attContrastBase%) + "," + Str$(attContrastList[attNContLevels%-1]) + ",";  'fill c$ with easy, up trial
                else
                    udList%[totalCount%] := -1;  'down contrast
                    cList%[totalCount%] := attContrastList[attNContLevels%];  'fill cList%[] with the lowest contrast
                    c$ := c$ + Str$(attContrastList[attNContLevels%]) + "," + Str$(attContrastBase%) + "," + "0,";  'fill c$ with easy, down trial
                endif;
            else 'regular trial
                if (Rand()*100 < attCatchTrialPercentage) then 'catch trial
                    vList%[totalCount%] := 0;  'catch = invalid
                    cList%[totalCount%] := attContrastList[attCatchTrialOrder%[catchCount%]];
                    if attCatchTrialOrder%[catchCount%] >= attNContLevels% then  'use index to determine whether contrast change is up or down
                        udList%[totalCount%] := -1;  'the second half are down contrast
                        c$ := c$ + Str$(attContrastList[attCatchTrialOrder%[catchCount%]]) + "," + Str$(attContrastBase%) + "," + "0,";  'fill c$ with down catch trial
                    else
                        udList%[totalCount%] := 1;   'the first half are up contrast
                        c$ := c$ + "0," + Str$(attContrastBase%) + "," + Str$(attContrastList[attCatchTrialOrder%[catchCount%]]) + ",";  'fill c$ with up catch trial
                    endif;
                    catchCount% += 1;  
                else  'valid trial
                    vList%[totalCount%] := 1;  'valid
                    cList%[totalCount%] := attContrastList[attTrialOrder%[stdCount%]];
                    if attTrialOrder%[stdCount%] >= attNContLevels% then  'use index to determine whether contrast change is up or down
                        udList%[totalCount%] := -1;  'the second half are down contrast
                        c$ := c$ + Str$(attContrastList[attTrialOrder%[stdCount%]]) + "," + Str$(attContrastBase%) + "," + "0,";  'fill c$ with down std trial
                    else
                        udList%[totalCount%] := 1;   'the first half are up contrast
                        c$ := c$ + "0," + Str$(attContrastBase%) + "," + Str$(attContrastList[attTrialOrder%[stdCount%]]) + ",";  'fill c$ with up std trial
                    endif;
                    stdCount% += 1;
                endif;
            endif;
            totalCount% += 1;
        next;        
    next;
    c$ := Left$(c$,len(c$)-1); 'remove trailing comma from the list
end;
