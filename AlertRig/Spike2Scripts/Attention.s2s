' $Id: Attention.s2s,v 1.19 2008-10-06 21:06:10 devel Exp $
'

#include "AttentionExtractFunctions.s2s"

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Get Current configuration START
'	
'	Fetch the current configuration from the registry and return it. 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func GetCurrentConfiguration$()
	var key$;
	var s$;
	key$:="AlertRig";
	Profile(key$, "CurrentConfiguration", "default", s$);
	return s$;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Get Current configuration END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Data parameters START
'
'	Vars that control where data is stored. 
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var dataPathRoot$;		' base path for data storage
var dataDataSet$;		' folder under data path where data files placed
var dataCellName$;		' part of base name for all data files
var dataDataSetTextItem%;	' 

proc GetDataParameters()
	var stmp$;
	var key$;

	key$:="AlertRig\\Data";

	Profile(key$, "PathRoot", "C:\\Experiments", dataPathRoot$);
	Profile(key$, "DataSet", "", dataDataSet$);
	Profile(key$, "CellName", "", dataCellName$);
	return;
end;

proc SaveDataParameters()
	var stmp$;
	var key$;

	key$:="AlertRig\\Data";

	Profile(key$, "PathRoot", dataPathRoot$);
	Profile(key$, "DataSet", dataDataSet$);
	Profile(key$, "CellName", dataCellName$);
	return;
end;

func DataParametersDialog%()
	var i%;
	GetDataParameters();
	DlgCreate("Data Storage Parameters", 25, 10, 50);
	DlgText("Data root path: " + dataPathRoot$, 0, 1);
	dataDataSetTextItem% := DlgText("Data set name: " + dataDataSet$, 0, 2);
	DlgString(1, "Cell name:", 10, "", 0, 3);
        DlgButton(2, "New Data Set", NewDataSet%);
	i% := DlgShow(dataCellName$);
	if (i% = 1) then
		if Len(dataDataSet$) = 0 then
			Message("Must specify a data set (try the button!)");
		else
			if Len(dataCellName$) = 0 then
				Message("Must specify a cell name");
			else
				FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3, 1);
				SaveDataParameters();
			endif;
		endif;
	endif;
	return i%;
end;


func NewDataSet%()
	var d$;
	var i%;
	var dirs$[100];	' if there are ever more than 100 datasets in a single day there will be trouble
	d$ := Date$(2, 2, 3, 3, "-");
	PrintLog("NewDataSet: date string = " + d$ + "\n");

	' Change current dir to data path root, then get list of subdirs with this date string
	PrintLog("NewDataSet: dataPathRoot$=" + dataPathRoot$ + "\n");
	FilePathSet(dataPathRoot$, 0, 1);
	i% := FileList(dirs$, -2, d$ + "-??");
        PrintLog("NewDataSet: found " + str$(i%) + " dirs\n");

	' form new dataset name. The first will have "-01" appended, the second "-02", etc. 
	dataDataSet$ := Print$("%s-%02d", d$, i%+1);
	PrintLog("NewDataSet: dataset= " + dataDataSet$ + "\n");
	DlgValue$(dataDataSetTextItem%, "Data set name: " + dataDataSet$);
	return 1;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Data parameters END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Fixation Point parameters START
'
'	These vars and funcs control the parameters for the fixation point stored in the registry. 
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var WindowRadius;
var FixationX, FixationY;
var FixationColor$;
var iFixationColor%;
var FixationDiameter;
var FixationColorList$[3]; 
var FixationArg$;

proc GetFixationPointParameters()
	var stmp$;
	var key$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\FixationPoint";
	Profile(key$, "WindowRadius", "1", stmp$);
	WindowRadius := val(stmp$);

	Profile(key$, "FixationX", "0", stmp$);
	FixationX := val(stmp$);
	Profile(key$, "FixationY", "0", stmp$);
	FixationY := val(stmp$);
	Profile(key$, "FixationColor", "0", stmp$);
	iFixationColor% := val(stmp$);

	FixationColorList$[0]:="red"; 
	FixationColorList$[1]:="green"; 
	FixationColorList$[2]:="blue"; 
	FixationColor$ := FixationColorList$[iFixationColor%];

	Profile(key$, "FixationDiameter", "0.5", stmp$);
	FixationDiameter := val(stmp$);

	' Form the argument for applications. Convenience for passing args. 
	FixationArg$ := " -f " + str$(FixationX) + "," + str$(FixationY) + "," + str$(FixationDiameter) + "," + FixationColor$;
end;

proc SaveFixationPointParameters()
	var key$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\FixationPoint";
	Profile(key$, "WindowRadius", str$(WindowRadius));
	Profile(key$, "FixationX", str$(FixationX));
	Profile(key$, "FixationY", str$(FixationY));
	Profile(key$, "FixationColor", str$(iFixationColor%));
	Profile(key$, "FixationDiameter", str$(FixationDiameter));
end;


func FixationPointDialog%()

	var i%;
	GetFixationPointParameters();
	DlgCreate("Fixation parameters: " + GetCurrentConfiguration$(), 25, 10);
	DlgReal(1, "Fixation X:", -20, 20);
	DlgReal(2, "Fixation Y:", -20, 20);
	DlgReal(3, "Fixation diam:", .1, 5);
	DlgReal(4, "Window radius:", .1, 10);
	DlgList(5, "Color:", FixationColorList$[]);
	i% := DlgShow(FixationX, FixationY, FixationDiameter, WindowRadius, iFixationColor%);	

	' If user cancelled, reload params
	if i% = 0 then
		GetFixationPointParameters();
	else
		SaveFixationPointParameters();
	endif

	return 1;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Fixation Point parameters END
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Rig Daily Totals START
'
'	Control, display, reset daily totals for a rig.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


var TotalTrials%;
var TotalRewards%;
var TotalDate$;


proc GetDailyTotals()
	var key$;
	key$ := "AlertRig\\Daily";
	Profile(key$, "TotalDate", "", TotalDate$);
	Profile(key$, "TotalTrials", 0, TotalTrials%);
	Profile(key$, "TotalRewards", 0, TotalRewards%);

	' Get date string if needed
	if Len(TotalDate$) = 0 then
		TotalDate$ := GetDayString$();
		SaveDailyTotals();
	endif
end;

proc SaveDailyTotals()
	var key$;
	key$ := "AlertRig\\Daily";
	Profile(key$, "TotalDate", TotalDate$);
	Profile(key$, "TotalTrials", TotalTrials%);
	Profile(key$, "TotalRewards", TotalRewards%);
end;

func DailyTotalsDialog%()
	GetDailyTotals();
	DlgCreate("Daily Totals");
	DlgText("Date: " + TotalDate$, 0, 1);
	DlgText("Trials: " + str$(TotalTrials%), 0, 2);
	DlgText("Rewards: " + str$(TotalRewards%), 0, 3);
	DlgButton(2, "Reset", ResetDailyTotals%);
	DlgShow();
	return 1;
end;


func GetDayString$()
	return Date$(2, 1, 3, 2, "-");
end;


func ResetDailyTotals%()
	GetDailyTotals();
	TotalRewards%:=0;
	TotalTrials%:=0;
	TotalDate$:= GetDayString$();
	SaveDailyTotals();
        return 0;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	Rig Daily Totals END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	DAQ Parameters START
'
'	Control of data acquisition parameters.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


var DistanceToScreenMM$;		' Distance to screen in MM
var DegreesPerVoltX;			' Conversion factor from ADC to visual degrees
var DegreesPerVoltY;			' Conversion factor from ADC to visual degrees
var EyeCoilSamplingFrequency%;		' Frequency to sample eye coil at
var NumberOfElectrodes%;		' Number of electrodes (i.e. wavemark inputs) in use
var JuicePerReward%;			' Number of juice squirts per reward


func DAQParametersDialog%()

	var iReturn%;
	var idist%;

	GetDAQParameters();

	idist% := val(DistanceToScreenMM$);
	DlgCreate("DAQ parameters: " + GetCurrentConfiguration$(), 25, 10);
	DlgInteger(1, "Number of Electrodes:", 1, 7, 0, 0, 1);
	DlgInteger(2, "Screen Distance (MM):", 1, 5000);
	DlgReal(3, "Degrees/Volt (X):", 0, 100);
	DlgReal(4, "Degrees/Volt (Y):", 0, 100);
	DlgInteger(5, "Eye Coil Sampling Freq (Hz):", 1, 20000);
	DlgInteger(6, "Juice per reward:", 0, 10, 0, 0, 1);
	iReturn% := DlgShow(NumberOfElectrodes%, idist%, DegreesPerVoltX, DegreesPerVoltY, EyeCoilSamplingFrequency%, JuicePerReward%);

	if iReturn% = 1 then
		DistanceToScreenMM$ := str$(idist%);
		SaveDAQParameters();
	endif
	return iReturn%;
end;




	
proc GetDAQParameters()
	var key$;
	var DegreesPerVoltX$, DegreesPerVoltY$;

	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\DAQ";
	Profile(key$, "DistanceToScreenMM", "850", DistanceToScreenMM$);	' will just pass this to stimulus app
	Profile(key$, "DegreesPerVoltX", "", DegreesPerVoltX$);
	Profile(key$, "DegreesPerVoltY", "", DegreesPerVoltY$);
	Profile(key$, "EyeCoilSamplingFrequency", 1000, EyeCoilSamplingFrequency%);
	Profile(key$, "NumberOfElectrodes", 1, NumberOfElectrodes%);
	Profile(key$, "JuicePerReward", 1, JuicePerReward%);
	DegreesPerVoltX := val(DegreesPerVoltX$);
	DegreesPerVoltY := val(DegreesPerVoltY$);

end;

proc SaveDAQParameters()
	var key$;
	var DegreesPerVoltX$, DegreesPerVoltY$;
	DegreesPerVoltX$ := str$(DegreesPerVoltX);
	DegreesPerVoltY$ := str$(DegreesPerVoltY);
	
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\DAQ";
	Profile(key$, "DistanceToScreenMM", DistanceToScreenMM$);
	Profile(key$, "DegreesPerVoltX", DegreesPerVoltX$);
	Profile(key$, "DegreesPerVoltY", DegreesPerVoltY$);
	Profile(key$, "EyeCoilSamplingFrequency", EyeCoilSamplingFrequency%);
	Profile(key$, "NumberOfElectrodes", NumberOfElectrodes%);
	Profile(key$, "JuicePerReward", JuicePerReward%);

end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
'	DAQ Parameters END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' 	Attention script dialog START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'	Vars that control the Attention script. 

var attNumberOfBlocks%;
var attTrialsPerBlock%;
var attCatchTrialPercentage;
var attBackgroundColor$;
var attBackgroundRed% := 0;
var attBackgroundGreen% := 0;
var attBackgroundBlue% := 0;
var attBackgroundFromRed% := 0;
var attBackgroundFromGreen% := 0;
var attBackgroundFromBlue% := 0;
var attBackgroundToRed% := 0;
var attBackgroundToGreen% := 0;
var attBackgroundToBlue% := 0;
var attAnswerPointDiameter := 0.05;
var attAnswerPointOffset := 5.0;
var attAnswerPointWindowRadius := 2.0;
var attContrastBase%;
var attContrastUp%;
var attContrastDown%;
var attFixationTime;
var attHazardMinTime;
var attHazardExpMeanTime;
var attAcquisitionTime;
var attInterTrialTime;
var attTimeToAnswer;
var attAbortWaitTime;
var attBlockAlternate%;
var attTrainingContrastCheck%:=0;
var attTrainingContrastPct%:=0;

var attCustomGratingColorCheck%;
var attCustomGratingColorStimFrom%[3];
var attCustomGratingColorStimTo%[3];
var attCustomGratingColorDistractorFrom%[3];
var attCustomGratingColorDistractorTo%[3];

' Counter vars for attention script
var attCountAllTrials% := 0;
var attCountAllTrialsCorrect% := 0;
var attCountAllTrialsIncorrect% := 0;
var attCountAllTrialsAbort% := 0;
var attCountTowardTrials% := 0;
var attCountTowardTrialsCorrect% := 0;
var attCountTowardTrialsIncorrect% := 0;
var attCountTowardTrialsAbort% := 0;
var attCountAwayTrials% := 0;
var attCountAwayTrialsCorrect% := 0;
var attCountAwayTrialsIncorrect% := 0;
var attCountAwayTrialsAbort% := 0;

' constants for dialog and check functio
var attdlgTrainingContrastCheck% := 8;
var attdlgTrainingContrastPct% := 9;

' constants for color dialog
var attdlgColorIndexGray% := 0;
var attdlgColorIndexBlack% := 1;
var attdlgColorIndexWhite% := 2;
var attdlgColorIndexCustom% := 3;
var attcolorsdlgBackgroundColor% := 1;
var attcolorsdlgBackgroundRed% := 2;
var attcolorsdlgBackgroundGreen% := 3;
var attcolorsdlgBackgroundBlue% := 4;
var attcolorsdlgCustomGratingColorCheck% := 5;
var attcolorsdlgCustomGratingColorStimFromRed% := 6;
var attcolorsdlgCustomGratingColorStimFromGreen% := 7;
var attcolorsdlgCustomGratingColorStimFromBlue% := 8;
var attcolorsdlgCustomGratingColorStimToRed% := 9;
var attcolorsdlgCustomGratingColorStimToGreen% := 10;
var attcolorsdlgCustomGratingColorStimToBlue% := 11;
var attcolorsdlgCustomGratingColorDistractorFromRed% := 12;
var attcolorsdlgCustomGratingColorDistractorFromGreen% := 13;
var attcolorsdlgCustomGratingColorDistractorFromBlue% := 14;
var attcolorsdlgCustomGratingColorDistractorToRed% := 15;
var attcolorsdlgCustomGratingColorDistractorToGreen% := 16;
var attcolorsdlgCustomGratingColorDistractorToBlue% := 17;

proc GetAttentionScriptParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Attention";

	Profile(key$, "NumberOfBlocks", 1, attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", 1, attTrialsPerBlock%);
	Profile(key$, "CatchTrialPercentage", "0.0", stmp$);
	attCatchTrialPercentage := val(stmp$);
	Profile(key$, "BlockAlternate", 1, attBlockAlternate%);
	Profile(key$, "TrainingContrastCheck", 0, attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", 0, attTrainingContrastPct%);
	Profile(key$, "BackgroundColor", "gray", attBackgroundColor$);
    
    if InStr(attBackgroundColor$, "(") = 1 then
        if ParseColor%(attBackgroundColor$, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%) <> 0 then
            attBackgroundColor$ := "gray";
        endif
    endif
    
    Profile(key$, "ContrastBase", 50, attContrastBase%);
	Profile(key$, "ContrastUp", 80, attContrastUp%);
	Profile(key$, "ContrastDown", 20, attContrastDown%);

	Profile(key$, "AnswerPointDiameter", "0.5", stmp$);
	attAnswerPointDiameter := val(stmp$);

	Profile(key$, "AnswerPointOffset", "5.0", stmp$);
	attAnswerPointOffset := val(stmp$);

	Profile(key$, "AnswerPointWindowRadius", "2.0", stmp$);
	attAnswerPointWindowRadius := val(stmp$);

	Profile(key$, "FixationTime", "1.0", stmp$);
	attFixationTime := val(stmp$);

	Profile(key$, "HazardMinTime", "0.5", stmp$);
	attHazardMinTime := val(stmp$);

	Profile(key$, "HazardExpMeanTime", "1.0", stmp$);
	attHazardExpMeanTime := val(stmp$);

	Profile(key$, "AcquisitionTime", "1.0", stmp$);
	attAcquisitionTime := val(stmp$);

	Profile(key$, "InterTrialTime", "1.0", stmp$);
	attInterTrialTime := val(stmp$);

	Profile(key$, "TimeToAnswer", "1.0", stmp$);
	attTimeToAnswer := val(stmp$);

	Profile(key$, "AbortWaitTime", "1.0", stmp$);
	attAbortWaitTime := val(stmp$);

    Profile(key$, "CustomGratingColorsCheck", 0, attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", 0, attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", 0, attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", 0, attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", 255, attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", 255, attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", 255, attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", 0, attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", 0, attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", 0, attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", 255, attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", 255, attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", 255, attCustomGratingColorDistractorTo%[2]);
    
end;

proc SaveAttentionScriptParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Attention";

	Profile(key$, "NumberOfBlocks", attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", attTrialsPerBlock%);
	Profile(key$, "CatchTrialPercentage", str$(attCatchTrialPercentage));
	Profile(key$, "BlockAlternate", attBlockAlternate%);
	Profile(key$, "TrainingContrastCheck", attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", attTrainingContrastPct%);
	Profile(key$, "BackgroundColor", attBackgroundColor$);
	Profile(key$, "ContrastBase", attContrastBase%);
	Profile(key$, "ContrastUp", attContrastUp%);
	Profile(key$, "ContrastDown", attContrastDown%);
	Profile(key$, "FixationTime", str$(attFixationTime));
	Profile(key$, "HazardMinTime", str$(attHazardMinTime));
	Profile(key$, "HazardExpMeanTime", str$(attHazardExpMeanTime));
	Profile(key$, "AcquisitionTime", str$(attAcquisitionTime));
	Profile(key$, "AbortWaitTime", str$(attAbortWaitTime));
	Profile(key$, "InterTrialTime", str$(attInterTrialTime));
	Profile(key$, "TimeToAnswer", str$(attTimeToAnswer));
	Profile(key$, "AnswerPointDiameter", str$(attAnswerPointDiameter));
	Profile(key$, "AnswerPointOffset", str$(attAnswerPointOffset));
	Profile(key$, "AnswerPointWindowRadius", str$(attAnswerPointWindowRadius));
    Profile(key$, "CustomGratingColorsCheck", attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", attCustomGratingColorDistractorTo%[2]);

	end;

func AttentionScriptDialog%()
	var i%;
	GetAttentionScriptParameters();

	DlgCreate("Attention Training Parameters", 25, 10);
    DlgGroup("Blocks, contrast", 1, 1, 35, 10);
	DlgInteger(1, "Number of Blocks:", 1, 1000, 20, 2);
	DlgInteger(2, "Trials per block:", 1, 1000, 20, 3);
	DlgReal(3, "Catch Trial pct (0-100)", 0, 100, 20, 4);
	DlgCheck(4, "Alternate cue type by block", 2, 5);
	DlgInteger(5, "Base contrast(%)", 0, 100, 20, 6);
	DlgInteger(6, "Up contrast(%)", 0, 100, 20, 7);
	DlgInteger(7, "Down contrast(%)", 0, 100, 20, 8);
	DlgCheck(attdlgTrainingContrastCheck%, "Training Contrast", 2, 9);
	DlgInteger(attdlgTrainingContrastPct%, "Training Contrast(%)", 0, 100, 20, 10);
    DlgButton(2, "Colors", ColorsDialog%, 1, 12);
    DlgGroup("Timing", 1, 13, 35, 11);
	DlgReal(10, "Acquisition time(s):", .01, 10, 20, 14);
	DlgReal(11, "Fixation time(s):", .01, 10, 20, 15);
	DlgReal(12, "Hazard min time(s):", 0, 10, 20, 16);
	DlgReal(13, "Hazard exp mean time(s):", 0, 10, 20, 17);
	DlgReal(14, "Time to answer(s):", 0.01, 10.0, 20, 18);
	DlgReal(15, "Intertrial time(s):", .01, 10, 20, 19);
	DlgReal(16, "Abort wait time(s):", .01, 10, 20, 20);
'	DlgList(14, "Background color:", bcl$);
	DlgReal(17, "AnsPt. Diam.(deg):", 0.1, 5.0, 20, 21);
	DlgReal(18, "AnsPt. Center Offset(deg):", 0.1, 10.0, 20, 22);
	DlgReal(19, "AnsPt. Window radius(deg):", 0.1, 10.0, 20, 23);
    DlgAllow(0, 0, AttentionScriptDialogChanged%);
	i%:=DlgShow(attNumberOfBlocks%, attTrialsPerBlock%, attCatchTrialPercentage,attBlockAlternate%, 
                attContrastBase%, attContrastUp%, attContrastDown%,
                attTrainingContrastCheck%, attTrainingContrastPct%, 
                attAcquisitionTime, attFixationTime, attHazardMinTime, attHazardExpMeanTime, attTimeToAnswer, 
                attInterTrialTime, attAbortWaitTime,
                attAnswerPointDiameter, attAnswerPointOffset, attAnswerPointWindowRadius);
	if i% = 1 then
	'	attBackgroundColor$ := bcl$[ibcl%];
		SaveAttentionScriptParameters();
	endif;
	return i%;
end;


func ParseColor%(s$, &r%, &g%, &b%)
    var status% := -1;
    var n;
    ReadSetup("", "/(", "(", ")");
    n := ReadStr(s$, r%, g%, b%);
    ReadSetup();
    if n = 3 then
        status% := 0;
    endif
    return status%;
end

func EncodeColor$(r%, g%, b%)
    var s$;
    s$ := Print$("(%d/%d/%d)", r%, g%, b%);
    return s$;
end


' Called when items in attention script dialog change. WARNING: The item #s are coded as constants
' If format of dialog changes then those constants should be changed. 

func AttentionScriptDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = attdlgTrainingContrastCheck% then
        DlgEnable(DlgValue(attdlgTrainingContrastCheck%), attdlgTrainingContrastPct%);
    case item% = 0 then
        DlgEnable(attTrainingContrastCheck%, attdlgTrainingContrastPct%);
    endcase
    return status%;
end

func ColorsDialog%()
	var i%;
	var bcl$[4];
	var ibcl%:=0;
	GetAttentionScriptParameters();
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
    bcl$[3] := "custom";
    if InStr(attBackgroundColor$, "(") = 1 then
        ibcl% := attdlgColorIndexCustom%;
    else
        ibcl% := 2;
        for i%:=0 to 2 do
            if attBackgroundColor$ = bcl$[i%] then
                ibcl% := i%;
            endif
        next;
    endif
    
	DlgCreate("Attention colors", 25, 10);
    DlgAllow(0, 0, ColorsDialogChanged%);
	DlgList(1, "Background color:", bcl$);
    DlgInteger(2, "Background red (0-255)", 0, 255);
    DlgInteger(3, "Background green (0-255)", 0, 255);
    DlgInteger(4, "Background blue (0-255)", 0, 255);
    DlgCheck(attcolorsdlgCustomGratingColorCheck%, "Custom grating colors");
    DlgGroup("Stimulus", 1, 6, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromRed%, "From Red (0-255)", 0, 255, 20, 7);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromGreen%, "From Green (0-255)", 0, 255, 20, 8);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromBlue%, "From Blue (0-255)", 0, 255, 20, 9);
    DlgInteger(attcolorsdlgCustomGratingColorStimToRed%, "To Red (0-255)", 0, 255, 20, 10);
    DlgInteger(attcolorsdlgCustomGratingColorStimToGreen%, "To Green (0-255)", 0, 255, 20, 11);
    DlgInteger(attcolorsdlgCustomGratingColorStimToBlue%, "To Blue (0-255)", 0, 255, 20, 12);
    DlgGroup("Distractor", 1, 13, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromRed%, "From Red (0-255)", 0, 255, 20, 14);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromGreen%, "From Green (0-255)", 0, 255, 20, 15);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromBlue%, "From Blue (0-255)", 0, 255, 20, 16);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToRed%, "To Red (0-255)", 0, 255, 20, 17);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToGreen%, "To Green (0-255)", 0, 255, 20, 18);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToBlue%, "To Blue (0-255)", 0, 255, 20, 19);
	i% := DlgShow(ibcl%, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%, 
    attCustomGratingColorCheck%, 
    attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2], 
    attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2], 
    attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2], 
    attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);

	' If user cancelled, reload params
	if i% = 1 then
        if ibcl% = attdlgColorIndexCustom% then
            attBackgroundColor$ := EncodeColor$(attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%);
        else
            attBackgroundColor$ := bcl$[ibcl%];
        endif
	endif
    
	return 1;
end;

func ColorsDialogChanged%(item%)
    var status% := 1;
    if item% = 0 or item% = attcolorsdlgBackgroundColor% then
        if DlgValue(attcolorsdlgBackgroundColor%) = 3 then
            DlgEnable(1, attcolorsdlgBackgroundRed%);
            DlgEnable(1, attcolorsdlgBackgroundGreen%);
            DlgEnable(1, attcolorsdlgBackgroundBlue%);
        else
            DlgEnable(0, attcolorsdlgBackgroundRed%);
            DlgEnable(0, attcolorsdlgBackgroundGreen%);
            DlgEnable(0, attcolorsdlgBackgroundBlue%);
        endif
    endif
    
    if item% = 0 or item% = attcolorsdlgCustomGratingColorCheck% then
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToBlue%);
    endif
    
    return status%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Attention script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''







' Local file system variables. 
var bin$, script$;
bin$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2) + "..\\bin";	' Location of executables is ..\bin, relative to script dir
script$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2);	' folder containing this script

' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameTriggerChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;

' tuning curves
var TuningWindow%[8];	' one for each channel. There'd better not be more than 8 channels! 
' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Fetch parameters
GetDailyTotals();
GetDAQParameters();
GetFixationPointParameters();
GetDataParameters();

' Check for valid data file path
if Len(dataDataSet$) = 0 then
	Message("No data set is selected! Edit Data parameters...");
	' Might be nice to open the dialog here....
	halt;
endif



var tmp$;

' run parameters script....
GetAttentionScriptParameters();
iScript% := AttentionScriptDialog%();
if iScript% = 1 then
		FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
		FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
        SampleAutoName$(dataCellName$ + "_atn_000");
		SampleAutoFile(1);
else
	PrintLog("User cancel - exit gracefully\n");
	Halt;
endif;





' Assign channel numbers for eye X,Y and trigger. 
XChannel% := NumberOfElectrodes%+1;
YChannel% := NumberOfElectrodes%+2;
FrameTriggerChannel% := NumberOfElectrodes%+3;
FixationPointChannel% := NumberOfElectrodes%+4;
StimChannel% := NumberOfElectrodes%+5;
StimChangeChannel% := NumberOfElectrodes%+6;
ReadyChannel% := NumberOfElectrodes%+7;
CreateSampleConfiguration();


' Initialize extraction
AttentionExtractInit(-1);

' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' UpdateToolbarText - Print tallies of trials in toolbar
'

proc UpdateToolbarText()

	var s$;
	var allpct$ := "--";
	var towpct$ := "--";
    var awapct$ := "--";
    var num, den, pct;

    if (attCountAllTrials% > 0) then
        num := attCountAllTrialsCorrect%;
        den := attCountAllTrials%;
        pct := num/den*100;
		allpct$ := print$("%2.0f", pct);
	endif
	if (attCountTowardTrials% > 0) then
        num := attCountTowardTrialsCorrect%;
        den := attCountTowardTrials%;
        pct := num/den*100;
		towpct$ := print$("%2.0f", pct);
	endif
	if (attCountAwayTrials% > 0) then
        num := attCountAwayTrialsCorrect%;
        den := attCountAwayTrials%;
        pct := num/den*100;
		awapct$ := print$("%2.0f", pct);
	endif
	s$ := Print$("Tallies count/correct/incorrect/aborted (correct%%): ALL %d/%d/%d/%d (%s%%) TOWARD %d/%d/%d/%d (%s%%) AWAY %d/%d/%d/%d (%s%%)", 
						attCountAllTrials%, attCountAllTrialsCorrect%, attCountAllTrialsIncorrect%, attCountAllTrialsAbort%, allpct$,
						attCountTowardTrials%, attCountTowardTrialsCorrect%, attCountTowardTrialsIncorrect%, attCountTowardTrialsAbort%, towpct$,
						attCountAwayTrials%, attCountAwayTrialsCorrect%, attCountAwayTrialsIncorrect%, attCountAwayTrialsAbort%, awapct$);

	ToolbarText(s$);

end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	UpdateToolbarText();
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
'	ToolbarSet(6,"Exp Parameters",AttentionScriptDialog%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Answer%(EyePosX, EyePosY)
    var ans% := 0;
    var ansptRadius;
    ansptRadius := Pow(attAnswerPointWindowRadius,2);
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-(FixationY+attAnswerPointOffset),2)) <= ansptRadius then ans% := 1; endif
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-(FixationY-attAnswerPointOffset),2)) <= ansptRadius then ans% := -1; endif
	return ans%;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
	var i%;
	for i%:=1 to JuicePerReward% do Yield(.05); SampleKey("J"); next
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 

' Constants for states
const stateStartTrial%:=0;		        ' Start trial state
const stateWaitForFixPtOn%:=1;		    ' Waiting for fixation point return trigger (on)
const stateWaitForFixation%:=2;		    ' Waiting for subject to fixate
const stateWaitForStimOn%:=3;		    ' Wait for stimulus return trigger (on)
const stateWaitForContrastChange%:=4;	' Wait for indication that contrast change has happened
const stateWaitForAcquisition%:=5;	    ' Waiting for subject to acquire fixation point
const stateHoldFixation%:=6;		    ' Holding fixation point
const stateAbort%:=7;			        ' Failed trial state
const stateWaitForAnswer%:=8;			' waiting for answer
const stateAbortWait%:=9;	            ' time out after failed trial
const stateVSGWait%:=10;		        ' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		    ' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		    ' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForBlank%:=14;
const stateBlockCompleted%:=16;
const stateStartBlock%:=17;
const stateTrialCompletedWaitForBlank% := 18;
const stateTrialCompletedPause% := 19;
var iState% := stateVSGWait%;	' present state

const trialtypeAttendToward% := 100;
const trialtypeAttendAway% := 101;
var trialType%;
var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 
var nBlocksCompleted%:=0;
var iAnswer%;
var isStimDistractorOff% := 0;
var trialCatch%;
var trialContrastUpDown%;
var trialHazardFunctionTime;

func IdleProcessing%()
	var iStatus% := 1;	
	tNow := MaxTime();

	xEye := ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
	yEye := ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastUpdate := tNow;
	endif


	docase 
		case iState% = stateVSGWait% then

			' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
			tTrigger := NextTime(ReadyChannel%, tLast, vTrigger);
			if tTrigger > tLastTrigger and vTrigger = 0 then
				PrintLog("state stateVSGWait: Got leading edge of trigger\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateVSGWaitConfirm%, tTrigger);
			endif;

		case iState% = stateVSGWaitConfirm% then

			' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
			tTrigger := NextTime(ReadyChannel%, tLastTrigger, vTrigger);
			if tTrigger > tLastTrigger and vTrigger = 1 then
				PrintLog("state stateVSGWaitConfirm: Got trailing edge of trigger\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateStartBlock%, tTrigger);
			endif;


		case iState% = stateStartBlock% then

			PrepareBlock();
			ChangeStateTo(stateStartTrial%, tNow);

		case iState% = stateStartTrial% then

			' Start trial. Put up fixation point.
			UpdateToolbarText();
			PrepareTrial();
			attCountAllTrials% += 1;
			docase
				case trialType% = trialtypeAttendToward% then
					PrintLog("stateStartTrial: Send fixation key F - AttendToward\n");
					SampleKey("F");
					attCountTowardTrials% += 1;
				case trialType% = trialtypeAttendAway% then
					PrintLog("stateStartTrial: Send fixation key G - AttendAway\n");
					SampleKey("G");
					attCountAwayTrials% += 1;
				else
					PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
			endcase
			ChangeStateTo(stateWaitForFixPtOn%, tTrigger);
		
		case iState% = stateWaitForFixPtOn% then

			tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
			if tTrigger > tLast and vTrigger = 0 then
				' Fixation point is up
				PrintLog("stateWaitForFixPtOn: signal received. " + str$(tNow) + "\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateWaitForAcquisition%, tTrigger);
				DrawStim(1);	' actually this draws the location of the fixpt.
			endif

		case iState% = stateWaitForAcquisition% then

			' Waiting for eye to fall inside of fixation window
			if Looking%(xEye, yEye) = 1 then
				PrintLog("stateWaitForAcquisition: eye in fixation window.\n");
				ChangeStateTo(stateWaitForFixation%, tNow);
			else 
				if tNow - tStateStart > attAcquisitionTime then
					PrintLog("stateWaitForAcquisition: failed.\n");
					ChangeStateTo(stateAbort%, tNow);
				endif
			endif

		case iState% = stateWaitForFixation% then

			' Eye must remain inside of fixation window
			if Looking%(xEye, yEye) = 1 then
				if tNow - tStateStart > attFixationTime then
					PrintLog("stateWaitForFixation: Success. Gratings up...\n");
					SampleKey("S");
					ChangeStateTo(stateWaitForStimOn%, tNow);
				endif
			else 
				PrintLog("stateWaitForFixation: failed.\n");
				ChangeStateTo(stateAbort%, tNow);
			endif

		case iState% = stateWaitForStimOn% then

			tTrigger := NextTime(StimChannel%, tLast, vTrigger);
			if tTrigger > tLast and vTrigger = 0 then
				' gratings et al are up
				PrintLog("stateWaitForStimOn: stim is up.\n");
				tStimOn := tTrigger;
				tLastTrigger := tTrigger;
				ChangeStateTo(stateHoldFixation%, tTrigger);
			endif

			
		case iState% = stateAbort% then

			' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
			' fixpt off. 
			PrintLog("stateAbort: send X key.\n");
			SampleKey("X");

			' tally up aborted trials
			attCountAllTrialsAbort% += 1;
			docase
				case trialType% = trialtypeAttendToward% then
					attCountTowardTrialsAbort% += 1;
				case trialType% = trialtypeAttendAway% then
					attCountAwayTrialsAbort% += 1;
				else
					PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
			endcase

			' move on
			ChangeStateTo(stateWaitForBlank%, tNow);

		case iState% = stateWaitForBlank% then

			' we just wait for fix point off signal in this case. 
			tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
			if tTrigger > tLast and vTrigger = 1 then
				' Fixation point is off
				PrintLog("stateWaitForBlank: Fix pt is off.\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateAbortWait%, tTrigger);
				DrawStim(0);	' actually this draws the location of the fixpt.
			endif

		case iState% = stateAbortWait% then

			if tNow - tStateStart > attAbortWaitTime then

				PrintLog("stateAbortWait: time out is done.\n");
				ChangeStateTo(stateStartTrial%, tNow);

			endif

		case iState% = stateHoldFixation% then

			if Looking%(xEye, yEye) = 0 then
	       		
				PrintLog("stateWaitForFixation: outside fixation window, aborting trial.\n");
				ChangeStateTo(stateAbort%, tNow);

			else 

				if (tNow - tStateStart) > (trialHazardFunctionTime) then

					' turn off stimulus and advance it
					PrintLog("stateHoldFixation: signal contrast change\n");
					docase
						case trialType% = trialtypeAttendToward% then
							if trialContrastUpDown% > 0 then
								if trialCatch% = 0 then
									SampleKey("C");
								else
									SampleKey("D");
								endif
							else
								if trialCatch% = 0 then
									SampleKey("c");
								else
									SampleKey("d");
								endif
							endif
						case trialType% = trialtypeAttendAway% then
							if trialContrastUpDown% > 0 then
								if trialCatch% = 0 then
									SampleKey("D");
								else
									SampleKey("C");
								endif
							else
								if trialCatch% = 0 then
									SampleKey("d");
								else
									SampleKey("c");
								endif
							endif
						else
							PrintLog("ERROR! Unknown blocktype!!!\n");
					endcase;
							

					' Now wait until contrast change trigger is received
					ChangeStateTo(stateWaitForContrastChange%, tNow);

				endif

			endif

		case iState% = stateWaitForContrastChange% then

			tTrigger := NextTime(StimChangeChannel%, tLast, vTrigger);
            if tTrigger > tLast and vTrigger = 0 then
                PrintLog("stateWaitForContrastChange: got it.\n");
                tLastTrigger := tTrigger;
                isStimDistractorOff% := 0;
				ChangeStateTo(stateWaitForAnswer%, tNow);
			endif

		case iState% = stateWaitForAnswer% then

			if tNow - tStateStart > attTimeToAnswer then
				PrintLog("stateWaitForAnswer: timed out\n");
				ChangeStateTo(stateAbort%, tNow);
            else
            ' When fixation is first broken we turn off the stim and distractor. 
            ' That test is done separately from the test for an answer. Also set up 
            ' a var to tell us whether the stim has been turned off. 
                if isStimDistractorOff% = 0 then
                    if Looking%(xEye, yEye) = 0 then
                        SampleKey("s");
           				PrintLog("stateWaitForAnswer: fix broken - turn off stim\n");
                        isStimDistractorOff% := 1;
                    endif
                endif

				iAnswer% := Answer%(xEye, yEye);
				if iAnswer% = 1 or iAnswer% = -1 then
					' Got an answer. Record marker for correct/incorrect answer
					if iAnswer% = trialContrastUpDown% then
						' Correct answer
						SampleText("+");
						attCountAllTrialsCorrect% += 1;
						docase
							case trialType% = trialtypeAttendToward% then
								attCountTowardTrialsCorrect% += 1;
							case trialType% = trialtypeAttendAway% then
								attCountAwayTrialsCorrect% += 1;
							else
								PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
						endcase
						Reward%();
					else
						SampleText("-");
						attCountAllTrialsIncorrect% += 1;
						docase
							case trialType% = trialtypeAttendToward% then
								attCountTowardTrialsIncorrect% += 1;
							case trialType% = trialtypeAttendAway% then
								attCountAwayTrialsIncorrect% += 1;
							else
								PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
						endcase
					endif
	
					SampleKey("X");
					ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
				endif
			endif

		case iState% = stateTrialCompletedWaitForBlank% then

			' we just wait for fix point off signal in this case. 
			tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
			if tTrigger > tLast and vTrigger = 1 then
				' Fixation point is off
				PrintLog("stateTrialCompleteWaitForBlank: Fix pt is off.\n");
				tLastTrigger := tTrigger;
				ChangeStateTo(stateTrialCompletedPause%, tTrigger);
				DrawStim(0);	' actually this draws the location of the fixpt.
			endif

		case iState% = stateTrialCompletedPause% then

			if tNow - tStateStart > attInterTrialTime then

				PrintLog("stateTrialCompletedPause: time out is done.\n");
				ChangeStateTo(stateTrialCompleted%, tNow);

			endif



		case iState% = stateTrialCompleted% then

			PrintLog("Trial completed.\n");
			nTrialsCompleted% := nTrialsCompleted% + 1;
			if nTrialsCompleted% = attTrialsPerBlock% then
				ChangeStateTo(stateBlockCompleted%, tNow);
			else
				ChangeStateTo(stateStartTrial%, tNow);
			endif
	
		case iState% = stateBlockCompleted% then

			PrintLog("Block completed.\n");
			nBlocksCompleted% := nBlocksCompleted% + 1;
			if nBlocksCompleted% = attNumberOfBlocks% then
				ChangeStateTo(stateDone%, tNow);
				Stop%();
				iStatus% := 0;
			else
				ChangeStateTo(stateStartBlock%, tNow);
			endif

		else
			
			' Unknown state!
			Message("Unknown state=" + str$(iState%));
			halt;

	endcase;

	tLast := tNow;
	return iStatus%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareTrial()

	PrintLog("Prepare trial: ");

	if attBlockAlternate% = 0 then
		if (Rand() < 0.5) then
			trialType% := trialtypeAttendToward%;
			PrintLog("Trial type: attend-toward\n");
		else
			trialType% := trialtypeAttendAway%;
			PrintLog("Trial type: attend-away\n");
		endif
	else
		if trialType% = trialtypeAttendToward% then
			PrintLog("Trial type: attend-toward (for this entire block)\n");
		else
			PrintLog("Trial type: attend-away (for this entire block)\n");
		endif
	endif


	
	' hazard function - compute time from fixation to contrast change
	trialHazardFunctionTime := RandExp(attHazardExpMeanTime, attHazardMinTime);
	' Catch trial?
	if (Rand()*100 < attCatchTrialPercentage) then
		trialCatch% := 1;
		PrintLog("CATCH ");
    else
        trialCatch% := 0;
    endif

	' Contrast up or down?
	trialContrastUpDown% := 1;
	if (Rand() < 0.5) then
		trialContrastUpDown% := -1;
		PrintLog(" Contrast UP\n");
	else
		PrintLog(" Contrast DOWN\n");
	endif


end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareBlock()
	PrintLog("Preparing block: ");
	' when blocksCompleted% is even, this is attend-toward
	' Modified: The above is done only when attBlockAlternate% is non zero. Otherwise its random trial-by-trial 
	' cue type. 
	if attBlockAlternate% <>0 then
		if (nBlocksCompleted% mod 2) = 0 then
			trialType% := trialtypeAttendToward%;
			PrintLog("Attend-toward ");
		else
			trialType% := trialtypeAttendAway%;
			PrintLog("Attend-away ");
		endif
	else
		PrintLog("Attend-toward/away done on a trial-by-trial basis.");
	endif
	PrintLog("\n");
	ntrialsCompleted% := 0;
	nTrialsStarted% := 0;
	nTrialsAborted% :=0;		' 
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end





proc InitializeWindows()

	'Open the data sampling window
	DataWindow% := FileNew(0,4);
	Window(0,48,100,95);
	View(DataWindow%).WindowVisible(1);

	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);


	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iStimWindowChannel% := XYSetChan(0);
	XYColour(2,13);
	XYDrawMode(2,2,1);
	XYJoin(2,1);
	'Draw the fixation window
	XYAddData(2, FixWindowX[], FixWindowY[]);

	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);

	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(4,13);
	XYDrawMode(4,3,1);
	XYJoin(4,2);
	XYAddData(4,-9,-7);
	XYAddData(4,9,-7);
	XYAddData(4,9,7);
	XYAddData(4,-9,7);

end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
'	SampleClear(); 'Set standard sampling state
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit

	'Channel recording definitions
	SampleEvent(FrameTriggerChannel%,0,2,3600); 'Trigger channel, level
	SampleComment$(FrameTriggerChannel%,"Frame");
	SampleTitle$(FrameTriggerChannel%,"Frame");

	SampleEvent(FixationPointChannel%,1,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixation");
	SampleTitle$(FixationPointChannel%,"Fixation");
	
	SampleEvent(StimChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
	
	SampleEvent(StimChangeChannel%,4,2,3600); 'Trigger channel, level
	SampleComment$(StimChangeChannel%,"Stim Chg.");
	SampleTitle$(StimChangeChannel%,"Stim Chg.");
	
	SampleEvent(ReadyChannel%,6,2,3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");

	for index := 1 to NumberOfElectrodes% do
		SampleWaveMark(index,index-1,2000,34,15,28000); ' chan, port, event rate, points, pre-trigger, rate
		SampleTitle$(index,"Electrode_"+Str$(index)); 
	next
	
	SampleWaveform(XChannel%,14,1000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%,15,1000);
	SampleTitle$(YChannel%,"Eye Y");

	SampleWaveform(NumberOfElectrodes%+10, 6, 1000);
	SampleTitle$(NumberOfElectrodes%+10, "PD");

	SampleTextMark(1);

	SampleSequencer(script$ + "Attention.pls");
	SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;



' Get grating p[arameters from registry AlertRig\\(config)\\Gratings\\type$
func GetGratingParameters$(type$)
	var key$;
	var stmp$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\Gratings";
	Profile(key$, type$, "", stmp$);
	return stmp$;
end;

' Replace the color vector spec in a grating with the specified value
func ReplaceGratingColorVector$(gspec$, cvspec$)
    var s$;
    var i1%, i2%;
    var index%:=0;
    var i%;
    ' i1% and i2% are the index positions of the 8th and 9th commas
    PrintLog(gspec$ + "\n");
    for i% := 1 to 7 do
        index% := InStr(gspec$, ",", index%+1);
        PrintLog("%d index %d\n", i%, index%);
    next;
    i1% := InStr(gspec$, ",", index%+1);
    i2% := InStr(gspec$, ",", i1%+1);
    s$ := Mid$(gspec$, 1, i1%) + cvspec$ + Mid$(gspec$, i2%);
    PrintLog(s$ + "\n");
    return s$;
end
    

' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()

	' Disable idle process func
	ToolbarSet(0,"");

	' Tell stim app to shut down
	SampleKey("q");
	Yield(.1);
	SampleStop();

	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend

    ' update statistics
    AttentionExtract%(-1);
    
	'ProgRun(bin$ + "\\ClearTrigger",0);

end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
	var Extras$;
	var Tune$;
	var Stim$:="";
	var Contrast$;
    var ttemp;
    var stimSpec$;
    var distSpec$;
	
	SampleStart(0); 'Start sampling
	SampleKey("0");
    ttemp := View(DataWindow%).MaxTime();
    Yield();
    tLast := View(DataWindow%).MaxTime();
    PrintLog("ttemp " + str$(ttemp) + " tlast " + str$(tLast) + "\n");
    
    stimSpec$ := GetGratingParameters$("Stimulus");
    distSpec$ := GetGratingParameters$("Distractor1");
    if attCustomGratingColorCheck% = 1 then
        var f$, t$;
        f$ := EncodeColor$(attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2]);
        stimSpec$ := ReplaceGratingColorVector$(stimSpec$, f$ + "-" + t$);
        f$ := EncodeColor$(attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);
        distSpec$ := ReplaceGratingColorVector$(distSpec$, f$ + "-" + t$);
    endif
	Stim$ := " -g " + distSpec$ + " -s " + stimSpec$;
	Contrast$ := " -t " + str$(attContrastDown%) + "," + str$(attContrastBase%) + "," + str$(attContrastUp%);
	Extras$ := " -b " + attBackgroundColor$ + " -d " + DistanceToScreenMM$ + " -A " + str$(attAnswerPointOffset) + " -D " + str$(attAnswerPointDiameter);
    if attTrainingContrastCheck% = 1 then
        Extras$ := Extras$ + " -T " + str$(attTrainingContrastPct%);
    endif
	
	'CommandLine$ := "cmd /c " + bin$ + "\\dAttention " + FixationArg$ + Extras$ + Distractors$;
	CommandLine$ := "cmd /k " + bin$ + "\\Attention " + FixationArg$ + Extras$ + Stim$ + Contrast$;
	
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(CommandLine$+"\n");
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	'Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(.1);
return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawStim
' 
' Draws stimulus in xy window (iDraw%==1) or blanks it (0). 
proc DrawStim(iDraw%)

	if iDraw% > 0 then
		var xstim, ystim;
		xstim := FixationX;
		ystim := FixationY;

		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif

end;


