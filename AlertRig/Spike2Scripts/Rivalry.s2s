#include "../../Spike2Util/RigName.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "Usrey.s2s"
#include "JoystickUtilities.s2s"


' Local config variables

const rivMaxTargets% := 8;
var rivNTargets% := 0;
var rivTargetSpecs$[rivMaxTargets%];
var rivMaxWaitForReadyTime := 1.0;
var rivReadFailWaitTime := 1.0;
var rivMaxResponseTime := 1.0;
var rivResponseFailWaitTime := 1.0;
var rivResponseIncorrectWaitTime := 1.0;
var rivMaxStimTime := 1.0;
var rivResponseCorrectRewardSize% := 2;
var rivMaintainResponseCorrectRewardSize% := 1;
var rivIntertrialTime := 1.0;
var rivUseBeep% := 0;
var rivBeepLengthMS% := 100;


' Counters

var rivCtrNTrials% := 0;
var rivCtrReadyFail% := 0;
var rivCtrNoResponse% := 0;
var rivCtrIncorrect% := 0;
var rivCtrCorrect% := 0;
var rivCtrNRewards% := 0;

' Channel numbers for DAQ inputs

var rivChanXEye%    := 1;
var rivChanYEye%    := 2;

' VSG trigger input channels

var rivChanVSGReady%    :=  20;
var rivChanVSGStim%     :=  21;

' Controls

var rivIsPaused% := 0;
var rivStimHandle := 0;

' States - these constants define a particular state

const stateStartup%             :=  1;
const statePaused%              :=  2;
const stateTrialStart%          :=  3;
const stateBeep%                :=  4;
const stateWaitForReady%        :=  5;
const stateWaitForStimUp%       :=  6;
const stateWaitForResponse%     :=  7;
const stateReward%              :=  8;
const stateMaintainResponse%    :=  9;
const stateMaxResponse%         :=  10;
const stateBreakResponse%       :=  11;
const stateWaitForStimOff%      :=  12;
const stateIntertrialWait%      :=  13;
const stateReadyFail%           :=  14;
const stateIncorrectResponse%   :=  15;
const stateNoResponse%          :=  16;
const stateQuit%                :=  17;
const stateDone%                :=  18;
const stateVSGWait%             :=  19;
const stateVSGConfirm%          :=  20;
const stateStartBlock%          :=  21;

var iState% := stateStartup%;              ' This holds the current state

var tNow:=0;		    ' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		    ' last time we checked for a trigger. 
var xEye, yEye;		    ' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		    ' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	    ' temp var for newly discovered trigger times

func IdleProcessing%()
	var iStatus% := 1;	
    var iLoop% := 0;        ' States can set this to 1 if we stay in state loop
	tNow := MaxTime();

'	xEye := ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
'	yEye := ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;
'	View(XYWindow%).XYAddData(1,xEye,yEye);
    
    repeat
        iLoop% := 0;
        docase 
        case iState% = stateVSGWait% then
            
            ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
            tTrigger := NextTime(ReadyChannel%, tLast, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 0 then
                LogStatus("stateVSGWait", "Got leading edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateVSGConfirm%, tTrigger);                
                iLoop% := 1;
            endif;
            
        case iState% = stateVSGConfirm% then
            
            ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
            tTrigger := NextTime(ReadyChannel%, tLastTrigger, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 1 then                
                LogStatus("stateVSGConfirm", "Got trailing edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateStartBlock%, tTrigger);
                iLoop% := 1;
            endif;
            
        case iState% = stateStartBlock% then
            
            PrepareBlock();
            ChangeStateTo(stateStartTrial%, tNow);
            iLoop% := 1;
            
        case iState% = stateStartTrial% then
            
            PrepareTrial();
            ChangeStateTo(stateBeep%, tNow);
            iLoop% := 1;
            
        case iState% = stateBeep% then
            
            if rivUseBeep% <> 0 then
                LogError("stateBeep", "TODO - implement beep!");
            endif
            ChangeStateTo(stateWaitForReady%, tNow);
            
        case iState% = stateWaitForReady% then
            
            ' Wait for joystick to be positioned in the center. 
        case iState% = stateTrialCompleted% then
            
            PrintLog("Trial completed.\n");
            ' When doing this test, make sure that we don't need a correction trial. If we don't 
            ' do this, then an incorrect answer on the LAST trial of a block will NEVER lead to 
            ' a correction trial. 
            if nTrialsCompleted% = attTrialsPerBlock% and iDoCorrectionTrial% = 0 then
                ChangeStateTo(stateBlockCompleted%, tNow);
            else
                ChangeStateTo(stateStartTrial%, tNow);
            endif
            
        case iState% = stateBlockCompleted% then
            
            PrintLog("Block completed.\n");
            nBlocksCompleted% := nBlocksCompleted% + 1;
            if nBlocksCompleted% = attNumberOfBlocks% then
                ChangeStateTo(stateDone%, tNow);
                Stop%();
                iStatus% := 0;
            else
                ChangeStateTo(stateStartBlock%, tNow);
            endif
            
        else
            
            ' Unknown state!
            Message("Unknown state=" + str$(iState%));
            halt;
            
        endcase;
    until iLoop% = 0;
    
	tLast := tNow;
	return iStatus%;
end;


proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


' PrepareBlock
'
' Prepares variables etc used for driving a block of trials for this expt. 
' TODO 

proc PrepareBlock()
    LogInfo("Preparing block...");
    return
end


' PrepareTrial
'
' Prepares variables etc used for driving a single trial
' TODO 

proc PrepareTrial()
    LogInfo("Preparing trial...");
    return
end

