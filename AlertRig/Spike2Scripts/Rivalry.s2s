#include "../../Spike2Util/TrialBlockGen.s2s"
#include "../../Spike2Util/ChannelUtilities.s2s"
#include "../../Spike2Util/UsreyUtil.s2s"
#include "UsreyGratings.s2s"
#include "Joystick.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"

' Local config variables

const rivMaxTargets% := 2;
var rivNTargets% := 0;
var rivTargetSpecs$[rivMaxTargets%];
var rivMaxWaitForReadyTime := 1.0;
var rivReadyHoldTime    := 1.0;
var rivReadyHoldRewardSize% := 1;
var rivReadyFailWaitTime := 1.0;
var rivMaxResponseTime := 1.0;
var rivResponseFailWaitTime := 3.0;
var rivResponseIncorrectWaitTime := 3.0;
var rivResponseBrokenWaitTime := 3.0;
var rivMaxStimWaitTime := 1.5;
var rivMaxStimTime := 3.0;
var rivResponseCorrectRewardSize% := 3;
var rivMaintainResponseRewardSize% := 1;
var rivSwapRewardSize% := 2;
var rivSwapMinTime := 2;
var rivSwapMaxTime := 4;
var rivSwapMaxResponseTime := 2.0;
var rivMaintainResponseRewardWait := .5;
var rivUseFixation% := 0;
var rivMaxAcquisitionTime := 4;
var rivAcquisitionFailWaitTime := 1;
var rivFixationHoldTime := 0.5;
var rivFixationFailWaitTime := 1;
var rivAlwaysLooking% := 0;
var rivUseBeep% := 1;
var rivCorrectionTrials% := 0;
var rivBeepLengthMS% := 100;
var rivNBlocks% := 10;
var rivNTrialsEachTypePerBlock% := 4;     ' Number of trials/block = this * 2
var rivLeftGrating$ := "-3,0,3,3,100,.5,.5,0,b,s,e";
var rivRightGRating$ := "3,0,3,3,100,.5,.5,0,b,s,e";
var rivLeftGratingX, rivLeftGratingY, rivLeftGratingD;
var rivRightGratingX, rivRightGratingY, rivRightGratingD;
var rivLeftGratingTextItem%;
var rivRightGratingTextItem%;
var rivFixationTextItem%;

' Counters

var rivCtrNTrials% := 0;
var rivCtrReadyFail% := 0;
var rivCtrNoResponse% := 0;
var rivCtrIncorrect% := 0;
var rivCtrCorrect% := 0;
var rivCtrNRewards% := 0;

' Channel numbers for DAQ inputs

var rivChanEyeX%    := 11;
var rivChanEyeY%    := 12;
var rivChanJoy%     := 13;

' VSG trigger input channels

var rivChanVSGReady%    :=  20;
var rivChanVSGStim%     :=  21;
var rivChanVSGSwap%     :=  22;
var rivChanFixpt%       :=  23;

' windows

var rivWindowData%;
var rivWindowXY%;

' display channels

var rivChanMonitor%;
var rivChanJoystickPos%;
var rivChanJoystickRangeL%;
var rivChanJoystickRangeC%;
var rivChanJoystickRangeR%;
var rivChanStimDisplay%;
var rivVCoeff;
var rivVConst;
var rivJoystickDisplayY;
var rivUnitCircleX[36];
var rivUnitCircleY[36];
var rivStimCircleX[36];
var rivStimCircleY[36];

' Controls

var rivIsPaused% := 0;
var rivStimHandle% := 0;
var rivCorrectResponse%;
var rivIncorrectResponse%;
var rivTStartStim;                  ' time at which stim is presented
var rivTLastReward;                 ' time at which last reward was delivered - for maintainence rewards
var rivUniversalIntertrialTime;     ' time to wait between trials
var rivSwapTime;                    ' time to hold between stim swaps

' States - these constants define a particular state

const stateStartup%             :=  1;
const statePaused%              :=  2;
const stateTrialStart%          :=  3;
const stateBeep%                :=  4;
const stateWaitForReady%        :=  5;
const stateWaitForStimUp%       :=  6;
const stateWaitForResponse%     :=  7;
const stateCorrectResponse%     :=  8;
const stateMaintainResponse%    :=  9;
const stateMaxResponse%         :=  10;
const stateBreakResponse%       :=  11;
const stateWaitForStimOff%      :=  12;
const stateIntertrialWait%      :=  13;
const stateReadyFail%           :=  14;
const stateIncorrectResponse%   :=  15;
const stateNoResponse%          :=  16;
const stateQuit%                :=  17;
const stateDone%                :=  18;
const stateVSGWait%             :=  19;
const stateVSGConfirm%          :=  20;
const stateTrialCompleted%      :=  21;
const stateReadyHold%           :=  22;
const stateWaitForSwap%         :=  23;
const stateWaitForSwapResponse% :=  24;
const stateCorrectSwapResponse% :=  25;
const stateNoSwapResponse%      :=  26;
const stateWaitForFixpt%        :=  27;
const stateWaitForAcquisition%  :=  28;
const stateFixationHold%        :=  29;
const stateAcquisitionFail%     :=  30;
const stateFixationFail%        :=  31;

var iState% := stateStartup%;              ' This holds the current state

var tNow:=0;		    ' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		    ' last time we checked for a trigger. 
var xEye, yEye;		    ' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		    ' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tLastReward := -1;
var tTrigger:=-1;	    ' temp var for newly discovered trigger times
var doCorrectionTrial% := 0;    ' this is set to 1 when a trial fails and correction trials were requested
var isCorrectionTrial% := 0;    ' this is set to 1 when we are in a trial that is a correction trial

'===========================================================================================
'
' Script execution starts here. 
'
'===========================================================================================

LogInit(1);
InitJoystick(13);
tbgInit(2, rivNTrialsEachTypePerBlock%, rivNBlocks%);


if RivalryDialog%() = 0 then
    halt;
endif

' Stupid checks
if rivSwapMaxTime < rivSwapMinTime then
    Message("Duh! Swap max time must be greater than swap min time!");
    halt;
endif

' Sampling config
CreateSampleConfiguration();

' Prepare display windows, input channels, etc. 
InitializeWindows();

' Set up toolbar and launch
InitializeToolbar();




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration - Set up recording channels, dig input channels for VSG communication
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc CreateSampleConfiguration()
	var index;
    
	SampleClear(); 'Set standard sampling state
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 3);
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 1);
    SampleAutoName$(dataCellName$ + "_riv_000");
	SampleAutoFile(1);
    
	'Channel recording definitions
	SampleEvent(rivChanVSGStim%, 2, 2, 3600); 'Trigger channel, level
	SampleComment$(rivChanVSGStim%, "Stim");
	SampleTitle$(rivChanVSGStim%, "Stim");
    
	SampleEvent(rivChanVSGSwap%, 3, 2, 3600); 'Trigger channel, level
	SampleComment$(rivChanVSGSwap%, "Swap");
	SampleTitle$(rivChanVSGSwap%, "Swap");
    
	SampleEvent(rivChanFixpt%, 4, 2, 3600); 'Trigger channel, level
	SampleComment$(rivChanFixpt%, "Fixpt");
	SampleTitle$(rivChanFixpt%, "Fixpt");
	
	SampleEvent(rivChanVSGReady%, 6, 2, 3600); 'Trigger channel, level
	SampleComment$(rivChanVSGReady%, "VSG Ready");
	SampleTitle$(rivChanVSGReady%, "VSG Ready");
    
	SampleWaveform(rivChanJoy%, 13, 1000);
	SampleTitle$(rivChanJoy%, "Joy");
    
    
	SampleWaveform(rivChanEyeX%, 14, 1000);
	SampleTitle$(rivChanEyeX%, "Eye X");
	SampleWaveform(rivChanEyeY%, 15, 1000);
	SampleTitle$(rivChanEyeY%, "Eye Y");

    
	SampleSequencer(script$ + "Rivalry.pls");
	SampleOptimise(2, 2, 2, 2, 50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling

end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
'	UpdateToolbarText();
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",Pause%);
	ToolbarSet(5,"Resume stimuli",Resume%);
	ToolbarSet(6,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeWindows - Open data file, set up windows for online display.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc InitializeWindows()
    var i%;
	var twopi;
    ' These set the max and min window dimensions. They are also used to scale the joystick 
    ' position to the xy display, so if you change the size of the window, do it by changing
    ' these vars!
    var xyXMin := -20;
    var xyXMax := 20;
    var xyYMin := -15;
    var xyYMax := 15;
    var lh, cl, ch, rl;
    rivJoystickDisplayY := -12;     ' y coord in xy window where joystick position is shown. 
    
	'Open the data sampling window
	rivWindowData% := FileNew(0,4);
	Window(0,48,100,95);
	View(rivWindowData%).WindowVisible(1);

	'Open an XY view to display eye position
	rivWindowXY% := FileNew(12);
	XRange(xyXMin, xyXMax);
	YRange(-2, xyYMin, xyYMax);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
	'Create a new channel in the XY view to show the monitor's location
	rivChanMonitor% := XYSetChan(0);
	XYColour(rivChanMonitor%, 13);
	XYDrawMode(rivChanMonitor%, 3, 1);
	XYJoin(rivChanMonitor%, 2);
	XYAddData(rivChanMonitor%, -9, -7);
	XYAddData(rivChanMonitor%, 9, -7);
	XYAddData(rivChanMonitor%, 9, 7);
	XYAddData(rivChanMonitor%, -9, 7);
    
    ' Set up joystick range numbers
    lh := GetJoystickLeftHigh();
    cl := GetJoystickCenterLow();
    ch := GetJoystickCenterHigh();
    rl := GetJoystickRightLow();
    
    ' We'll take the joystick voltage 'v' (which should be between 1 and 4volts) and 
    ' convert it for display in the xy window like this:
    ' x coord = v * rivVCoeff + rivVConst;
    
    rivVCoeff := (xyXMax - xyXMin)/3;
    rivVConst := -2.5 * rivVCoeff;
    
    rivChanJoystickRangeL% := XYSetChan(0);
    XYColour(rivChanJoystickRangeL%, 13);
    XYSize(rivChanJoystickRangeL%, 2);
    XYJoin(rivChanJoystickRangeL%, 1);
    XYDrawMode(rivChanJoystickRangeL%, 4, 3);
    XYAddData(rivChanJoystickRangeL%, xyXMin, rivJoystickDisplayY+1);
    XYAddData(rivChanJoystickRangeL%, lh * rivVCoeff + rivVConst, rivJoystickDisplayY+1);
    
    rivChanJoystickRangeC% := XYSetChan(0);
    XYColour(rivChanJoystickRangeC%, 13);
    XYSize(rivChanJoystickRangeC%, 2);
    XYJoin(rivChanJoystickRangeC%, 1);
    XYDrawMode(rivChanJoystickRangeC%, 4, 3);
    XYAddData(rivChanJoystickRangeC%, cl * rivVCoeff + rivVConst, rivJoystickDisplayY+1);
    XYAddData(rivChanJoystickRangeC%, ch * rivVCoeff + rivVConst, rivJoystickDisplayY+1);
    
    rivChanJoystickRangeR% := XYSetChan(0);
    XYColour(rivChanJoystickRangeR%, 13);
    XYSize(rivChanJoystickRangeR%, 2);
    XYJoin(rivChanJoystickRangeR%, 1);
    XYDrawMode(rivChanJoystickRangeR%, 4, 3);
    XYAddData(rivChanJoystickRangeR%, rl * rivVCoeff + rivVConst, rivJoystickDisplayY+1);
    XYAddData(rivChanJoystickRangeR%, xyXMax, rivJoystickDisplayY+1);
    
    
    ' this channel is for a symbol representing the actual joystick position
    rivChanJoystickPos% := XYSetChan(0);
    XYColour(rivChanJoystickPos%, 11);
    XYDrawMode(rivChanJoystickPos%, 1, 8);
    XYDrawMode(rivChanJoystickPos%, 2, 10);
    XYSize(rivChanJoystickPos%, -1);
    
    ' this channel is for displaying the stimulus
    rivChanStimDisplay% := XYSetChan(0);
    XYColour(rivChanStimDisplay%, 8);
    XYDrawMode(rivChanStimDisplay%, 2, 0);
    XYDrawMode(rivChanStimDisplay%, 3, 0);
    XYJoin(rivChanStimDisplay%, 2);
    XYSize(rivChanStimDisplay%, 36);
    
	twopi := 2.0*4.0*ATan(1.0);
	for i% := 0 to 35 do
		rivUnitCircleX[i%] := Cos(i% * twopi/36.0);
		rivUnitCircleY[i%] := Sin(i% * twopi/36.0);
	next;

    
end;

proc DisplayStim(iOn%)
    
    View(rivWindowXY%).XYDelete(rivChanStimDisplay%);
    if iOn% <> 0 then
        if rivCorrectResponse% = JSLeft% then
            ArrConst(rivStimCircleX[], rivUnitCircleX[]);
            ArrMul(rivStimCircleX[], rivLeftGratingD/2);
            ArrAdd(rivStimCircleX[], rivLeftGratingX);
            ArrConst(rivStimCircleY[], rivUnitCircleY[]);
            ArrMul(rivStimCircleY[], rivLeftGratingD/2);
            ArrAdd(rivStimCircleY[], rivLeftGratingY);
        else
            ArrConst(rivStimCircleX[], rivUnitCircleX[]);
            ArrMul(rivStimCircleX[], rivRightGratingD/2);
            ArrAdd(rivStimCircleX[], rivRightGratingX);
            ArrConst(rivStimCircleY[], rivUnitCircleY[]);
            ArrMul(rivStimCircleY[], rivRightGratingD/2);
            ArrAdd(rivStimCircleY[], rivRightGratingY);
        endif
        View(rivWindowXY%).XYAddData(rivChanStimDisplay%, rivStimCircleX[], rivStimCircleY[]);
    endif
    return;
end

func IdleProcessing%()
	var iStatus% := 1;	
    var iLoop% := 0;        ' States can set this to 1 if we stay in state loop
    var joystickPosition%;
    var joystickVoltage;
    
	tNow := MaxTime();
    
    ' Get and display joystick voltage and position
    joystickPosition% := GetJoystickPosition%(joystickVoltage);
    View(rivWindowXY%).XYAddData(rivChanJoystickPos%, joystickVoltage * rivVCoeff + rivVConst, rivJoystickDisplayY);
    
    if tNow > 0.005 then
        xEye := ChanMeasure(rivChanEyeX%, 2, tNow, tNow-.005) * DegreesPerVoltX;
        yEye := ChanMeasure(rivChanEyeY%, 2, tNow-.001, tNow-.006) * DegreesPerVoltY;
        View(rivWindowXY%).XYAddData(1, xEye, yEye);
    endif
    
    repeat
        iLoop% := 0;
        docase 
        case iState% = stateStartup% then
            
            LogStatus("stateStartup", "Starting up.");
            ChangeStateTo(stateVSGWait%, tNow);
            iLoop% := 1;
            
        case iState% = stateVSGWait% then
            
            ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
            tTrigger := NextTime(rivChanVSGReady%, tLast, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 0 then
                LogStatus("stateVSGWait", "Got leading edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateVSGConfirm%, tTrigger);                
                iLoop% := 1;
            endif;
            
        case iState% = stateVSGConfirm% then
            
            ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
            tTrigger := NextTime(rivChanVSGReady%, tLastTrigger, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 1 then                
                LogStatus("stateVSGConfirm", "Got trailing edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateTrialStart%, tTrigger);
                iLoop% := 1;
            endif;
            
        case iState% = stateTrialStart% then
            
            var s%;
            s% := PrepareTrial%();
            if s% = 1 then
                ChangeStateTo(stateBeep%, tNow);
            else
                ChangeStateTo(stateDone%, tNow);
            endif
            iLoop% := 1;
            
        case iState% = stateBeep% then
            
            if rivUseBeep% <> 0 then
                Sound("ding", 1);
            endif
            Yield(.5);
            ChangeStateTo(stateWaitForReady%, tNow);
            iLoop% := 1;
            
        case iState% = stateWaitForReady% then
            
            ' Wait for joystick to be positioned in the center. 
            docase
            case joystickPosition% = JSCenter% then
                LogStatus("WaitForReady", "Joystick ready.");
                ChangeStateTo(stateReadyHold%, tNow);
            case tNow - tStateStart > rivMaxWaitForReadyTime then
                LogStatus("WaitForReady", "Ready wait time expired.");
                ChangeStateTo(stateReadyFail%, tNow);
            endcase
            iLoop% := 0;
            
        case iState% = stateReadyHold% then
            
            iLoop% := 0;
            docase
            case tNow - tStateStart > rivReadyHoldTime then
                LogStatus("stateReadyHold", "Ready hold time met.");
                if rivReadyHoldRewardSize% > 0 then
                    DeliverReward(rivReadyHoldRewardSize%, tNow);
                    Yield(.1);
                endif
                SampleKey("F");
                ChangeStateTo(stateWaitForFixpt%, tNow);
            case joystickPosition% <> JSCenter% then
                LogStatus("stateReadyHold", "Joystick not in ready position.");
                ChangeStateTo(stateReadyFail%, tNow);
                iLoop% := 1;
            endcase
            
        case iState% = stateWaitForFixpt% then
            
                ' TODO: Check for js ready here? Exit to what state?
            iLoop% := 0;
            docase
            case FindRisingEdge%(rivChanFixpt%, tStateStart, tTrigger) = 0 then
                ' Fixpt is up
                LogStatus("stateWaitForFixpt", "Fixpt is up.");
                ChangeStateTo(stateWaitForAcquisition%, tNow);
                iLoop% := 1;
            endcase
                
        case iState% = stateWaitForAcquisition% then
            
            ' Waiting for eye to fall in fixation window. Joystick must remain in ready position.
            docase
            case joystickPosition% <> JSCenter% then
                LogStatus("stateWaitForAcquisition", "Joystick not in ready position.");
                ChangeStateTo(stateAcquisitionFail%, tNow);
            case Looking%(xEye, yEye) = 1 then
                LogStatus("stateWaitForAcquisition", "Eye in fixation window.");
                ChangeStateTo(stateFixationHold%, tNow);
            case tNow - tStateStart > rivMaxAcquisitionTime then
                LogStatus("stateWaitForAcquisition", "Acquisition time is up!");
                ChangeStateTo(stateAcquisitionFail%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateFixationHold% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> JSCenter% then
                LogStatus("stateFixationHold", "Joystick not in ready position.");
                ChangeStateTo(stateFixationFail%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateFixationHold", "Eye not in fixation window.");
                ChangeStateTo(stateFixationFail%, tNow);
            case tNow - tStateStart > rivFixationHoldTime then
                ChangeStateTo(stateWaitForStimUp%, tNow);
                docase 
                case rivCorrectResponse% = JSLeft% then
                    SampleKey("l");
                case rivCorrectResponse% = JSRight% then
                    SampleKey("r");
                else
                    LogError("stateWaitForReady", "Correct response unknown");
                    Stop%();
                endcase
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateAcquisitionFail% then
            
            rivUniversalIntertrialTime := rivAcquisitionFailWaitTime;
            SampleKey("X");
            ChangeStateTo(stateWaitForStimOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateFixationFail% then
            
            rivUniversalIntertrialTime := rivFixationFailWaitTime;
            SampleKey("X");
            ChangeStateTo(stateWaitForStimOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateReadyFail% then
            
            rivCtrReadyFail% += 1;
            rivUniversalIntertrialTime := rivReadyFailWaitTime;
            ChangeStateTo(stateIntertrialWait%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForStimUp% then
            
            ' Waiting for stim signal on channel StimChannel%
			tTrigger := NextTime(rivChanVSGStim%, tLastTrigger, vTrigger);
			if tTrigger > tLastTrigger and vTrigger = 0 then
				LogStatus("stateVSGWaitForStimUp", "Stimulus is up.\n");
                DisplayStim(1);
				tLastTrigger := tTrigger;
                rivTStartStim := tTrigger;
				ChangeStateTo(stateWaitForResponse%, tTrigger);
			endif;
            iLoop% := 0;
            
        case iState% = stateWaitForResponse% then
            
            ' Waiting for response. PrepareTrial() sets the global var rivCorrectResponse% (and rivIncorrectResponse%) 
            ' to either JSLeft% or JSRight%.
            iLoop% := 1;
            docase
            case joystickPosition% = rivCorrectResponse% then
                LogStatus("stateWaitForResponse", "Correct response!");
                ChangeStateTo(stateCorrectResponse%, tNow);
                iLoop% := 1;
            case joystickPosition% = rivIncorrectResponse% then
                LogStatus("stateWaitForResponse", "Incorrect response!");
                ChangeStateTo(stateIncorrectResponse%, tNow);
                iLoop% := 1;
            case tNow - tStateStart > rivMaxResponseTime then
                LogStatus("stateWaitForResponse", "No response!");
                ChangeStateTo(stateNoResponse%, tNow);
                iLoop% := 1;
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateNoResponse% then
            
            doCorrectionTrial% := 1;
            rivCtrNoResponse% += 1;
            SampleKey("X");
            rivUniversalIntertrialTime := rivResponseFailWaitTime;
            ChangeStateTo(stateWaitForStimOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateCorrectResponse% then
            
            doCorrectionTrial% := 0;
            rivCtrCorrect% += 1;
            DeliverReward(rivResponseCorrectRewardSize%, tNow);
            UpdateSwapValues(0);
            ChangeStateTo(stateMaintainResponse%, tNow);
            iLoop% := 0;
            
        case iState% = stateIncorrectResponse% then
            
            doCorrectionTrial% := 1;
            rivCtrIncorrect% += 1;
            SampleKey("X");
            rivUniversalIntertrialTime := rivResponseIncorrectWaitTime;
            ChangeStateTo(stateWaitForStimOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateMaintainResponse% then
            
            ' If subject maintains correct response for specified amount of time, deliver another
            ' reward, loop again. Upper time limit on this loop applies. 
            
            iLoop% := 1;
            docase
            case joystickPosition% <> rivCorrectResponse% then
                LogStatus("stateMaintainResponse", "Correct response broken!");
                rivUniversalIntertrialTime := rivResponseBrokenWaitTime;
                SampleKey("X");
                ChangeStateTo(stateWaitForStimOff%, tNow);
                iLoop% := 0;
            case tNow - rivTStartStim > rivMaxStimTime then
                LogStatus("stateMaintainResponse", "Max response time reached. Moving on...");
                rivUniversalIntertrialTime := rivMaxStimWaitTime;
                SampleKey("X");
                ChangeStateTo(stateWaitForStimOff%, tNow);
                iLoop% := 0;
            case joystickPosition% = rivCorrectResponse% then
                
                ' Check for maintenance reward
                if tLastReward > 0 and tNow - tLastReward > rivMaintainResponseRewardWait then
                    DeliverReward(rivMaintainResponseRewardSize%, tNow);
                endif
                
                if  tNow - tStateStart > rivSwapTime then
                    LogStatus("stateMaintainResponse", "Request stim swap.");
                    SampleKey("z");
                    UpdateSwapValues(1);
'                    DeliverReward(rivMaintainResponseRewardSize%);
                    ChangeStateTo(stateWaitForSwap%, tNow);
                endif
                
                iLoop% := 0;
            else
                LogError("stateMaintainResponse", "Unknown condition!!!");
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForSwap% then
            
            if FindEdge%(rivChanVSGSwap%, tStateStart, tTrigger) > -1 then
                LogStatus("stateWaitForSwap", "Swap detected.");
                DisplayStim(1);
                ChangeStateTo(stateWaitForSwapResponse%, tNow);
                iLoop% := 0;
            endif
            
        case iState% = stateWaitForSwapResponse% then
            
            ' The stim has been swapped, and the value of rivCorrectResponse has been set to the 
            ' new stim position. We anxiously await a response.
            
            iLoop% := 1;
            docase
            case joystickPosition% = rivCorrectResponse% then
                LogStatus("stateWaitForSwapResponse", "Correct response!");
                ChangeStateTo(stateCorrectSwapResponse%, tNow);
                iLoop% := 1;
            case tNow - tStateStart > rivSwapMaxResponseTime then
                LogStatus("stateWaitForSwapResponse", "No response!");
                ChangeStateTo(stateNoSwapResponse%, tNow);
                iLoop% := 1;
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateCorrectSwapResponse% then
            
            DeliverReward(rivSwapRewardSize%, tNow);
            ChangeStateTo(stateMaintainResponse%, tNow);
            iLoop% := 0;
            
        case iState% = stateNoSwapResponse% then
            
            SampleKey("X");
            rivUniversalIntertrialTime := rivResponseBrokenWaitTime;
            ChangeStateTo(stateWaitForStimOff%, tNow);
            iLoop% := 0;

        case iState% = stateWaitForStimOff% then
            
            ' Waiting for stim signal off channel StimChannel%
            iLoop% := 0;
			tTrigger := NextTime(rivChanVSGStim%, tLastTrigger, vTrigger);
			if tTrigger > tLastTrigger and vTrigger = 1 then
				LogStatus("stateVSGWaitForStimUp", "Stimulus is off.\n");
                DisplayStim(0);
				tLastTrigger := tTrigger;
				ChangeStateTo(stateIntertrialWait%, tTrigger);
                iLoop% := 1;
			endif;
            
        case iState% = stateIntertrialWait% then
            
            ' Any states that exit to here should have set the universal intertrial wait time!
            iLoop% := 0;
            if tNow - tStateStart > rivUniversalIntertrialTime then
                ChangeStateTo(stateTrialCompleted%, tNow);
                iLoop% := 1;
            endif
            
        case iState% = stateTrialCompleted% then
            
            LogStatus("stateTrialCompleted", "Trial completed.");
            ' If correction trials are required, deal with that now....
            ChangeStateTo(stateTrialStart%, tNow);
            iLoop% := 1;
            
        case iState% = stateDone% then
            
            LogStatus("stateDone", "Reached done state. Calling Stop%()...\n");
            iLoop% := 0;
            iStatus% := 0;
            
        else
            
            ' Unknown state!
            Message("Unknown state=" + str$(iState%));
            halt;
            
        endcase;
    until iLoop% = 0;
    
	tLast := tNow;
	return iStatus%;
end;


proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;

proc DeliverReward(iNumRewards%, t)
    tLastReward := t;
    SampleSeqVar(1, iNumRewards%);
    SampleKey("R");
    return;
end

func Reward%()
    DeliverReward(1, -1);
    return 1;
end


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	if rivStimHandle% > 0 then
        ProgKill(rivStimHandle%);
        while ProgStatus(rivStimHandle%) > 0 do
            Yield();
        wend
        rivStimHandle% := 0;
    endif
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()

	' Disable idle process func
	ToolbarSet(0, "");

	' Tell stim app to shut down
	SampleKey("q");
	Yield(.1);
	SampleStop();

	if rivStimHandle% > 0 then
        ProgKill(rivStimHandle%);
        while ProgStatus(rivStimHandle%) > 0 do
            Yield();
        wend
        rivStimHandle% := 0;
    endif
    return 0;

end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    var cmdLine$;
    var h, contrast%, sf, tf, ori, cv$, pattern$, aperture$;
    
    ' Parse the grating coordinates for display in the xy window
    ParseGratingParameters%(rivLeftGrating$, rivLeftGratingX, rivLeftGratingY, rivLeftGratingD, h, contrast%, sf, tf, ori, cv$, pattern$, aperture$);
    ParseGratingParameters%(rivRightGrating$, rivRightGratingX, rivRightGratingY, rivRightGratingD, h, contrast%, sf, tf, ori, cv$, pattern$, aperture$);

    ' Start sampling
   	SampleStart(0);

    ' Hack to just run the darned thing. 
    cmdLine$ := "cmd /k " + GetBinDir$(1) + "gratings -d 555 -b gray -s " + rivLeftGrating$ + " -s " + rivRightGrating$;
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	LogInfo(cmdLine$+"\n");
	rivStimHandle% := ProgRun(cmdLine$, 1);
	if rivStimHandle% < 0 then Message("Could not start stimulus."); halt; endif
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(1,0);
	ToolbarEnable(2,1);
	ToolbarEnable(4,1);
	View(rivWindowData%);
    return 1;
end;

func Pause%()
    LogInfo("Pause requested.");
    rivIsPaused% := 1;
    return 1;
end

func Resume%()
    LogInfo("Resume requested.");
    rivIsPaused% := 0;
    return 1;
end

' UpdateSwapValues(iUpdateCorrectResponse)
'
' Compute the (random) time before another stim swap. If 'UpdateCorrectResponse
' is nonzero, also resets the correct js position. 

proc UpdateSwapValues(iJS%)
    
    rivSwapTime := Rand(rivSwapMaxTime - rivSwapMinTime, rivSwapMinTime);
    
    if iJS% <> 0 then
        docase
        case rivCorrectResponse% = JSLeft% then
            rivCorrectResponse% := JSRight%;
        case rivCorrectResponse% = JSRight% then
            rivCorrectResponse% := JSLeft%;
        else
            LogError("UpdateSwapValues", "ERROR! Unknown value for rivCorrectResponse (" + str$(rivCorrectResponse%) + ")");
            rivCorrectResponse% := JSUndefined%;
        endcase
    endif
    
    return;
end


' PrepareBlock
'
' Prepares variables etc used for driving a block of trials for this expt. 
' TODO 

proc PrepareBlock()
    LogInfo("Preparing block...");
    tbgInit(2, rivNTrialsEachTypePerBlock%, rivNBlocks%);
    return
end

' PrepareTrial
'
' Prepares variables etc used for driving a single trial

func PrepareTrial%()
    var index%;
    var s%;
    if rivCorrectionTrials% = 1 and doCorrectionTrial% = 1 then
        docase
        case rivCorrectResponse% = JSLeft% then
            LogInfo("Correction trial... LEFT");
            s% := 1;
        case rivCorrectResponse% = JSRight% then
            LogInfo("Correction trial... RIGHT");
            s% := 1;
        else
            LogError("", "Unknown correct response value!!!\n");
            s% := 0;
        endcase
    else
        s% := tbgGetTrialIndex%(index%);
        if s% = 1 then
            docase
            case index% = 0 then
                LogInfo("Preparing trial... LEFT");
                rivCorrectResponse% := JSLeft%;
                rivIncorrectResponse% := JSRight%;
            case index% = 1 then
                LogInfo("Preparing trial... RIGHT");
                rivCorrectResponse% := JSRight%;
                rivIncorrectResponse% := JSLeft%;
            else
                LogError("", "Unknown index returned from tbgGetTrialIndex%.\n");
            endcase
        endif
    endif
    
    return s%;
end


func RivalryDialog%()
    var i%;
    GetRivalryParameters();
    DlgCreate("Rivalry Parameters");
    DlgGroup("General", 1, 1, 50, 6);
    DlgInteger(1, "# of blocks", 1, 100, 25, 2);
    DlgInteger(2, "Trials per block", 1, 100, 25, 3);
    DlgCheck(3, "Use beep?", 1, 4);
    DlgCheck(4, "Correction trials?", 1, 5);
    DlgInteger(5, "Beep length (ms)", 1, 1000, 25, 6);
    DlgButton(101, "Timing", RivalryTimingDialog%, 1, 7);
    DlgGroup("Reward/Swap", 1, 8, 50, 10);
    DlgReal(6, "Ready hold time (s)", .1, 10, 25, 9);
    DlgInteger(7, "Ready hold reward", 0, 10, 25, 10);
    DlgInteger(8, "Reward (correct resp)", 1, 10, 25, 11);
    DlgInteger(9, "Reward (maintain)", 1, 10, 25, 12);
    DlgReal(10, "Reward wait (maintain)", 0.01, 10, 25, 13);
    DlgInteger(11, "Reward (swap)", 1, 10, 25, 14);
    DlgReal(12, "Swap time - min", 0.01, 20, 25, 15);
    DlgReal(13, "Swap time - max", 0.01, 20, 25, 16);
    DlgReal(14, "Max stim time (s)", .01, 20, 25, 17);
    DlgGroup("Fixation", 1, 18, 50, 3);
    DlgCheck(15, "Use Fixation?", 1, 19);
    DlgButton(104, "Fixation Settings", RivalryFixationDialog%, 1, 20);
    DlgGroup("Gratings", 1, 21, 50, 3);
    DlgButton(102, "Left Grating", RivalryLGratingDialog%, 1, 22);
    rivLeftGratingTextItem% := DlgText(rivLeftGrating$, 15, 22);
    DlgButton(103, "Right Grating", RivalryRGratingDialog%, 1, 23);
    rivRightGratingTextItem% := DlgText(rivRightGrating$, 15, 23);
    i% := DlgShow(rivNBlocks%, rivNTrialsEachTypePerBlock%, rivUseBeep%, rivCorrectionTrials%, rivBeepLengthMS%, rivReadyHoldTime, 
                  rivReadyHoldRewardSize%, rivResponseCorrectRewardSize%, rivMaintainResponseRewardSize%, rivMaintainResponseRewardWait, 
                  rivSwapRewardSize%, rivSwapMinTime, rivSwapMaxTime, rivMaxStimTime, rivUseFixation%);
    if i% = 1 then
        SaveRivalryParameters();
    endif
    return i%;
end

proc GetRivalryParameters()
    var key$;
    var stmp$;
    key$ := GetRegistryKey$(1) + "\\Rivalry";
    rivLeftGrating$ := GetStringRegistryValue$(key$, "LeftGrating", rivLeftGrating$);
    rivRightGrating$ := GetStringRegistryValue$(key$, "RightGrating", rivRightGrating$);
    rivNBlocks% := GetIntRegistryValue%(key$, "NBlocks", rivNBlocks%);
    rivNTrialsEachTypePerBlock% := GetIntRegistryValue%(key$, "NTrialsEachTypePerBlock", rivNTrialsEachTypePerBlock%);
    rivUseBeep% := GetIntRegistryValue%(key$, "UseBeep", rivUseBeep%);
    rivCorrectionTrials% := GetIntRegistryValue%(key$, "CorrectionTrials", rivCorrectionTrials%);
    rivBeepLengthMS% := GetIntRegistryValue%(key$, "BeepLengthMS", rivBeepLengthMS%);
    rivResponseCorrectRewardSize% := GetIntRegistryValue%(key$, "ResponseCorrectRewardSize", rivResponseCorrectRewardSize%);
    rivMaintainResponseRewardSize% := GetIntRegistryValue%(key$, "MaintainResponseRewardSize", rivMaintainResponseRewardSize%);
    rivMaintainResponseRewardWait := GetFloatRegistryValue(key$, "MaintainResponseRewardWait", rivMaintainResponseRewardWait);
    rivSwapRewardSize% := GetIntRegistryValue%(key$, "SwapRewardSize", rivSwapRewardSize%);
    rivSwapMinTime := GetFloatRegistryValue(key$, "SwapMinTime", rivSwapMinTime);
    rivSwapMaxTime := GetFloatRegistryValue(key$, "SwapMaxTime", rivSwapMaxTime);
    rivMaxStimTime := GetFloatRegistryValue(key$, "MaxStimTime", rivMaxStimTime);
    rivMaxWaitForReadyTime := GetFloatRegistryValue(key$, "MaxWaitForReadyTime", rivMaxWaitForReadyTime);
    rivReadyFailWaitTime := GetFloatRegistryValue(key$, "ReadyFailWaitTime", rivReadyFailWaitTime);
    rivSwapMaxResponseTime := GetFloatRegistryValue(key$, "SwapMaxResponseTime", rivSwapMaxResponseTime);
    rivMaxResponseTime := GetFloatRegistryValue(key$, "MaxResponseTime", rivMaxResponseTime);
    rivResponseFailWaitTime := GetFloatRegistryValue(key$, "ResponseFailWaitTime", rivResponseFailWaitTime);
    rivResponseIncorrectWaitTime := GetFloatRegistryValue(key$, "ResponseIncorrectWaitTime", rivResponseIncorrectWaitTime);
    rivResponseBrokenWaitTime := GetFloatRegistryValue(key$, "ResponseBrokenWaitTime", rivResponseBrokenWaitTime);
    rivMaxStimWaitTime := GetFloatRegistryValue(key$, "MaxStimWaitTime", rivMaxStimWaitTime);
    rivReadyHoldRewardSize% := GetIntRegistryValue%(key$, "ReadyHoldRewardSize", rivReadyHoldRewardSize%);
    rivReadyHoldTime := GetFloatRegistryValue(key$, "ReadyHoldTime", rivReadyHoldTime);
    
    rivUseFixation% := GetIntRegistryValue%(key$, "UseFixation", rivUseFixation%);
    rivMaxAcquisitionTime := GetFloatRegistryValue(key$, "MaxAcquisitionTime", rivMaxAcquisitionTime);
    rivAcquisitionFailWaitTime := GetFloatRegistryValue(key$, "AcquisitionFailWaitTime", rivAcquisitionFailWaitTime);
    rivFixationHoldTime := GetFloatRegistryValue(key$, "FixationHoldTime", rivFixationHoldTime);
    rivFixationFailWaitTime := GetFloatRegistryValue(key$, "FixationFailWaitTime", rivFixationFailWaitTime);
end

proc SaveRivalryParameters()
    var key$;
    var stmp$;
    key$ := GetRegistryKey$(1) + "\\Rivalry";
    SetStringRegistryValue(key$, "LeftGrating", rivLeftGrating$);
    SetStringRegistryValue(key$, "RightGrating", rivRightGrating$);
    SetIntRegistryValue(key$, "NBlocks", rivNBlocks%);
    SetIntRegistryValue(key$, "NTrialsEachTypePerBlock", rivNTrialsEachTypePerBlock%);
    SetIntRegistryValue(key$, "UseBeep", rivUseBeep%);
    SetIntRegistryValue(key$, "CorrectionTrials", rivCorrectionTrials%);
    SetIntRegistryValue(key$, "BeepLengthMS", rivBeepLengthMS%);
    SetIntRegistryValue(key$, "ResponseCorrectRewardSize", rivResponseCorrectRewardSize%);
    SetIntRegistryValue(key$, "MaintainResponseRewardSize", rivMaintainResponseRewardSize%);
    SetFloatRegistryValue(key$, "MaintainResponseRewardWait", rivMaintainResponseRewardWait);
    SetIntRegistryValue(key$, "SwapRewardSize", rivSwapRewardSize%);
    SetFloatRegistryValue(key$, "SwapMinTime", rivSwapMinTime);
    SetFloatRegistryValue(key$, "SwapMaxTime", rivSwapMaxTime);
    SetFloatRegistryValue(key$, "MaxStimTime", rivMaxStimTime);
    SetFloatRegistryValue(key$, "MaxWaitForReadyTime", rivMaxWaitForReadyTime);
    SetFloatRegistryValue(key$, "ReadyFailWaitTime", rivReadyFailWaitTime);
    SetFloatRegistryValue(key$, "MaxResponseTime", rivMaxResponseTime);
    SetFloatRegistryValue(key$, "SwapMaxResponseTime", rivSwapMaxResponseTime);
    SetFloatRegistryValue(key$, "ResponseFailWaitTime", rivResponseFailWaitTime);
    SetFloatRegistryValue(key$, "ResponseIncorrectWaitTime", rivResponseIncorrectWaitTime);
    SetFloatRegistryValue(key$, "ResponseBrokenWaitTime", rivResponseBrokenWaitTime);
    SetFloatRegistryValue(key$, "MaxStimWaitTime", rivMaxStimWaitTime);
    SetIntRegistryValue(key$, "ReadyHoldRewardSize", rivReadyHoldRewardSize%);
    SetFloatRegistryValue(key$, "ReadyHoldTime", rivReadyHoldTime);
    SetIntRegistryValue(key$, "UseFixation", rivUseFixation%);
    SetFloatRegistryValue(key$, "MaxAcquisitionTime", rivMaxAcquisitionTime);
    SetFloatRegistryValue(key$, "AcquisitionFailWaitTime", rivAcquisitionFailWaitTime);
    SetFloatRegistryValue(key$, "FixationHoldTime", rivFixationHoldTime);
    SetFloatRegistryValue(key$, "FixationFailWaitTime", rivFixationFailWaitTime);
end

func RivalryFixationDialog%()
    DlgCreate("Rivarly Fixation parameters");
    DlgReal(1, "Max acq. time(s):", .01, 100);
    DlgReal(2, "Acq. FAIL wait time(s):", .01, 10);
    DlgReal(3, "Fixation hold time(s):", 0.01, 10);
    DlgReal(4, "Fix. BREAK wait time(s):", 0.01, 10);
    DlgCheck(5, "Always Looking (TESTING)");
    DlgShow(rivMaxAcquisitionTime, rivAcquisitionFailWaitTime, rivFixationHoldTime, rivFixationFailWaitTime, rivAlwaysLooking%);
    return 1;
end


func RivalryTimingDialog%()
	DlgCreate("Rivalry timing", 25, 10);
	DlgReal(1, "Max rdy time(s):", .01, 10);
	DlgReal(2, "Rdy FAIL wait time(s):", .01, 10);
    DlgReal(3, "Max resp time(s):", .01, 10);
    DlgReal(4, "Swap resp time(s):", .01, 10);
    DlgReal(5, "Resp FAIL wait time(s):", .01, 10);
    DlgReal(6, "Resp INCORRECT wait time(s):", .01, 10);
    DlgReal(7, "Resp BROKEN wait time(s):", .01, 10);
    DlgReal(8, "Max stim wait time(s):", .01, 10);
	DlgShow(rivMaxWaitForReadyTime, rivReadyFailWaitTime, rivMaxResponseTime, rivSwapMaxResponseTime, rivResponseFailWaitTime, 
            rivResponseIncorrectWaitTime, rivResponseBrokenWaitTime, rivMaxStimWaitTime);
    return 1;
end

func DoGratingDialog%(label$, &param$)
    var status%;
    var disable%[1];
    var ndisable% := 0;
    var x, y, w, h, sf, tf, orientation;
    var contrast%;
    var cv$, pattern$, aperture$;
    
    status% := GratingParametersDialog%(label$, param$,
                                        disable%[], ndisable%, 
                                        x, y, w, h, contrast%, sf, tf, orientation, cv$, pattern$, aperture$);                                       
    return status%;
end

func RivalryLGratingDialog%()
    var s%;
    s% := DoGratingDialog%("Left Grating Params", rivLeftGrating$);
    if s% = 1 then
        DlgValue$(rivLeftGratingTextItem%, rivLeftGrating$);
    endif
    return 1;
end


func RivalryRGratingDialog%()
    var s%;
    s% := DoGratingDialog%("Right Grating Params", rivRightGrating$);
    if s% = 1 then
        DlgValue$(rivRightGratingTextItem%, rivRightGrating$);
    endif
    return 1;
end

func Looking%(x, y)
	'Determine if the eye position is within the fixation window
    var s% := 0;
    docase
    case rivAlwaysLooking% = 1 then
        s% := 1;
    case (Pow(x-FixationX, 2) + Pow(y-FixationY, 2)) <= Pow(WindowRadius, 2) then 
        s% := 1; 
    else 
        s% := 0; 
    endcase
    return s%;
end;
