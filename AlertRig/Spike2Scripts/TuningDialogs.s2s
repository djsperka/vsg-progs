' $Id: TuningDialogs.s2s,v 1.22 2014-02-11 01:12:17 jeff Exp $
'
' This file contains dialog functions for the alert tuning script Tuning.s2s.
#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/LogUtilities.s2s"
#include "../../Spike2Util/MiscUtilities.s2s"
#include "UsreyGratings.s2s"
#include "UsreyDAQ.s2s"


const tunTypeNone$ := "None";
const tunTypeOrientation$ := "O";
const tunTypeContrast$ := "C";
const tunTypeSpatial$ := "S";
const tunTypeTemporal$ := "T";
const tunTypeArea$ := "A";
const tunTypeDonut$ := "H";  '(H)ole in stimulus
const tunTypeBerliner$ := "B";
const tunTypeBoxODonuts$ := "G";  '(G)rid of stimuli
const tunTypeXPos$ := "X";
const tunTypeXYPos$ := "Z";
const tunTypeDots$ := "D";
const tunTypeDisparity$ := "DX";
const tunTypeCRG$ := "R";
const tunTypeBlank$ := "BLANK";
const tunTypeGratingOnly$ := "GO";
const tunTypeDanish$ := "DN";
const tunTypeDSS$ := "DSS";
var tunType$:=tunTypeNone$;
var tunType1$:=tunTypeNone$;  'for first of two tuning curves, if Box O' Donuts, or for non-CRG curve in CRG scenarios
var tunType2$:=tunTypeNone$;  'for second of two tuning curves, if Box O' Donuts
var tunDualTuningType%;  'Determines whether, on dual tuning, both (0), Master (1), or Slave (2) screen varies.

const tunContextDAQ$ := "DAQ";
const tunContextConfig$ := "Config";
var tunContext$ := tunContextConfig$;

const tundlgXHairButton% := 8;
const tundlgOrientationButton% := 9;
const tundlgContrastButton% := 10;
const tundlgSpatialButton% := 11;
const tundlgTemporalButton% := 12;
const tundlgAreaButton% := 13;
const tundlgDonutButton% := 14;
const tundlgBerlinerButton% := 15;
const tundlgBoxODonutsButton% := 16;
const tundlgXPosButton% := 17;
const tundlgDotsButton% := 18;
const tundlgDisparityButton% := 19;
const tundlgCRGButton% := 20;
const tundlgSelectSEQFileButton% := 21;
const tundlgBlankButton% := 22;
const tundlgGratingOnlyButton% := 23;
const tundlgCRG2Button% := 24;  'This is for CRG on SECOND screen
const tundlgDanishButton% := 25;
const tundlgDSSButton% := 26;

' A note about "steps". 
' The dialogs ask for a number of "steps". A step is a transition from one stimulus
' to another. Thus, if there are N steps, there are N+1 different stimuli.

' These are specific to the individual tuning curve types - orientation first
var tunOriNSteps%;		' # steps in orientation tuning curve
var tunOriNRepeats%;		' # repeats in ori tuning curve
var tunOriMinOrientation;	' min orientation
var tunOriMaxOrientation;	' max orientation
var tunOriProgression%;

' Contrast next
var tunContrastNSteps%;			' # steps in contrast tuning curve
var tunContrastNRepeats%;		' # repeats in contrast tuning curve
var tunContrastMinContrast;		' min contrast
var tunContrastMaxContrast;		' max contrast
var tunContrastProgression%;

' Spatial next
var tunSpatialNSteps%;			' # steps in spatial freq tuning curve
var tunSpatialNRepeats%;		' # repeats in spatial freq tuning curve
var tunSpatialMinSF;			' min SF
var tunSpatialMaxSF;			' max SF
var tunSpatialProgression%;

' Temporal next
var tunTemporalNSteps%;			' # steps in temporal tuning curve
var tunTemporalNRepeats%;		' # repeats in temporal tuning curve
var tunTemporalMinTF;		' min TF
var tunTemporalMaxTF;		' max TF
var tunTemporalProgression%;

' Area next
var tunAreaNSteps%;			' # steps in area tuning curve
var tunAreaNRepeats%;		' # repeats in area tuning curve
var tunAreaMinDiam;		' min diameter
var tunAreaMaxDiam;		' max diameter
var tunAreaProgression%;

' X/XY Position next
var tunXPosNSteps%;			' # steps in X position tuning curve
var tunXPosNRepeats%;		' # repeats in X position tuning curve
var tunXPosMinXPos;		' min position
var tunXPosMaxXPos;		' max position
var tunXPosProgression%;
var tunXYPosNXSteps%;			' # steps in X position tuning curve
var tunXYPosNRepeats%;		' # repeats in X position tuning curve
var tunXYPosMinXPos;		' min position
var tunXYPosMaxXPos;		' max position
var tunXYPosProgression%;
var tunXYPosNYSteps%;			' # steps in Y position tuning curve
var tunXYPosMinYPos;		' min position
var tunXYPosMaxYPos;		' max position

' Donuts - use same vars as area. There is one additional var - the optimal value index.
var tunDonutOptimalIndex%:=0;		' step index where area stim stops growing and donut stim starts
var tunDonutOptimalDiam;
var tunDonutProgression%;


' Berliners - also use same variables as Area.  Use optimal value index from Donuts.  Add maximal value index
var tunDonutOptimalDiamPlusOne;
var tunBerlinerMaximalIndex%:=0;    ' index for "maximal" size
var tunBerlinerMaximalDiam;
var tunBerlinerNSteps%;
var tunBerlinerNRepeats% := 3;  'just putting in 3 repeats for now
var tunBerlinerProgression%;

' Box O' Donuts
'var tunUseHoleKluge%;               'will be set by tuning dialogs if we are putting a hole in the stimulus
var tunBoxODonutsCurrentCurve%:=0;  'note, will be 0 unless BoxODonuts is selected on the dialog
var tunCurve1Text$;                 'For the nifty boxes telling us what's been done!
var tunCurve2Text$;
var updateCurve1Text%;              'These is just a pointer that allows us to change the tunCurve1Text$ value on the fly
var updateCurve2Text%;
var tunCurve1SelectedType$;         'This prevents us from doubling up
var tunBoxODonutsProgression%;
var tunBoxODonutsNRepeats%;
var tunMasterFollowsCurve1%;


' Dots - this is a bit different - it's an orientation tuning curve, 
' but the other parameters aren't quite general grating parameters, so do them here, too
var tunDotsNSteps%;		' # steps in orientation tuning curve
var tunDotsNRepeats%;		' # repeats in ori tuning curve
var tunDotsMinOrientation;	' min orientation
var tunDotsMaxOrientation;	' max orientation
var tunDotsProgression%;
var tunDotsX;               ' X position, deg
var tunDotsY;               ' Y position, deg
var tunDotsDiameter;        ' deg
var tunDotsSpeed;           ' deg/sec
var tunDotsDensity;         ' dots/deg^2
var tunDotsSize%;           ' pixels
var tunDotsBGR%;            ' Background color, red level
var tunDotsBGG%;            ' Background color, green level
var tunDotsBGB%;            ' Background color, blue level
var tunDotsFGR%;            ' Dot color, red level
var tunDotsFGG%;            ' Dot color, green level
var tunDotsFGB%;            ' Dot color, blue level


' Disparity - this runs a Disparity tuning curve on either the slave or master screen
var tunDisparityOnMaster%;      ' if 1, Disparity is on master, if 0, Disparity is on slave.
var tunDisparityProgression%;   ' if 1, progression is random
var tunDisparityLinear%;        ' if 1, tuning curve is linear, 0 log
var tunDisparityNSteps%;
var tunDisparityNRepeats%;
var tunDisparityCenterXPos;
var tunDisparityMaxXPos;
var tunDisparityMinXPos;


' Contrast Reversing Gratings
var tunCRGCurrentCurve%:=0;     ' note, will be 0 unless CRG is selected on the dialog
var tunCRGNRepeats%;            ' number of repeats of the CRG sequence, note there will be one repeat for each level in the non-CRG tuning curve
                                    ' thus if this is 3 and the tuning curve has 5 values and there are 10 sequences this is 150 stimuli
var tunCRGFramesPerFlip%;       ' number of frames for each contrast reverse in the sequence
var tunCRGProgression%;         ' if 1, progression is random
var tunCRGOnSlave%;             ' if 1, CRG is on slave screen, using slave here so "master" is at top of list box with this variable as an index
var tunCRGSeqFile$;             ' full path of sequence file
var tunCRGSeqFile2$;            ' full path of secondary sequence file, if used
var tunCRGNSeq1%;               ' will hold the number of sequences in the sequence file, not saved to registry
var tunCRGNSeq2%;               ' will hold the number of sequences in the sequence file, not saved to registry
var tunCRGNFlips1%;             ' number of flips per sequence in file 1 (note that nFlips is a bit of a misnomer...it's really the number of frame-blocks)
var tunCRGNFlips2%;             ' number of flips per sequence in file 2
var tunCRGSecsPerSeq:=0;        ' length of a sequence in seconds, to be compared to stim duration in tuning curve, not saved to registry


' Danishes
var tunDanishNSteps%;           ' # steps in outer diameter tuning curve
var tunDanishNRepeats%;         ' # repeats in outer diameter tuning curve
var tunDanishMinOuterDiameter;  ' min outer diameter
var tunDanishMaxOuterDiameter;  ' max outer diameter
var tunDanishProgression%;      ' if 1, progression is random
var tunDanishIncludeBlank%;     ' if 1, include "blank" (that is, zero-size donut) in tuning curve


'Dynamic Surround Suppression
var tunDSSNTrials%;             ' # of trials (one trial is made of N periods)
var tunDSSNPeriods%;            ' # of flash + blank periods
var tunDSSNBlanks%;             ' # of blank periods, the remainder are flashes
var tunDSSNFlashesPerReward%;   ' # of flashes per each reward
var tunDSSCurrPeriod%;          ' counts current period
var tunDSSFlashesUntilReward%;  ' how many flashes until we get a reward?
var tunDSSFlashOrBlank%[1000];  'is current "flash" a flash or a blank?
var tunDSSDuration;             'how long is each flash, will take from "fixation duration"
var tunDSSIsOn%;                'keep track of current state
var tunNextDSSTime;             'when is the next flip?


' Strings that hold grating parameters
var tunGratingParams$;
var tunGratingParamsSlave$;

' Crosshair display variables
var tunUseXHairs%;                'Do we use crosshairs?
var tunXHairInnerRadiusOffset;    'Inner diameter of inner grid ring
var tunXHairMiddleRadiusOffset;   'Outer diameter of inner grid ring/Inner diameter of outer grid ring
var tunXHairOuterRadiusOffset;    'Outer diameter of outer grid ring
var tunXHairNumGridDivisions%;    'Number of divisions in the grid rings
var tunXHairTicInnerOffset;       'Inner extent of 0/90/180/270 ticks
var tunXHairTicOuterOffset;       'Outer extent of 0/90/180/270 ticks
var tunMaximalDiam;
var tunSlaveMaximalDiam;

var tunAlwaysLooking% := 1; ' If set eye signals ignored - subject presumed to be looking always. TESTING ONLY.

var tunFixationDuration := 2.0;	' Time required to hold fixation for reward (stim ON) - this is the stimulus duration
var tunUseMaintainMode% := 1;  ' If 1, maintain fixation point on screen through stimuli, if zero, force "restart" on each stimulus
var tunMaintainFixation := 2.0;	' Time required to hold fixation for reward (stim OFF)
var tunAcquisitionTime := 1.0;		' Time allowed to acquire fixation
var tunBackgroundColor$ := "gray";	' background color for stim
var tunAcqFailTime := 2.0;			' Wait time after acquisition failure
var tunHoldFailTime := 2.0;			' Wait time after failure to hold fixation (not on the first time after acquisition)
var tunMaintainFailTime := 2.0;	' Wait time after breaking fixation during maintain phase
'var tunTimeOutTime := 2.0;			' Wait time after failure to hold fixation (first time after acquisition)
var tunStdInterTrialTime := 2.0;    'Standard intertrial time
var tunDoRivalry% := 0;          ' If checked, run for the rivalry rig
var tunDoF12% := 1;                 ' compute f1 and f2. 
var tunDoTuningHist% := 1;          'do tuning histograms?
var tunSetStationary% := 0;         'do stationary?
var tunXHairText$;                  'holds whether crosshairs are on or off
var updateXHairText%;             'Gets the item number of a DlgText object for update
var TunCurveMArg$:="";            'holds type of tuning curve on Master
var TunCurveSArg$:="";            'holds type of tuning curve on slave
var TunCurveS2Arg$:="";           'holds second type of tuning curve on slave, for Box O' Donuts
var tunNoCardSync%;               'allows us to turn off card synching for Dualstim
var tunButtonCollect%;            'Collect button data for rivalry?

' These will be set by the tuning curve choice
var tunNAdvances%;		' Number of times stim will advance during one repeat
var tunNRepeats%;		' Number of repeats

' This vector will hold the actual values to step through. Some are log steps, some are not. 
' The Indices array is the order to step through the values with: tunValues[tunValuesIndices%[0]], tunValues[tunValuesIndices%[1]], ...
' djs Make a constant tunMaxTrials to set the max number of trials. Arrays etc should be declared with this const. See below and
' tunF1Sum, tunF2Sum. 
const tunMaxTrials% := 1000;
var tunValues[tunMaxTrials%];
var tun1Values[tunMaxTrials%];
var tun2Values[tunMaxTrials%];
var tunValuesIndices%[tunMaxTrials%]; 
var tun1ValuesIndices%[tunMaxTrials%]; 
var tun2ValuesIndices%[tunMaxTrials%]; 
var tunNValues%;
var tun1NValues%;
var tun2NValues%;
var tunValuesStringified$;
var tun1ValuesStringified$;     'For Box O' Donuts
var tun2ValuesStringified$;


' Wavemarks and continuous ports are specified elsewhere
var tunNWavemarks% := 0;
var tunWavemarkPorts%[16];
var tunNContinuous% := 0;
var tunContinuousPorts%[16];

' Hold sum of F1 values. Each channel (up to 16) has values saved according to the index of the tuning value
' Rely on the fact that arrays are initialized with 0s in Spike2. 
var tunF1Sum[16][tunMaxTrials%];
var tunF2Sum[16][tunMaxTrials%];
var tunTF;              ' Will need to use this during FFT analysis. Use at your own risk....


'------------ Read/write tuning curve parameters to the registry ------------

proc GetTuningCurveOrientationParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";
    tunOriNSteps% := GetIntRegistryValue%(key$, "NSteps", tunOriNSteps%);
    tunOriNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunOriNRepeats%);
    tunOriMinOrientation := GetFloatRegistryValue(key$, "MinOrientation", tunOriMinOrientation);
    tunOriMaxOrientation := GetFloatRegistryValue(key$, "MaxOrientation", tunOriMaxOrientation);
    tunOriProgression% := GetIntRegistryValue%(key$, "Progression", tunOriProgression%);
end;

proc SaveTuningCurveOrientationParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Orientation";
    SetIntRegistryValue(key$, "NSteps", tunOriNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunOriNRepeats%);
    SetFloatRegistryValue(key$, "MinOrientation", tunOriMinOrientation);
    SetFloatRegistryValue(key$, "MaxOrientation", tunOriMaxOrientation);
    SetIntRegistryValue(key$, "Progression", tunOriProgression%);
end;

proc GetTuningCurveContrastParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";
    
    tunContrastNSteps% := GetIntRegistryValue%(key$, "NSteps", tunContrastNSteps%);
    tunContrastNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunContrastNRepeats%);
    tunContrastMinContrast := GetFloatRegistryValue(key$, "MinContrast", tunContrastMinContrast);
    tunContrastMaxContrast := GetFloatRegistryValue(key$, "MaxContrast", tunContrastMaxContrast);
    tunContrastProgression% := GetIntRegistryValue%(key$, "Progression", tunContrastProgression%);
end;

proc SaveTuningCurveContrastParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Contrast";
    SetIntRegistryValue(key$, "NSteps", tunContrastNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunContrastNRepeats%);
    SetFloatRegistryValue(key$, "MinContrast", tunContrastMinContrast);
    SetFloatRegistryValue(key$, "MaxContrast", tunContrastMaxContrast);
    SetIntRegistryValue(key$, "Progression", tunContrastProgression%);
end;

proc GetTuningCurveSpatialParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";
    
    tunSpatialNSteps% := GetIntRegistryValue%(key$, "NSteps", tunSpatialNSteps%);
    tunSpatialNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunSpatialNRepeats%);
    tunSpatialMinSF := GetFloatRegistryValue(key$, "MinSF", tunSpatialMinSF);
    tunSpatialMaxSF := GetFloatRegistryValue(key$, "MaxSF", tunSpatialMaxSF);
    tunSpatialProgression% := GetIntRegistryValue%(key$, "Progression", tunSpatialProgression%);
end;

proc SaveTuningCurveSpatialParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Spatial";
    
    SetIntRegistryValue(key$, "NSteps", tunSpatialNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunSpatialNRepeats%);
    SetFloatRegistryValue(key$, "MinSF", tunSpatialMinSF);
    SetFloatRegistryValue(key$, "MaxSF", tunSpatialMaxSF);
    SetIntRegistryValue(key$, "Progression", tunSpatialProgression%);
end;

proc GetTuningCurveTemporalParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";
    
    tunTemporalNSteps% := GetIntRegistryValue%(key$, "NSteps", tunTemporalNSteps%);
    tunTemporalNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunTemporalNRepeats%);
    tunTemporalMinTF := GetFloatRegistryValue(key$, "MinTF", tunTemporalMinTF);
    tunTemporalMaxTF := GetFloatRegistryValue(key$, "MaxTF", tunTemporalMaxTF);
    tunTemporalProgression% := GetIntRegistryValue%(key$, "Progression", tunTemporalProgression%);
end;

proc SaveTuningCurveTemporalParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Temporal";

    SetIntRegistryValue(key$, "NSteps", tunTemporalNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunTemporalNRepeats%);
    SetFloatRegistryValue(key$, "MinTF", tunTemporalMinTF);
    SetFloatRegistryValue(key$, "MaxTF", tunTemporalMaxTF);
    SetIntRegistryValue(key$, "Progression", tunTemporalProgression%);
end;


proc GetTuningCurveXPosParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XPos";
    
    tunXPosNSteps% := GetIntRegistryValue%(key$, "NSteps", tunXPosNSteps%);
    tunXPosNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunXPosNRepeats%);
    tunXPosMinXPos := GetFloatRegistryValue(key$, "MinXPos", tunXPosMinXPos);
    tunXPosMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunXPosMaxXPos);
    tunXPosProgression% := GetIntRegistryValue%(key$, "Progression", tunXPosProgression%);
end;

proc SaveTuningCurveXPosParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XPos";

    SetIntRegistryValue(key$, "NSteps", tunXPosNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunXPosNRepeats%);
    SetFloatRegistryValue(key$, "MinXPos", tunXPosMinXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunXPosMaxXPos);
    SetIntRegistryValue(key$, "Progression", tunXPosProgression%);
end;


proc GetTuningCurveXYPosParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XYPos";
    
    tunXYPosNXSteps% := GetIntRegistryValue%(key$, "NXSteps", tunXYPosNXSteps%);
    tunXYPosNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunXYPosNRepeats%);
    tunXYPosMinXPos := GetFloatRegistryValue(key$, "MinXPos", tunXYPosMinXPos);
    tunXYPosMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunXYPosMaxXPos);
    tunXYPosProgression% := GetIntRegistryValue%(key$, "Progression", tunXYPosProgression%);
    tunXYPosNYSteps% := GetIntRegistryValue%(key$, "NYSteps", tunXYPosNYSteps%);
    tunXYPosMinYPos := GetFloatRegistryValue(key$, "MinYPos", tunXYPosMinYPos);
    tunXYPosMaxYPos := GetFloatRegistryValue(key$, "MaxYPos", tunXYPosMaxYPos);
end;

proc SaveTuningCurveXYPosParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\XYPos";

    SetIntRegistryValue(key$, "NXSteps", tunXYPosNXSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunXYPosNRepeats%);
    SetFloatRegistryValue(key$, "MinXPos", tunXYPosMinXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunXYPosMaxXPos);
    SetIntRegistryValue(key$, "Progression", tunXYPosProgression%);
    SetIntRegistryValue(key$, "NYSteps", tunXYPosNYSteps%);
    SetFloatRegistryValue(key$, "MinYPos", tunXYPosMinYPos);
    SetFloatRegistryValue(key$, "MaxYPos", tunXYPosMaxYPos);
end;


proc GetTuningCurveDisparityParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Disparity";
    
    tunDisparityNSteps% := GetIntRegistryValue%(key$, "NSteps", tunDisparityNSteps%);
    tunDisparityNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunDisparityNRepeats%);
    tunDisparityCenterXPos := GetFloatRegistryValue(key$, "CenterXPos", tunDisparityCenterXPos);
    tunDisparityMaxXPos := GetFloatRegistryValue(key$, "MaxXPos", tunDisparityMaxXPos);
    tunDisparityProgression% := GetIntRegistryValue%(key$, "Progression", tunDisparityProgression%);
    tunDisparityLinear% := GetIntRegistryValue%(key$, "Linear", tunDisparityLinear%);
    tunDisparityOnMaster% := GetIntRegistryValue%(key$, "Master", tunDisparityOnMaster%);
    
end;

proc SaveTuningCurveDisparityParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Disparity";
    
    SetIntRegistryValue(key$, "NSteps", tunDisparityNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunDisparityNRepeats%);
    SetFloatRegistryValue(key$, "CenterXPos", tunDisparityCenterXPos);
    SetFloatRegistryValue(key$, "MaxXPos", tunDisparityMaxXPos);
    SetIntRegistryValue(key$, "Progression", tunDisparityProgression%);
    SetIntRegistryValue(key$, "Linear", tunDisparityLinear%);
    SetIntRegistryValue(key$, "Master", tunDisparityOnMaster%);
    
end;


proc GetTuningCurveAreaParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

    tunAreaNSteps% := GetIntRegistryValue%(key$, "NSteps", tunAreaNSteps%);
    tunAreaNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunAreaNRepeats%);
    tunAreaMinDiam := GetFloatRegistryValue(key$, "MinDiam", tunAreaMinDiam);
    tunAreaMaxDiam := GetFloatRegistryValue(key$, "MaxDiam", tunAreaMaxDiam);
    tunAreaProgression% := GetIntRegistryValue%(key$, "Progression", tunAreaProgression%);
    tunDonutOptimalIndex% := GetIntRegistryValue%(key$, "OptimalIndex", tunDonutOptimalIndex%);
    tunDonutProgression% := GetIntRegistryValue%(key$, "DonutProgression", tunDonutProgression%);
    tunBerlinerMaximalIndex% := GetIntRegistryValue%(key$, "MaximalIndexBerliner", tunBerlinerMaximalIndex%);
    tunBerlinerMaximalDiam := GetFloatRegistryValue(key$, "MaximalDiamBerliner", tunBerlinerMaximalDiam);
    tunBerlinerNSteps% := GetIntRegistryValue%(key$, "NStepsBerliner", tunBerlinerNSteps%);
    tunBerlinerNRepeats% := GetIntRegistryValue%(key$, "NRepeatsDiamBerliner", tunBerlinerNRepeats%);
    tunBerlinerProgression% := GetIntRegistryValue%(key$, "BerlinerProgression", tunBerlinerProgression%);
    tunMasterFollowsCurve1% := GetIntRegistryValue%(key$, "MasterFollowsCurve1", tunMasterFollowsCurve1%); 
    tunBoxODonutsProgression% := GetIntRegistryValue%(key$, "BoxODonutsProgression", tunBoxODonutsProgression%);
    tunBoxODonutsNRepeats% := GetIntRegistryValue%(key$, "BoxODonutsNRepeats", tunBoxODonutsNRepeats%);
end;

proc SaveTuningCurveAreaParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Area";

    SetIntRegistryValue(key$, "NSteps", tunAreaNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunAreaNRepeats%);
    SetFloatRegistryValue(key$, "MinDiam", tunAreaMinDiam);
    SetFloatRegistryValue(key$, "MaxDiam", tunAreaMaxDiam);
    SetIntRegistryValue(key$, "Progression", tunAreaProgression%);
    SetIntRegistryValue(key$, "OptimalIndex", tunDonutOptimalIndex%);
    SetIntRegistryValue(key$, "DonutProgression", tunDonutProgression%);
    SetIntRegistryValue(key$, "MaximalIndexBerliner", tunBerlinerMaximalIndex%);
    SetFloatRegistryValue(key$, "MaximalDiamBerliner", tunBerlinerMaximalDiam);
    SetIntRegistryValue(key$, "NStepsBerliner", tunBerlinerNSteps%);
    SetIntRegistryValue(key$, "NRepeatsDiamBerliner", tunBerlinerNRepeats%);
    SetIntRegistryValue(key$, "BerlinerProgression", tunBerlinerProgression%);
    SetIntRegistryValue(key$, "MasterFollowsCurve1", tunMasterFollowsCurve1%);
    SetIntRegistryValue(key$, "BoxODonutsProgression", tunBoxODonutsProgression%);
    SetIntRegistryValue(key$, "BoxODonutsNRepeats", tunBoxODonutsNRepeats%);
end;

proc GetTuningCurveDotsParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Dots";
    tunDotsNSteps% := GetIntRegistryValue%(key$, "NSteps", tunDotsNSteps%);
    tunDotsNRepeats% := GetIntRegistryValue%(key$, "NRepeats", tunDotsNRepeats%);
    tunDotsMinOrientation := GetFloatRegistryValue(key$, "MinOrientation", tunDotsMinOrientation);
    tunDotsMaxOrientation := GetFloatRegistryValue(key$, "MaxOrientation", tunDotsMaxOrientation);
    tunDotsX := GetFloatRegistryValue(key$, "X", tunDotsX);
    tunDotsY := GetFloatRegistryValue(key$, "Y", tunDotsY);
    tunDotsDiameter := GetFloatRegistryValue(key$, "Diameter", tunDotsDiameter);
    tunDotsSpeed := GetFloatRegistryValue(key$, "Speed", tunDotsSpeed);
    tunDotsDensity := GetFloatRegistryValue(key$, "Density", tunDotsDensity);
    tunDotsSize% := GetIntRegistryValue%(key$, "Size", tunDotsSize%);
    tunDotsProgression% := GetIntRegistryValue%(key$, "Progression", tunDotsProgression%);
    tunDotsBGR% := GetIntRegistryValue%(key$, "BGR", tunDotsBGR%);
    tunDotsBGG% := GetIntRegistryValue%(key$, "BGG", tunDotsBGG%);
    tunDotsBGB% := GetIntRegistryValue%(key$, "BGB", tunDotsBGB%);
    tunDotsFGR% := GetIntRegistryValue%(key$, "FGR", tunDotsFGR%);
    tunDotsFGG% := GetIntRegistryValue%(key$, "FGG", tunDotsFGG%);
    tunDotsFGB% := GetIntRegistryValue%(key$, "FGB", tunDotsFGB%);
end;

proc SaveTuningCurveDotsParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Dots";
    SetIntRegistryValue(key$, "NSteps", tunDotsNSteps%);
    SetIntRegistryValue(key$, "NRepeats", tunDotsNRepeats%);
    SetFloatRegistryValue(key$, "MinOrientation", tunDotsMinOrientation);
    SetFloatRegistryValue(key$, "MaxOrientation", tunDotsMaxOrientation);
    SetFloatRegistryValue(key$, "X", tunDotsX);
    SetFloatRegistryValue(key$, "Y", tunDotsY);
    SetFloatRegistryValue(key$, "Diameter", tunDotsDiameter);
    SetFloatRegistryValue(key$, "Speed", tunDotsSpeed);
    SetFloatRegistryValue(key$, "Density", tunDotsDensity);
    SetIntRegistryValue(key$, "Size", tunDotsSize%);
    SetIntRegistryValue(key$, "Progression", tunDotsProgression%);
    SetIntRegistryValue(key$, "BGR", tunDotsBGR%);
    SetIntRegistryValue(key$, "BGG", tunDotsBGG%);
    SetIntRegistryValue(key$, "BGB", tunDotsBGB%);
    SetIntRegistryValue(key$, "FGR", tunDotsFGR%);
    SetIntRegistryValue(key$, "FGG", tunDotsFGG%);
    SetIntRegistryValue(key$, "FGB", tunDotsFGB%);
end;


proc GetTuningCurveCRGParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\CRG";
    tunCRGNRepeats% := GetIntRegistryValue%(key$, "CRGNRepeats", tunCRGNRepeats%);
    tunCRGFramesPerFlip% := GetIntRegistryValue%(key$, "CRGFramesPerTurn", tunCRGFramesPerFlip%);
    tunCRGProgression% := GetIntRegistryValue%(key$, "CRGProgression", tunCRGProgression%);
    tunCRGOnSlave% := GetIntRegistryValue%(key$, "CRGOnSlave", tunCRGOnSlave%);
    tunCRGSeqFile$ := GetStringRegistryValue$(key$, "CRGSeqFile", tunCRGSeqFile$);
end;


proc SaveTuningCurveCRGParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\CRG";
    SetIntRegistryValue(key$, "CRGNRepeats", tunCRGNRepeats%);
    SetIntRegistryValue(key$, "CRGFramesPerTurn", tunCRGFramesPerFlip%);
    SetIntRegistryValue(key$, "CRGProgression", tunCRGProgression%);
    SetIntRegistryValue(key$, "CRGOnSlave", tunCRGOnSlave%);
    SetStringRegistryValue(key$, "CRGSeqFile", tunCRGSeqFile$);
end;



proc GetTuningCurveDanishParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Danish";
    tunDanishNSteps% := GetIntRegistryValue%(key$, "DanishNSteps", tunDanishNSteps%);
    tunDanishNRepeats% := GetIntRegistryValue%(key$, "DanishNRepeats", tunDanishNRepeats%);
    tunDanishMinOuterDiameter := GetFloatRegistryValue(key$, "DanishMinOuterDiameter", tunDanishMinOuterDiameter);
    tunDanishMaxOuterDiameter := GetFloatRegistryValue(key$, "DanishMaxOuterDiameter", tunDanishMaxOuterDiameter);
    tunDanishProgression% := GetIntRegistryValue%(key$, "DanishProgression", tunDanishProgression%);
    tunDanishIncludeBlank% := GetIntRegistryValue%(key$, "DanishIncludeBlank", tunDanishIncludeBlank%);
end;


proc SaveTuningCurveDanishParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\Danish";
    SetIntRegistryValue(key$, "DanishNSteps", tunDanishNSteps%);
    SetIntRegistryValue(key$, "DanishNRepeats", tunDanishNRepeats%);
    SetFloatRegistryValue(key$, "DanishMinOuterDiameter", tunDanishMinOuterDiameter);
    SetFloatRegistryValue(key$, "DanishMaxOuterDiameter", tunDanishMaxOuterDiameter);
    SetIntRegistryValue(key$, "DanishProgression", tunDanishProgression%);
    SetIntRegistryValue(key$, "DanishIncludeBlank", tunDanishIncludeBlank%);
end;


proc GetTuningCurveDSSParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\DSS";
    tunDSSNPeriods% := GetIntRegistryValue%(key$, "DSSNPeriods", tunDSSNPeriods%);
    tunDSSNBlanks% := GetIntRegistryValue%(key$, "DSSNBlanks", tunDSSNBlanks%);
    tunDSSNFlashesPerReward% := GetIntRegistryValue%(key$, "DSSNFlashesPerReward", tunDSSNFlashesPerReward%);
    tunDSSNTrials% := GetIntRegistryValue%(key$, "DSSNTrials", tunDSSNTrials%);
end;


proc SaveTuningCurveDSSParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning\\DSS";
    SetIntRegistryValue(key$, "DSSNPeriods", tunDSSNPeriods%);
    SetIntRegistryValue(key$, "DSSNBlanks", tunDSSNBlanks%);
    SetIntRegistryValue(key$, "DSSNFlashesPerReward", tunDSSNFlashesPerReward%);
    SetIntRegistryValue(key$, "DSSNTrials", tunDSSNTrials%);
end;



'------------ END Read/write tuning curve parameters to the registry ------------


func TuningCurveOrientationDialog%()
	var iReturn%;
	var i%;
	GetTuningCurveOrientationParameters();
	DlgCreate("Run Orientation Tuning Curve");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min Orientation (deg)", 0, 360);
	DlgReal(4, "Max Orientation (deg)", 0, 360);
	'DlgCheck(5, "Random Progression");
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    
	i% := DlgShow(tunOriNSteps%, tunOriNRepeats%, tunOriMinOrientation, tunOriMaxOrientation, tunOriProgression%);

	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveOrientationParameters();
		PrintLog("TuningCurveOrientationDialog - user hit OK\n");
		tunType$ := tunTypeOrientation$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeOrientation$;
            tunCurve1Text$ := "Tuning Curve 1 is ORIENTATION";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgOrientationButton%);  'So we don't pick orientation again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeOrientation$;
            tunCurve2Text$ := "Tuning Curve 2 is ORIENTATION";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgOrientationButton%);  'So we don't pick orientation again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeOrientation$;
            if DlgValue(5) = 0 then 'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is ORIENTATION";
            else
                tunCurve1Text$ := "Tuning Curve on Master is ORIENTATION";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		PrintLog("TuningCurveOrientationDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    PrintLog("Return value is %d\n", iReturn%);
	return iReturn%;
end;



func TuningCurveContrastDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveContrastParameters();
	DlgCreate("Contrast Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min Contrast (%)", 0.1, 100);
	DlgReal(4, "Max Contrast (%)", 0.1, 100);
	'DlgCheck(5, "Random Progression");
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;

	i% := DlgShow(tunContrastNSteps%, tunContrastNRepeats%, tunContrastMinContrast, tunContrastMaxContrast, tunContrastProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveContrastParameters();
'		PrintLog("TuningCurveContrastDialog - user hit OK\n");
		tunType$ := tunTypeContrast$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeContrast$;
            tunCurve1Text$ := "Tuning Curve 1 is CONTRAST";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgContrastButton%);  'So we don't pick contrast again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeContrast$;
            tunCurve2Text$ := "Tuning Curve 2 is CONTRAST";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgContrastButton%);  'So we don't pick contrast again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeContrast$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is CONTRAST";
            else
                tunCurve1Text$ := "Tuning Curve on Master is CONTRAST";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveContrastDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveSpatialDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveSpatialParameters();
	DlgCreate("Spatial Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min SF", .01, 100);
	DlgReal(4, "Max SF", .01, 100);
	'DlgCheck(5, "Random Progression");
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;

	i% := DlgShow(tunSpatialNSteps%, tunSpatialNRepeats%, tunSpatialMinSF, tunSpatialMaxSF, tunSpatialProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveSpatialParameters();
'		PrintLog("TuningCurveSpatialDialog - user hit OK\n");
		tunType$ := tunTypeSpatial$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeSpatial$;
            tunCurve1Text$ := "Tuning Curve 1 is SPATIAL FREQ";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgSpatialButton%);  'So we don't pick spatial frequency again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeSpatial$;
            tunCurve2Text$ := "Tuning Curve 2 is SPATIAL FREQ";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgSpatialButton%);  'So we don't pick spatial frequency again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeSpatial$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is SPATIAL FREQ";
            else
                tunCurve1Text$ := "Tuning Curve on Master is SPATIAL FREQ";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveSpatialDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveTemporalDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveTemporalParameters();
	DlgCreate("Temporal Freq Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 10);
	DlgReal(3, "Min TF", 0, 100);
	DlgReal(4, "Max TF", 0, 100);
	'DlgCheck(5, "Random Progression");
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;

	i% := DlgShow(tunTemporalNSteps%, tunTemporalNRepeats%, tunTemporalMinTF, tunTemporalMaxTF, tunTemporalProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveTemporalParameters();
'		PrintLog("TuningCurveTemporalDialog - user hit OK\n");
		tunType$ := tunTypeTemporal$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeTemporal$;
            tunCurve1Text$ := "Tuning Curve 1 is TEMPORAL FREQ";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgTemporalButton%);  'So we don't pick temporal frequency again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeTemporal$;
            tunCurve2Text$ := "Tuning Curve 2 is TEMPORAL FREQ";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgTemporalButton%);  'So we don't pick temporal frequency again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeTemporal$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is TEMPORAL FREQ";
            else
                tunCurve1Text$ := "Tuning Curve on Master is TEMPORAL FREQ";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveTemporalDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;

	return iReturn%;
end;

func TuningCurveAreaDialog%()
	var iReturn% := 0;
	var i%;
	GetTuningCurveAreaParameters();
	DlgCreate("Area Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	'DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	'DlgCheck(5, "Random Progression");
    if tunBoxODonutsCurrentCurve% = 0 then
        DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgCheck(5, "Random Progression");
    else
        DlgInteger(2, "----------------", 1, 1);
        DlgCheck(5, "----------------");
    endif;
    
    
	i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTuningCurveAreaParameters();
'		PrintLog("TuningCurveAreaDialog - user hit OK\n");
		tunType$ := tunTypeArea$;
        
        'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
        docase
        case tunBoxODonutsCurrentCurve% = 1 then
            tunType1$ := tunTypeArea$;
            tunCurve1Text$ := "Tuning Curve 1 is AREA";
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            tunBoxODonutsCurrentCurve% := 2;  'update current curve 
            DlgEnable(0,-tundlgAreaButton%);  'So we don't pick area again
        case tunBoxODonutsCurrentCurve% = 2 then
            tunType2$ := tunTypeArea$;
            tunCurve2Text$ := "Tuning Curve 2 is AREA";
            DlgValue$(updateCurve2Text%, tunCurve2Text$);
            tunBoxODonutsCurrentCurve% := 3;  'update current curve 
            DlgEnable(0,-tundlgAreaButton%);  'So we don't pick area again
            TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        case tunCRGCurrentCurve% = 1 then
            tunCRGCurrentCurve% := 2;
            tunType1$ := tunTypeArea$;
            if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                tunCurve1Text$ := "Tuning Curve on Slave is AREA";
            else
                tunCurve1Text$ := "Tuning Curve on Master is AREA";
            endif;
            DlgValue$(updateCurve1Text%, tunCurve1Text$);
            TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
        endcase;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;


func TuningCurveXPosDialog%()
	var iReturn% := 0;
	var i%;
    
    'This function is now complicated because fixstim has XY tuning while dualstim only has X tuning
    'Because XY tuning is a superset of X tuning there does not seem to be much reason to have a separate
    'button, so that means this button needs to change between XY tuning and X tuning depending on the
    'context.  But that's doable.
    if DlgValue(10) = 1 then  'if it's a dualstim scenario, use X position
        
        GetTuningCurveXPosParameters();
        DlgCreate("XPos Tuning Curve Parameters");
        DlgInteger(1, "Number of Steps", 1, 100);
        'DlgInteger(2, "Number of Repeats", 1, 1000);
        DlgReal(3, "Min X Position", -14, 14);
        DlgReal(4, "Max X Position", -14, 14);
        'DlgCheck(5, "Random Progression");
        if tunBoxODonutsCurrentCurve% = 0 then
            DlgInteger(2, "Number of Repeats", 1, 1000);
            DlgCheck(5, "Random Progression");
        else
            DlgInteger(2, "----------------", 1, 1);
            DlgCheck(5, "----------------");
        endif;

        
        i% := DlgShow(tunXPosNSteps%, tunXPosNRepeats%, tunXPosMinXPos, tunXPosMaxXPos, tunXPosProgression%);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        
        if i% = 1 then
            SaveTuningCurveXPosParameters();
            '		PrintLog("TuningCurveAreaDialog - user hit OK\n");
            tunType$ := tunTypeXPos$;
            
            'Change text on Box O' Donuts/CRG dialog box, if we're calling from there.
            'Oh, and update tuning types we are going to use.
            docase
            case tunBoxODonutsCurrentCurve% = 1 then
                tunType1$ := tunTypeXPos$;
                tunCurve1Text$ := "Tuning Curve 1 is X POSITION";
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                tunBoxODonutsCurrentCurve% := 2;  'update current curve 
                DlgEnable(0,-tundlgXPosButton%);  'So we don't pick X position again
            case tunBoxODonutsCurrentCurve% = 2 then
                tunType2$ := tunTypeXPos$;
                tunCurve2Text$ := "Tuning Curve 2 is X POSITION";
                DlgValue$(updateCurve2Text%, tunCurve2Text$);
                tunBoxODonutsCurrentCurve% := 3;  'update current curve 
                DlgEnable(0,-tundlgXPosButton%);  'So we don't pick X position again
                TuningCurveBoxODonutsDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            case tunCRGCurrentCurve% = 1 then
                tunCRGCurrentCurve% := 2;
                tunType1$ := tunTypeXPos$;
                if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
                    tunCurve1Text$ := "Tuning Curve on Slave is X POSITION";
                else
                    tunCurve1Text$ := "Tuning Curve on Master is X POSITION";
                endif;
                DlgValue$(updateCurve1Text%, tunCurve1Text$);
                TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
            endcase;
            
            
            if tunContext$ = tunContextDAQ$ then
                ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
                iReturn% := 1;
            else
                iReturn% := 1;
            endif;
        endif;
    else 'if it's a fixstim scenario, use XY position
        
        GetTuningCurveXYPosParameters();
        DlgCreate("XYPos Tuning Curve Parameters");
        DlgInteger(1, "Number of Repeats", 1, 1000);
        DlgInteger(2, "Number of X Steps", 0, 100);
        DlgReal(3, "Min X Position", -14, 14);
        DlgReal(4, "Max X Position", -14, 14);
        DlgInteger(5, "Number of Y Steps", 0, 100);
        DlgReal(6, "Min Y Position", -14, 14);
        DlgReal(7, "Max Y Position", -14, 14);
        DlgCheck(8, "Random Progression");
        
        DlgAllow(0xffff, 0, TuningCurveXYPosDialogChanged%);
        
        i% := DlgShow(tunXYPosNRepeats%, tunXYPosNXSteps%, tunXYPosMinXPos, tunXYPosMaxXPos, tunXYPosNYSteps%, tunXYPosMinYPos, tunXYPosMaxYPos, tunXYPosProgression%);
        ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
        ' When user hits OK we always save the parameters, and when user hits Cancel we don't.
        
        if i% = 1 then
            SaveTuningCurveXYPosParameters();
            '		PrintLog("TuningCurveAreaDialog - user hit OK\n");
            tunType$ := tunTypeXYPos$;
               
            
            if tunContext$ = tunContextDAQ$ then
                ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
                iReturn% := 1;
            else
                iReturn% := 1;
            endif;
        endif;
    endif;    
        
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;



func TuningCurveXYPosDialogChanged%(item%) 
    if DlgValue(2) = 0 then  'If no X variation
        DlgEnable(0,4); 'disable X Max
    else
        DlgEnable(1,4); 'enable X Max
    endif
    if DlgValue(5) = 0 then  'If no Y variation
        DlgEnable(0,7); 'disable Y Max
    else
        DlgEnable(1,7); 'enable Y Max
    endif
    return 1;
end





func TuningCurveDisparityDialog%()
    'This is closely related to XPos
	var iReturn% := 0;
	var i%;
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    
    'get parameters for Disparity tuning curve
    GetTuningCurveDisparityParameters();
    
    'get current x position, will allow update without going to grating parameters
    param$ := GetGratingParameters$("Stimulus");  'for XPos, get grating parameters from master stimulus, will reset master/slave accordingly 
	ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    tunDisparityCenterXPos := x;
    
	DlgCreate("Disparity Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps (one way)", 1, 100);
	DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Center X Position", -14, 14);
	DlgReal(4, "Max X Position (will mirror)", -14, 14);
    DlgCheck(5, "Slave Screen Is Stationary");
    DlgCheck(6, "No function - only linear for now");
    'DlgCheck(6, "Linear progression (unchecked is log)");
    DlgCheck(7, "Random Progression");
    
    
	i% := DlgShow(tunDisparityNSteps%, tunDisparityNRepeats%, tunDisparityCenterXPos, tunDisparityMaxXPos, tunDisparityOnMaster%, tunDisparityLinear%, tunDisparityProgression%);
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    'tunMaximalDiam := tunAreaMaxDiam;  This won't do anything unless FIXSTIM is updated to allow crosshairs
	if i% = 1 then
		SaveTuningCurveDisparityParameters();
        'and reset the x position for master AND slave gratings
        x := tunDisparityCenterXPos;
        param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
        SaveGratingParameters("Stimulus", param$);  'this saves master
        TunMasterValsToSlave%();  'this copies master values over to slave
		
        tunType$ := tunTypeDisparity$;
        
        
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
'		PrintLog("TuningCurveAreaDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;






' This function is initially called with a "0" input, which forces the 1-5 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
func TuningCurveDonutDialogChanged%(item%)
    if item% = 0 then
        DlgEnable(0, 1, 2, 3, 4);
    endif    
    return 1;
end

func TuningCurveDonutDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    
	GetTuningCurveAreaParameters();
    
    ' Before we proceed, we must generate a list of choices for the optimal diameter. 
    ' Note that there are nsteps+1 values. 
    
    GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, result[], indices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, 0);
    sValues$ := GetRealArrayAsStringSep$(result[0:tunAreaNSteps%+1], indices%[0:tunAreaNSteps%+1], "|");
    
	DlgCreate("Donut Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 1, 100);
	DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgList(6, "Optimal diameter", sValues$);
    DlgButton(151, "Master Grating", TunDlgGratingMaster%);
    DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
    DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
    DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
    DlgAllow(0xffff, 0, TuningCurveDonutDialogChanged%);
	i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunDonutProgression%, tunDonutOptimalIndex%);
    tunDonutOptimalDiam := result[tunDonutOptimalIndex%];
    
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
    tunMaximalDiam := result[tunDonutOptimalIndex%];
    tunSlaveMaximalDiam := tunAreaMaxDiam;
	if i% = 1 then
		SaveTuningCurveAreaParameters();
		tunType$ := tunTypeDonut$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;

' This function is initially called with a "0" input, which forces the 1, 3, 4 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
func TuningCurveBerlinerDialogChanged%(item%)    
    if item% = 0 then
        DlgEnable(0, 1, 3, 4);
    endif   
    return 1;
end

func TuningCurveBerlinerDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    
	GetTuningCurveAreaParameters();
    
    ' Before we proceed, we must generate a list of choices for the optimal diameter. These are based on the most recent run of Area tuning
    ' Note that there are nsteps+1 values. 
    
    GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, result[], indices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
    sValues$ := GetRealArrayAsStringSep$(result[0:tunAreaNSteps%+1], indices%[0:tunAreaNSteps%+1], "|");
    
    'We want the default maximal value to be the largest value available when we open the dialog
    'so set tunBerlinerMaximalIndex% appropriately
    tunBerlinerMaximalIndex% := tunAreaNSteps%;
    
    'Define tunBerlinerNSteps%, because we are no longer doing a tuning curve.
    tunBerlinerNSteps% := 6;
    
	DlgCreate("Berliner Tuning Curve Parameters");
	'DlgInteger(1, "Number of Steps", 2, 100);
    DlgInteger(1, "Number of Stimuli", 1, 100);
	DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Min Diameter", 0.1, 100);
	DlgReal(4, "Max Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgList(6, "Optimal diameter", sValues$);
    DlgList(7, "Maximal diameter", sValues$);
    DlgButton(151, "Master Grating", TunDlgGratingMaster%);
    DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
    DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
    DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
    DlgAllow(0xffff, 0, TuningCurveBerlinerDialogChanged%);
	'i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%, tunDonutOptimalIndex%, tunBerlinerMaximalIndex%);
    i% := DlgShow(tunBerlinerNSteps%, tunBerlinerNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunBerlinerProgression%, tunDonutOptimalIndex%, tunBerlinerMaximalIndex%);
    
    tunMaximalDiam := tunAreaMaxDiam;
    tunSlaveMaximalDiam := result[tunBerlinerMaximalIndex%];
    ' Don't let the user screw this up by selecting incompatible values
    if tunBerlinerMaximalIndex% > tunDonutOptimalIndex%+1 then
        tunDonutOptimalDiam := result[tunDonutOptimalIndex%];
        tunDonutOptimalDiamPlusOne := result[tunDonutOptimalIndex%+1];
        tunBerlinerMaximalDiam := result[tunBerlinerMaximalIndex%];
    else
        i% := 0;  'Treat this as a "cancel"
        if tunBerlinerMaximalIndex% > tunDonutOptimalIndex% then
            message("Oops!|The maximal index was only one value greater than the optimal index!\nThis would result in 'near facilitation' and 'far suppression'\nstimuli being identical!\n\nI know you didn't want that, so try again!");
        else
            message("Oops!|The maximal index was not greater than the optimal index!\n\nI know you didn't want that, so try again!");
        endif;
    endif;
    
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveAreaParameters();
		tunType$ := tunTypeBerliner$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;




' This function is initially called with a "0" input, no function decided yet
' Second tuning curve and OK should be disabled until first curve/second curve
' are selected
func TuningCurveBoxODonutsDialogChanged%(item%)    
    'This re-enables any disabled buttons if the Box O' Donuts dialog is cancelled
    if item% = 0 then
        DlgEnable(1,-tundlgOrientationButton%);
        DlgEnable(1,-tundlgContrastButton%);
        DlgEnable(1,-tundlgSpatialButton%);
        DlgEnable(1,-tundlgTemporalButton%);
        DlgEnable(1,-tundlgAreaButton%);
        DlgEnable(1,-tundlgXPosButton%);
    endif;  
    if tunBoxODonutsCurrentCurve% = 3 then
        DlgEnable(1,-1);  'enable "OK" if both curves have been selected
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    return 1;
end


func TuningCurveBoxODonutsDialog%()
    var sValues$;
    var i%;
    var iReturn%;
    
    GetTuningCurveAreaParameters();   'parameters are still carried in "area", may not be ideal but ought to work 
    
    tunBoxODonutsCurrentCurve% := 1;  'this will be 0 unless we select this tuning curve
    
    tunCurve1Text$ := "Tuning Curve 1 is unselected";
    tunCurve2Text$ := "Tuning Curve 2 is unselected";
    
    
    DlgCreate("Box O' Donuts Parameters");
    
    DlgInteger(1,"Number of repeats",1,100,20);
    DlgCheck(2, "Random Progression", 2, 2);
    DlgCheck(3, "Master Follows Curve 1", 2, 3);
    
    DlgGroup("Select Two Tuning Curve Types", 1, 4, 47, 6); 
    updateCurve1Text% := DlgText(tunCurve1Text$, 14, 5, 30);  'this is to keep track of selected tuning curve 1
    updateCurve2Text% := DlgText(tunCurve2Text$, 14, 6, 30);  'this is to keep track of selected tuning curve 2
    DlgButton(tundlgOrientationButton%, " Orientation  ", TuningCurveOrientationDialog%, 2, 8); 'Note that labels for Orientation-Area are superceded 
	DlgButton(tundlgContrastButton%, "     Contrast     ", TuningCurveContrastDialog%, 18, 8);  'by TuningCurveScriptDialogChanged% even upon opening 
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 9);           'the dialog (i.e. whatever label is here is unused)
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 18, 9);
	DlgButton(tundlgAreaButton%, "Area", TuningCurveAreaDialog%, 36, 8);
    DlgButton(tundlgXPosButton%, "X Position", TuningCurveXPosDialog%, 36, 9);
    
    DlgButton(151, "Master Grating", TunDlgGratingMaster%);
    DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
    DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
    DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
    DlgAllow(0xffff, 0, TuningCurveBoxODonutsDialogChanged%);
    
    i% := DlgShow(tunBoxODonutsNRepeats%,tunBoxODonutsProgression%,tunMasterFollowsCurve1%);
    
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	
    tunBoxODonutsCurrentCurve% := 0;  'reset this, we don't need it once this dialog box is closed and it messes up stuff if we want to pick a different tuning curve    
    if i% = 1 then
		SaveTuningCurveAreaParameters();
		tunType$ := tunTypeBoxODonuts$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;   
    
end



func TuningCurveDotsDialog%()
	var iReturn%;
	var i%;
	GetTuningCurveDotsParameters();
	DlgCreate("Run Dots Tuning Curve");
    
    DlgGroup("Tuning Curve Parameters", 1, 1, 47, 6);
	DlgInteger(1, "Number of Steps", 1, 100, 0, 2);
	DlgInteger(2, "Number of Repeats", 1, 10, 0, 3);
	DlgReal(3, "Min Orientation (deg)", 0, 360, 0, 4);
	DlgReal(4, "Max Orientation (deg)", 0, 360, 0, 5);
	DlgCheck(5, "Random Progression", 0, 6);
    
    DlgGroup("Dot Parameters", 1, 7, 47, 7);
    DlgReal(6, "X Position (deg):",  -40, 40, 0, 8);
    DlgReal(7, "Y Position (deg):", -40, 40, 0, 9);
    DlgReal(8, "Diameter (deg):", .1, 30, 0, 10);
    DlgReal(9, "Speed (deg/sec):", 0, 100, 0, 11);
    DlgReal(10, "Density (dots/deg^2):", 0, 200, 0 ,12);
    DlgInteger(11, "Dot Size (pixels):", 0, 50, 0, 13);
    
    DlgGroup("Color", 1, 14, 47, 7);
    DlgInteger(12, "BG Color Red Value:", 0, 255, 0, 15);
    DlgInteger(13, "BG Color Green Value:", 0, 255, 0, 16);
    DlgInteger(14, "BG Color Blue Value:", 0, 255, 0, 17);
    DlgInteger(15, "Dot Color Red Value:", 0, 255, 0, 18);
    DlgInteger(16, "Dot Color Green Value:", 0, 255, 0, 19);
    DlgInteger(17, "Dot Color Blue Value:", 0, 255, 0, 20);

    
    
    'DlgList(12, "Color:", ColorVectorList$[]);  Color, BG color?  
    
    
	i% := DlgShow(tunDotsNSteps%, tunDotsNRepeats%, tunDotsMinOrientation, tunDotsMaxOrientation, tunDotsProgression%, tunDotsX, tunDotsY,
    tunDotsDiameter, tunDotsSpeed, tunDotsDensity, tunDotsSize%, tunDotsBGR%, tunDotsBGG%, tunDotsBGB%, tunDotsFGR%, tunDotsFGG%, tunDotsFGB%);

	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we alwaus save the parameters, and when user hits Cancel we don't.
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveDotsParameters();
		PrintLog("TuningCurveDotsDialog - user hit OK\n");
		tunType$ := tunTypeDots$;
                
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		PrintLog("TuningCurveDotsDialog - user hit Cancel\n");
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    PrintLog("Return value is %d\n", iReturn%);
	return iReturn%;
end;




' This function is initially called with a "0" input, no function decided yet
' Second tuning curve and OK should be disabled until first curve/second curve
' are selected
func TuningCurveCRGDialogChanged%(item%)    
    'This re-enables the master/slave listbox if CRG dialog is cancelled (actually not needed)
    'if item% = 0 then
        'DlgEnable(1,5); 
    'endif;  
    if item% = 5 then
        if DlgValue(5) = 0 then
            DlgValue$(updateCurve2Text%,"Contrast Reversing Grating on MASTER");
        else
            DlgValue$(updateCurve2Text%,"Contrast Reversing Grating on SLAVE");
        endif;
    endif;
    if tunCRGCurrentCurve% = 2 then
        DlgEnable(1,-1);  'enable "OK" if curve has been selected
        DlgEnable(0,5);   'and disable the master/slave listbox - can't change this once you've picked a curve
    else
        DlgEnable(0,-1);  'Otherwise disable "OK"
    endif;
    
    return 1;
end


func TuningCurveCRGDialog%()
    'Just copied over Box O Donuts for now
    var sValues$;
    var i%;
    var iReturn%;
    var tunCurveText$;
    var tunCurveCRGText$;
    
    var mylist$[2];
    mylist$[0] := "Master";
    mylist$[1] := "Slave";
    
    GetTuningCurveCRGParameters();    
    
    tunCRGCurrentCurve% := 1;  'this will be 0 unless we select this tuning curve
    
    tunCurveText$ := "Tuning Curve is unselected";
    if tunCRGOnSlave% = 0 then
        tunCurveCRGText$ := "Contrast Reversing Grating on MASTER";
    else
        tunCurveCRGText$ := "Contrast Reversing Grating on SLAVE";
    endif;
    
    
    DlgCreate("Contrast Reversing Grating Parameters");
    
    DlgInteger(1,"# of repeats per CRG sequence",1,100,30,1);
    DlgInteger(2,"# of frames per turn",1,1000,30,2);
    DlgCheck(3, "Random Progression", 2, 3);
    DlgButton(tundlgSelectSEQFileButton%,   "Select Sequence File", SelectSEQFile%,49,3);
    DlgString(4,40,20,"",50,2);  'for visual confirmation of selected seq file
    
    
    
    DlgGroup("CRG Screen and Tuning Curve Type", 1, 4, 52, 7); 
    DlgList(5, "CRG is on:", mylist$[], 2, 3);
    updateCurve2Text% := DlgText(tunCurveCRGText$, 9, 6, 50);  'this keeps track of which screen holds CRG, 1/2 label got swapped, just rolling with it
    updateCurve1Text% := DlgText(tunCurveText$, 9, 7, 50);  'this is to keep track of selected tuning curve 
    DlgButton(tundlgBlankButton%, "     Blank     ", TuningCurveCRGBlank%, 2, 8);  'for blank screen
    DlgButton(tundlgGratingOnlyButton%, "  Grating Only  ", TuningCurveCRGGratingOnly%, 18, 8);  'for single grating
    DlgButton(tundlgCRG2Button%, "Secondary CRG", TuningCurveCRG2%, 36, 8);  'for secondary CRG
    
    DlgButton(tundlgOrientationButton%, " Orientation  ", TuningCurveOrientationDialog%, 2, 9); 'Note that labels for Orientation-Area are superceded 
	DlgButton(tundlgContrastButton%, "     Contrast     ", TuningCurveContrastDialog%, 18, 9);  'by TuningCurveScriptDialogChanged% even upon opening 
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 10);           'the dialog (i.e. whatever label is here is unused)
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 18, 10);
	DlgButton(tundlgAreaButton%, "         Area         ", TuningCurveAreaDialog%, 36, 9);
    DlgButton(tundlgXPosButton%, "     X Position     ", TuningCurveXPosDialog%, 36, 10);
    
    DlgButton(151, "Master Grating", TunDlgGratingMaster%);
    DlgButton(152, "Slave Grating", TunDlgGratingSlave%);
    DlgButton(153, "Master Vals -> Slave", TunMasterValsToSlave%);
    DlgButton(154, "Slave Vals -> Master", TunSlaveValsToMaster%);
    DlgAllow(0xffff, 0, TuningCurveCRGDialogChanged%);
    
    i% := DlgShow(tunCRGNRepeats%,tunCRGFramesPerFlip%,tunCRGProgression%,tunCRGSeqFile$,tunCRGOnSlave%);
    
    ' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	
    tunCRGCurrentCurve% := 0;  'reset this, we don't need it once this dialog box is closed and it messes up stuff if we want to pick a different tuning curve    
    if i% = 1 then
		SaveTuningCurveCRGParameters();
		tunType$ := tunTypeCRG$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;   
    
end





func TuningCurveCRGBlank%()
'This function is ONLY called from the CRG dialog box, calling from anywhere else would make no sense, don't do it.
    tunCRGCurrentCurve% := 2;
    tunType1$ := tunTypeBlank$;
    if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
        tunCurve1Text$ := "Slave will be BLANK";
    else
        tunCurve1Text$ := "Master will be BLANK";
    endif;
    DlgValue$(updateCurve1Text%, tunCurve1Text$);
    TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    return 1;
end





func TuningCurveCRGGratingOnly%()
'This function is ONLY called from the CRG dialog box, calling from anywhere else would make no sense, don't do it.
    tunCRGCurrentCurve% := 2;
    tunType1$ := tunTypeGratingOnly$;
    if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
        tunCurve1Text$ := "Slave will have STATIC GRATING";
    else
        tunCurve1Text$ := "Master will have STATIC GRATING";
    endif;
    DlgValue$(updateCurve1Text%, tunCurve1Text$);
    TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    'set some contrast values...I think we can get away without committing these to the registry
    'Actually, I'm just going to hard code this in Tuning's CreateSampleConfiguration, should work fine
    'tunContrastNSteps% := 1;
    'tunContrastMinContrast := 0;
    'tunContrastMaxContrast := 100;
    return 1;
end




func TuningCurveCRG2%()
'This function is ONLY called from the CRG dialog box, calling from anywhere else would make no sense, don't do it.
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a secondary CRG sequence file");  'Find a sequence file
    tunCRGSeqFile2$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it 
    
    
    if fh0% > 0  then 'success in opening file 
        tunCRGCurrentCurve% := 2;
        tunType1$ := tunTypeCRG$;
    
        if DlgValue(5) = 0 then  'if CRG is on master, then tuning curve selected is on slave
            tunCurve1Text$ := "Slave will have SECONDARY CRG";
        else
            tunCurve1Text$ := "Master will have SECONDARY CRG";
        endif;
        DlgValue$(updateCurve1Text%, tunCurve1Text$);
        TuningCurveCRGDialogChanged%(-1);  'Enables "OK" button, -1 is sham input
    endif
    
    return 1;
end





' This function is initially called with a "0" input, which forces the 1, 3, 4 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
'func TuningCurveDanishDialogChanged%(item%)    
    'if item% = 0 then
    '    DlgEnable(0, 1, 3, 4);
    'endif   
    'return 1;
'end

func TuningCurveDanishDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    
	GetTuningCurveDanishParameters();
    
    
	DlgCreate("Danish Tuning Curve Parameters");
	DlgInteger(1, "Number of Steps", 2, 100);
    'DlgInteger(1, "Number of Stimuli", 1, 100);
	DlgInteger(2, "Number of Repeats", 1, 1000);
	DlgReal(3, "Min Outer Diameter", 0.1, 100);
	DlgReal(4, "Max Outer Diameter", 0.1, 100);
	DlgCheck(5, "Random Progression");
    DlgCheck(6, "Include Blank");
    DlgButton(151, "Core Grating", TunDlgGratingCore%);
    DlgButton(152, "Donut Grating", TunDlgGratingDonut%);
    DlgButton(153, "Core Vals -> Donut", TunCoreValsToDonut%);
    DlgButton(154, "Donut Vals -> Core", TunDonutValsToCore%);
    'DlgAllow(0xffff, 0, TuningCurveDanishDialogChanged%);
	
    i% := DlgShow(tunDanishNSteps%, tunDanishNRepeats%, tunDanishMinOuterDiameter, tunDanishMaxOuterDiameter, tunDanishProgression%, tunDanishIncludeBlank%);
    
    'for now, no dummy-proofing


	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveDanishParameters();
		tunType$ := tunTypeDanish$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;



' This function is initially called with a "0" input, which forces the 1, 3, 4 dialogs to be disabled
' Of course, this could just be done with a DlgEnable call at the point of dialog creation.  There
' doesn't seem to be any plan to un-disable those dialogs when the enabled dialog is changed.
'func TuningCurveDSSDialogChanged%(item%)    
'    if item% = 0 then
'        DlgEnable(0, 1, 3, 4);
'    endif   
'    return 1;
'end

func TuningCurveDSSDialog%()
	var iReturn% := 0;
	var i%;
    var sValues$;
    var iValue%:=0;
    var result[1000];
    var indices%[1000];
    
	GetTuningCurveDSSParameters();
    
    ' Before we proceed, we must generate a list of choices for the optimal diameter. These are based on the most recent run of Area tuning
    ' Note that there are nsteps+1 values. 
    
    'GetRepeatedParameterProgression%(tunAreaNSteps%+1, 1, result[], indices%[], tunAreaMinDiam, tunAreaMaxDiam, 1, tunAreaProgression%);
    'sValues$ := GetRealArrayAsStringSep$(result[0:tunAreaNSteps%+1], indices%[0:tunAreaNSteps%+1], "|");
    
    'We want the default maximal value to be the largest value available when we open the dialog
    'so set tunBerlinerMaximalIndex% appropriately
    'tunBerlinerMaximalIndex% := tunAreaNSteps%;
    
    'Define tunBerlinerNSteps%, because we are no longer doing a tuning curve.
    'tunBerlinerNSteps% := 6;
    
	DlgCreate("DSS Parameters");
    DlgInteger(1, "Number of Trials", 1, 1000);
	DlgInteger(2, "Number of Surround Flashes/Blanks", 1, 1000);
	DlgInteger(3, "Number of 'Blank' Flashes", 0, 500);
	DlgInteger(4, "Number of Flashes per Reward",  1, 100);
    DlgButton(151, "Core Grating", TunDlgGratingMaster%);
    DlgButton(152, "Donut Grating", TunDlgGratingDonut%);
    DlgButton(153, "Core Vals -> Donut", TunCoreValsToDonut%);
    DlgButton(154, "Donut Vals -> Core", TunDonutValsToCore%);
    'DlgAllow(0xffff, 0, TuningCurveDSSDialogChanged%);
	'i% := DlgShow(tunAreaNSteps%, tunAreaNRepeats%, tunAreaMinDiam, tunAreaMaxDiam, tunAreaProgression%, tunDonutOptimalIndex%, tunBerlinerMaximalIndex%);
    i% := DlgShow(tunDSSNTrials%,tunDSSNPeriods%, tunDSSNBlanks%, tunDSSNFlashesPerReward%);
    
  
    ' Can't allow too many blanks
    if tunDSSNBlanks%*10 > tunDSSNPeriods% then
        i% := 0;  'Treat this as a "cancel"
        message("Oops!|A maximum of 1/10 of stimuli can be flashes\nTry again!");
    endif;
    
	' If i% is 1 the user hit "OK". If its 0, user hit "Cancel". 
	' When user hits OK we always save the parameters, and when user hits Cancel we don't.
    ' 
    ' djs 2/4/2011
    ' Spike2 bug workaround implemented. The return value from this function (when in DAQ context this
    ' dialog is called from a DlgButton in another dialog) should make the parent dialog close, as if 
    ' the OK button were hit. Bug in Spike2 v6 means this doesn't work right - the parent dialog will 
    ' close but its variables are not updated prior to doing so.... so any changes to the parent dialog
    ' are not seen in the subsequent expt, they're not saved in the registry, etc. Workaround is to return
    ' something > 0 here. The parent dialog will continue to display, and the user has to hit OK on that 
    ' before things proceed. 
	if i% = 1 then
		SaveTuningCurveDSSParameters();
		tunType$ := tunTypeDSS$;
		if tunContext$ = tunContextDAQ$ then
            ' djs 2/4/2011 We return 1 - that's the workaround			iReturn% := 0;
            iReturn% := 1;
		else
			iReturn% := 1;
		endif;
	endif;
	if i% = 0 then
		tunType$ := tunTypeNone$;
		if tunContext$ = tunContextDAQ$ then
			iReturn% := 1;
		else
			iReturn% := 2;
		endif;
	endif;
    
	return iReturn%;
end;






func TunDlgGratingMaster%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Stimulus");
    i% := GratingParametersDialogMaster%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("Stimulus", tunGratingParams$);
        SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end



func TunDlgGratingSlave%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("SlaveStimulus");
    i% := GratingParametersDialogSlave%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("SlaveStimulus", tunGratingParams$);
        SaveGratingParameters("StatSlaveStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end


func TunDlgGratingCore%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Stimulus");
    i% := GratingParametersDialogCore%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("Stimulus", tunGratingParams$);
        SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end


func TunDlgGratingDonut%()
    
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var param$, cv$, pattern$, aperture$;
    var label$;
    var i%;
    var tunGratingParamsStat$;
    
    tunGratingParams$ := GetGratingParameters$("Distractor1");
    i% := GratingParametersDialogDonut%(label$, tunGratingParams$, tunGratingParamsStat$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    if i% = 1 then
        SaveGratingParameters("Distractor1", tunGratingParams$);
        'SaveGratingParameters("StatStimulus", tunGratingParamsStat$);
    endif
    
    return 1;
end


func GratingParametersDialogMaster%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    
	var i% := 15;  'That's right, 15, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 15 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 10);
        DlgReal(9, "Temporal Freq:", 0, 10);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern:", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgButton(15, "Copy from Slave", TunCopySlaveVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
        Convert180(phase);
        
    wend;
      
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif
    return i%;
end;

func GratingParametersDialogSlave%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    
	var i% := 15;  'That's right, 15, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 15 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 10);
        DlgReal(9, "Temporal Freq:", 0, 10);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern:", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgButton(15, "Copy From Master", TunCopyMasterVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
        Convert180(phase);
        
    wend;
    
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif;
    return i%;
end;


func GratingParametersDialogCore%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    
	var i% := 15;  'That's right, 15, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 15 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 10);
        DlgReal(9, "Temporal Freq:", 0, 10);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern:", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgButton(15, "Copy from Donut!", TunCopyDonutVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
        Convert180(phase);
        
    wend;
      
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters, not using static but easier to just leave it in
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif
    return i%;
end;



func GratingParametersDialogDonut%(label$, &param$, &statparam$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    
	var i% := 15;  'That's right, 15, which is the button that we want to use for copying parameters over
    
	var ColorVectorList$[5];
	var cvl$[5];
	var icvl% := 0;
    var icvlS% := 0;
	ColorVectorList$[0]:="Black/White";	cvl$[0]:="b";
	ColorVectorList$[1]:="L cone";		cvl$[1]:="l";
	ColorVectorList$[2]:="M cone";		cvl$[2]:="m";
	ColorVectorList$[3]:="S cone";		cvl$[3]:="s";
	ColorVectorList$[4]:="Custom";		cvl$[4]:="custom";
    
	var PatternList$[2];
	var pl$[2];
	var ipl% := 0;
    var iplS% := 0;
	PatternList$[0]:="Sine";	pl$[0]:="s";
	PatternList$[1]:="Square";	pl$[1]:="q";
    
	var ApertureList$[2];
	var al$[2];
	var ial% := 0;
    var ialS% := 0;
	ApertureList$[0]:="Ellipse";	al$[0]:="e";
	ApertureList$[1]:="Rectangle";	al$[1]:="r";
    
    while i% = 15 do
        
        ' If the passed param$ is non-empty, then parse it before opening the dialog. 
        if Len(param$)>0 then
            if ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$) = 0 then
                icvl% := FindMatchedStringIndex%(cv$, cvl$[], 2, 0);
                ipl% := FindMatchedStringIndex%(pattern$, pl$[], 2, 0);
                ial% := FindMatchedStringIndex%(aperture$, al$, 3, 0);
            endif
        endif
        
        DlgCreate("Grating parameters: " + label$, 25, 11);
        '    DlgAllow(0, 0, GratingParametersDialogDoubleCheck%);
        DlgReal(1, "X:", -40, 40);
        DlgReal(2, "Y:", -40, 40);
        DlgReal(3, "Outer Width:", .1, 30);
        DlgReal(4, "Outer Height:", .1, 30);
        DlgReal(5, "Inner Width:", 0, 30);
        DlgReal(6, "Inner Height:", 0, 30);
        DlgInteger(7, "Contrast(%):", -100, 100);
        DlgReal(8, "Spatial Freq:", .01, 10);
        DlgReal(9, "Temporal Freq:", 0, 10);
        DlgReal(10, "Orientation (degrees):", -360, 360);
        DlgReal(11, "Initial Phase (deg, 0 = white at center)", 0, 360);
        DlgList(12, "Color:", ColorVectorList$[]);
        DlgList(13, "Pattern:", PatternList$[]);
        DlgList(14, "Aperture:", ApertureList$[]);
        DlgButton(15, "Copy From Core", TunCopyCoreVals%(param$));
        
        i% := DlgShow(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, icvl%, ipl%, ial%);
        Convert180(phase);
        
    wend;
    
	if i%=1 then
		cv$ := cvl$[icvl%];
		pattern$ := pl$[ipl%];
		aperture$ := al$[ial%];
        if w > iw and h > ih then  'don't let inner dimensions of donut be larger than outer
            ' save parameters, not using static but easier to just leave it in
            param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
            statparam$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
        else
            message("Inner diameters cannot be greater than outer diameters!  Try Again!");
        endif;
    endif;
    return i%;
end;



func TunCopySlaveVals%(&param$)

    param$ := GetGratingParameters$("SlaveStimulus");

    return 1;
end



func TunCopyMasterVals%(&param$)

    param$ := GetGratingParameters$("Stimulus");

    return 1;
end


func TunCopyDonutVals%(&param$)
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    'Simply using "Distractor1" rather than making a separate "Donut" grating, can change if it's a problem
    param$ := GetGratingParameters$("Distractor1");
    ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    w := iw;  'set grating width to make a core that fits inside the donut, of zero inner diameter
    h := ih;
    iw := 0;
    ih := 0;
    param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);


    return 1;
end

func TunCopyCoreVals%(&param$)
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;    
    
    param$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(param$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    iw := w;  'set grating width to make a donut that surrounds the core, of arbitrary width
    ih := h;
    w := iw+1;
    h := ih+1;
    param$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);

    return 1;
end


func TunMasterValsToSlave%()
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("Stimulus");
    SaveGratingParameters("SlaveStimulus", tempParams$);
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
    SaveGratingParameters("StatSlaveStimulus", tempParams$);
    
    return 1;
end


func TunSlaveValsToMaster%()
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("SlaveStimulus");
    SaveGratingParameters("Stimulus", tempParams$);
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, 0, ori, phase, cv$, pattern$, aperture$);  'hardcoded zero TF
    SaveGratingParameters("StatStimulus", tempParams$);
    
    return 1;
end


func TunCoreValsToDonut%()
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("Stimulus");
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    iw := w;  'set grating width to make a donut that surrounds the core, of arbitrary width
    ih := h;
    w := iw+1;
    h := ih+1;
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    SaveGratingParameters("Distractor1", tempParams$);
    
    return 1;
end


func TunDonutValsToCore%()
    
    var x, y, w, h, iw, ih;
    var contrast%;
    var sf, tf, ori, phase;
    var cv$, pattern$, aperture$;
    
    var tempParams$;
    
    tempParams$ := GetGratingParameters$("Distractor1");
    ParseGratingParameters%(tempParams$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    w := iw;  'set grating width to make a core that fits inside the donut, of zero inner diameter
    h := ih;
    iw := 0;
    ih := 0;
    tempParams$ := EncodeGratingParameters$(x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    SaveGratingParameters("Stimulus", tempParams$);
    
    return 1;
end


func TuningXHairDialog%()
    DlgCreate("Crosshair/Grid");
    DlgCheck(1, "Use crosshair grid");
    DlgReal(2, "Grid inner radius offset", 0, 100);
    DlgReal(3, "Grid mid radius offset", 0, 100);
    DlgReal(4, "Grid outer radius offset", 0, 100);
    DlgInteger(5, "Number of divisions in grid", 2, 128);
    DlgReal(6, "XHair inner offset", -1, 100);
    DlgReal(7, "XHair outer offset", -1, 100);
    DlgAllow(0xffff, 0, TuningXHairDialogChanged%);
    DlgShow(tunUseXHairs%, tunXHairInnerRadiusOffset, tunXHairMiddleRadiusOffset, tunXHairOuterRadiusOffset, tunXHairNumGridDivisions%, tunXHairTicInnerOffset, tunXHairTicOuterOffset);
    return 1;
end


func TuningXHairDialogChanged%(item%)
    docase 
    case item% = 0 then
        DlgEnable(tunUseXHairs%, 2, 3, 4, 5, 6, 7);
    case item% = 1 then
        DlgEnable(DlgValue(1), 2, 3, 4, 5, 6, 7);
    endcase
    return 1;
end





'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve main dialog START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''




proc GetTuningCurveScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
	tunFixationDuration := GetFloatRegistryValue(key$, "FixationDuration", tunFixationDuration);
    tunUseMaintainMode% := GetIntRegistryValue%(key$, "UseMaintainMode", tunUseMaintainMode%);
	tunMaintainFixation := GetFloatRegistryValue(key$, "MaintainFixation", tunMaintainFixation);
    tunAcquisitionTime := GetFloatRegistryValue(key$, "AcquisitionTime", tunAcquisitionTime);
    tunAcqFailTime := GetFloatRegistryValue(key$, "AcqFailTime", tunAcqFailTime);
    tunHoldFailTime := GetFloatRegistryValue(key$, "HoldFailTime", tunHoldFailTime);
    tunMaintainFailTime := GetFloatRegistryValue(key$, "MaintainFailTime", tunMaintainFailTime);
    tunStdInterTrialTime := GetFloatRegistryValue(key$, "StdInterTrialTime", tunStdInterTrialTime);
    tunBackgroundColor$ := GetStringRegistryValue$(key$, "BackgroundColor", tunBackgroundColor$);
    tunDoRivalry% := GetIntRegistryValue%(key$, "DoRivalry", tunDoRivalry%);
    tunDualTuningType% := GetIntRegistryValue%(key$, "DualTuningType", tunDualTuningType%);
    tunUseXHairs% := GetIntRegistryValue%(key$, "UseXHairs", tunUseXHairs%);
    tunXHairInnerRadiusOffset := GetFloatRegistryValue(key$, "XHairInnerRadiusOffset", tunXHairInnerRadiusOffset);
    tunXHairMiddleRadiusOffset := GetFloatRegistryValue(key$, "XHairMiddleRadiusOffset", tunXHairMiddleRadiusOffset);
    tunXHairOuterRadiusOffset := GetFloatRegistryValue(key$, "XHairOuterRadiusOffset", tunXHairOuterRadiusOffset);
    tunXHairTicInnerOffset := GetFloatRegistryValue(key$, "XHairTicInnerOffset", tunXHairTicInnerOffset);
    tunXHairTicOuterOffset := GetFloatRegistryValue(key$, "XHairTicOuterOffset", tunXHairTicOuterOffset);
    tunXHairNumGridDivisions% := GetIntRegistryValue%(key$, "XHairNumGridDivisions", tunXHairNumGridDivisions%);
    tunButtonCollect% := GetIntRegistryValue%(key$, "ButtonCollect", tunButtonCollect%);
    tunDoTuningHist% := GetIntRegistryValue%(key$, "DoTuningHist", tunDoTuningHist%);
     
end;

proc SaveTuningCurveScriptParameters()
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Tuning";
    
	SetFloatRegistryValue(key$, "FixationDuration", tunFixationDuration);
    SetIntRegistryValue(key$, "UseMaintainMode", tunUseMaintainMode%);
	SetFloatRegistryValue(key$, "MaintainFixation", tunMaintainFixation);
    SetFloatRegistryValue(key$, "AcquisitionTime", tunAcquisitionTime);
    SetFloatRegistryValue(key$, "AcqFailTime", tunAcqFailTime);
    SetFloatRegistryValue(key$, "HoldFailTime", tunHoldFailTime);
    SetFloatRegistryValue(key$, "MaintainFailTime", tunMaintainFailTime);
    SetFloatRegistryValue(key$, "StdInterTrialTime", tunStdInterTrialTime);
    SetStringRegistryValue(key$, "BackgroundColor", tunBackgroundColor$);
    SetIntRegistryValue(key$, "DoRivalry", tunDoRivalry%);
    SetIntRegistryValue(key$, "DualTuningType", tunDualTuningType%);
    SetIntRegistryValue(key$, "UseXHairs", tunUseXHairs%);
    SetFloatRegistryValue(key$, "XHairInnerRadiusOffset", tunXHairInnerRadiusOffset);
    SetFloatRegistryValue(key$, "XHairMiddleRadiusOffset", tunXHairMiddleRadiusOffset);
    SetFloatRegistryValue(key$, "XHairOuterRadiusOffset", tunXHairOuterRadiusOffset);
    SetFloatRegistryValue(key$, "XHairTicInnerOffset", tunXHairTicInnerOffset);
    SetFloatRegistryValue(key$, "XHairTicOuterOffset", tunXHairTicOuterOffset);
    SetIntRegistryValue(key$, "XHairNumGridDivisions", tunXHairNumGridDivisions%);
    SetIntRegistryValue(key$, "ButtonCollect", tunButtonCollect%);
    SetIntRegistryValue(key$, "DoTuningHist", tunDoTuningHist%);

    PrintLog("Saved DoRivalry=%d\n", tunDoRivalry%);
end;


' TuningCurveScriptDialog
' This dialog uses two global variables, tunContext$ and tunType$. 
' Set tunContext$ = tunContextConfig$ to run in the config scripts. The dialog 
' and its children (TuningCurveOrientationDialog, etc) will behave as expected, 
' allowing the user to set parameters and saving them in the registry. Set 
' tunContext$ = tunContextDAQ$ to run in a DAQ script. In this context you 
' must check the return value of the dialog and (possibly) the value of 
' tunType$. If the user hits Cancel in the main dialog, the return value is 0. 
' If the user selects a subdialog and hits OK, the return value will be 1 and 
' the value of tunType$ will be one of (tunTypeOrientation$, tunTypeContrast$, 
' tunTypeSpatial$, tunTypeTemporal$). Here, proceed directly to DAQ. If the 
' user Hits Cancel from the subdialog, then they return to the main dialog. If 
' they hit OK from the main dialog, then the return value is 1, but 
' tunType$ = tunTypeNone$. 


func TuningCurveScriptDialog%()
	var i%;
	var iReturn%;
    var tempParam$;
    var tempPhase;
    var boxOK% := 1;  'do the stimulus/crosshairs boxes overlap?
	GetTuningCurveScriptParameters();
	var bcl$[3];
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
    var ibcl%:=0;
    var dualType$[3];
    dualType$[0] := "Dual Tuning";
    dualType$[1] := "Master only";
    dualType$[2] := "Slave only";
    var maintainList$[4];
    maintainList$[0] := "No";
    maintainList$[1] := "FixOnly";
    maintainList$[2] := "All";
    maintainList$[3] := "All+Rwd";
    
	for i%:=0 to 2 do
		if tunBackgroundColor$ = bcl$[i%] then
			ibcl% := i%;
		endif
	next;
    
    docase 
    case tunUseXHairs% = 0 then
        tunXHairText$ := "Crosshairs are OFF";
    case tunUseXHairs% = 1 then
        tunXHairText$ := "Crosshairs are ON";
    endcase
    
    'Updated dialog box - more efficient use of space, neater
    DlgCreate("Tuning Curve Parameters", 0, 0, 0, 0, -1, 1, 1);  'center dialog relative to screen and not to application window to eliminate cutting off the bottom of the dialog!
	DlgGroup("Common Parameters", 1, 1, 52, 10);
	DlgReal(1, "Acquire Fixation time(s):", 1, 1000, 40, 2);
    DlgReal(2, "Acquire Fixation penalty(s):", .01, 10, 40, 3);
	DlgReal(3, "Stimulus duration(s):", .1, 60, 40, 4);
    DlgReal(4, "During-Stim fixation break penalty(s):", .01, 10, 40, 5);
    DlgReal(5, "Intertrial interval(s):", .01, 10, 40, 6);
	DlgReal(6, "Maintain fixation after stim(s):", .1, 10, 40, 7);
	DlgReal(7, "Maintain fixation after stim penalty(s):", .01, 10, 40, 8);
	DlgList(8, "Background color:", bcl$, 3, 34, 9);
    if JuicerType% = 1 then
        DlgInteger(9, "Juicer open dur. (ms):", 1, 2000, 40, 10);
    else  'JuicerResult should only be 2, other values should not allow access to dialog box
        DlgInteger(9, "Num. juicer pulses:", 1, 20, 40, 10);
    endif;   
    'juicer duration / n repeats dialog here?  Have to write values to DAQ parameters if changed, disable if not correct for juicer? 
    DlgGroup("Dual VSG Options", 1, 11, 52, 3);
    DlgCheck(10, "Use Dual VSG", 2, 12);
    DlgCheck(11, "Select to turn off card sync", 25, 12);
    DlgList(12, "Dual Tuning Configuration:", dualType$, 3, 25, 13);
    
    'DlgCheck(13, "Maintain Fixpt between trials", 2, 14);  'change this to a list
    DlgList(13, 11, maintainList$, 4, 3, 14); DlgText("Maintain Fixpt btwn trls", 15, 14);
    DlgCheck(14, "Stationary",2,15);
    DlgCheck(15, "Make Histograms", 35,14);
    DlgCheck(16, "Use Rivalry Button", 35,15);
    DlgButton(tundlgXHairButton%, " Crosshairs  ", UpdateTuningXHairDialog%, 1, 16);
    updateXHairText% := DlgText(tunXHairText$, 15, 16);
	DlgGroup("Individual Tuning Curve Types", 1, 17, 52, 6);
	DlgButton(tundlgOrientationButton%, " Orientation  ", TuningCurveOrientationDialog%, 2, 18); 'Note that labels for Orientation-Area are superceded 
	DlgButton(tundlgContrastButton%, "     Contrast     ", TuningCurveContrastDialog%, 18, 18);  'by TuningCurveScriptDialogChanged% even upon opening 
	DlgButton(tundlgSpatialButton%, "Spatial Freq", TuningCurveSpatialDialog%, 2, 19);           'the dialog (i.e. whatever label is here is unused)
	DlgButton(tundlgTemporalButton%, "Temporal Freq", TuningCurveTemporalDialog%, 18, 19);
	DlgButton(tundlgAreaButton%, "         Area         ", TuningCurveAreaDialog%, 36, 18);
    DlgButton(tundlgXPosButton%, "     X Position     ", TuningCurveXPosDialog%, 36, 19);
	DlgButton(tundlgDonutButton%, "   Donuts!   ", TuningCurveDonutDialog%, 2, 20);
    DlgButton(tundlgBerlinerButton%, "    Berliners!    ", TuningCurveBerlinerDialog%, 18, 20);
    DlgButton(tundlgBoxODonutsButton%, " Box O' Donuts ", TuningCurveBoxODonutsDialog%, 36, 20);
    DlgButton(tundlgDotsButton%, "     Dots!     ", TuningCurveDotsDialog%, 2, 21);
    DlgButton(tundlgCRGButton%,"      CRaGs      ",TuningCurveCRGDialog%, 18, 21);
    DlgButton(tundlgDisparityButton%, "      Disparity      ", TuningCurveDisparityDialog%, 36, 21);
    DlgButton(tundlgDanishButton%, "  Danishes!  ", TuningCurveDanishDialog%, 2, 22);
    DlgButton(tundlgDSSButton%,"        DSS        ",TuningCurveDSSDialog%, 18, 22);
    DlgAllow(0xffff, 0, TuningCurveScriptDialogChanged%);
	
    if JuicerType% = 1 then
        i%:=DlgShow(tunAcquisitionTime, tunAcqFailTime, tunFixationDuration, tunHoldFailTime, 
        tunStdInterTrialTime, tunMaintainFixation, tunMaintainFailTime,
        ibcl%, JuiceRewardMS%, tunDoRivalry%, tunNoCardSync%, 
        tunDualTuningType%, tunUseMaintainMode%, tunSetStationary%, tunDoTuningHist%, tunButtonCollect%);
    else
        i%:=DlgShow(tunAcquisitionTime, tunAcqFailTime, tunFixationDuration, tunHoldFailTime, 
        tunStdInterTrialTime, tunMaintainFixation, tunMaintainFailTime, 
        ibcl%, JuicePerReward%, tunDoRivalry%, tunNoCardSync%, 
        tunDualTuningType%, tunUseMaintainMode%, tunSetStationary%, tunDoTuningHist%, tunButtonCollect%);
    endif;
    
    
    ' djs 4-1-09
    ' Spike2 v6 change. DlgShow will return the button number when a button on the dialog is hit and the corresponding
    ' function returns 0. In this case those buttons open the various tuning type sub dialogs (orientation, area, etc). 
    ' In the last version, DlgShow would return the same value that the subdialog's function returned, and the code here
    ' was set up to behave accordingly. When the user hits the Cancel button in the subdialog everything still remains
    ' the same. 
    
    ' djs 2-4-2011
    ' Spike2v6 bug (see TuningDialogs.s2s) workaround requires that the tuning type dialogs return something > 0. 
    ' That will mean that closing any of those dialogs will not cause the main dialog (this one) to close automatically. 
    ' When it did close automatically the return value from DlgShow above was the same as the button that caused
    ' the close. Now, that button is NOT causing the close, so the return value is going to be 1 (not the button number). 
    ' In addition, the return value from this function needs to change because we now assume that the user will have
    ' to hit OK on this dialog to start the experiment. Thus, make sure that the return value from this function is 1
    ' when user hits OK and 0 when user hits Cancel. Also, do not save script parameters when user hits Cancel.
    
    'PrintLog("Tuning Curve Parameters Dialog - return from DlgShow is %d\n", i%);
    '	if i%=tundlgOrientationButton% or i%=tundlgContrastButton% or i%=tundlgSpatialButton% or i%=tundlgTemporalButton% or i%=tundlgAreaButton% then
    if i% = 1 then
		tunBackgroundColor$ := bcl$[ibcl%];
		SaveTuningCurveScriptParameters();
        SaveDAQParameters();  'Now saving DAQ parameters because juicer variables can change
        tunDSSDuration := tunFixationDuration;  'just setting this no matter what, not much reason to put in an IF
		if tunContext$ = tunContextDAQ$ then 
            iReturn% := 1;
		else iReturn% := 1;
		endif;
        
        'do not allow incorrect maintain mode - 1 is only legal for danishes
        if tunUseMaintainMode% = 1 and tunType$ <> tunTypeDanish$ then
            tunUseMaintainMode% := 2;
        endif;
        
        'check to make sure that the box for the crosshairs and stimuli do not overlap
        'this would work if it only got the maximum value of the size of the stimuli
        if tunUseXHairs% = 1 and (tunType$ = tunTypeBerliner$ or tunType$ = tunTypeDonut$) then
            tempParam$ := GetGratingParameters$("Stimulus");
            boxOK% := CheckXHairStimulusBox(tempParam$,tunXHairOuterRadiusOffset,tunMaximalDiam);
            if boxOK% = 0 then
                boxOK% := Query("The stimulus will overlap the crosshairs!","Continue","Quit");
            endif;           
            if boxOK% = 1 then
                tempParam$ := GetGratingParameters$("SlaveStimulus");
                boxOK% := CheckXHairStimulusBox(tempParam$,tunXHairOuterRadiusOffset,tunSlaveMaximalDiam);
                if boxOK% = 0 then
                    boxOK% := Query("The slave stimulus will overlap the crosshairs!","Continue","Quit");
                endif;
            endif;
            if boxOK% = 0 then
                iReturn% := 0;  'quit if user requested quit
            endif;
        endif;  
        
	endif;
	if i% = 0 then
		'PrintLog("Tuning Curve Parameters dialog - user hit Cancel, tunType=" + tunType$ + "\n");
		if tunContext$ = tunContextDAQ$ then 
			if tunType$ <> tunTypeNone$ then 
				iReturn% := 0;
				'SaveTuningCurveScriptParameters();
			else iReturn% := 0;
		 	endif;
		else
			iReturn% := 2;		' The calling/main dialog would close if we returned 0
		endif;
	endif;
	return iReturn%;
end;



func TuningCurveScriptDialogChanged%(item%) 
    if DlgValue(10) = 0 then  'If single VSG, do not allow Donuts or Berliners or disparity or CRG
        DlgEnable(0,-tundlgDonutButton%,-tundlgBerlinerButton%,-tundlgBoxODonutsButton%,-tundlgCRGButton%,-tundlgDisparityButton%);
        'Also disable card synch functions, dual tuning listbox
        DlgEnable(0,11); 'card synch
        DlgEnable(0,12); 'dual tuning listbox
        'But do allow Dots, Danish, DSS
        DlgEnable(1,-tundlgDotsButton%);
        DlgEnable(1,-tundlgDanishButton%);
        DlgEnable(1,-tundlgDSSButton%);
        'Also, change labels on buttons to reflect the monocular aspect of not using dual VSG
        DlgValue$(-tundlgOrientationButton%, " Orientation  ");
        DlgValue$(-tundlgContrastButton%, "     Contrast     ");
        DlgValue$(-tundlgSpatialButton%, "Spatial Freq");
        DlgValue$(-tundlgTemporalButton%, "Temporal Freq");
        DlgValue$(-tundlgAreaButton%, "Area");
        DlgValue$(-tundlgXPosButton%, "XY Position");
    endif;
    if DlgValue(10) = 1 then  'If dual VSG, allow donuts and Berliners and disparity and CRG
        DlgEnable(1,-tundlgDonutButton%,-tundlgBerlinerButton%,-tundlgBoxODonutsButton%,-tundlgCRGButton%,-tundlgDisparityButton%);
        'Also allow turning off card synch, dual tuning listbox
        DlgEnable(1,11);  'card synch
        DlgEnable(1,12);  'dual tuning listbox
        'But don't allow Dots, Danish, DSS
        DlgEnable(0,-tundlgDotsButton%);
        DlgEnable(0,-tundlgDanishButton%);
        DlgEnable(0,-tundlgDSSButton%);
        'Also, change labels on buttons to reflect the binocular aspect of using dual VSG
        docase 
            case DlgValue(12) = 0 then
                DlgValue$(-tundlgOrientationButton%, " D Orientation ");
                DlgValue$(-tundlgContrastButton%, "    D Contrast    ");
                DlgValue$(-tundlgSpatialButton%, "D Spatial Freq");
                DlgValue$(-tundlgTemporalButton%, "D Temporal Freq");
                DlgValue$(-tundlgAreaButton%, "D Area");
                DlgValue$(-tundlgXPosButton%, "D X Position");
            case DlgValue(12) = 1 then
                DlgValue$(-tundlgOrientationButton%, " M Orientation ");
                DlgValue$(-tundlgContrastButton%, "    M Contrast    ");
                DlgValue$(-tundlgSpatialButton%, "M Spatial Freq");
                DlgValue$(-tundlgTemporalButton%, "M Temporal Freq");
                DlgValue$(-tundlgAreaButton%, "M Area");
                DlgValue$(-tundlgXPosButton%, "M X Position");
            case DlgValue(12) = 2 then
                DlgValue$(-tundlgOrientationButton%, " S Orientation ");
                DlgValue$(-tundlgContrastButton%, "    S Contrast    ");
                DlgValue$(-tundlgSpatialButton%, "S Spatial Freq");
                DlgValue$(-tundlgTemporalButton%, "S Temporal Freq");
                DlgValue$(-tundlgAreaButton%, "S Area");
                DlgValue$(-tundlgXPosButton%, "S X Position");
        endcase;
    endif;
    if DlgValue(13) = 0 then 'disable maintain mode timing if not using maintain mode
        DlgEnable(0,6);
        DlgEnable(0,7);
    endif;
    if DlgValue(13) = 1 then 'enable maintain mode timing if using maintain mode
        DlgEnable(1,6);
        DlgEnable(1,7);
    endif;
    return 1;
end




func UpdateTuningXHairDialog%()
    
    'Run the tuning crosshairs dialog  
    TuningXHairDialog%();  
    
    'When done with the tuning crosshairs dialog, update tunXHairText$ and update the main dialog
    docase 
    case tunUseXHairs% = 0 then
        tunXHairText$ := "Crosshairs are OFF";
    case tunUseXHairs% = 1 then
        tunXHairText$ := "Crosshairs are ON";
    endcase
    
    DlgValue$(updateXHairText%, tunXHairText$);
    
    return 1;
end


'----- Check to make sure the stimulus and crosshair rectangles do not overlap
Func CheckXHairStimulusBox(gr$,maxRadius,maxDiam);
    var x;
    var y;
    var w;
    var h;
    var iw;
    var ih;
    var contrast%;
    var sf;
    var tf;
    var ori;
    var phase;
    var cv$;
    var pattern$;
    var aperture$;
    var xencroach;
    var yencroach;
    
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    xencroach := Abs(x) - w/2;
    yencroach := Abs(y) - h/2;
    if maxDiam > 0 then
        xencroach := Abs(x) - maxDiam/2;
        yencroach := Abs(y) - maxDiam/2;
    endif;
    if xencroach < maxRadius and yencroach < maxRadius then
        return 0;  'rectangles will overlap
    else
        return 1;  'rectangles will not overlap
    endif;
       
end



func SelectSEQFile%()

    var status% := 1;
    var direc$;
    var fh0%;
    
    direc$ := FilePath$();  'get current directory
    fh0%:=FileOpen(direc$+"*.txt",1,0,"Please select a CRG sequence file");  'Find a sequence file
    direc$ := FileName$(0);  'Get full path of selected file
    FileClose(fh0%);  'Just close the file, we're not using it
    DlgValue$(4,direc$);  'Place filename into dialog item 4 of calling dialog

	return status%;  'return 1 so calling dialog doesn't close
    
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Tuning Curve main dialog END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
