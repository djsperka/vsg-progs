' $Id: Fixation.s2s,v 1.41 2016-04-01 22:03:36 devel Exp $
' Update 11/8/11 Jeff, includes SafeSampleKey and multi-juicer updates

#include "../../Spike2Util/UsreyUtil.s2s"
#include "../../Spike2Util/ChannelUtilities.s2s"
#include "UsreyDAQ.s2s"
#include "UsreyFixationPoint.s2s"

'========================================================================
'
' INPUTS
'
' Eye X, Y - ADC input 14, 15 respectively
' VSG trigger - assumed on DIGIN byte 0.  *** THE 1401 SHOULD HAVE PREFERENCES 
'               SET WITH THE "Event Ports 0 and 1 on read digital input connector" 
'               BOX CHECKED!!!
'
'========================================================================


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Fixation script parameters START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Fixation-script specific control vars.
var fixFixationDuration;			' Time required to maintain fixation, seconds
var fixAcquisitionTime;			' Time allowed to acquire target before fail trial, seconds
var fixInterTrialTime;			' Blank time following a trial (both successful and failed), seconds
var fixNumberOfTrials%;			' Number of trials to run
var fixStimulusFlag%;			' Tells whether to use stimulus grating (used as a distractor) 
var fixDistractor1Flag%; 			' Tells stim to use distractor1 (1) or not (0)
var fixDistractor2Flag%; 			' Tells stim to use distractor1 (1) or not (0)
var fixDistractor3Flag%; 			' Tells stim to use distractor1 (1) or not (0)
var fixDistractor4Flag%; 			' Tells stim to use distractor1 (1) or not (0)
var fixBackgroundColor$;			' Background color for stim
var fixDualStim%;                   ' 1 for dual stim on Joe's rig
var fixCalibrationFlag%;			' 1 for calibration run
var fixCalibrationOffset;			' degree offset for calibration dots
var fixAlwaysLooking% := 0;
var fixPendingCalMode% := 0;        ' Set when user hits Horizontal, Vertical, Corners, or Center key. See UpdateCalMode().
var fixInterleaveLED%;              'If 1, interleave fixation LED with fixation point
var fixSimultaneousLED%;
var fixSaveData%;                   'If 1, save data to fixSaveDataName$;
var fixSaveDataName$ := "F:\\Experiments\\fixation\\fixdata.mat";

proc GetFixationScriptParameters()
	var stmp$;
	var key$;

	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Fixation";

	Profile(key$, "FixationDuration", "1.0", stmp$);
	fixFixationDuration := val(stmp$);

	Profile(key$, "AcquisitionTime", "1.0", stmp$);
	fixAcquisitionTime := val(stmp$);

	Profile(key$, "InterTrialTime", "1.0", stmp$);
	fixInterTrialTime := val(stmp$);

	Profile(key$, "NumberOfTrials", 1, fixNumberOfTrials%);
	Profile(key$, "BackgroundColor", "gray", fixBackgroundColor$);

	Profile(key$, "UseStimulusFlag", 0, fixStimulusFlag%);
	Profile(key$, "UseDistractor1Flag", 0, fixDistractor1Flag%);
	Profile(key$, "UseDistractor2Flag", 0, fixDistractor2Flag%);
	Profile(key$, "UseDistractor3Flag", 0, fixDistractor3Flag%);
	Profile(key$, "UseDistractor4Flag", 0, fixDistractor4Flag%);
	Profile(key$, "DoCalibrationFlag", 0, fixCalibrationFlag%);
    Profile(key$, "InterleaveLED", 0, fixInterleaveLED%);
    Profile(key$, "SimultaneousLED", 0, fixSimultaneousLED%);
    Profile(key$, "SaveData", 0, fixSaveData%);
	Profile(key$, "CalibrationOffset", "5.0", stmp$);
	fixCalibrationOffset := val(stmp$);
    Profile(key$, "DualStim", "0", stmp$);
    fixDualStim% := val(stmp$);
end;
 	
proc SaveFixationScriptParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\Fixation";

	Profile(key$, "FixationDuration", str$(fixFixationDuration));
	Profile(key$, "AcquisitionTime", str$(fixAcquisitionTime));
	Profile(key$, "InterTrialTime", str$(fixInterTrialTime));
	Profile(key$, "NumberOfTrials", fixNumberOfTrials%);
	Profile(key$, "BackgroundColor", fixBackgroundColor$);
	Profile(key$, "UseStimulusFlag", fixStimulusFlag%);
	Profile(key$, "UseDistractor1Flag", fixDistractor1Flag%);
	Profile(key$, "UseDistractor2Flag", fixDistractor2Flag%);
	Profile(key$, "UseDistractor3Flag", fixDistractor3Flag%);
	Profile(key$, "UseDistractor4Flag", fixDistractor4Flag%);
	Profile(key$, "DoCalibrationFlag", fixCalibrationFlag%);
    Profile(key$, "InterleaveLED", fixInterleaveLED%);
    Profile(key$, "SimultaneousLED", fixSimultaneousLED%);
    Profile(key$, "SaveData", fixSaveData%);
	Profile(key$, "CalibrationOffset", str$(fixCalibrationOffset));
    Profile(key$, "DualStim", str$(fixDualStim%));
end;



func FixationScriptDialog%()
	var i%;
	var bcl$[3];
	var ibcl%:=0;
	GetFixationScriptParameters();
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
	for i%:=0 to 2 do
		if fixBackgroundColor$ = bcl$[i%] then
			ibcl% := i%;
		endif
	next;
	DlgCreate("Fixation Training Parameters", 25, 10);
	DlgReal(1, "Fixation duration(s):", .01, 10);
	DlgReal(2, "Acquisition time(s):", .01, 10);
	DlgReal(3, "Intertrial time(s):", .01, 10);
	DlgInteger(4, "Number of Trials:", 1, 1000);
	DlgList(5, "Background color:", bcl$);
    DlgCheck(6, "Interleave Fixation LED?");
    DlgCheck(7, "LED and Fixation Simultaneous?");
    DlgCheck(8, "Save Data?");
	DlgCheck(9, "Use stimulus?");
	DlgCheck(10, "Use distractor 1?"); 
	DlgCheck(11, "Use distractor 2?");
	DlgCheck(12, "Use distractor 3?");
	DlgCheck(13, "Use distractor 4?");
    DlgCheck(14, "Dual stim?");
	DlgCheck(15, "Calibration run?");
	DlgReal(16, "Calibration offset (deg):", 0, 10);
    DlgCheck(17, "Always looking?");
	i%:=DlgShow(fixFixationDuration, fixAcquisitionTime, fixInterTrialTime, fixNumberOfTrials%, ibcl%, fixInterleaveLED%,
    fixSimultaneousLED%,fixSaveData%, fixStimulusFlag%, fixDistractor1Flag%, fixDistractor2Flag%, fixDistractor3Flag%, fixDistractor4Flag%, 
    fixDualStim%, fixCalibrationFlag%, fixCalibrationOffset, fixAlwaysLooking%);
	if i% = 1 then
		fixBackgroundColor$ := bcl$[ibcl%];
		SaveFixationScriptParameters();
	endif;
	return i%;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Fixation script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''






' Window handles and channel numbers
var XChannel%,YChannel%;		' Channel number assigned to eye x and y
var keyboardChannel%:=31;       'this is the number of the keyboard channel
var TriggerChannel%;			' Channel number assigned to vsg trigger input (i.e. trigger sent by vsg)
var ReadyChannel%;			' channel number for VSG ready pulse signal
var TriggerSlaveChannel%;			' Channel number assigned to vsg trigger input (i.e. trigger sent by vsg)
var ReadySlaveChannel%;			' channel number for VSG ready pulse signal
var DataWindow%;	' time view
var XYWindow%;		' window with eye pos shown
var iStimChannel%;	' channel number for stimulus in xy window
var iStimWindowChannel%;' channel number for stimulus window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window
var StimHandle%;	' handle for stimulus application
var StimHandleSlave%;	' handle for slave stimulus application
' Experimental control
var Pause%:=0;		' When 1, expt is paused - no idle processing done


' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];
' Stimulus location stuff
var iStimX%[9];
var iStimY%[9];
var iStimIndex% := 1;


' init logging so msgs appear in LogWindow
LogInit(1);

' Check for valid data file path
if Len(dataDataSet$) = 0 then
	Message("No data set is selected! Edit Data parameters...");
	' Might be nice to open the dialog here....
	halt;
endif


if FixationScriptDialog%() = 0 then
    halt;
endif

if fixCalibrationFlag% = 1 and fixInterleaveLED% = 1 then
    message("Calibration Flag and Interleave LED flag cannot be simultaneously implemented!");
    halt;
endif


' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 21;
YChannel% := 22;
TriggerChannel% := 23;
ReadyChannel% := 24;
TriggerSlaveChannel% := 25;
ReadySlaveChannel% := 26;
CreateSampleConfiguration();


' Get display windows ready
InitializeWindows();

' Prepare the toolbar buttons
InitializeToolbar();







const stateStartTrial%		:= 0;
const stateWaitForStim%		:= 1;
const stateWaitForAcquisition%	:= 2;
const stateHoldFixation%	:= 3;
const stateSuccess%		:= 4;
const stateFailure%		:= 5;
const stateStimOff%		:= 6;
const stateWaitForBlank%	:= 7;
const stateCheckTrial%		:= 8;
const stateInterval%		:= 9;
const stateDone%		:= 10;
const stateVSGWait%:=10;		' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		' waif for vsg to send ready signal #2
const statePreLEDInterval%:=12;
const stateStartLEDTrial%:=13;
const stateWaitForLEDAcquisition%:=14;
const stateHoldLEDFixation%:=15;
const stateLEDFailure%:=16;
const stateLEDSuccess%:=17;
const stateLEDIsOff%:=18;
const stateNextAfterFixation%:=19;

var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var iState%:=stateVSGWait%;		' present state
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var nTrialsStarted%:=0;
var nTrialsSuccess%:=0;
var nTrialsFail%:=0;
var nLEDTrialsStarted%:=0;
var nLEDTrialsSuccess%:=0;
var nLEDTrialsFail%:=0;
var LEDSuccess%:=0;
var fixSuccess% := 0;

' Run real time analysis here. 
func IdleProcessing%()
	var iStatus% := 1;	' this is return value. value of 1 (0) continues (stops) processing
    var stayInLoop% := 1;
    var pulseFound%, pulseFoundSlave%;
    var tRise, tFall;
    
	tNow := MaxTime();
    
    if tNow - tLast < 0.001 then
        Yield(.001);
        return 1;
    endif
    

	xEye := ChanMeasure(XChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltX;
	yEye := ChanMeasure(YChannel%,2,tNow-.006,tNow-.001)*DegreesPerVoltY;

	' Don't update display every time....
	if tNow-tLastUpdate > .005 then
		View(XYWindow%).XYAddData(1,xEye,yEye);
		tLastUpdate := tNow;
	endif
    
    while stayInLoop% = 1 do
        
        tNow := MaxTime();  'reestablish tNow in case it has changed
        stayInLoop% := 0;  'Allow break
        
        ' What state are we in? 
        docase 
            
            
        case iState% = stateVSGWait% then
            
            pulseFound% := View(DataWindow%).FindPulseUp%(ReadyChannel%, tLastTrigger+View(DataWindow%).BinSize(), tRise, tFall);
        
            if fixDualStim% = 0 then
                if pulseFound% = 1 then
                    LogStatus("VSGWait", "Got Ready Pulse from VSG at " + str$(tRise));
                    Yield(1.0);
                    tLastTrigger := tFall;
                    ChangeStateTo(stateStartTrial%, tFall);
                else
                    if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                        LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                        tLastTrigger := tFall;
                    endif;
                endif;
            else
                pulseFoundSlave% := View(DataWindow%).FindPulseUp%(ReadySlaveChannel%, tLastTrigger+View(DataWindow%).BinSize(), tRise, tFall);
                if pulseFound% = 1 and pulseFoundSlave% = 1 then
                    LogStatus("VSGWait", "Got SLAVE Ready Pulse from VSG at " + str$(tRise));
                    Yield(1.0);
                    tLastTrigger := tFall;
                    ChangeStateTo(stateStartTrial%, tFall);
                else
                    ' TODO - do this for slave also
                    if pulseFound% = 0 then  'if a (short) "false" trigger is found, update tLastTrigger so we don't see it again
                        LogStatus("VSGWait", "Got FALSE Ready Pulse from VSG at " + str$(tRise));
                        tLastTrigger := tFall;
                    endif;
                endif;
            endif
            
            stayInLoop% := 0;   ' exit loop; need a gap in between pulse and F
                          
        case iState% = stateStartTrial% then
            
            ' initial state on startup. 
            ' DIGOUT to present stimulus
            ' Enter state 1
            if Pause% = 0 then
                nTrialsStarted% += 1;
                
                 ' djs - calibration x,y are set at trial end. 
                SafeSampleKey("F");
                if fixSimultaneousLED% = 1 then
                    SafeSampleKey("L");
                endif
                
                iState% := stateWaitForStim%;
                '			PrintLog("State 0 - Start new trial - stimulus trigger sent\n");
                UpdateToolbarText();
                ChangeStateTo(stateWaitForStim%, tNow);
            endif;
            
            
        case iState% = stateWaitForStim% then
            
            ' Waiting for stimulus to be presented by vsg and trigger to return. 
            ' NextTime returns a non-negative value whenever there is a TRANSITION. In that case, the 
            ' value of 'vTrigger' returned is 1 (0) if the transition is high (low) to low (high). Maybe not
            ' intuitive, but that's the way it is. 
            tTrigger := NextTime(TriggerChannel%, tStateStart, vTrigger);
            'LogStatus("WaitForStim", str$(tStateStart) + "," + str$(tNow) + "," + str$(tTrigger) + "," + str$(vTrigger));
            if tTrigger > 0 then
                if vTrigger = 0 then
                    ' Stimulus has been presented. Display stim location and window. Enter state 2
                    DrawStim(1);
                    ChangeStateTo(stateWaitForAcquisition%, tTrigger);
                    LogStatus("WaitForStim", "Stim up trig");
                else
                    ' This should never happen
                    LogStatus("WaitForStim", "Wrong trig edge tNow=" + str$(tNow) + " tTrigger=" + str$(tTrigger) + " tLastTrigger=" + str$(tLastTrigger));
                    Message("Wrong trig edge in stateWaitForStim!");
                    halt;
                endif
            endif
            
        case iState% = stateWaitForAcquisition% then
            
            if tNow-tStateStart < fixAcquisitionTime then
                ' Acquisition happens when the eye falls within the fixation window.
                if InFixationWindow%(xEye, yEye) > 0 then
                    ChangeStateTo(stateHoldFixation%, tNow);
                endif
            else
                ' Failed. Turn off stim and try again.
                fixSuccess% := 0;
                ChangeStateTo(stateStimOff%, tNow);
                stayInLoop% := 1;  'No reason to wait, go straight to stim off
            endif
            
        case iState% = stateHoldFixation% then
            
            ' Waiting for fixation....
            if InFixationWindow%(xEye, yEye) <= 0 then
                fixSuccess% := 0;
                ChangeStateTo(stateStimOff%, tNow);
                stayInLoop% := 1;  'No reason to wait, go straight to stim off
            else
                if tNow - tStateStart >= fixFixationDuration then
                    ' Fixation. Reward. New trial.
                    fixSuccess% := 1;
                    ChangeStateTo(stateStimOff%, tNow);
                    stayInLoop% := 1;  'No reason to wait, go straight to stim off
                endif
            endif
            
        case iState% = stateStimOff% then
            
            ' Turn off stimulus
            DrawStim(0);
            SafeSampleKey("X");
            if fixSimultaneousLED% = 1 then
                SafeSampleKey("M");
            endif
            ChangeStateTo(stateWaitForBlank%, tNow);            
            
            
        case iState% = stateWaitForBlank% then
            
            ' Wait for stim to be off
            tTrigger := NextTime(TriggerChannel%, tStateStart,vTrigger);
            'LogStatus("WaitForBlank", str$(tStateStart) + "," + str$(tNow) + "," + str$(tTrigger) + "," + str$(vTrigger));
            if tTrigger > tLast then
                
                if vTrigger = 1 then      
                    tLastTrigger := tTrigger;
                    LogStatus("WaitForBlank", "Stim off trig");
                    if fixSuccess% = 0 then
                        ChangeStateTo(stateFailure%, tTrigger);
                    else
                        ChangeStateTo(stateSuccess%, tTrigger);
                    endif;
                    
                    ' calibration run: Update next x,y for eye window, send "a".
                    AdvanceCalibrationPoint();
                    
                else
                    ' this should never happen!
                    Message("Wrong trig edge in stateWaitForBlank!");
                    LogStatus("WaitForBlank", "Wrong trig edge tNow=" + str$(tNow) + " tTrigger=" + str$(tTrigger) + " tLastTrigger=" + str$(tLastTrigger));
                    halt;
                endif
                
            endif
            
            
        case iState% = stateSuccess% then
            
            nTrialsSuccess% += 1;
            DefaultReward();
            ChangeStateTo(stateNextAfterFixation%, tNow);
            stayInLoop% := 1;  'No reason to wait
            
        case iState% = stateFailure% then
            
            nTrialsFail% += 1;
            ChangeStateTo(stateNextAfterFixation%, tNow);
            stayInLoop% := 1;  'No reason to wait
            
        
        case iState% = stateNextAfterFixation% then
            
            if fixInterleaveLED% = 0 then  'If no interleaved LED, go to next Fixation Point
                ChangeStateTo(stateCheckTrial%, tNow);
                stayInLoop% := 1;  'No reason to wait
            else
                if fixSuccess% = 1 then  'if success during interleaved LED, go to LED
                    fixSuccess% := 0; 'reset success variable
                    ChangeStateTo(statePreLEDInterval%, tNow);
                    stayInLoop% := 1;  'No reason to wait
                else 'if failure, go back to fixation point
                    ChangeStateTo(stateCheckTrial%, tNow);
                    stayInLoop% := 1;  'No reason to wait
                endif;
            endif;
        
            
        case iState% = statePreLEDInterval% then
            ' Inter-trial wait time
            if tNow - tStateStart > fixInterTrialTime then
                
                ChangeStateTo(stateStartLEDTrial%, tNow);
                stayInLoop% := 1;  'No reason to wait
                
            endif
            
            
            
        case iState% = stateStartLEDTrial% then
            
            ' initial state on startup. 
            ' DIGOUT to present stimulus
            ' Enter state 1
            
            if Pause% = 0 then
                nLEDTrialsStarted% += 1;
                'iStimIndex% := (iStimIndex% + 1) mod 8;
                
                SafeSampleKey("L");
                
                ChangeStateTo(stateWaitForLEDAcquisition%, tNow);
                
                UpdateToolbarText();
            endif
            
            
            
        case iState% = stateWaitForLEDAcquisition% then
            
            if tNow-tStateStart < fixAcquisitionTime then
                
                ' Acquisition happens when the eye falls within the fixation window.
                if InFixationWindow%(xEye, yEye) > 0 then
                    
                    ChangeStateTo(stateHoldLEDFixation%, tNow);
                    
                endif
                
            else
                
                ' Failed. Turn off stim and try again.
                ' Turn off stimulus immediately
                SafeSampleKey("M");
                ChangeStateTo(stateLEDFailure%, tNow);
                stayInLoop% := 1;  'No reason to wait
            endif
            
        case iState% = stateHoldLEDFixation% then
            
            ' Waiting for fixation....
            if InFixationWindow%(xEye, yEye) <= 0 then
                ' Turn off stimulus immediately
                SafeSampleKey("M");
                ChangeStateTo(stateLEDFailure%, tNow);
                stayInLoop% := 1;  'No reason to wait
            else
                
                if tNow - tStateStart >= fixFixationDuration then
                    
                    ' Turn off stimulus immediately
                    SafeSampleKey("M");
                    ' Fixation. Reward. New trial.
                    ChangeStateTo(stateLEDSuccess%, tNow);
                    stayInLoop% := 1;  'No reason to wait
                endif
                
            endif
            
        case iState% = stateLEDSuccess% then
            
            nLEDTrialsSuccess% += 1;
            DefaultReward();
            LEDSuccess% := 1;
            ' tally successful trials
            ChangeStateTo(stateLEDIsOff%, tNow);
            stayInLoop% := 1;  'No reason to wait
            
        case iState% = stateLEDFailure% then
            
            LEDSuccess% := 0;
            nLEDTrialsFail% += 1;
            ChangeStateTo(stateLEDIsOff%, tNow);
            stayInLoop% := 1;  'No reason to wait
            
        case iState% = stateLEDIsOff% then
            
            
            'must be interleaved to get here
            if LEDSuccess% = 1 then  'If LED trial was OK, 
                LEDSuccess%:=0; 'reset LED success variables
                ChangeStateTo(stateCheckTrial%, tNow); 'prepare for next Fixation trial
                stayInLoop% := 1;  'No reason to wait
            else
                ChangeStateTo(statePreLEDInterval%, tNow);  'return to LED
            endif;
            
            
        case iState% = stateCheckTrial% then
            
            ' Check trial count
            if nTrialsStarted% = fixNumberOfTrials%  and fixCalibrationFlag% = 0 then
                Stop%();
                'ChangeStateTo(stateDone%, tNow);  '??? Stop% overrides
                'stayInLoop% := 1;  'No reason to wait
                iStatus% := 0;
            else
                ChangeStateTo(stateInterval%, tNow);
            endif
            
            
        case iState% = stateInterval% then
            
            ' Inter-trial wait time
            if tNow - tStateStart > fixInterTrialTime then
                
                ' Back to state 0
                ChangeStateTo(stateStartTrial%, tNow);
                stayInLoop% := 1;  'No reason to wait
                
            endif
            
        else 
            
            ' Unknown state!
            Message("Unknown state=" + str$(iState%));
            halt;
            
        endcase;
        
        tLast := tNow;
                
    wend
    
	return iStatus%;

end;

proc AdvanceCalibrationPoint()
    if fixDualStim% = 1 then
        iStimIndex% := (iStimIndex% + 1) mod 9;         
        SafeSampleKey("a");
    endif
end;

proc UpdateToolbarText()

	var s$;
    if fixInterleaveLED% = 0 then
        s$ := Print$("Trial#/Total %d/%d Success/Failure %d/%d", nTrialsStarted%, fixNumberOfTrials%, nTrialsSuccess%, nTrialsFail%);
    else        
        s$ := Print$("Trial#/Total %d/%d Success/Failure %d/%d LEDSuccess/LEDFail %d/%d", nTrialsStarted%, fixNumberOfTrials%, nTrialsSuccess%, nTrialsFail%, nLEDTrialsSuccess%, nLEDTrialsFail%);
    endif;
	ToolbarText(s$);

end;


proc ChangeStateTo(stateTo%, t)
    iState% := stateTo%;
    tStateStart := t;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
	SampleClear(); 'Set standard sampling state
'	SampleAutoFile(0); 'Enable automatic file naming
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
	' Set path for new data files
	FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3, 1);
	FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1, 1);
	SampleAutoName$(dataCellName$ + "_fix_000");
	SampleAutoFile(1);

	'Channel recording definitions
	SampleEvent(TriggerChannel%, 2, 2, 3600); 'Trigger channel, level
	SampleComment$(TriggerChannel%, "Trigger");
	SampleTitle$(TriggerChannel%, "Trigger");

	' channel to look for ready signal from vsg
	SampleEvent(ReadyChannel%, 1, 2, 3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
    if fixDualStim% = 1 then
        SampleEvent(TriggerSlaveChannel%, 4, 2, 3600); 'Trigger channel, level
        SampleComment$(TriggerSlaveChannel%, "Trigger-slave");
        SampleTitle$(TriggerSlaveChannel%, "Trigger-slave");

        SampleEvent(ReadySlaveChannel%, 5, 2, 3600); 'Trigger channel, level
        SampleComment$(ReadySlaveChannel%,"VSG Ready-slave");
        SampleTitle$(ReadySlaveChannel%,"VSG Ready-slave");
    endif
    
    
	'EYE COIL CHANNELS. Last # is sampling freq in Hz. 
	SampleWaveform(XChannel%, GetEyeXPort%(), 1000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%, GetEyeYPort%(), 1000);
	SampleTitle$(YChannel%, "Eye Y");

    ' Set up channels for sampling electrodes.
    CreateElectrodeSamplingConfiguration(1, 11);

    ' different pls file if remote
'    if GetUseRemoteStimulus%() = 0 then
'        SampleSequencer(script$ + "Fixation.pls");
 '   else
        SampleSequencer(script$ + "Tuning.pls");
   ' endif
        
	SampleOptimise(2, 2, 2, 2, 50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawStim
' 
' Draws stimulus in xy window (iDraw%==1) or blanks it (0). 
proc DrawStim(iDraw%)

	if iDraw% > 0 then
		var xstim, ystim;
		xstim := GetStimX();
		ystim := GetStimY();

		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	
		' draw fixation window
		ArrConst(windowX[], FixWindowX[]);
		ArrAdd(windowX[], xstim);
		ArrConst(windowY[], FixWindowY[]);
		ArrAdd(windowY[], ystim);

		View(XYWindow%).XYAddData(iStimWindowChannel%, windowX[], windowY[]);		
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
		View(XYWindow%).XYDelete(iStimWindowChannel%);
	endif

end;


proc InitializeWindows()

	'Open the data sampling window
	DataWindow% := FileNew(0,4);
    Window(-0.235849,52.746,97.2484,99.8856);
    XRange(0, 30);
	View(DataWindow%).WindowVisible(1);

	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(-0.550314,0.114416,41.5094,52.746);
	XYColour(1,16);
	XYSize(1,-1);

	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := WindowRadius * Sin(index% * twopi/36.0);
	next;

	'Create a new channel in the XY view to display the fixation window
	iStimWindowChannel% := XYSetChan(0);
	XYColour(2,13);
	XYDrawMode(2,2,1);
	XYJoin(2,1);

	'Draw the fixation window ON SECOND THOUGHT, DON'T
	'XYAddData(2, FixWindowX[], FixWindowY[]);	

	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);

	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(4,13);
	XYDrawMode(4,3,1);
	XYJoin(4,2);
	XYAddData(4,-9,-7);
	XYAddData(4,9,-7);
	XYAddData(4,9,7);
	XYAddData(4,-9,7);

end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()

	'View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	ToolbarSet(1,"Sample start",Start%);
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice",DefaultReward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
	ToolbarSet(6,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go", 0x3ff);

end;


' Get grating p[arameters from registry AlertRig\\(config)\\Gratings\\type$
func GetGratingParameters$(type$)
	var key$;
	var stmp$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\Gratings";
	Profile(key$, type$, "", stmp$);
	return stmp$;
end;


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
    var CommandLineSlave$;
	var FixationPoint$;
    var DualTrigger$ := "";
	var Extras$;
	var Distractors$:="";
    var DistractorFlag$ := " -g ";  ' -k for fixstim/remote
    var DistractorFixstimFlag$ := "";
    var Invocation$;                ' initialized below
	var InvocationSlave$;
    
	SampleStart(0); 'Start sampling
    
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    
	GetFixationScriptParameters();

    ' some stuff depends on whether this is a remote session
    if GetUseRemoteStimulus%() = 1 then
        DistractorFlag$ := " -k ";
        DistractorFixstimFlag$ := " -K ";
        Invocation$ := "cmd /c " + GetBinDir$(1) + "remote " + GetRemoteStimulusIP$() + " " + GetRemoteStimulusPort$() + " fixstim -p 2 ";
    else
        Invocation$ := "cmd /c " + GetBinDir$(1) + "fixstim ";
    endif
    
    if fixDualStim% = 1 then
        InvocationSlave$ := "cmd /c " + GetBinDir$(1) + "remote " + GetSlaveStimulusIP$() + " " + GetSlaveStimulusPort$() + " fixstim -p 2 ";
        DualTrigger$ := " -V 128,FS ";
        ' djs Set sequencer variable 5 if this is rivalry
        SampleSeqVar(5, 1);
    else
        SampleSeqVar(5, 0);
    endif

	if fixCalibrationFlag% = 0 then

		' Use distractors? 
		if fixStimulusFlag% = 1 then
			Extras$ := GetGratingParameters$("Stimulus");
			if Len(Extras$) = 0 then
				Message("Warning! Use stimulus flag is set, but stimulus grating is not configured!");
			else
				Distractors$ += DistractorFlag$ + Extras$;
			endif
		endif
		
		if fixDistractor1Flag% = 1 then
			Extras$ := GetGratingParameters$("Distractor1");
			if Len(Extras$) = 0 then
				Message("Warning! Use distractor 1 flag is set, but distractor 1 grating is not configured!");
			else
				Distractors$ += DistractorFlag$ + Extras$;
			endif
		endif
		
		if fixDistractor2Flag% = 1 then
			Extras$ := GetGratingParameters$("Distractor2");
			if Len(Extras$) = 0 then
				Message("Warning! Use distractor 2 flag is set, but distractor 2 grating is not configured!");
			else
				Distractors$ += DistractorFlag$ + Extras$;
			endif
		endif
		
		if fixDistractor3Flag% = 1 then
			Extras$ := GetGratingParameters$("Distractor3");
			if Len(Extras$) = 0 then
				Message("Warning! Use distractor 3 flag is set, but distractor 3 grating is not configured!");
			else
				Distractors$ += DistractorFlag$ + Extras$;
			endif
		endif
		
		if fixDistractor4Flag% = 1 then
			Extras$ := GetGratingParameters$("Distractor4");
			if Len(Extras$) = 0 then
				Message("Warning! Use distractor 4 flag is set, but distractor 4 grating is not configured!");
			else
				Distractors$ += DistractorFlag$ + Extras$;
			endif
		endif
		
		Extras$ := " -b " + fixBackgroundColor$ + " -d " + GetDistanceToScreenMM$();
		
		CommandLine$ := Invocation$ + FixationArg$ + Extras$ + DualTrigger$ + Distractors$ + DistractorFixstimFlag$;
        CommandLineSlave$ := InvocationSlave$ + FixationArg$ + Extras$ + DualTrigger$ + Distractors$ + DistractorFixstimFlag$;
		
		'CommandLine$ :=bin$ + "\\dFixation " + FixationPoint$ + Distractors$ + Extras$;
	else
        var calLocations$;
        calLocations$ := Print$(" -y %.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f ",
        -fixCalibrationOffset, fixCalibrationOffset, 0, fixCalibrationOffset, fixCalibrationOffset, fixCalibrationOffset, 
        -fixCalibrationOffset, 0, 0, 0, fixCalibrationOffset, 0, 
        -fixCalibrationOffset, -fixCalibrationOffset, 0, -fixCalibrationOffset, fixCalibrationOffset, -fixCalibrationOffset);
        
        Extras$ := Print$("-b %s -d %s %s ", fixBackgroundColor$, GetDistanceToScreenMM$(), FixationArg$);
        
		CommandLine$ := Invocation$ + Extras$ + DualTrigger$ + calLocations$;
		CommandLineSlave$ := InvocationSlave$ + Extras$ + DualTrigger$ + calLocations$;

	endif

	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	LogStatus("Start%()", CommandLine$);
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
    
    if fixDualStim% = 1 then
        StimHandleSlave% := ProgRun(CommandLineSlave$, 1);
        if StimHandleSlave% <0 then Message("Could not start slave stimulus."); halt; endif
    endif
    
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,1);
	View(DataWindow%);
	Yield(.1);
	return 1;
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var s$;
    
	' Disable idle process func
	ToolbarSet(0,"");

	' Tell stim app to shut down
    Yield(.1);
	SafeSampleKey("Q");
	Yield(.1);
	SampleStop();
	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend

	' Increment daily totals and save then
	TotalTrials% += (nTrialsStarted% + nLEDTrialsStarted%);
	TotalRewards% += (nTrialsSuccess% + nLEDTrialsSuccess%);
	SaveDailyTotals();

	s$ := Print$("Trial#/Total %d/%d Success/Failure %d/%d", nTrialsStarted%, fixNumberOfTrials%, nTrialsSuccess%, nTrialsFail%);
	LogStatus("Stop%()", s$);
    
    if fixSaveData% = 1 then
        View(DataWindow%);
        'call to ExportChanList() may be necessary?
        ExportChanList();
        ExportChanList(0,maxtime(),XChannel%,YChannel%,TriggerChannel%,ReadyChannel%,31);  'export all channels, 31 is the keyboard channel
        FileSaveAs(fixSaveDataName$,100,1,"",0,"UseSName=0"); 'We will overwrite the .mat file every time; Ben will save what he needs.  Default behavior is fine here.
    endif
    
    
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
Pause% :=1;
ToolbarEnable(4,0);
ToolbarEnable(5,1);
return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
Pause% :=0;
ToolbarEnable(4,1);
ToolbarEnable(5,0);
return 1;
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func GetStimX()
	var xstim;
	if fixCalibrationFlag% = 0 then
		xstim := FixationX;
	else
        docase
        case iStimIndex% = 1 or iStimIndex% = 4 or iStimIndex% = 7 then xstim := -fixCalibrationOffset;
        case iStimIndex% = 2 or iStimIndex% = 5 or iStimIndex% = 8 then xstim := 0;
        case iStimIndex% = 3 or iStimIndex% = 6 or iStimIndex% = 9 then xstim := fixCalibrationOffset;
        endcase        
	endif
	return xstim;
end;

func GetStimY()
	var ystim;
	if fixCalibrationFlag% = 0 then
		ystim := FixationY;
	else
        docase
        case iStimIndex% = 1 or iStimIndex% = 2 or iStimIndex% = 3 then ystim := fixCalibrationOffset;
        case iStimIndex% = 4 or iStimIndex% = 5 or iStimIndex% = 6 then ystim := 0;
        case iStimIndex% = 7 or iStimIndex% = 8 or iStimIndex% = 9 then ystim := -fixCalibrationOffset;
        endcase        
	endif
	return ystim;
end;

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func InFixationWindow%(EyePosX,EyePosY)
	var i% := 0;
	var xstim, ystim;
    if fixAlwaysLooking% = 1 then
        i% := 1;
    else
        xstim := GetStimX();
        ystim := GetStimY();
        'Determine if the eye position is within the fixation window
        if (Pow(EyePosX-xstim, 2) + Pow(EyePosY-ystim, 2)) <= Pow(WindowRadius,2) then 
            i% := 1;
        endif
    endif
    
	return i%;
end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


' When user hits one of the direction buttons (Horizontal, Vertical, Corners, Center), a flag is set to indicate
' a pending mode change. The mode isn't changed immediately. If we did that in the middle of a trial, the idle 
' function may think that the target is at a position DIFFERENT than the one its really at. This function is called
' from DoCalSampleKeys, which is called at a "safe" time (between trials), to ensure that the stim program and this
' script have the same notion of where the target is on screen. 

'proc UpdateCalMode()
'    if fixPendingCalMode% = 0 then return; endif
'        
'    docase
'    case fixPendingCalMode% = 1 then        ' horizontal
'        iStimX%[0] := 1; iStimY%[0] := 2;
'        iStimX%[1] := 1; iStimY%[1] := 2;
'        iStimX%[2] := 2; iStimY%[2] := 2;
'        iStimX%[3] := 2; iStimY%[3] := 2;
'        iStimX%[4] := 3; iStimY%[4] := 2;
'        iStimX%[5] := 3; iStimY%[5] := 2;
'        iStimX%[6] := 2; iStimY%[6] := 2;
'        iStimX%[7] := 2; iStimY%[7] := 2;
'    case fixPendingCalMode% = 2 then        ' vertical
'        iStimX%[0] := 2; iStimY%[0] := 1;
'        iStimX%[1] := 2; iStimY%[1] := 1;
'        iStimX%[2] := 2; iStimY%[2] := 2;
'        iStimX%[3] := 2; iStimY%[3] := 2;
'        iStimX%[4] := 2; iStimY%[4] := 3;
'        iStimX%[5] := 2; iStimY%[5] := 3;
'        iStimX%[6] := 2; iStimY%[6] := 2;
'        iStimX%[7] := 2; iStimY%[7] := 2;
'    case fixPendingCalMode% = 3 then        ' corners
'        iStimX%[0] := 1; iStimY%[0] := 1;
'        iStimX%[1] := 1; iStimY%[1] := 1;
'        iStimX%[2] := 3; iStimY%[2] := 1;
'        iStimX%[3] := 3; iStimY%[3] := 1;
'        iStimX%[4] := 3; iStimY%[4] := 3;
'        iStimX%[5] := 3; iStimY%[5] := 3;
'        iStimX%[6] := 1; iStimY%[6] := 3;
'        iStimX%[7] := 1; iStimY%[7] := 3;
'    case fixPendingCalMode% = 4 then    ' center
'        iStimX%[0] := 2; iStimY%[0] := 2;
'        iStimX%[1] := 2; iStimY%[1] := 2;
'        iStimX%[2] := 2; iStimY%[2] := 2;
'        iStimX%[3] := 2; iStimY%[3] := 2;
'        iStimX%[4] := 2; iStimY%[4] := 2;
'        iStimX%[5] := 2; iStimY%[5] := 2;
'        iStimX%[6] := 2; iStimY%[6] := 2;
'        iStimX%[7] := 2; iStimY%[7] := 2;        
'    endcase    
'    fixPendingCalMode% := 0;
'    
'    return;
'end;
'    
'