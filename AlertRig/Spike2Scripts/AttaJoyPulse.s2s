' $Id: AttaJoyPulse.s2s,v 1.1 2010-08-20 01:15:49 devel Exp $
const ajCVSID$ := "$Id: AttaJoyPulse.s2s,v 1.1 2010-08-20 01:15:49 devel Exp $";

#include "../../Spike2Util/TrialGenInterface.s2s"
#include "../../Spike2Util/ChannelUtilities.s2s"
#include "../../Spike2Util/UsreyUtil.s2s"
#include "UsreyGratings.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"
#include "Joystick.s2s"

' Local config variables

var ajNBlocks% := 1;
var ajNTrialsEachTypePerBlock% := 10;
const ajNoTraining% := 0;
const ajReadyTraining% := 1;
const ajReadyFixTraining% := 2;
const ajReadyFixStimTraining% := 3;
var ajTrainingType% := ajNoTraining%;
var ajCatchTrialPct := 0;
var ajAlternateCueTypeByBlock% := 0;
var ajMaxWaitForReadyTime := 1.0;
var ajReadyFailPauseTime := 1.0;
var ajReadyBreakPauseTime := 1.0;
var ajMaxAcquisitionTime := 1.0;
var ajUseCueCircles% := 1;
var ajHoldFixationTime := 1.0;
var ajHoldFixation1Time := 1.0;
var ajHoldFixation2Time := 1.0;
var ajHoldFixation3Time := 1.0;
var ajFixationBreakPauseTime := 1.0;
var ajAcquisitionFailPauseTime := 1.0;
var ajTrainingSuccessPauseTime := 1.0;
var ajHazardTimeMin := 1.0;
var ajHazardTimeMean := 1.5;
var ajHazardTimeMax := 2.0;
var ajMaxResponseTime := 2.0;
var ajCorrectResponsePauseTime := 1.0;
var ajIncorrectResponsePauseTime := 1.0;
var ajRewardSize% := 1;
var ajUseBeep% := 1;
var ajContrastBase% := 75;
var ajContrastUp% := 100;
var ajContrastDown% := 50;
var ajAlwaysLooking% := 0;      ' Set to 1 in timing dialog. Will cause Looking% to always return 1. 
var ajTrialTypesListIndex% := 0;
var ajShowSingleStim% := 0;
var ajExtraFixationTime := 0.2;     ' Extra fixation time during stateWaitForResponse
var ajDoHoldFixationMiniReward% := 0;   ' 2010-07-14 Hard-coded. Set to 0 to eliminate mini-reward. 
var ajHoldFixationMiniRewardEnable% := 0;   ' when 1 mini reward is enabled; used per-trial
var ajHoldFixationMiniRewardFraction := .99; ' fraction of hold fixation time passed before mini-reward given
var ajElectrodes%[8];
var ajTuningFixationTime := 1.0;
var ajTuningStimulusTime := 1.0;
var ajDoTuningTrials% := 0;

' Strings for DlgList training type
var ajTrainingTypes$[4];

' Text items for dialogs
var ajElectrodeTextItem%;

' Counters

var ajCtrNTrials% := 0;
var ajCtrReadyFail% := 0;
var ajCtrReadyBreak% := 0;
var ajCtrIncorrect% := 0;
var ajCtrCorrect% := 0;
var ajCtrNRewards% := 0;
var ajCtrNTrialsReady% := 0;
var ajCtrNTrialsAcq% := 0;
var ajCtrNTrialsAcqFail% := 0;
var ajCtrNTrialsFix% := 0;
var ajCtrNTrialsFixBreak% := 0;
var ajCtrNTrialsStim% := 0;
var ajCtrNTrialsChg% := 0;

' Channel numbers for DAQ inputs

var ajChanEyeX%    := 11;
var ajChanEyeY%    := 12;
var ajChanJoy%     := 13;

' VSG trigger input channels

var ajChanVSGReady%    :=  20;
var ajChanFixpt%       :=  21;
var ajChanCircle%      :=  22;
var ajChanStimulus%    :=  23;
var ajChanContrastChg% :=  24;

' windows

var ajWindowData%;
var ajWindowXY%;

' display channels

var ajChanMonitor%;
var ajChanJoystickPos%;
var ajChanJoystickRangeL%;
var ajChanJoystickRangeC%;
var ajChanJoystickRangeR%;
var ajChanStimDisplay0%;
var ajChanStimDisplay1%;
var ajChanFixptDisplay%;
var ajChanFixptWindowDisplay%;
var ajVCoeff;
var ajVConst;
var ajJoystickDisplayY;
var ajUnitCircleX[36];
var ajUnitCircleY[36];
var ajCircleX[36];
var ajCircleY[36];
var ajStim0X, ajStim0Y, ajStim1X, ajStim1Y;
var ajStim0D, ajStim1D;
var ajFixationX, ajFixationY, ajFixationD, ajFixationWindowRadius;

' Controls

var ajIsPaused% := 0;
var ajStimHandle% := 0;
var ajTrialTypesList$[3];
var ajNTrialTypes%;
var ajTrialTypeIndex%;
var ajTrialFixptTypeKeys$[2];
var ajTrialChangeTypeKeys$[2];
var ajTrialFixptSampleKey$;
var ajTrialChangeSampleKey$;
var ajIsCatchTrial% := 0;
var ajTrialHazardTime := 1.0;
var ajReadyResponse% := JSRight%;
var ajCorrectResponse%;
var ajIncorrectResponse%;
var ajUniversalIntertrialTime;     ' time to wait between trials

' Item numbers for toolbar buttons
const toolbarItemStart% := 1;
const toolbarItemStop% := 2;
const toolbarItemJuice% := 3;
const toolbarItemStartAttaJoy% := 4;
const toolbarItemStartTuning% := 5;
const toolbarItemPause% := 6;
const toolbarItemResume% := 7;
const toolbarItemQuit% := 8;

' States - these constants define a particular state

const stateStartup%             :=  1;
const statePaused%              :=  2;
const stateTrialStart%          :=  3;
const stateBeep%                :=  4;
const stateWaitForReady%        :=  5;
const stateReadyFail%           :=  6;
const stateIntertrialWait%      :=  7;
const stateTrialCompleted%      :=  8;
const stateWaitForFixpt%        :=  9;
const stateReadyBreak%          :=  10;
const stateWaitForFixptOff%     :=  11;
const stateWaitForAcquisition%  :=  12;
const stateAcquisitionFail%     :=  13;
const stateHoldFixation%        :=  14;
const stateHoldFixation1%       :=  15;
const stateHoldFixation2%       :=  16;
const stateHoldFixation3%       :=  17;
const stateFixationBreak%       :=  18;
const stateWaitForCircle%       :=  19;
const stateWaitForCircleOff%    :=  20;
const stateWaitForStimOn%       :=  21;
const stateWaitHazardTime%      :=  22;
const stateWaitForContrastChange% :=  23;
const stateWaitForResponse%     :=  24;
const stateCorrectResponse%     :=  25;
const stateIncorrectResponse%   :=  26;
const stateQuit%                :=  27;
const stateDone%                :=  28;
const stateVSGWait%             :=  29;
const stateVSGConfirm%          :=  30;
const stateT1Success%           :=  31;
const stateT2Success%           :=  32;
const stateWaitForNeutral%      :=  33;
const stateT3Success%           :=  34;
const statePausedWaiting%       :=  35;
const stateAttaJoyOrTuning%     :=  36;
const stateStartAttaJoyTrials%  :=  37;
const stateStartTuningTrials%   :=  38;
const stateTuningTrialStart%    :=  39;
const stateTuningWaitForFixpt%  :=  40;
const stateTuningWaitForAcquisition%    :=  41;
const stateTuningAcquisitionFail%       :=  42;
const stateTuningHoldFixation%  :=  43;
const stateTuningWaitForStimOn% :=  44;
const stateTuningHoldFixationMore%      :=  45;
const stateTuningSuccess%               :=  46;
const stateTuningWaitForFixptOff%       :=  47;

var iState% := stateStartup%;              ' This holds the current state

var tNow:=0;		    ' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		    ' last time we checked for a trigger. 
var xEye, yEye;		    ' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		    ' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	    ' temp var for newly discovered trigger times
var doCorrectionTrial% := 0;    ' this is set to 1 when a trial fails and correction trials were requested
var isCorrectionTrial% := 0;    ' this is set to 1 when we are in a trial that is a correction trial
var tCircleOn := -1;

'===========================================================================================
'
' Script execution starts here. 
'
'===========================================================================================

LogInit(1);
InitJoystick(13);
ajTrialTypesList$[0] := "Both";
ajTrialTypesList$[1] := "Red";
ajTrialTypesList$[2] := "Green";
ajTrainingTypes$[ajNoTraining%] := "No Training";
ajTrainingTypes$[ajReadyTraining%] := "Ready Training";
ajTrainingTypes$[ajReadyFixTraining%] := "Ready/Fix Training";
ajTrainingTypes$[ajReadyFixStimTraining%] := "Ready/Fix/Stim Training";

if AttaJoyDialog%() = 0 then
    halt;
endif


' Check a few values for reasonable-ness....
if ajHazardTimeMax < ajHazardTimeMean or ajHazardTimeMean < ajHazardTimeMin then
    Message("Must have hazard time max > mean > min!");
    halt;
endif

'if ajDoReadyTraining% = 0 and ajTrialTypesListIndex% = 0 then
if ajTrainingType% <> ajReadyTraining% and ajTrialTypesListIndex% = 0 then
    ajNTrialTypes% := 2;
    ajTrialFixptTypeKeys$[0] := "F";
    ajTrialFixptTypeKeys$[1] := "G";
    ajTrialChangeTypeKeys$[0] := "C";
    ajTrialChangeTypeKeys$[1] := "D";
else
    ajNTrialTypes% := 1;
    docase
'    case ajDoReadyTraining% = 1 then
    case ajTrainingType% = ajReadyTraining% then
        ajTrialFixptTypeKeys$[0] := "Z";
        ajTrialFixptTypeKeys$[1] := "Z";
        ajTrialChangeTypeKeys$[0] := "Z";
        ajTrialChangeTypeKeys$[1] := "Z";        
    case ajTrialTypesListIndex% = 1 then
        ajTrialFixptTypeKeys$[0] := "F";
        ajTrialFixptTypeKeys$[1] := "Z";
        ajTrialChangeTypeKeys$[0] := "C";
        ajTrialChangeTypeKeys$[1] := "Z";
    case ajTrialTypesListIndex% = 2 then
        ajTrialFixptTypeKeys$[0] := "G";
        ajTrialFixptTypeKeys$[1] := "Z";
        ajTrialChangeTypeKeys$[0] := "D";
        ajTrialChangeTypeKeys$[1] := "Z";
    endcase
endif        

' Init trial generator
if ajAlternateCueTypeByBlock% <> 1 then
    tbgInit(ajNTrialTypes%, ajNTrialsEachTypePerBlock%, ajNBlocks%);
else
    tbaltgInit(ajNTrialTypes%, ajNTrialsEachTypePerBlock%, ajNBlocks%);
endif


' Get fixation point parameters
GetFixationPointParameters();


' Sampling config
CreateSampleConfiguration();

' Prepare display windows, input channels, etc. 
InitializeWindows();

' Set up toolbar and launch
InitializeToolbar();




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' CreateSampleConfiguration - Set up recording channels, dig input channels for VSG communication
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc CreateSampleConfiguration()
	var i%;
    
	SampleClear(); 'Set standard sampling state
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 3);
    FilePathSet(GetDataPathRoot$() + "\\" + GetDataSetName$(), 1);
    SampleAutoName$(dataCellName$ + "_aj_000");
	SampleAutoFile(1);
    
	'Channel recording definitions
    
	SampleEvent(ajChanVSGReady%, 6, 2, 3600); 'Trigger channel, level
	SampleComment$(ajChanVSGReady%, "VSG Ready");
	SampleTitle$(ajChanVSGReady%, "VSG Ready");
    
	SampleEvent(ajChanFixpt%, 1, 2, 3600);
	SampleComment$(ajChanFixpt%, "Fixpt");
	SampleTitle$(ajChanFixpt%, "Fixpt");
    
	SampleEvent(ajChanCircle%, 3, 2, 3600);
	SampleComment$(ajChanCircle%, "Cue");
	SampleTitle$(ajChanCircle%, "Cue");
    
	SampleEvent(ajChanStimulus%, 2, 2, 3600);
	SampleComment$(ajChanStimulus%, "Stim");
	SampleTitle$(ajChanStimulus%, "Stim");    
    
	SampleEvent(ajChanContrastChg%, 4, 2, 3600);
	SampleComment$(ajChanContrastChg%, "Chg");
	SampleTitle$(ajChanContrastChg%, "Chg");
	
	SampleWaveform(ajChanJoy%, GetJoystickPort%(), 1000);
	SampleTitle$(ajChanJoy%, "Joy");
    
	SampleWaveform(ajChanEyeX%, GetEyeXPort%(), 1000);
	SampleTitle$(ajChanEyeX%, "Eye X");
	SampleWaveform(ajChanEyeY%, GetEyeYPort%(), 1000);
	SampleTitle$(ajChanEyeY%, "Eye Y");
    
    ' Electrodes, if any.
    for i% := 0 to 7 do
        if ajElectrodes%[i%] = 1 then
            SampleWaveMark(i% + 1, i%, 2000, 34, 15, 28000); 
        endif
    next

    
	SampleSequencer(script$ + "AttaJoy.pls");
	SampleOptimise(2, 2, 2, 2, 50);  'Set optimise mode (do this last)
	SampleMode(1); 'Continuous sampling

end;




'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


proc InitializeToolbar()

	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);

	ToolbarSet(toolbarItemStart%, "Sample start", Start%);
	ToolbarSet(toolbarItemStop%, "Sample stop", Stop%);
	ToolbarSet(toolbarItemJuice%, "Juice", Reward%);
    ToolbarSet(toolbarItemStartAttaJoy%, "AttaJoy Trials", StartAttaJoyTrials%);
    ToolbarSet(toolbarItemStartTuning%, "Tuning Trials", StartTuningTrials%);
	ToolbarSet(toolbarItemPause%, "Pause", Pause%);
	ToolbarSet(toolbarItemResume%, "Resume", Resume%);
	ToolbarSet(toolbarItemQuit%, "Quit",Quit%);
	ToolbarEnable(toolbarItemStop%, 0);
	ToolbarEnable(toolbarItemStartAttaJoy%, 0);
	ToolbarEnable(toolbarItemStartTuning%, 0);
	ToolbarEnable(toolbarItemStop%, 0);
	ToolbarEnable(toolbarItemPause%, 0);
	ToolbarEnable(toolbarItemResume%, 0);
	Toolbar("Go",0x3ff);

end;



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeWindows - Open data file, set up windows for online display.
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

proc InitializeWindows()
    var i%;
	var twopi;
    
    ' These set the max and min window dimensions. They are also used to scale the joystick 
    ' position to the xy display, so if you change the size of the window, do it by changing
    ' these vars!
    var xyXMin := -20;
    var xyXMax := 20;
    var xyYMin := -15;
    var xyYMax := 15;
    var lh, cl, ch, rl;
    ajJoystickDisplayY := -12;     ' y coord in xy window where joystick position is shown. 
    
	'Open the data sampling window
	ajWindowData% := FileNew(0,4);
	Window(0,48,100,95);
	View(ajWindowData%).WindowVisible(1);
    XRange(0, 15);

	'Open an XY view to display eye position
	ajWindowXY% := FileNew(12);
	XRange(xyXMin, xyXMax);
	YRange(-2, xyYMin, xyYMax);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
	'Create a new channel in the XY view to show the monitor's location
	ajChanMonitor% := XYSetChan(0);
	XYColour(ajChanMonitor%, 13);
	XYDrawMode(ajChanMonitor%, 3, 1);
	XYJoin(ajChanMonitor%, 2);
	XYAddData(ajChanMonitor%, -9, -7);
	XYAddData(ajChanMonitor%, 9, -7);
	XYAddData(ajChanMonitor%, 9, 7);
	XYAddData(ajChanMonitor%, -9, 7);
    
    ' Set up joystick range numbers
    lh := GetJoystickLeftHigh();
    cl := GetJoystickCenterLow();
    ch := GetJoystickCenterHigh();
    rl := GetJoystickRightLow();
    
    ' We'll take the joystick voltage 'v' (which should be between 1 and 4volts) and 
    ' convert it for display in the xy window like this:
    ' x coord = v * rivVCoeff + rivVConst;
    
    ajVCoeff := (xyXMax - xyXMin)/3;
    ajVConst := -2.5 * ajVCoeff;
    
    ajChanJoystickRangeL% := XYSetChan(0);
    XYColour(ajChanJoystickRangeL%, 13);
    XYSize(ajChanJoystickRangeL%, 2);
    XYJoin(ajChanJoystickRangeL%, 1);
    XYDrawMode(ajChanJoystickRangeL%, 4, 3);
    XYAddData(ajChanJoystickRangeL%, xyXMin, ajJoystickDisplayY+1);
    XYAddData(ajChanJoystickRangeL%, lh * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    
    ajChanJoystickRangeC% := XYSetChan(0);
    XYColour(ajChanJoystickRangeC%, 13);
    XYSize(ajChanJoystickRangeC%, 2);
    XYJoin(ajChanJoystickRangeC%, 1);
    XYDrawMode(ajChanJoystickRangeC%, 4, 3);
    XYAddData(ajChanJoystickRangeC%, cl * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    XYAddData(ajChanJoystickRangeC%, ch * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    
    ajChanJoystickRangeR% := XYSetChan(0);
    XYColour(ajChanJoystickRangeR%, 13);
    XYSize(ajChanJoystickRangeR%, 2);
    XYJoin(ajChanJoystickRangeR%, 1);
    XYDrawMode(ajChanJoystickRangeR%, 4, 3);
    XYAddData(ajChanJoystickRangeR%, rl * ajVCoeff + ajVConst, ajJoystickDisplayY+1);
    XYAddData(ajChanJoystickRangeR%, xyXMax, ajJoystickDisplayY+1);
    
    
    ' this channel is for a symbol representing the actual joystick position
    ajChanJoystickPos% := XYSetChan(0);
    XYColour(ajChanJoystickPos%, 11);
    XYDrawMode(ajChanJoystickPos%, 1, 8);
    XYDrawMode(ajChanJoystickPos%, 2, 10);
    XYSize(ajChanJoystickPos%, -1);
    
    ' this channel is for displaying the stimulus
    ajChanStimDisplay0% := XYSetChan(0);
    XYColour(ajChanStimDisplay0%, 8);
    XYDrawMode(ajChanStimDisplay0%, 2, 0);
    XYDrawMode(ajChanStimDisplay0%, 3, 0);
    XYJoin(ajChanStimDisplay0%, 2);
    XYSize(ajChanStimDisplay0%, 36);
    
    ajChanStimDisplay1% := XYSetChan(0);
    XYColour(ajChanStimDisplay1%, 8);
    XYDrawMode(ajChanStimDisplay1%, 2, 0);
    XYDrawMode(ajChanStimDisplay1%, 3, 0);
    XYJoin(ajChanStimDisplay1%, 2);
    XYSize(ajChanStimDisplay1%, 36);
    
    ajChanFixptDisplay% := XYSetChan(0);
    XYColour(ajChanFixptDisplay%, 8);
    XYDrawMode(ajChanFixptDisplay%, 2, 0);
    XYDrawMode(ajChanFixptDisplay%, 3, 0);
    XYJoin(ajChanFixptDisplay%, 2);
    XYSize(ajChanFixptDisplay%, 36);
    
    ajChanFixptWindowDisplay% := XYSetChan(0);
    XYColour(ajChanFixptWindowDisplay%, 8);
    XYDrawMode(ajChanFixptWindowDisplay%, 2, 0);
    XYDrawMode(ajChanFixptWindowDisplay%, 3, 0);
    XYJoin(ajChanFixptWindowDisplay%, 2);
    XYSize(ajChanFixptWindowDisplay%, 36);

    ' prepare unit circles for drawing 
	twopi := 2.0*4.0*ATan(1.0);
	for i% := 0 to 35 do
		ajUnitCircleX[i%] := Cos(i% * twopi/36.0);
		ajUnitCircleY[i%] := Sin(i% * twopi/36.0);
	next;

    
end;

proc DisplayStim(iOn%)
    var x, y, d, wr;
    
    docase
    case iOn% = 0 then
        ' erase all
        View(ajWindowXY%).XYDelete(ajChanFixptDisplay%);
        View(ajWindowXY%).XYDelete(ajChanFixptWindowDisplay%);
        View(ajWindowXY%).XYDelete(ajChanStimDisplay0%);
        View(ajWindowXY%).XYDelete(ajChanStimDisplay1%);
    case iOn% = 1 then
        ' fixpt and fixation window
		View(ajWindowXY%).XYAddData(ajChanFixptDisplay%, ajFixationX, ajFixationY);
        MakeCircle(ajFixationWindowRadius, ajFixationX, ajFixationY);
        View(ajWindowXY%).XYAddData(ajChanFixptWindowDisplay%, ajCircleX[], ajCircleY[]);
    case iOn% = 2 then
        if ajShowSingleStim% = 1 then
            ' single stim only
            if ajTrialFixptSampleKey$ = "F" then
                MakeCircle(ajStim0D/2, ajStim0X, ajStim0Y);
                View(ajWindowXY%).XYAddData(ajChanStimDisplay0%, ajCircleX[], ajCircleY[]);
            else
                MakeCircle(ajStim1D/2, ajStim1X, ajStim1Y);
                View(ajWindowXY%).XYAddData(ajChanStimDisplay1%, ajCircleX[], ajCircleY[]);        
            endif
        else
            ' both stim
            MakeCircle(ajStim0D/2, ajStim0X, ajStim0Y);
            View(ajWindowXY%).XYAddData(ajChanStimDisplay0%, ajCircleX[], ajCircleY[]);
            MakeCircle(ajStim1D/2, ajStim1X, ajStim1Y);
            View(ajWindowXY%).XYAddData(ajChanStimDisplay1%, ajCircleX[], ajCircleY[]);        
        endif
    else
        ' do nothing
    endcase
    
    return;
end

' Helper function - makes a circle of radius 'r' centered at (x, y). 
' The results are in ajCircleX[] and ajCircleY[]. 
proc MakeCircle(r, x, y)
    ArrConst(ajCircleX[], ajUnitCircleX[]);
    ArrMul(ajCircleX[], r);
    ArrAdd(ajCircleX[], x);
    ArrConst(ajCircleY[], ajUnitCircleY[]);
    ArrMul(ajCircleY[], r);
    ArrAdd(ajCircleY[], y);
    return;
end


func IdleProcessing%()
	var iStatus% := 1;	
    var iLoop% := 0;        ' States can set this to 1 if we stay in state loop
    var joystickPosition%;
    var joystickVoltage;
    
	tNow := MaxTime();
    
    ' Get and display joystick voltage and position
    joystickPosition% := GetJoystickPosition%(joystickVoltage);
    View(ajWindowXY%).XYAddData(ajChanJoystickPos%, joystickVoltage * ajVCoeff + ajVConst, ajJoystickDisplayY);
    
    if tNow > 0.005 then
        xEye := ChanMeasure(ajChanEyeX%, 2, tNow, tNow-.005) * DegreesPerVoltX;
        yEye := ChanMeasure(ajChanEyeY%, 2, tNow-.001, tNow-.006) * DegreesPerVoltY;
        View(ajWindowXY%).XYAddData(1, xEye, yEye);
    endif
    
    
    repeat
        iLoop% := 0;
        docase 
        case iState% = stateStartup% then
            
            LogStatus("stateStartup", "Starting up.");
            ChangeStateTo(stateVSGWait%, tNow);
            iLoop% := 1;
            
        case iState% = stateVSGWait% then
            
            ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.

            tTrigger := NextTime(ajChanVSGReady%, tLast, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 0 then
                LogStatus("stateVSGWait", "Got leading edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateVSGConfirm%, tTrigger);                
                iLoop% := 1;
            endif;
            
        case iState% = stateVSGConfirm% then
            
            ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
            tTrigger := NextTime(ajChanVSGReady%, tLastTrigger, vTrigger);
            if tTrigger > tLastTrigger and vTrigger = 1 then                
                LogStatus("stateVSGConfirm", "Got trailing edge of trigger.");
                tLastTrigger := tTrigger;
                ChangeStateTo(stateAttaJoyOrTuning%, tTrigger);
                iLoop% := 1;
            endif;
            
        case iState% = stateAttaJoyOrTuning% then
            
            if ajDoTuningTrials% = 1 then
                ChangeStateTo(stateStartTuningTrials%, tNow);
            else
                ChangeStateTo(stateStartAttaJoyTrials%, tNow);
            endif
            iLoop% := 1;
            
        case iState% = stateStartTuningTrials% then
            
            LogStatus("stateStartTuningTrials", "Starting Tuning trials.");
            ChangeStateTo(stateTuningTrialStart%, tNow);
            iLoop% := 1;
            
        case iState% = stateTuningTrialStart% then
            
            SampleKey("F");
            ChangeStateTo(stateWaitForFixpt%, tNow);
            
        case iState% = stateStartAttaJoyTrials% then
            
            LogStatus("stateStartAttaJoyTrials", "Starting AttaJoy trials.");
            ChangeStateTo(stateTrialStart%, tNow);
            
        case iState% = stateTrialStart% then
            
            var s%;
            s% := PrepareTrial%();
            if s% = 1 then
                ajCtrNTrials% += 1;
                ChangeStateTo(stateWaitForNeutral%, tNow);
            else
                ChangeStateTo(stateDone%, tNow);
            endif
            iLoop% := 1;
            
        case iState% = stateWaitForNeutral% then
            
            if joystickPosition% = JSCenter% then
                LogStatus("stateWaitForNeutral", "Joystick in neutral. Proceed.");
                ChangeStateTo(stateBeep%, tNow);
                iLoop% := 0;
            endif
            
        case iState% = stateBeep% then
            
            if ajUseBeep% <> 0 then
                Sound("ding", 1);
            endif
            Yield(.5);
            ChangeStateTo(stateWaitForReady%, tNow);
            iLoop% := 1;
            
        case iState% = stateWaitForReady% then
            
            ' Wait for joystick to be positioned in the center. 
            docase
            case joystickPosition% = ajReadyResponse% then
                LogStatus("WaitForReady", "Joystick ready.");
                ajCtrNTrialsReady% += 1;
'                if ajDoReadyTraining% = 0 then
                if ajTrainingType% <> ajReadyTraining% then
                    SampleKey(ajTrialFixptSampleKey$);                   ' this is determined in PrepareTrial, depends on trial type
                    ChangeStateTo(stateWaitForFixpt%, tNow);
                else
                    ChangeStateTo(stateT1Success%, tNow);
                    iLoop% := 1;
                endif
            case tNow - tStateStart > ajMaxWaitForReadyTime then
                LogStatus("WaitForReady", "Ready wait time expired.");
                ChangeStateTo(stateReadyFail%, tNow);
            endcase
            iLoop% := 0;
            
        case iState% = stateT1Success% then
            
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajTrainingSuccessPauseTime;
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            ChangeStateTo(stateIntertrialWait%, tNow);
            iLoop% := 0;
            
        case iState% = stateReadyFail% then
            
            ajCtrReadyFail% += 1;
            ajUniversalIntertrialTime := ajReadyFailPauseTime;
            ChangeStateTo(stateIntertrialWait%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForFixpt% then
            
            ' Waiting for fixpt signal on channel ajChanFixpt%
            if FindRisingEdge%(ajChanFixpt%, tStateStart, tTrigger) = 0 then
				LogStatus("stateWaitForFixpt", "Fixpt is up.");
                DisplayStim(1); ' display fixpt and fixation window in xy view
				ChangeStateTo(stateWaitForAcquisition%, tTrigger);
			endif;
            iLoop% := 0;
            
        case iState% = stateWaitForAcquisition% then
            
            ' Waiting for eye to fall in fixation window. If an AttaJoy trial, 
            ' then joystick must remain in ready position.
            if ajDoTuningTrials% = 0 then    
                docase
                case joystickPosition% <> ajReadyResponse% then
                    LogStatus("stateWaitForAcquisition", "Joystick not in ready position.");
                    ChangeStateTo(stateReadyBreak%, tNow);
                case Looking%(xEye, yEye) = 1 then
                    LogStatus("stateWaitForAcquisition", "Eye in fixation window.");
                    ajCtrNTrialsAcq% += 1;
                    if ajUseCueCircles% then
                        ChangeStateTo(stateHoldFixation1%, tNow);
                    else
                        ajHoldFixationMiniRewardEnable% := 1;
                        ChangeStateTo(stateHoldFixation%, tNow);
                    endif
                case tNow - tStateStart > ajMaxAcquisitionTime then
                    LogStatus("stateWaitForAcquisition", "Acquisition time is up!");
                    ajCtrNTrialsAcqFail% += 1;
                    ChangeStateTo(stateAcquisitionFail%, tNow);
                else
                    iLoop% := 0;
                endcase
            else
                docase
                case Looking%(xEye, yEye) = 1 then    
                    LogStatus("stateWaitForAcquisition", "Eye in fixation window.");
                    ChangeStateTo(stateHoldFixation%, tNow);
                case tNow - tStateStart > ajMaxAcquisitionTime then
                    LogStatus("stateWaitForAcquisition", "Acquisition time is up!");
                    ajCtrNTrialsAcqFail% += 1;
                    ChangeStateTo(stateAcquisitionFail%, tNow);
                else
                    iLoop% := 0;
                endcase
            endif
            
        case iState% = stateReadyBreak% then
            
            ajCtrReadyBreak% += 1;
            SampleKey("X");
            ajUniversalIntertrialTime := ajReadyBreakPauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateAcquisitionFail% then
            
            ajCtrNTrialsAcqFail% += 1;
            ajUniversalIntertrialTime := ajAcquisitionFailPauseTime;
            SampleKey("X");
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateHoldFixation% then
            
            iLoop% := 0;
            if ajDoTuningTrials% = 0 then
                docase
                case joystickPosition% <> ajReadyResponse% then
                    LogStatus("stateHoldFixation", "Joystick not in ready position.");
                    ChangeStateTo(stateReadyBreak%, tNow);
                case Looking%(xEye, yEye) <> 1 then
                    LogStatus("stateHoldFixation", "Eye not in fixation window.");
                    ChangeStateTo(stateFixationBreak%, tNow);
                case tNow - tStateStart > ajHoldFixationTime then
                    ajCtrNTrialsFix% += 1;
                    if ajTrainingType% <> ajReadyFixTraining% then
                        LogStatus("stateHoldFixation", "Fixation held. Request stim up.");
                        SampleKey("S");
                        ChangeStateTo(stateWaitForStimOn%, tNow);
                    else
                        LogStatus("stateHoldFixation", "Fixation held, trial complete.");
                        ChangeStateTo(stateT2Success%, tNow);
                    endif
                case ajDoHoldFixationMiniReward% = 1 and (tNow-tStateStart)/ajHoldFixationTime > ajHoldFixationMiniRewardFraction and ajHoldFixationMiniRewardEnable% = 1 then
                    LogStatus("stateHoldFixation", "Mini-reward fraction " + str$((tNow-tStateStart)/ajHoldFixationTime));
                    ajHoldFixationMiniRewardEnable% := 0;
                    DeliverReward(1);
                else
                    iLoop% := 0;
                endcase
            else
                docase
                case Looking%(xEye, yEye) <> 1 then
                    LogStatus("stateHoldFixation", "Eye not in fixation window.");
                    ChangeStateTo(stateFixationBreak%, tNow);
                case tNow - tStateStart > ajHoldFixationTime then
                    ajCtrNTrialsFix% += 1;
                    LogStatus("stateHoldFixation", "Fixation held. Request stim up.");
                    SampleKey("C");
                    ChangeStateTo(stateTuningWaitForStimOn%, tNow);
                endcase
            endif
            
        case iState% = stateT2Success% then
            
            SampleKey("X");
            Yield();
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajTrainingSuccessPauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateHoldFixation1% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateHoldFixation1", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation1", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajHoldFixation1Time then
                LogStatus("stateHoldFixation1", "Fixation held. Request circle up.");
                SampleKey("W");
                ChangeStateTo(stateWaitForCircle%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForCircle% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitForCircle", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForCircle", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanCircle%, tStateStart, tCircleOn) = 0 then
                LogStatus("stateWaitForCircle", "Circle up.");
                ChangeStateTo(stateHoldFixation2%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateHoldFixation2% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateHoldFixation2", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation2", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tCircleOn > ajHoldFixation2Time then
                LogStatus("stateHoldFixation2", "Fixation held. Request circle off.");
                SampleKey("w");
                ChangeStateTo(stateWaitForCircleOff%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForCircleOff% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitForCircleOff", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForCircleOff", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindFallingEdge%(ajChanCircle%, tStateStart, tTrigger) = 1 then
                LogStatus("stateWaitForCircleOff", "Circle off.");
                ChangeStateTo(stateHoldFixation3%, tTrigger);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateHoldFixation3% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateHoldFixation3", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateHoldFixation3", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajHoldFixation3Time then
                LogStatus("stateHoldFixation3", "Fixation held. Request stim up.");
                ajCtrNTrialsFix% += 1;
'                if ajDoReadyFixTraining% = 0 then
                if ajTrainingType% <> ajReadyFixTraining% then
                    LogStatus("stateHoldFixation3", "Fixation held. Request stim up.");
                    SampleKey("S");
                    ChangeStateTo(stateWaitForStimOn%, tNow);
                else
                    LogStatus("stateHoldFixation3", "Fixation held, trial complete.");
                    ChangeStateTo(stateT2Success%, tNow);
                endif
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateFixationBreak% then
            
            ajUniversalIntertrialTime := ajFixationBreakPauseTime;
            ajCtrNTrialsFixBreak% += 1;
            SampleKey("X");
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForStimOn% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitForStimOn", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForStimOn", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanStimulus%, tStateStart, tTrigger) = 0 then
                LogStatus("stateWaitForStimOn", "Stim up.");
                ChangeStateTo(stateWaitHazardTime%, tNow);
                DisplayStim(2);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateTuningWaitForStimOn% then
            
            iLoop% := 0;
            docase
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForStimOn", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanContrastChg%, tStateStart, tTrigger) = 0 then
                LogStatus("stateTuningWaitForStimOn", "Stim up.");
                ChangeStateTo(stateTuningHoldFixationMore%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateTuningHoldFixationMore% then
            
            iLoop% := 0;
            docase
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("TuningHoldFixationMore", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajTuningStimulusTime then
                LogStatus("TuningHoldFixationMore", "Success!");
                ChangeStateTo(stateTuningSuccess%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateTuningSuccess% then
            
            SampleKey("X");
            Yield();
            DeliverReward(ajRewardSize%);
            LogStatus("TuningSuccess", "TODO: Analysis!");
            ajUniversalIntertrialTime := ajCorrectResponsePauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            
        case iState% = stateWaitHazardTime% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitHazardTime", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitHazardTime", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case tNow - tStateStart > ajTrialHazardTime then
'                if ajDoReadyFixStimTraining% = 0 then
                if ajTrainingType% <> ajReadyFixStimTraining% then
                    LogStatus("stateWaitHazardTime", "Request stim contrast change.");
                    ajCtrNTrialsChg% += 1;
                    SampleKey(ajTrialChangeSampleKey$);
                    ChangeStateTo(stateWaitForContrastChange%, tNow);
                else
                    LogStatus("stateWaitHazardTime", "Fixation held, trial complete.");
                    ChangeStateTo(stateT3Success%, tNow);
                endif
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateT3Success% then
            
            SampleKey("X");
            Yield();
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajTrainingSuccessPauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            iLoop% := 0;
            
        case iState% = stateWaitForContrastChange% then
            
            iLoop% := 0;
            docase
            case joystickPosition% <> ajReadyResponse% then
                LogStatus("stateWaitForContrastChange", "Joystick not in ready position.");
                ChangeStateTo(stateReadyBreak%, tNow);
            case Looking%(xEye, yEye) <> 1 then
                LogStatus("stateWaitForContrastChange", "Eye not in fixation window.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case FindRisingEdge%(ajChanContrastChg%, tStateStart, tTrigger) = 0 then
                LogStatus("stateWaitForContrastChange", "Got contrast change.");
                ChangeStateTo(stateWaitForResponse%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateWaitForResponse% then
            
            iLoop% := 0;
            docase
                ' djs 6-9-2010
                ' Farran wanted to impose a short "must continue fixating" period 
                ' during this state. The subject must remain fixated for a short time
                ' (ajExtraFixationTime, not in dialogs)
            case Looking%(xEye, yEye) <> 1 and tNow - tStateStart < ajExtraFixationTime then
                LogStatus("stateWaitForResponse", "Eye not in fixation window for at least " + str$(ajExtraFixationTime) + "s after contrast change.");
                ChangeStateTo(stateFixationBreak%, tNow);
            case joystickPosition% = JSCenter% then
                LogStatus("stateWaitForResponse", "Got response.");
                ChangeStateTo(stateCorrectResponse%, tNow);
            case tNow - tStateStart > ajMaxResponseTime then
                LogStatus("stateWaitForResponse", "Time's up!");
                ChangeStateTo(stateIncorrectResponse%, tNow);
            else
                iLoop% := 0;
            endcase
            
        case iState% = stateCorrectResponse% then
            
            iLoop% := 0;
            ajCtrCorrect% += 1;
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            SampleKey("X");
            Yield();
            DeliverReward(ajRewardSize%);
            ajUniversalIntertrialTime := ajCorrectResponsePauseTime;
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            
        case iState% = stateIncorrectResponse% then
            
            iLoop% := 0;
            ajCtrIncorrect% += 1;
            trialgenTrialIndexCompleted(ajTrialTypeIndex%);
            ajUniversalIntertrialTime := ajIncorrectResponsePauseTime;
            SampleKey("X");
            ChangeStateTo(stateWaitForFixptOff%, tNow);
            
        case iState% = stateWaitForFixptOff% then
            
            iLoop% := 0;
            if FindFallingEdge%(ajChanFixpt%, tStateStart, tTrigger) = 1 then
                DisplayStim(0);
                LogStatus("stateWaitForFixptOff", "Fixpt off.");
                ChangeStateTo(stateIntertrialWait%, tNow);
            else
                iLoop% := 0;
            endif
            
        case iState% = stateIntertrialWait% then
            
            ' Any states that exit to here should have set the universal intertrial wait time!
            iLoop% := 0;
            if tNow - tStateStart > ajUniversalIntertrialTime then
                ChangeStateTo(stateTrialCompleted%, tNow);
                iLoop% := 1;
            endif
            
        case iState% = stateTrialCompleted% then
            
            LogStatus("stateTrialCompleted", "Trial completed.");
            docase
            case ajIsPaused% = 1 then
                ChangeStateTo(statePaused%, tNow);
            case ajDoTuningTrials% = 0 then
                ChangeStateTo(stateTrialStart%, tNow);
            else
                ChangeStateTo(stateTuningTrialStart%, tNow);
            endcase
            iLoop% := 1;
            UpdateToolbarText(0, "");
            
        case iState% = statePaused% then
            
            ToolbarEnable(toolbarItemPause%, 0);
            ToolbarEnable(toolbarItemResume%, 1);
            UpdateToolbarText(1, "Paused");
            ChangeStateTo(statePausedWaiting%, tNow);
            iLoop% := 0;
            
        case iState% = statePausedWaiting% then
            
            if ajIsPaused% = 0 then
                if ajDoTuningTrials% = 0 then
                    ChangeStateTo(stateTrialStart%, tNow);
                else
                    ChangeStateTo(stateTuningTrialStart%, tNow);
                endif
                ToolbarEnable(toolbarItemPause%, 1);
                ToolbarEnable(toolbarItemResume%, 0);
                UpdateToolbarText(1, "Resumed");
            endif
            iLoop% := 0;
            
        case iState% = stateDone% then
            
            LogStatus("stateDone", "Reached done state. Calling Stop%()...\n");
            Stop%();
            iLoop% := 0;
            iStatus% := 0;
            
        else
            
            ' Unknown state!
            Message("Unknown state=" + str$(iState%));
            Stop%();
            halt;
            
        endcase;
    until iLoop% = 0;
    
	tLast := tNow;
	return iStatus%;
end;


proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;

proc DeliverReward(iNumRewards%)
    SampleSeqVar(1, iNumRewards%);
    SampleKey("R");
    return;
end

func ajChanFixptWindowDisplay()
    DeliverReward(1);
    return 1;
end


' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	if ajStimHandle% > 0 then
        ProgKill(ajStimHandle%);
        while ProgStatus(ajStimHandle%) > 0 do
            Yield();
        wend
        ajStimHandle% := 0;
    endif
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    
    ' Dump results to log window
    UpdateToolbarText(1, "Stopped");
    
	' Disable idle process func
	ToolbarSet(0, "");

	' Tell stim app to shut down
	SampleKey("q");
	Yield(.1);
	SampleStop();

	if ajStimHandle% > 0 then
        ProgKill(ajStimHandle%);
        while ProgStatus(ajStimHandle%) > 0 do
            Yield();
        wend
        ajStimHandle% := 0;
    endif
    return 0;

end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
    var cmdLine$;
    var h, contrast%, sf, tf, ori, cv$, pattern$, aperture$;
    var stimSpec$;
    var distSpec$;
    var fixSpec$;
    var extra$;
    
    ' Get stimulus, distractor and fixpt specs
    stimSpec$ := GetGratingParameters$("Stimulus");
    ParseGratingParametersBrief%(stimSpec$, ajStim0X, ajStim0Y, ajStim0D, ajStim0D);
    distSpec$ := GetGratingParameters$("Distractor1");
    ParseGratingParametersBrief%(distSpec$, ajStim1X, ajStim1Y, ajStim1D, ajStim1D);
    fixSpec$ := GetFixationArg$();
    GetFixationPointParameterValues(ajFixationX, ajFixationY, ajFixationD, ajFixationWindowRadius);
    
    ' extra parameters
    extra$ := " -d " + GetDistanceToScreenMM$() + " -b gray -N -Q -t " + str$(ajContrastDown%) + "," + str$(ajContrastBase%) + "," + str$(ajContrastUp%);
    if ajUseCueCircles% = 1 then
        extra$ += " -Q -c 0.5";
    endif
    if ajShowSingleStim% = 1 then
        extra$ += " -S";
    endif
    
    ' Generate command line
    cmdLine$ := "cmd /k " + GetBinDir$(1) + "Attention " + fixSpec$ + extra$ + " -s " + stimSpec$ + " -g " + distSpec$;

    ' Start sampling
   	SampleStart(0);
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	LogInfo(cmdLine$+"\n");
	ajStimHandle% := ProgRun(cmdLine$, 1);
	if ajStimHandle% < 0 then 
        Message("Could not start stimulus."); 
        halt; 
    endif
	
	ToolbarEnable(toolbarItemStart%, 0);
	ToolbarEnable(toolbarItemStop%, 1);
	ToolbarEnable(toolbarItemStartAttaJoy%, 1);
    ToolbarEnable(toolbarItemStartTuning%, 1);
	View(ajWindowData%);
    return 1;
end;


func StartAttaJoyTrials%()
    ajDoTuningTrials% := 0;
    ToolbarSet(0, "", IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(toolbarItemStartAttaJoy%, 0);
    ToolbarEnable(toolbarItemStartTuning%, 0);
    ToolbarEnable(toolbarItemPause%, 1);
    ToolbarEnable(toolbarItemResume%, 0);
    
    ' Kill PSTH windows if they remain
    
    ' Resize eye window
    View(ajWindowXY%).Window(0, 0, 100, 47);
    
    return 1;
end

func StartTuningTrials%()
    var i%, list%[64];
    ajDoTuningTrials% := 1;
    ToolbarSet(0, "", IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(toolbarItemStartAttaJoy%, 0);
    ToolbarEnable(toolbarItemStartTuning%, 0);
    ToolbarEnable(toolbarItemPause%, 1);
    ToolbarEnable(toolbarItemResume%, 0);
    
    ' Kill PSTH windows if they remain
    
    ' Resize eye window
    View(ajWindowXY%).Window(0, 0, 20, 25);
    
    ' Set up PSTH's
    if ChanList(list%[], 0x10) > 0 then
        View(ajWindowData%);
        for i% := 1 to list%[0] do
            ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ
        next
    else
        Message("No wavemark channels configured, not setting up PSTH plots.");
    endif
    
    return 1;
end


func Pause%()
    LogInfo("Pause requested.");
    ajIsPaused% := 1;
    return 1;
end

func Resume%()
    LogInfo("Resume requested.");
    ajIsPaused% := 0;
    return 1;
end

func Reward%()
    DeliverReward(1);
    return 0;
end


' PrepareBlock
'
' Prepares variables etc used for driving a block of trials for this expt. 
' TODO 

proc PrepareBlock()
    LogInfo("Preparing block...");
' TODO     tbgInit(2, rivNTrialsEachTypePerBlock%, rivNBlocks%);
    return
end

' PrepareTrial
'
' Prepares variables etc used for driving a single trial

' TODO

func PrepareTrial%()
    var index%;
    var s% := 1;
    
    s% := trialgenGetTrialIndex%(ajTrialTypeIndex%);
    LogInfo("Preparing trial... index " + str$(ajTrialTypeIndex%) + " s=" + str$(s%));
    ajIsCatchTrial% := 0;
'    if s% = 1 and ajDoReadyTraining% = 0 and ajDoReadyFixTraining% = 0 then
    if s% = 1 and ajTrainingType% <> ajReadyTraining% and ajTrainingType% <> ajReadyFixTraining% then
            
        ' Generate hazard time
        repeat
            ajTrialHazardTime := RandExp(ajHazardTimeMean, ajHazardTimeMin);
            until ajTrialHazardTime <= ajHazardTimeMax;
        
        
        ' Catch trial?
        if ajShowSingleStim% = 0 and ajCatchTrialPct > 0 and Rand()*100 < ajCatchTrialPct then
            ajIsCatchTrial% := 1;
            LogInfo("Catch trial!");
        else
            ajIsCatchTrial% := 0;
        endif
        
    endif
        
    if ajIsCatchTrial% = 0 then
        ajTrialFixptSampleKey$ := ajTrialFixptTypeKeys$[ajTrialTypeIndex%];
        ajTrialChangeSampleKey$ := ajTrialChangeTypeKeys$[ajTrialTypeIndex%];
    else
        ajTrialFixptSampleKey$ := ajTrialFixptTypeKeys$[ajTrialTypeIndex%];
        ajTrialChangeSampleKey$ := ajTrialChangeTypeKeys$[1-ajTrialTypeIndex%];
    endif

    return s%;
end


func AttaJoyDialog%()
    var status% := 1;
    GetAttaJoyParameters();
    DlgCreate("AttaJoy Parameters");
    DlgGroup("Blocks/contrast/training", 1, 1, 40, 12);
	DlgInteger(1, "Number of Blocks:", 1, 1000, 20, 2);
	DlgInteger(2, "# each type/block:", 1, 1000, 20, 3);
    DlgList(3, "Types", "Both|Red|Green", 3, 20, 4);
    DlgList(4, "Training type", ajTrainingTypes$[], 4, 20, 5);
    DlgCheck(5, "Use Beep", 2, 6);
	DlgInteger(6, "Reward size:", 1, 1000, 20, 7);
	DlgReal(7, "Catch Trial pct (0-100)", 0, 100, 20, 8);
	DlgCheck(8, "Show Single Stim", 2, 9);
	DlgCheck(9, "Alternate cue type by block", 2, 10);
	DlgInteger(10, "Base contrast(%)", 0, 100, 20, 11);
	DlgInteger(11, "Chg contrast(%)", 0, 100, 20, 12);
    
    DlgButton(100, "Cue/HoldFix/Hazard", AttaJoyFixationHazardDialog%, 1, 13);
    DlgButton(101, "Timing", AttaJoyTimingDialog%, 1, 14);
    DlgButton(102, "Electrodes", AttaJoyElectrodeDialog%, 1, 15);
    ajElectrodeTextItem% := DlgText(GetElectrodeTextItem$(), 15, 15, 15);

    status% := DlgShow(ajNBlocks%, ajNTrialsEachTypePerBlock%, ajTrialTypesListIndex%, 
                       ajTrainingType%, ajUseBeep%, ajRewardSize%,
                       ajCatchTrialPct, ajShowSingleStim%, ajAlternateCueTypeByBlock%, 
                       ajContrastBase%, ajContrastUp%);
    
    if status% = 1 then
        SaveAttaJoyParameters();
    endif
    return status%;
end



func AttaJoyFixationHazardDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = 1 then
        DlgEnable(DlgValue(1), 2);
        DlgEnable(DlgValue(1), 3);
        DlgEnable(DlgValue(1), 4);
        DlgEnable(1-DlgValue(1), 5);
    case item% = 0 then
        DlgEnable(ajUseCueCircles%, 2);
        DlgEnable(ajUseCueCircles%, 3);
        DlgEnable(ajUseCueCircles%, 4);
        DlgEnable(1-ajUseCueCircles%, 5);
    endcase
    return status%;
end


func AttaJoyTimingDialog%()
	DlgCreate("AttaJoy timing", 25, 10);
	DlgReal(1, "Max rdy time(s):", .01, 10);
	DlgReal(2, "Rdy FAIL pause time(s):", .01, 10);
	DlgReal(3, "Rdy BREAK pause time(s):", .01, 10);
    DlgReal(4, "Trng Success pause time(s):",  .01, 10);
    DlgReal(5, "Max acq time(s):", .01, 10);
	DlgReal(6, "Acq FAIL pause time(s):", .01, 10);
    DlgReal(7, "Max resp time(s):", .01, 10);
    DlgReal(8, "Correct resp pause time(s):",  .01, 10);
    DlgReal(9, "Incorrect resp pause time(s):",  .01, 10);
    DlgReal(10, "Fix break pause time(s):",  .01, 10);
    DlgReal(11, "Fix time after con chg(s):", 0, 10);
    DlgCheck(12, "Always looking (TESTING ONLY)");
	DlgShow(ajMaxWaitForReadyTime, ajReadyFailPauseTime, ajReadyBreakPauseTime,
    ajTrainingSuccessPauseTime,
    ajMaxAcquisitionTime, ajAcquisitionFailPauseTime, ajMaxResponseTime, 
    ajCorrectResponsePauseTime, ajIncorrectResponsePauseTime, ajFixationBreakPauseTime, ajExtraFixationTime,
    ajAlwaysLooking%);
    return 1;
end

func AttaJoyFixationHazardDialog%()
	DlgCreate("AttaJoy Fixation/Hazard");
    DlgGroup("AttaJoy Fixation", 1, 1, 40, 6);
    DlgCheck(1, "Use Cue Circles", 2, 2);
    DlgReal(2, "HoldFix time #1", 0.0, 100.0, 20, 3);
    DlgReal(3, "HoldFix time #2", 0.0, 100.0, 20, 4);
    DlgReal(4, "HoldFix time #3", 0.0, 100.0, 20, 5);
    DlgReal(5, "HoldFix time", 0.0, 100.0, 20, 6);
    DlgGroup("AttaJoy Hazard Time", 1, 7, 40, 4);
    DlgReal(6, "Hazard time (min)", 0.0, 100.0, 20, 8);
    DlgReal(7, "Hazard time (mean)", 0.0, 100.0, 20, 9);
    DlgReal(8, "Hazard time (max)", 0.0, 100.0, 20, 10);
    DlgGroup("Pulse Tuning", 1, 11, 40, 3);
    DlgReal(9, "Fixation time", 0.1, 10.0, 20, 12);
    DlgReal(10, "Stimulus time", 0.1, 10.0, 20, 13);
    DlgAllow(0, 0, AttaJoyFixationHazardDialogChanged%);
    DlgShow(ajUseCueCircles%, ajHoldFixation1Time, ajHoldFixation2Time, ajHoldFixation3Time,
    ajHoldFixationTime, ajHazardTimeMin, ajHazardTimeMean, ajHazardTimeMax, ajTuningFixationTime, ajTuningStimulusTime);
    return 1;
end


func AttaJoyElectrodeDialog%()
	DlgCreate("AttaJoy Electrodes");
    DlgCheck(1, "Port 0");
    DlgCheck(2, "Port 1");
    DlgCheck(3, "Port 2");
    DlgCheck(4, "Port 3");
    DlgCheck(5, "Port 4");
    DlgCheck(6, "Port 5");
    DlgCheck(7, "Port 6");
    DlgCheck(8, "Port 7");
	DlgShow(ajElectrodes%[0], ajElectrodes%[1], ajElectrodes%[2], ajElectrodes%[3], ajElectrodes%[4], ajElectrodes%[5], ajElectrodes%[6], ajElectrodes%[7]); 
    DlgValue$(ajElectrodeTextItem%, GetElectrodeTextItem$());
    return 1;
end

func GetElectrodeTextItem$()
    var s$ := "";
    var n% := 0;
    var i%;
    for i% := 0 to 7 do
        if ajElectrodes%[i%] = 1 then
            if n%> 0 then
                s$ += ",";
            endif
            n% += 1;
            s$ += str$(i%);
        endif
    next
    if n% = 0 then
        s$ := "None";
    endif
    return s$;
end


proc GetAttaJoyParameters()
    var key$;
    var stmp$;
    key$ := GetRegistryKey$(1) + "\\AttaJoy";
    ajNBlocks% := GetIntRegistryValue%(key$, "NBlocks", ajNBlocks%);
    ajNTrialsEachTypePerBlock% := GetIntRegistryValue%(key$, "NTrialsEachTypePerBlock", ajNTrialsEachTypePerBlock%);
    ajTrialTypesListIndex% := GetIntRegistryValue%(key$, "TrialTypesListIndex", ajTrialTypesListIndex%);
    ajTrainingType% := GetIntRegistryValue%(key$, "TrainingType", ajTrainingType%);
    ajRewardSize% := GetIntRegistryValue%(key$, "RewardSize", ajRewardSize%);
    ajCatchTrialPct := GetFloatRegistryValue(key$, "CatchTrialPct", ajCatchTrialPct);
    ajShowSingleStim% := GetIntRegistryValue%(key$, "ShowSingleStim", ajShowSingleStim%);
    ajAlternateCueTypeByBlock% := GetIntRegistryValue%(key$, "AlternateCueTypeByBlock", ajAlternateCueTypeByBlock%);
    ajContrastBase% := GetIntRegistryValue%(key$, "BaseContrast", ajContrastBase%);
    ajContrastUp% := GetIntRegistryValue%(key$, "UpContrast", ajContrastUp%);
    ajUseCueCircles% := GetIntRegistryValue%(key$, "UseCueCircles", ajUseCueCircles%);
    ajHoldFixation1Time := GetFloatRegistryValue(key$, "HoldFixation1Time", ajHoldFixation1Time);
    ajHoldFixation2Time := GetFloatRegistryValue(key$, "HoldFixation2Time", ajHoldFixation2Time);
    ajHoldFixation3Time := GetFloatRegistryValue(key$, "HoldFixation3Time", ajHoldFixation3Time);
    ajHoldFixationTime := GetFloatRegistryValue(key$, "HoldFixationTime", ajHoldFixationTime);
    ajFixationBreakPauseTime := GetFloatRegistryValue(key$, "FixationBreakPauseTime", ajFixationBreakPauseTime);
    ajHazardTimeMin := GetFloatRegistryValue(key$, "HazardTimeMin", ajHazardTimeMin);
    ajHazardTimeMean := GetFloatRegistryValue(key$, "HazardTimeMean", ajHazardTimeMean);
    ajHazardTimeMax := GetFloatRegistryValue(key$, "HazardTimeMax", ajHazardTimeMax);
	ajMaxWaitForReadyTime := GetFloatRegistryValue(key$, "MaxWaitForReadyTime", ajMaxWaitForReadyTime);
    ajReadyFailPauseTime := GetFloatRegistryValue(key$, "ReadyFailPauseTime", ajReadyFailPauseTime);
    ajReadyBreakPauseTime := GetFloatRegistryValue(key$, "ReadyBreakPauseTime", ajReadyBreakPauseTime);
    ajTrainingSuccessPauseTime := GetFloatRegistryValue(key$, "TrainingSuccessPauseTime", ajTrainingSuccessPauseTime);
    ajMaxAcquisitionTime := GetFloatRegistryValue(key$, "MaxAcquisitionTime", ajMaxAcquisitionTime);
    ajAcquisitionFailPauseTime := GetFloatRegistryValue(key$, "AcquisitionFailPauseTime", ajAcquisitionFailPauseTime);
    ajMaxResponseTime := GetFloatRegistryValue(key$, "MaxResponseTime", ajMaxResponseTime);
    ajCorrectResponsePauseTime := GetFloatRegistryValue(key$, "CorrectResponsePauseTime", ajCorrectResponsePauseTime);
    ajIncorrectResponsePauseTime := GetFloatRegistryValue(key$, "IncorrectResponsePauseTime", ajIncorrectResponsePauseTime);
    ajExtraFixationTime := GetFloatRegistryValue(key$, "ExtraFixationTime", ajExtraFixationTime);
    ajElectrodes%[0] := GetIntRegistryValue%(key$, "ElectrodePort0", ajElectrodes%[0]);
    ajElectrodes%[1] := GetIntRegistryValue%(key$, "ElectrodePort1", ajElectrodes%[1]);
    ajElectrodes%[2] := GetIntRegistryValue%(key$, "ElectrodePort2", ajElectrodes%[2]);
    ajElectrodes%[3] := GetIntRegistryValue%(key$, "ElectrodePort3", ajElectrodes%[3]);
    ajElectrodes%[4] := GetIntRegistryValue%(key$, "ElectrodePort4", ajElectrodes%[4]);
    ajElectrodes%[5] := GetIntRegistryValue%(key$, "ElectrodePort5", ajElectrodes%[5]);
    ajElectrodes%[6] := GetIntRegistryValue%(key$, "ElectrodePort6", ajElectrodes%[6]);
    ajElectrodes%[7] := GetIntRegistryValue%(key$, "ElectrodePort7", ajElectrodes%[7]);
    ajTuningStimulusTime := GetFloatRegistryValue(key$, "TuningStimulusTime", ajTuningStimulusTime);
end

proc SaveAttaJoyParameters()
    var key$;
    var stmp$;
    key$ := GetRegistryKey$(1) + "\\AttaJoy";
    SetIntRegistryValue(key$, "NBlocks", ajNBlocks%);
    SetIntRegistryValue(key$, "NTrialsEachTypePerBlock", ajNTrialsEachTypePerBlock%);
    SetIntRegistryValue(key$, "TrialTypesListIndex", ajTrialTypesListIndex%);
    SetIntRegistryValue(key$, "TrainingType", ajTrainingType%);
    SetIntRegistryValue(key$, "RewardSize", ajRewardSize%);
    SetFloatRegistryValue(key$, "CatchTrialPct", ajCatchTrialPct);
    SetIntRegistryValue(key$, "ShowSingleStim", ajShowSingleStim%);
    SetIntRegistryValue(key$, "AlternateCueTypeByBlock", ajAlternateCueTypeByBlock%);
    SetIntRegistryValue(key$, "BaseContrast", ajContrastBase%);
    SetIntRegistryValue(key$, "UpContrast", ajContrastUp%);
    SetIntRegistryValue(key$, "UseCueCircles", ajUseCueCircles%);
    SetFloatRegistryValue(key$, "HoldFixation1Time", ajHoldFixation1Time);
    SetFloatRegistryValue(key$, "HoldFixation2Time", ajHoldFixation2Time);
    SetFloatRegistryValue(key$, "HoldFixation3Time", ajHoldFixation3Time);
    SetFloatRegistryValue(key$, "HoldFixationTime", ajHoldFixationTime);
    SetFloatRegistryValue(key$, "FixationBreakPauseTime", ajFixationBreakPauseTime);
    SetFloatRegistryValue(key$, "HazardTimeMin", ajHazardTimeMin);
    SetFloatRegistryValue(key$, "HazardTimeMean", ajHazardTimeMean);
    SetFloatRegistryValue(key$, "HazardTimeMax", ajHazardTimeMax);
	SetFloatRegistryValue(key$, "MaxWaitForReadyTime", ajMaxWaitForReadyTime);
    SetFloatRegistryValue(key$, "ReadyFailPauseTime", ajReadyFailPauseTime);
    SetFloatRegistryValue(key$, "ReadyBreakPauseTime", ajReadyBreakPauseTime);
    SetFloatRegistryValue(key$, "TrainingSuccessPauseTime", ajTrainingSuccessPauseTime);
    SetFloatRegistryValue(key$, "MaxAcquisitionTime", ajMaxAcquisitionTime);
    SetFloatRegistryValue(key$, "AcquisitionFailPauseTime", ajAcquisitionFailPauseTime);
    SetFloatRegistryValue(key$, "MaxResponseTime", ajMaxResponseTime);
    SetFloatRegistryValue(key$, "CorrectResponsePauseTime", ajCorrectResponsePauseTime);
    SetFloatRegistryValue(key$, "IncorrectResponsePauseTime", ajIncorrectResponsePauseTime);
    SetFloatRegistryValue(key$, "ExtraFixationTime", ajExtraFixationTime);
    SetIntRegistryValue(key$, "ElectrodePort0", ajElectrodes%[0]);
    SetIntRegistryValue(key$, "ElectrodePort1", ajElectrodes%[1]);
    SetIntRegistryValue(key$, "ElectrodePort2", ajElectrodes%[2]);
    SetIntRegistryValue(key$, "ElectrodePort3", ajElectrodes%[3]);
    SetIntRegistryValue(key$, "ElectrodePort4", ajElectrodes%[4]);
    SetIntRegistryValue(key$, "ElectrodePort5", ajElectrodes%[5]);
    SetIntRegistryValue(key$, "ElectrodePort6", ajElectrodes%[6]);
    SetIntRegistryValue(key$, "ElectrodePort7", ajElectrodes%[7]);
    SetFloatRegistryValue(key$, "TuningStimulusTime", ajTuningStimulusTime);
end


func Looking%(x, y)
	'Determine if the eye position is within the fixation window
    var s% := 0;
    docase
    case ajAlwaysLooking% = 1 then
        s% := 1;
    case (Pow(x-FixationX, 2) + Pow(y-FixationY, 2)) <= Pow(WindowRadius, 2) then 
        s% := 1; 
    else 
        s% := 0; 
    endcase
    return s%;
end;

proc UpdateToolbarText(iLogWindowAlso%, append$)

	var s$;
    s$ := Print$("N/Rdy/Acq/Fix/Haz/+(%)/-(%) = %d/%d/%d/%d/%d/%d/%d", ajCtrNTrials%, ajCtrNTrialsReady%, ajCtrNTrialsAcq%, ajCtrNTrialsFix%, ajCtrNTrialsChg%, ajCtrCorrect%, ajCtrIncorrect%);
    if Len(append$)>0 then
        s$ := s$ + ": " + append$;
    endif
	ToolbarText(s$);
    
    if iLogWindowAlso% <> 0 then
        PrintLog(s$);
    endif

end;
