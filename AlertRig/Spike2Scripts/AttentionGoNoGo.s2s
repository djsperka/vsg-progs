' $Id: AttentionGoNoGo.s2s,v 1.47 2015-05-12 17:15:18 devel Exp $
'
#include "../../Spike2Util/UsreyUtil.s2s"
#include "AttentionExtractFunctions.s2s"
#include "UsreyFixationPoint.s2s"
#include "UsreyDAQ.s2s"


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' 	Attention script dialog START
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'	Vars that control the Attention script 

var attNumberOfBlocks%;
var attTrialsPerBlock%;
var attEasyTrialsPerBlock%;
var distracterOffForEasy%;
var attCatchTrialPercentage;
var attUncatchTrialPercentage;
var attDoUncatch%;
var attNoGoTrialPercentage;
var attNumPatches%;  'how many stimulus patches on the screen?
var attGetGPFromMainStim%;  'check box variable, should we get the distractor grating parameters (except for XY position) from the main stimulus?
var attUseCueCircles%;
var attCueCircleExtraRadius;
var attBackgroundColor$;
var attBackgroundRed% := 0;
var attBackgroundGreen% := 0;
var attBackgroundBlue% := 0;
var attBackgroundFromRed% := 0;
var attBackgroundFromGreen% := 0;
var attBackgroundFromBlue% := 0;
var attBackgroundToRed% := 0;
var attBackgroundToGreen% := 0;
var attBackgroundToBlue% := 0;
var attAnswerPointDiameter := 0.05;
var attAnswerPointOffset := 5.0;
var attAnswerPointWindowRadius := 2.5;
var attContrastBase%;
var attMaxContChange;
var attMinContChange;
var attNContLevels%;
var attContrastList[20];        'max of 20 (10 up, 10 down) contrast levels
var attFixationTime;
'var attWhitePointTime;          ' xxxxx
var attFixationCueMinTime;      ' xxxxx
var attFixationCueMaxTime;      ' xxxxx
var attHazardMinTime;
var attHazardExpMeanTime;
var attHazardCutoffTime;
var attAcquisitionTime;
var attInterTrialTime;
var attInterTrialTime2;
var attTimeToAnswer;
var attTimeToAnswerPerTrial;  'filled on a trial-to-trial basis because the value is different for no-change trials
var attNoChangeDuration;
var attAbortWaitTime;
var attMissPenalty;
var attFalseAlarmWaitTime;
var attFalseAlarmCheckWindow;
var attBlockAlternate%;
var attSelectRandomContrastEachTrial%;  'if 1, don't do blocked randomization
var attTrainingContrastCheck%:=0;
var attTrainingContrastPct%:=0;
var randBlockOrderVar%;     'this will be 0 or 1, and will determine whether we start attend-toward or attend-away
randBlockOrderVar% := round(rand(0.0)); 'just set it right now, may need 0.0 to properly seed random number generator

var attCueCircleContrastStim%;
var attCueCircleContrastD1%;
var attCueCircleContrastD2%;
var attCueCircleContrastD3%;
var attCueCircleContrastD4%;

var attStartBlock%;
var attNoChangeCondition%;
var attSwapCueCircle%;

var attCustomGratingColorCheck%;
var attCustomGratingColorStimFrom%[3];
var attCustomGratingColorStimTo%[3];
var attCustomGratingColorDistractorFrom%[3];
var attCustomGratingColorDistractorTo%[3];

'var attLollipopCheck%;
'var attCueLinePct;
'var attCircleDiameterDiff;
'var attLollipopContrast%;
'var attLollipopStickContrast%;
'var attCueLineGap;
var attPhaseCheck%;
var attPhaseDeg%;
var Contrast$;

' Counter vars for attention script
var attCountAllTrials% := 0;
var attCountAllTrialsCorrect% := 0;
var attCountAllTrialsIncorrect% := 0;
var attCountAllTrialsAbort% := 0;
var attCountTowardTrials% := 0;
var attCountTowardTrialsCorrect% := 0;
var attCountTowardTrialsIncorrect% := 0;
var attCountTowardTrialsAbort% := 0;
var attCountAwayTrials% := 0;
var attCountAwayTrialsCorrect% := 0;
var attCountAwayTrialsIncorrect% := 0;
var attCountAwayTrialsAbort% := 0;
var attNoChangeAwayTrials% := 0;
var attCountNoChangeTrials% := 0;
var attCountNoChangeTrialsCorrect% := 0;
var attCountNoChangeTrialsIncorrect% := 0;
var attCountNoChangeTrialsAbort% := 0;
var attOnlyOneCatch% := 0;
var attOneCatchContrast% := 0;
var attUseLowReward% := 0;
var attLowReward% := 0;


var lowRewardMS%;
var origRewardMS%;


' constants for dialog and check function - start with 10 because there are 9 dialog entries prior
' sure, it would be great if all the dialog numbers were done like this, but they ain't, and time is time
const attdlgAnsWindowRadius% := 12;
const attdlgTrainingContrastCheck% := 13;
const attdlgTrainingContrastPct% := 14;
const attdlgPhaseCheck% := 15;
const attdlgPhaseDeg% := 16;
'const attdlgLollipopCheck% := 14;  'these constant values obviously don't fly anymore, so if we bring it back re-assign them
'const attdlgCueLinePct% := 15;
'const attdlgCircleDiameterDiff% := 16;
'const attdlgLollipopContrast% := 17;
'const attdlgLollipopStickContrast% := 18;
'const attdlgLollipopStickGap := 19;
'const attdlgUseAnsWindow% := 20;
const attdlgOnlyOneCatch% := 17;
const attdlgOneCatchContrast% := 18;
const attdlgDoUncatch% := 19;
const attdlgNumPatches% := 20;
const attdlgGetGP% := 21;
const attdlgUseCueCircles% := 22;
const attdlgCueCircleExtraRadius% := 23;
const attdlgDistracterOffForEasy% := 24;
const attdlgStartBlock% := 25;
const attdlgNoChangeCondition% := 26;
const attdlgSwapCueCircle% := 27;
const attdlgUseLowReward% := 28;
const attdlgLowReward% := 29;

' constants for timing dialog
const atttimingdlgFixationCueMinTime% := 2;
const atttimingdlgFixationCueMaxTime% := 3;
const atttimingdlgHazardMinTime% := 4;
const atttimingdlgHazardExpMeanTime% := 5;
const atttimingdlgHazardCutoffTime% := 6;

' constants for color dialog
var attdlgColorIndexGray% := 0;
var attdlgColorIndexBlack% := 1;
var attdlgColorIndexWhite% := 2;
var attdlgColorIndexCustom% := 3;
var attcolorsdlgBackgroundColor% := 1;
var attcolorsdlgBackgroundRed% := 2;
var attcolorsdlgBackgroundGreen% := 3;
var attcolorsdlgBackgroundBlue% := 4;
var attcolorsdlgCueContrastStim% := 5;
var attcolorsdlgCueContrastD1% := 6;
var attcolorsdlgCueContrastD2% := 7;
var attcolorsdlgCueContrastD3% := 8;
var attcolorsdlgCueContrastD4% := 9;
var attcolorsdlgCustomGratingColorCheck% := 10;
var attcolorsdlgCustomGratingColorStimFromRed% := 11;
var attcolorsdlgCustomGratingColorStimFromGreen% := 12;
var attcolorsdlgCustomGratingColorStimFromBlue% := 13;
var attcolorsdlgCustomGratingColorStimToRed% := 14;
var attcolorsdlgCustomGratingColorStimToGreen% := 15;
var attcolorsdlgCustomGratingColorStimToBlue% := 16;
var attcolorsdlgCustomGratingColorDistractorFromRed% := 17;
var attcolorsdlgCustomGratingColorDistractorFromGreen% := 18;
var attcolorsdlgCustomGratingColorDistractorFromBlue% := 19;
var attcolorsdlgCustomGratingColorDistractorToRed% := 20;
var attcolorsdlgCustomGratingColorDistractorToGreen% := 21;
var attcolorsdlgCustomGratingColorDistractorToBlue% := 22;

'variables for Henry's tuning curve version
const attMaxTrl% := 1000;
var attTrialOrder%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the test trials
var attCatchTrialOrder%[attMaxTrl%]; 'this variable will hold the index to attContrastList[] to get contrast of the catch trials
var attTrial[attMaxTrl%];       'this variable is really only here because GetRepeatedParameterProgression wants to fill it; we will ignore it
var attCurrTrialIndex%;         'We'll need to keep track of the current trial index
var attContrastList%[attMaxTrl%];  'A list of which contrast is being used on each trial, filled by CreateContrastList
var attChangeList%[attMaxTrl%];  'A list of which stimulus patch (1 = main, 2 = dist1, 3 = dist2, etc.) changes
var attValidList%[attMaxTrl%];     '1 if valid, 0 if catch trial, filled by CreateContrastList
var attAttendList%[attMaxTrl%];  'A list of which stimulus patch (1 = main, 2 = dist1, 3 = dist2, etc.) is being attended
var attHazardList[attMaxTrl%];     'holds hazard times, now pre-calculated
var attOffBitsList%[attMaxTrl%];  'A list of which stimulus patches are off for this trial, in a bit sum, 1 = main, 2 = dist1, 4 = dist2, etc.
var attRotationList%[attMaxTrl%]; 'A list of which rotation is being used for this trial
var attFixColor%[attMaxTrl%];     'A list of which color fixation point (as a number) is being used for this trial
var thisContrast%;                 'for sampletexty stuff
var fixColor$;                  'more sampletexty stuff
var FAIsResponse%;              'if 1, use "response abort", otherwise use regular abort
var expectedAnswer%;            'keeps track of expected answer, saves a bunch of redundant code
'var useSpikeTemplate%;          'not sure where to put it, allows us to load up the most recent spike template, not used
'For fixation/cue colors, use a master list so we don't get a bunch of values redefined, and have to change them all if a change is made
var masterColorList$[6];  'human readable, updated to hold 6 (1 on-RF, 4 distractor, 1 No-change)
var masterColorListVSG$[6];  'VSG readable

masterColorList$[0] := "red";
masterColorListVSG$[0] := "red";
masterColorList$[1] := "green";
masterColorListVSG$[1] := "green";
masterColorList$[2] := "cyan";
masterColorListVSG$[2] := "(0/255/255)"; 'parens are the proper syntax for inserting the the color list on the command line
masterColorList$[3] := "yellow";
masterColorListVSG$[3] := "(255/255/0)";
masterColorList$[4] := "magenta";
masterColorListVSG$[4] := "(255/0/255)";
masterColorList$[5] := "blue";
masterColorListVSG$[5] := "blue";


'we need to explicitly know the position of the gratings to place the answer windows on the gratings
var mainX;  'the main grating patch is expected to be the one located over the receptive field
var mainY;
var mainW;
var mainH;
var dist1X;  'there are also four possible distracters, these are set in config
var dist1Y;
var dist1W;
var dist1H;
var dist2X; 
var dist2Y;
var dist2W;
var dist2H;
var dist3X; 
var dist3Y;
var dist3W;
var dist3H;
var dist4X; 
var dist4Y;
var dist4W;
var dist4H;

var autoNameTemplate$;

proc GetAttentionScriptParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
	Profile(key$, "NumberOfBlocks", 1, attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", 1, attTrialsPerBlock%);
    Profile(key$, "EasyTrialsPerBlock", 1, attEasyTrialsPerBlock%);
    Profile(key$, "DistracterOffForEasy", 1, distracterOffForEasy%);
    Profile(key$, "DoUncatch", 1, attDoUncatch%);
    Profile(key$, "NumPatches", 1, attNumPatches%);
    Profile(key$, "GetGPFromMainStim", 1, attGetGPFromMainStim%);
    Profile(key$, "UseCueCircles", 1, attUseCueCircles%);
    Profile(key$, "CueCircleExtraRadius", "0.0", stmp$);
    attCueCircleExtraRadius := val(stmp$);
	Profile(key$, "CatchTrialPercentage", "0.0", stmp$);
	attCatchTrialPercentage := val(stmp$);
    Profile(key$, "NoGoTrialPercentage", "0.0", stmp$);
	attNoGoTrialPercentage := val(stmp$);
	Profile(key$, "BlockAlternate", 1, attBlockAlternate%);
    Profile(key$, "NoBlockRand", 1, attSelectRandomContrastEachTrial%);
	Profile(key$, "TrainingContrastCheck", 0, attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", 0, attTrainingContrastPct%);
    Profile(key$, "OnlyOneCatch", 0, attOnlyOneCatch%);
    Profile(key$, "OneCatchContrast", 0, attOneCatchContrast%);

    
    Profile(key$, "ContrastBase", 50, attContrastBase%);
	'Profile(key$, "ContrastMax", 80, attMaxContChange);  ;now reals, have to do pull a string and convert
	'Profile(key$, "ContrastMin", 20, attMinContChange);
    Profile(key$, "NContrastLevels", 20, attNContLevels%);
    
    
    Profile(key$, "ContrastMax", "1", stmp$);
	attMaxContChange := val(stmp$);
    
    Profile(key$, "ContrastMin", "1", stmp$);
	attMinContChange := val(stmp$);
    
	Profile(key$, "AnswerPointDiameter", "0.5", stmp$);
	attAnswerPointDiameter := val(stmp$);
    
	Profile(key$, "AnswerPointOffset", "5.0", stmp$);
	attAnswerPointOffset := val(stmp$);
    
	Profile(key$, "AnswerPointWindowRadius", "2.0", stmp$);
	attAnswerPointWindowRadius := val(stmp$);
   
    Profile(key$, "NoChangeCondition", 0, attNoChangeCondition%);
    Profile(key$, "SwapCueCircle", 0, attSwapCueCircle%);
    
    Profile(key$, "UseLowReward", 0, attUseLowReward%);
    Profile(key$, "LowReward", 0, attLowReward%);


    
	'Profile(key$, "LollipopCheck", 0, attLollipopCheck%);
	'Profile(key$, "CueLinePct", "100.0", stmp$);
    'attCueLinePct := val(stmp$);
    'Profile(key$, "CircleDiameterDiff", "0.1", stmp$);
    'attCircleDiameterDiff := val(stmp$);
    'Profile(key$, "LollipopContrast", 100, attLollipopContrast%);
    'Profile(key$, "LollipopStickContrast", 100, attLollipopStickContrast%);
	'Profile(key$, "CueLineGap", "0.5", stmp$);
    'attCueLineGap := val(stmp$);
    
    Profile(key$, "DoPhase", 1, attPhaseCheck%);
    Profile(key$, "PhaseDeg", 1, attPhaseDeg%);
    
end;

proc SaveAttentionScriptParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
    
	Profile(key$, "NumberOfBlocks", attNumberOfBlocks%);
	Profile(key$, "TrialsPerBlock", attTrialsPerBlock%);
    Profile(key$, "EasyTrialsPerBlock", attEasyTrialsPerBlock%);
    Profile(key$, "DistracterOffForEasy", distracterOffForEasy%);
    Profile(key$, "DoUncatch", attDoUncatch%);
    Profile(key$, "NumPatches", attNumPatches%);
    Profile(key$, "GetGPFromMainStim", attGetGPFromMainStim%);
    Profile(key$, "UseCueCircles", attUseCueCircles%);
    Profile(key$, "CueCircleExtraRadius", str$(attCueCircleExtraRadius));
	Profile(key$, "CatchTrialPercentage", str$(attCatchTrialPercentage));
    Profile(key$, "NoGoTrialPercentage", str$(attNoGoTrialPercentage));
	Profile(key$, "BlockAlternate", attBlockAlternate%);
    Profile(key$, "NoBlockRand", attSelectRandomContrastEachTrial%);
	Profile(key$, "TrainingContrastCheck", attTrainingContrastCheck%);
	Profile(key$, "TrainingContrastPct", attTrainingContrastPct%);
    Profile(key$, "OnlyOneCatch", attOnlyOneCatch%);
    Profile(key$, "OneCatchContrast", attOneCatchContrast%);
	Profile(key$, "ContrastBase", attContrastBase%);
	Profile(key$, "ContrastMax", str$(attMaxContChange));
	Profile(key$, "ContrastMin", str$(attMinContChange));
    Profile(key$, "NContrastLevels", attNContLevels%);
	Profile(key$, "AnswerPointDiameter", str$(attAnswerPointDiameter));
	Profile(key$, "AnswerPointOffset", str$(attAnswerPointOffset));
	Profile(key$, "AnswerPointWindowRadius", str$(attAnswerPointWindowRadius));
    Profile(key$, "NoChangeCondition", attNoChangeCondition%);
    Profile(key$, "SwapCueCircle", attSwapCueCircle%);  
    Profile(key$, "UseLowReward", attUseLowReward%);
    Profile(key$, "LowReward", attLowReward%);    

    
	'Profile(key$, "LollipopCheck", attLollipopCheck%);
	'Profile(key$, "CueLinePct", str$(attCueLinePct));
    'Profile(key$, "CircleDiameterDiff", str$(attCircleDiameterDiff));
    'Profile(key$, "LollipopContrast", attLollipopContrast%);
    'Profile(key$, "LollipopContrast", attLollipopContrast%);
    'Profile(key$, "LollipopStickContrast", attLollipopStickContrast%);
	'Profile(key$, "CueLineGap", str$(attCueLineGap));
    
    Profile(key$, "DoPhase", attPhaseCheck%);
    Profile(key$, "PhaseDeg", attPhaseDeg%);

    
end;



proc GetTimingDialogParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
    
	Profile(key$, "FixationCueMinTime", "1.0", stmp$);
	attFixationCueMinTime := val(stmp$);
    
	Profile(key$, "FixationCueMaxTime", "1.0", stmp$);
	attFixationCueMaxTime := val(stmp$);
    
    '	Profile(key$, "WhitePointTime", "1.0", stmp$);
    '	attWhitePointTime := val(stmp$);
    
	Profile(key$, "HazardMinTime", "0.5", stmp$);
	attHazardMinTime := val(stmp$);
    
	Profile(key$, "HazardExpMeanTime", "1.0", stmp$);
	attHazardExpMeanTime := val(stmp$);
    
   	Profile(key$, "HazardCutoffTime", "5.0", stmp$);
	attHazardCutoffTime := val(stmp$);
    
	Profile(key$, "AcquisitionTime", "1.0", stmp$);
	attAcquisitionTime := val(stmp$);
    
	Profile(key$, "InterTrialTime", "1.0", stmp$);
	attInterTrialTime := val(stmp$);
    
	Profile(key$, "TimeToAnswer", "1.0", stmp$);
	attTimeToAnswer := val(stmp$);
    
    Profile(key$, "NoChangeDuration", "1.0", stmp$);
	attNoChangeDuration := val(stmp$);
    
	Profile(key$, "AbortWaitTime", "1.0", stmp$);
	attAbortWaitTime := val(stmp$);
    
    Profile(key$, "MissPenalty", "1.0", stmp$);
	attMissPenalty := val(stmp$);
    
    Profile(key$, "FalseAlarmWaitTime", "1.0", stmp$);
	attFalseAlarmWaitTime := val(stmp$);
    
    Profile(key$, "FalseAlarmCheckWindow", "1.0", stmp$);
	attFalseAlarmCheckWindow := val(stmp$);
    
end;

proc SaveTimingDialogParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    
	Profile(key$, "FixationCueMinTime", str$(attFixationCueMinTime));
	Profile(key$, "FixationCueMaxTime", str$(attFixationCueMaxTime));
    '	Profile(key$, "WhitePointTime", str$(attWhitePointTime));
	Profile(key$, "HazardMinTime", str$(attHazardMinTime));
	Profile(key$, "HazardExpMeanTime", str$(attHazardExpMeanTime));
    Profile(key$, "HazardCutoffTime", str$(attHazardCutoffTime));
	Profile(key$, "AcquisitionTime", str$(attAcquisitionTime));
	Profile(key$, "AbortWaitTime", str$(attAbortWaitTime));
    Profile(key$, "MissPenalty", str$(attMissPenalty));
    Profile(key$, "FalseAlarmWaitTime", str$(attFalseAlarmWaitTime));
    Profile(key$, "FalseAlarmCheckWindow", str$(attFalseAlarmCheckWindow));
	Profile(key$, "InterTrialTime", str$(attInterTrialTime));
	Profile(key$, "TimeToAnswer", str$(attTimeToAnswer));
    Profile(key$, "NoChangeDuration", str$(attNoChangeDuration));
    
end;



proc GetColorsDialogParameters()
	var stmp$;
	var key$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    

	Profile(key$, "BackgroundColor", "gray", attBackgroundColor$);
    
    
    if InStr(attBackgroundColor$, "(") = 1 then
        if ParseColor%(attBackgroundColor$, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%) <> 0 then
            attBackgroundColor$ := "gray";
        endif
    endif
    

    Profile(key$, "CueCircleContrastStim", 0, attCueCircleContrastStim%);
    Profile(key$, "CueCircleContrastD1", 0, attCueCircleContrastD1%);
    Profile(key$, "CueCircleContrastD2", 0, attCueCircleContrastD2%);
    Profile(key$, "CueCircleContrastD3", 0, attCueCircleContrastD3%);
    Profile(key$, "CueCircleContrastD4", 0, attCueCircleContrastD4%);
    Profile(key$, "CustomGratingColorsCheck", 0, attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", 0, attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", 0, attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", 0, attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", 255, attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", 255, attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", 255, attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", 0, attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", 0, attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", 0, attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", 255, attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", 255, attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", 255, attCustomGratingColorDistractorTo%[2]);
    
end;

proc SaveColorsDialogParameters()
	var key$;
	var stmp$;
	key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
    

	Profile(key$, "BackgroundColor", attBackgroundColor$);
    Profile(key$, "CueCircleContrastStim", attCueCircleContrastStim%);
    Profile(key$, "CueCircleContrastD1", attCueCircleContrastD1%);
    Profile(key$, "CueCircleContrastD2", attCueCircleContrastD2%);
    Profile(key$, "CueCircleContrastD3", attCueCircleContrastD3%);
    Profile(key$, "CueCircleContrastD4", attCueCircleContrastD4%);  
    Profile(key$, "CustomGratingColorsCheck", attCustomGratingColorCheck%);
    Profile(key$, "CustomGratingColorsStimFromRed", attCustomGratingColorStimFrom%[0]);
    Profile(key$, "CustomGratingColorsStimFromGreen", attCustomGratingColorStimFrom%[1]);
    Profile(key$, "CustomGratingColorsStimFromBlue", attCustomGratingColorStimFrom%[2]);
    Profile(key$, "CustomGratingColorsStimToRed", attCustomGratingColorStimTo%[0]);
    Profile(key$, "CustomGratingColorsStimToGreen", attCustomGratingColorStimTo%[1]);
    Profile(key$, "CustomGratingColorsStimToBlue", attCustomGratingColorStimTo%[2]);
    Profile(key$, "CustomGratingColorsDistractorFromRed", attCustomGratingColorDistractorFrom%[0]);
    Profile(key$, "CustomGratingColorsDistractorFromGreen", attCustomGratingColorDistractorFrom%[1]);
    Profile(key$, "CustomGratingColorsDistractorFromBlue", attCustomGratingColorDistractorFrom%[2]);
    Profile(key$, "CustomGratingColorsDistractorToRed", attCustomGratingColorDistractorTo%[0]);
    Profile(key$, "CustomGratingColorsDistractorToGreen", attCustomGratingColorDistractorTo%[1]);
    Profile(key$, "CustomGratingColorsDistractorToBlue", attCustomGratingColorDistractorTo%[2]);

    
end;





func AttentionScriptDialog%()
	var i%;
    var tempNBlocks%;
    var tempTotal;  'friggin integer math
    var tempWhoops;
    var fiveints%[5];
    var sixmoreints%[6];
    var blockAlternateList$[3];
    var blockStartList$[7];
    
    blockAlternateList$[0] := "Randomize cue type by trial";
    blockAlternateList$[1] := "Randomize cue type by block";
    blockAlternateList$[2] := "Alternate cue type by block";
    
    blockStartList$[0] := "Start Block: Random";
    blockStartList$[1] := "Start Block: Attend-Toward";
    blockStartList$[2] := "Start Block: Distracter 1";
    blockStartList$[3] := "Start Block: Distracter 2";
    blockStartList$[4] := "Start Block: Distracter 3";
    blockStartList$[5] := "Start Block: Distracter 4";
    blockStartList$[6] := "Start Block: No Change";
    
	GetAttentionScriptParameters();
    GetColorsDialogParameters();  'we need to GET the parameters here, even though we may not use any of them...but we WILL use backgroundColor$, that's why
    GetTimingDialogParameters();  'this too...
    
    fiveints%[0] := attOnlyOneCatch%;
    fiveints%[1] := attOneCatchContrast%;
    fiveints%[2] := attDoUncatch%;
    fiveints%[3] := attNumPatches%;
    fiveints%[4] := attGetGPFromMainStim%;
    
    sixmoreints%[0] := distracterOffForEasy%;
    sixmoreints%[1] := attStartBlock%;
    sixmoreints%[2] := attNoChangeCondition%;
    sixmoreints%[3] := attSwapCueCircle%; 
    sixmoreints%[4] := attUseLowReward%;
    sixmoreints%[5] := attLowReward%;
    

    
	DlgCreate("Attention Training Parameters", 25, 10);
    DlgGroup("Blocks", 1, 1, 34, 11);
	DlgInteger(1, "Number of Blocks:", 1, 1000, 22, 2);
	DlgInteger(2, "Reg. Trials per block:", 1, 1000, 22, 3);
    DlgInteger(3, "Easy Trials per block:", 0, 1000, 22, 4);
    DlgCheck(attdlgDistracterOffForEasy%, "Distracter Off for Easy Trials", 2, 5);
	DlgReal(4, "Catch Trial pct (0-100)", 0, 100, 22, 6);
    DlgCheck(attdlgDoUncatch%, "Use 'Uncatch' trials at same %age", 2, 7);
    DlgReal(5, "No-Go Trial pct (0-100)", 0, 100, 22, 8);
	'DlgCheck(6, "Alternate cue type by block", 2, 9);
    DlgList(6, 30, blockAlternateList$[], 3, 4, 9);
    DlgCheck(7, "Select random contrast each trial", 2, 10);  '"Do NOT randomize by block"
    DlgList(attdlgStartBlock%, 30, blockStartList$, 7, 4, 11);  'I put it in, don't want to take it out just because it does nothing, in principle it can be repurposed easier than it can be removed (the whole fourmoreints thing)
    
    'Moving this group to the right, so we have to use DlgText because otherwise CED justifies the text all the way left
    DlgGroup("Contrast",36,1,34,11);
    DlgInteger(8, "", 0, 100, 56, 2);  DlgText("Base contrast (%)",37,2);
	DlgReal(9, "", 0, 10, 56, 3);  DlgText("Max dContrast (oct)",37,3);
	DlgReal(10, "", 0, 10, 56, 4);  DlgText("Min dContrast (oct)",37,4);
    DlgInteger(11, "", 1, 10, 56, 5);  DlgText("N contrast levels",37,5);
    DlgReal(attdlgAnsWindowRadius%, "", 0, 10, 56, 6);  DlgText("Ans. window rad. (deg)",37,6);
	DlgCheck(attdlgTrainingContrastCheck%, "Training Contrast", 37, 7);
	DlgInteger(attdlgTrainingContrastPct%, "", 0, 100, 56, 8);  DlgText("Training Contrast(%)",37,8);
    DlgCheck(attdlgOnlyOneCatch%, "Use only one catch value", 37,9);
    DlgInteger(attdlgOneCatchContrast%,"",0,100,56,10);  DlgText("Single Catch Cont (%)",37,10);
    DlgCheck(attdlgNoChangeCondition%, "Include no-change condition", 37, 11);  
    
    DlgGroup("Phase", 1, 12, 34, 3);
    DlgCheck(attdlgPhaseCheck%, "Set phase at contrast change", 2, 13);
	DlgInteger(attdlgPhaseDeg%, 7, 0, 360, 27, 14);  DlgText("Phase at cc (deg, 0 = white)",2,14);
    
    DlgGroup("Number of Stimuli", 36, 12, 34, 3);
    DlgInteger(attdlgNumPatches%, 10, 1, 5, 58, 13); DlgText("Num of grating patches",37,13);
    DlgCheck(attdlgGetGP%, "Get distracter params from main stim", 37, 14);
    
    DlgGroup("Cue Circles", 1, 15, 34, 4);
    DlgCheck(attdlgUseCueCircles%, "Use Cue Circles", 2, 16);
    DlgCheck(attdlgSwapCueCircle%, "Swap Cue Circles (if used)", 2, 17);
	DlgReal(attdlgCueCircleExtraRadius%, "Cue extra radius (deg)", 0, 5, 22, 18);
    
    DlgGroup("Reward", 36, 15, 34, 3);
    DlgCheck(attdlgUseLowReward%, "Use Low Reward For No-Change Trls", 37, 16);
    DlgInteger(attdlgLowReward%, 10, 1, 1000, 58, 17); DlgText("Low Reward (ms)",37,17);
    
    DlgButton(2, "Colors", ColorsDialog%, 2+36, 19);
    DlgButton(3, "Timing", TimingDialog%, 20+36, 19);
    'DlgGroup("Lollipops", 1, 18, 34, 7);
    'DlgCheck(attdlgLollipopCheck%, "Use lollipop cues", 2, 19);
    'DlgReal(attdlgCueLinePct%, "Cue line %", 0, 100, 22, 20);
    'DlgReal(attdlgCircleDiameterDiff%, "Circle diameter diff", 0, 10, 22, 21);
    'DlgInteger(attdlgLollipopContrast%, "Lollipop contrast", 0, 100, 22, 22);
    'DlgInteger(attdlgLollipopStickContrast%, "Stick contrast", 0, 100, 22, 23);
    'DlgReal(attdlgLollipopStickGap, "Lollipop stick gap", 0, 10, 22, 24);
    DlgAllow(0, 0, AttentionScriptDialogChanged%);
	i%:=DlgShow(attNumberOfBlocks%, attTrialsPerBlock%, attEasyTrialsPerBlock%, attCatchTrialPercentage, attNoGoTrialPercentage, 
    attBlockAlternate%, attSelectRandomContrastEachTrial%, attContrastBase%, attMaxContChange, attMinContChange, attNContLevels%,
    attAnswerPointWindowRadius, attTrainingContrastCheck%, attTrainingContrastPct%, attPhaseCheck%, attPhaseDeg%, fiveints%[], 
    attUseCueCircles%,attCueCircleExtraRadius,sixmoreints%);
    
    'attLollipopCheck%, attCueLinePct, attCircleDiameterDiff, 
    'attLollipopContrast%, attLollipopStickContrast%, attCueLineGap);
    
	if i% = 1 then
        '	attBackgroundColor$ := bcl$[ibcl%];
        
        'put fiveints values back into variables
        attOnlyOneCatch% := fiveints%[0];
        attOneCatchContrast% := fiveints%[1];
        attDoUncatch% := fiveints%[2];
        attNumPatches% := fiveints%[3];
        attGetGPFromMainStim% := fiveints%[4];
        
        'put sixmoreints values back into variables
        distracterOffForEasy% := sixmoreints%[0];
        attStartBlock% := sixmoreints%[1];
        attNoChangeCondition% := sixmoreints%[2];
        attSwapCueCircle% := sixmoreints%[3];         
        attUseLowReward% := sixmoreints%[4];
        attLowReward% := sixmoreints%[5];
        
        'Check values of attStartBlock% for legality
        docase
        case attStartBlock% = 6 then
            if attNoChangeCondition% = 0 then
                message("Error: No Change was selected as the start block, but 'No Change' is OFF!!!");
                Quit%();
            endif
        case attStartBlock% > 1 and attNumPatches% < attStartBlock% then
            message("Error: The requested start block is for an undefined distracter!!!  Check 'number of patches'!");
            Quit%();
        endcase
        
        'randBlockOrderVar is a variable which allows us to alternate between attend-toward and random attend-away blocks
        'and indicates which comes first.  But if we set a start block, then we know which comes first, so override it
        docase
        case attStartBlock% = 1 then
            randBlockOrderVar% := 1;
        case attStartBlock% > 1 then
            randBlockOrderVar% := 0;
        endcase
        
        
        'set low reward if we are using it
        if attUseLowReward% = 1 then
            lowRewardMS% := attLowReward%;
        else
            lowRewardMS% := origRewardMS%;
        endif;
        
        
        'put twoints values back into variables
        'attUseCueCircles% := twoints%[0];
        'attCueCircleExtraRadius% := twoints%[1];
        
        'If we are doing the Uncatch trials, set UncatchTrialPercentage to 2x CatchTrialPercentage
        'The logic here is:  case rand < catch, then catch; case rand < uncatch, then uncatch
        'When uncatch = catch, there will be no uncatch; when uncatch = 2x catch, there will be the
        'same number of each.
        if attDoUncatch% = 1 and attOnlyOneCatch% = 1 then
            attUncatchTrialPercentage := 2*attCatchTrialPercentage;
        else
            attUncatchTrialPercentage := attCatchTrialPercentage;
        endif;
        'sanity check
        if attUncatchTrialPercentage > 100 then
            message("Error: Catch Trials + Uncatch Trials > 100%!!!");
            Quit%();
        endif;
        
        if attMinContChange > attMaxContChange then
            message("The maximum contrast change must be MORE than the minimum!  Swapping!");
            tempWhoops := attMinContChange;
            attMinContChange := attMaxContChange;
            attMaxContChange := tempWhoops;
        endif;
        
		SaveAttentionScriptParameters();
        
        'After saving parameters, set phase to -1 if we are not controlling it
        if attPhaseCheck% = 0 then
            attPhaseDeg% := -1;
        endif;
        
        'if we aren't alternating cues by block, then "easy" trials don't make any sense
        'I'm doing this after the parameter save so that the actual Easy Trials value sticks around as default in this event
        if attBlockAlternate% = 0 then
            attEasyTrialsPerBlock% := 0;
        endif;
        
        'get contrast list
        if attNContLevels% > 1 then
            GetLogProgression(attContrastBase%*(pow(2,attMinContChange)),attContrastBase%*(pow(2,attMaxContChange)),attNContLevels%-1,attContrastList[0:attNContLevels%]);  'levels above base
            Arrconst(attContrastList[attNContLevels%:attNContLevels%],attContrastBase%);  'for no-go, assign the second half of stimuli as identical to the base contrast
            round(attContrastList[]);  'we can only use integer values in the VSG call
        else
            'if only one value is requested, this will crash GetLogProgression, so just do it manually
            attContrastList[0] := attContrastBase%*(pow(2,attMaxContChange));
            attContrastList[1] := attContrastBase%;  'for go/no-go, use the base, not a down contrast
            
            'Henry does not want this warning
            'message("Note that only one contrast level was requested, using MAX as actual value!");
        endif;
        
        'get number of trials to run, which is hypothetical "max" number for both test trials and catch trials regardless of catch/test percentage
        tempTotal := attNumberOfBlocks%*attTrialsPerBlock%;  'total number of non-"easy" trials
        tempNBlocks% := ceil(tempTotal/(attNContLevels%));  'MAXIMUM number of times we have to repeat the tuning curve to reach the total number of trials, if 0 no-go trials
        
        printlog("number of contrast levels is %d and tempnblocks is %d\n",attNContLevels%,tempNBlocks%);
        
        'It's a bit tricky to try to push the idea of variable No-Go percentage (as opposed to 50%) into the GetRepeatedParameterProgression
        'schematic, but I think I've got a plan.
        'First step - create a list of contrasts as normal in a temporary variable, but only include "go" contrasts 
        if attSelectRandomContrastEachTrial% = 0 then
            'get trial order, attTrialOrder%[] will hold indices into attContrastList[] for all trials
            GetRepeatedParameterProgression%(attNContLevels%,tempNBlocks%,attTrial[],attTrialOrder%[],0,(attNContLevels%)-1,0,1);  'this has only Go contrasts
        else 'Henry sez just do true random, selects a random contrast level for every trial for the entire experiment
            Rand(attTrialOrder%[0:attNContLevels%*tempNBlocks%],attNContLevels%);  'this has only the Go contrast
        endif;   

        'The below line will assign only GO trials as catch trials
        GetRepeatedParameterProgression%(attNContLevels%,tempNBlocks%,attTrial[],attCatchTrialOrder%[],0,attNContLevels%-1,0,1);
        
        
        ''Commented out - useful for testing the creation of the trial order
        'var Contrast$;
        'CreateContrastList(Contrast$,attContrastList%,attChangeList%,attValidList%,attAttendList%,attHazardList,attOffBitsList%);
        'var specFileName$:="E:\\AttentionSpecFile.txt";
        'var specHandle%;
        'specHandle% := FileOpen(specFileName$, 8, 1);
        ''print to spec file
        'Print("%s",Contrast$);  'file should be everything starting from FixationArg$ on
        ''close spec file
        'FileClose(0);
        'printlog("Temp trial order list is %d\n",attTrialOrderTemp%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("Contrast list is %d\n",attContrastList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("Valid list is %d\n",attValidList%[0:attNumberOfBlocks%*(attTrialsPerBlock%+attEasyTrialsPerBlock%)]);
        'printlog("contrasts are %d\n",attContrastList[]);
        'halt();
	endif;
	return i%;
end;


func ParseColor%(s$, &r%, &g%, &b%)
    var status% := -1;
    var n;
    ReadSetup("", "/(", "(", ")");
    n := ReadStr(s$, r%, g%, b%);
    ReadSetup();
    if n = 3 then
        status% := 0;
    endif
    return status%;
end

func EncodeColor$(r%, g%, b%)
    var s$;
    s$ := Print$("(%d/%d/%d)", r%, g%, b%);
    return s$;
end


' Called when items in attention script dialog change. WARNING: The item #s are coded as constants
' If format of dialog changes then those constants should be changed. 

func AttentionScriptDialogChanged%(item%)
    var status% := 1;
    
    docase
    case item% = attdlgTrainingContrastCheck% then
        DlgEnable(DlgValue(attdlgTrainingContrastCheck%), attdlgTrainingContrastPct%);
    case item% = attdlgOnlyOneCatch% then
        DlgEnable(DlgValue(attdlgOnlyOneCatch%), attdlgOneCatchContrast%);
        DlgEnable(DlgValue(attdlgOnlyOneCatch%), attdlgDoUncatch%);
    case item% = attdlgPhaseCheck% then
        DlgEnable(DlgValue(attdlgPhaseCheck%), attdlgPhaseDeg%);
'    case item% = attdlgLollipopCheck% then
'        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgCircleDiameterDiff%);
'        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgCueLinePct%);
        '        DlgEnable(DlgValue(attdlgLollipopCheck%), attdlgLollipopContrast%);
    case item% = attdlgUseCueCircles% then
        DlgEnable(DlgValue(attdlgUseCueCircles%), attdlgCueCircleExtraRadius%);
    case item% = attdlgUseLowReward% then
        DlgEnable(DlgValue(attdlgUseLowReward%), attdlgLowReward%);
    case item% = 0 then
        DlgEnable(attTrainingContrastCheck%, attdlgTrainingContrastPct%);
        DlgEnable(attPhaseCheck%, attPhaseDeg%);
        DlgEnable(attOnlyOneCatch%, attdlgOneCatchContrast%);
        DlgEnable(attOnlyOneCatch%, attdlgDoUncatch%);
        DlgEnable(attdlgUseCueCircles%, attdlgCueCircleExtraRadius%);
        DlgEnable(DlgValue(attdlgUseLowReward%), attdlgLowReward%);
        DlgEnable(0,attdlgAnsWindowRadius%);  'Turn off answer window radius, it is currently unused
'        DlgEnable(attLollipopCheck%, attdlgCircleDiameterDiff%);
'        DlgEnable(attLollipopCheck%, attdlgCueLinePct%);
'        DlgEnable(attLollipopCheck%, attdlgLollipopContrast%);
    endcase
    return status%;
end


func TimingDialog%()
    var i%;
    
    GetTimingDialogParameters();
    
	DlgCreate("Attention timing", 25, 10);
	DlgReal(1, "Acquisition time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMinTime%, "Fixation cue min time(s):", .01, 10);
	DlgReal(atttimingdlgFixationCueMaxTime%, "Fixation cue max time(s):", .01, 10);  'We will presumably lose the ability to have a variable stimulus onset time when the animation is implemented
	DlgReal(atttimingdlgHazardMinTime%, "Hazard min time(s):", 0, 10);
	DlgReal(atttimingdlgHazardExpMeanTime%, "Hazard exp mean time(s):", 0, 10);
	DlgReal(atttimingdlgHazardCutoffTime%, "Hazard cutoff time(s):", 0, 10);
	DlgReal(7, "Time to answer(s):", 0.01, 10.0);
    DlgReal(8, "No-Change duration(s):", 0.2, 10.0);
	DlgReal(9, "Intertrial time(s):", .01, 10);
	DlgReal(10, "Abort wait time(s):", .01, 10);
    DlgReal(11, "False Alarm penalty time(s):", .01, 100);  'I'll let that be really really long
    DlgReal(12, "False Alarm check window(s): ", .01, 1);
    DlgReal(13, "Miss penalty time(s): ", 0, 100);
    
    DlgAllow(0, 0, TimingDialogChanged%);
	i%:=DlgShow(attAcquisitionTime, attFixationCueMinTime, attFixationCueMaxTime, 
    attHazardMinTime, attHazardExpMeanTime, attHazardCutoffTime, attTimeToAnswer, attNoChangeDuration,
    attInterTrialTime, attAbortWaitTime,attFalseAlarmWaitTime,attFalseAlarmCheckWindow,attMissPenalty);
    if i% = 1 then
        if attAbortWaitTime < attFalseAlarmCheckWindow then
            message("False Alarm Check Window is longer than Abort Wait Time!");
            message("Reducing window to be equal to Abort Wait Time!");
            attFalseAlarmCheckWindow := attAbortWaitTime;
        endif;
        
        SaveTimingDialogParameters();
        
    endif;
    return 1;
end


func TimingDialogChanged%(item%)
    var status% := 1;
    docase
    case item% = atttimingdlgFixationCueMinTime% or item% = atttimingdlgFixationCueMaxTime% then
        ' max >= min
        if DlgValue(atttimingdlgFixationCueMinTime%) > DlgValue(atttimingdlgFixationCueMaxTime%) then
            status% := 0;
            Message("Fixation cue min time cannot be greater than max time!");
        endif
    case item% = atttimingdlgHazardMinTime% or item% = atttimingdlgHazardExpMeanTime% or item% = atttimingdlgHazardCutoffTime% then
        ' max >= min
        if DlgValue(atttimingdlgHazardMinTime%) > DlgValue(atttimingdlgHazardExpMeanTime%)  or DlgValue(atttimingdlgHazardExpMeanTime%) > DlgValue(atttimingdlgHazardCutoffTime%) then
            status% := 0;
            Message("Hazard min time <= Hazard mean time <= Hazard cutoff time");
        endif
    endcase
    return status%;
end


func ColorsDialog%()
	var i%;
	var bcl$[4];
	var ibcl%:=0;
    var fiveints%[5];
    
    GetColorsDialogParameters();
    
    'put defaults into fiveints%[]
    fiveints%[0] := attCueCircleContrastStim%;
    fiveints%[1] := attCueCircleContrastD1%;
    fiveints%[2] := attCueCircleContrastD2%;  'D2-D4 are currently constrained to be identical by the dialog-changed function,
    fiveints%[3] := attCueCircleContrastD3%;  'but the old syntax still works so it's much easier to change back, if desired,
    fiveints%[4] := attCueCircleContrastD4%;  'just undo the changes (noted) in the dialog-changed function.
    
	GetAttentionScriptParameters();
	bcl$[0] := "gray";
	bcl$[1] := "black";
	bcl$[2] := "white";
    bcl$[3] := "custom";
    if InStr(attBackgroundColor$, "(") = 1 then
        ibcl% := attdlgColorIndexCustom%;
    else
        ibcl% := 2;
        for i%:=0 to 2 do
            if attBackgroundColor$ = bcl$[i%] then
                ibcl% := i%;
            endif
        next;
    endif
    
	DlgCreate("Attention colors", 25, 10);
    DlgAllow(0, 0, ColorsDialogChanged%);
	DlgList(1, "Background color:", bcl$);
    DlgInteger(2, "Background red (0-255)", 0, 255);
    DlgInteger(3, "Background green (0-255)", 0, 255);
    DlgInteger(4, "Background blue (0-255)", 0, 255);
    DlgInteger(attcolorsdlgCueContrastStim%, "Stim Cue Circle Contrast (0-128)", 0, 128);
    DlgInteger(attcolorsdlgCueContrastD1%, "D1 Cue Circle Contrast (0-128)", 0, 128);
    DlgInteger(attcolorsdlgCueContrastD2%, "D2 Cue Circle Contrast (0-128)", 0, 128);
    DlgInteger(attcolorsdlgCueContrastD3%, "D3 Cue Circle Contrast (0-128)", 0, 128);
    DlgInteger(attcolorsdlgCueContrastD4%, "D4 Cue Circle Contrast (0-128)", 0, 128);
    DlgCheck(attcolorsdlgCustomGratingColorCheck%, "Custom grating colors");
    DlgGroup("Stimulus", 1, 11, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromRed%, "From Red (0-255)", 0, 255, 20, 12);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromGreen%, "From Green (0-255)", 0, 255, 20, 13);
    DlgInteger(attcolorsdlgCustomGratingColorStimFromBlue%, "From Blue (0-255)", 0, 255, 20, 14);
    DlgInteger(attcolorsdlgCustomGratingColorStimToRed%, "To Red (0-255)", 0, 255, 20, 15);
    DlgInteger(attcolorsdlgCustomGratingColorStimToGreen%, "To Green (0-255)", 0, 255, 20, 16);
    DlgInteger(attcolorsdlgCustomGratingColorStimToBlue%, "To Blue (0-255)", 0, 255, 20, 17);
    DlgGroup("Distractor", 1, 18, 35, 7);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromRed%, "From Red (0-255)", 0, 255, 20, 19);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromGreen%, "From Green (0-255)", 0, 255, 20, 20);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorFromBlue%, "From Blue (0-255)", 0, 255, 20, 21);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToRed%, "To Red (0-255)", 0, 255, 20, 22);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToGreen%, "To Green (0-255)", 0, 255, 20, 23);
    DlgInteger(attcolorsdlgCustomGratingColorDistractorToBlue%, "To Blue (0-255)", 0, 255, 20, 24);
	i% := DlgShow(ibcl%, attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%, 
    fiveints%,attCustomGratingColorCheck%, 
    attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2], 
    attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2], 
    attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2], 
    attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);
    
    
    
    
	' If user cancelled, reload params
	if i% = 1 then
        if ibcl% = attdlgColorIndexCustom% then
            attBackgroundColor$ := EncodeColor$(attBackgroundRed%, attBackgroundGreen%, attBackgroundBlue%);
        else
            attBackgroundColor$ := bcl$[ibcl%];
        endif
        
        'unpack the cue circle contrasts
        attCueCircleContrastStim% := fiveints%[0];
        attCueCircleContrastD1% := fiveints%[1];  
        attCueCircleContrastD2% := fiveints%[2];  'don't need to change old version, the dialog-changed function fixes it
        attCueCircleContrastD3% := fiveints%[3];
        attCueCircleContrastD4% := fiveints%[4];         
        
        'if the background is not gray, set cue circles to full contrast, if you want to change contrast of cue circles
        'but use a different color background the you will have to adapt FadeColorToGray$()
        if ibcl% <> attdlgColorIndexGray% then
            attCueCircleContrastStim% := 128;
            attCueCircleContrastD1% := 128;
            attCueCircleContrastD2% := 128;
            attCueCircleContrastD3% := 128;
            attCueCircleContrastD4% := 128;
        endif
        
        
        SaveColorsDialogParameters();
        
	endif
    
	return 1;
end;

func ColorsDialogChanged%(item%)
    var status% := 1;    
    
    if item% = 0 or item% = attcolorsdlgBackgroundColor% then
        docase
        case DlgValue(attcolorsdlgBackgroundColor%) = 3 then
            DlgEnable(1, attcolorsdlgBackgroundRed%);
            DlgEnable(1, attcolorsdlgBackgroundGreen%);
            DlgEnable(1, attcolorsdlgBackgroundBlue%);
            DlgEnable(0, attcolorsdlgCueContrastStim%);  'For now, no changing cue circle contrast if background is not gray
            DlgEnable(0, attcolorsdlgCueContrastD1%);
            DlgEnable(0, attcolorsdlgCueContrastD2%);
            DlgEnable(0, attcolorsdlgCueContrastD3%);
            DlgEnable(0, attcolorsdlgCueContrastD4%);
        case DlgValue(attcolorsdlgBackgroundColor%) = 0 then  
            DlgEnable(0, attcolorsdlgBackgroundRed%);
            DlgEnable(0, attcolorsdlgBackgroundGreen%);
            DlgEnable(0, attcolorsdlgBackgroundBlue%);
            DlgEnable(1, attcolorsdlgCueContrastStim%);  'Allow changing cue circle contrast if background is gray
            DlgEnable(1, attcolorsdlgCueContrastD1%);
'            DlgEnable(1, attcolorsdlgCueContrastD2%);
'            DlgEnable(1, attcolorsdlgCueContrastD3%);
'            DlgEnable(1, attcolorsdlgCueContrastD4%);
        else
            DlgEnable(0, attcolorsdlgBackgroundRed%);
            DlgEnable(0, attcolorsdlgBackgroundGreen%);
            DlgEnable(0, attcolorsdlgBackgroundBlue%);
            DlgEnable(0, attcolorsdlgCueContrastStim%);  'For now, no changing cue circle contrast if background is not gray
            DlgEnable(0, attcolorsdlgCueContrastD1%);
            DlgEnable(0, attcolorsdlgCueContrastD2%);
            DlgEnable(0, attcolorsdlgCueContrastD3%);
            DlgEnable(0, attcolorsdlgCueContrastD4%);
        endcase
    endif
    
    if item% = 0 or item% = attcolorsdlgCustomGratingColorCheck% then
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorStimToBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorFromBlue%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToRed%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToGreen%);
        DlgEnable(DlgValue(attcolorsdlgCustomGratingColorCheck%), attcolorsdlgCustomGratingColorDistractorToBlue%);
    endif
    
    'If we decide to make the different invalid cue circles have different contrasts, get rid of this
    'if statement altogether and uncomment three commented lines above.  
    if item% = 0 or item% = attcolorsdlgCueContrastD1% then
        'Currently, just don't allow these to change
        DlgEnable(0, attcolorsdlgCueContrastD2%);
        DlgEnable(0, attcolorsdlgCueContrastD3%);
        DlgEnable(0, attcolorsdlgCueContrastD4%);
        DlgValue(attcolorsdlgCueContrastD2%,DlgValue(attcolorsdlgCueContrastD1%));  'update the other values to whatever the d1 value is
        DlgValue(attcolorsdlgCueContrastD3%,DlgValue(attcolorsdlgCueContrastD1%));
        DlgValue(attcolorsdlgCueContrastD4%,DlgValue(attcolorsdlgCueContrastD1%));
    endif
    
    return status%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' Attention script END
'
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''






' Overall script control vars
var Pause% := 0;

' Channel numbers and handles
var StimHandle%;			' handle for stimulus application
var DataWindow%;		' 
var XChannel%;
var YChannel%;

var FrameTriggerChannel%;
var SynchChannel%;
var FixationPointChannel%;
var StimChannel%;
var StimChangeChannel%;
var ReadyChannel%;

' tuning curves
var TuningWindow%[8];	' one for each channel. There'd better not be more than 8 channels! 
' XY window stuff
var XYWindow%;			' 
var iStimChannel%;	' channel number for stimulus in xy window
var iFixationWindowChannel%;' channel number for fixation window in xy window
var iMonitorChannel%;	' channel number for monitor position display in xy window
var iAnswerWindowChannelMain%;  'channel number for main stimulus answer window display in xy window
var iAnswerWindowChannelDist1%;  'channel number for distracter 1 answer window display in XY window
var iAnswerWindowChannelDist2%;  'channel number for distracter 2 answer window display in XY window
var iAnswerWindowChannelDist3%;  'channel number for distracter 3 answer window display in XY window
var iAnswerWindowChannelDist4%;  'channel number for distracter 4 answer window display in XY window

' Display stuff
var FixWindowX[36],FixWindowY[36];	' points for displaying fixation window in xy view
var windowX[36], windowY[36];

' dummy vars
var iScript%;

' Check for valid data file path
if Len(dataDataSet$) = 0 then
	Message("No data set is selected! Edit Data parameters...");
	' Might be nice to open the dialog here....
	halt;
endif

'we're going to muck with reward so that Henry can have a "high reward" and a "low reward"
'I hate to do it this way, but I think that the alternative of doing it in the config is even
'worse.  This way, we simply override the config value, but only for the low-reward state. 
'For the high-reward state we still use the config value.  It's not pretty, but it keeps
'everything from cascading into a comedy of errors in other scripts.
'get original reward value from config
origRewardMS% := GetJuiceRewardMS%();

' run dialog
iScript% := AttentionScriptDialog%();
if iScript% <> 1 then
	PrintLog("User cancel - exit gracefully\n");
	Halt;
endif;





' Assign channel numbers for eye X,Y and trigger. 
XChannel% := 23;
YChannel% := 24;
FrameTriggerChannel% := 25;
FixationPointChannel% := 26;
StimChannel% := 27;
StimChangeChannel% := 28;
ReadyChannel% := 29;
SynchChannel% := 32;

'If we are not using the Plexon (and thus linking the two 1401s together, just use the standard order of operations:
'1) create sampling configuration, 2) Initialize windows, 3) Initialize/run toolbar.
'However, if we are linking the 1401s we have to do this in a different order, because we have to open up the second
'instance of Spike 2 BEFORE setting up the sampling configuration/windows on the first instance.  Doing this in the
'wrong order results in a non-fatal error in the second Spike2 instance indicating that the file which is preparing
'to be recorded in the first instance cannot be accessed, despite no explicit attempt to access any such thing.
'Hence, for the Plexon setups, we first initialize the toolbar, which has a specialty button "Start Plexon".  StartPlexon%()
'launches the second instance and the associated script, and both scripts move forward independently to create their own
'sampling configuration, initialize their own windows and are ready to have sampling started.  Note well that sampling
'must be started on the POWER 1401 (the second, non-dominant instance of Spike2) FIRST and on the MICRO 1401 (the first, 
'dominant instance of Spike 2) SECOND.  Starting sampling on the Micro will run the VSG program (Fixstim) which gives
'the sampling trigger and sets the experiment in motion.
if UsePlexon% = 0 then
    CreateSampleConfiguration();

    ' Initialize extraction
    'AttentionExtractInit%(-1, "");

    ' Get display windows ready
    InitializeWindows();

    ' Prepare the toolbar buttons
    InitializeToolbar();
else
    InitializeToolbar();
endif;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' UpdateToolbarText - Print tallies of trials in toolbar
'

proc UpdateToolbarText()
    
	var s$;
	var allPct$ := "--";
	var towardPct$ := "--";
    var awayPct$ := "--";
    var noChangePct$ := "--";
    var num, den, pct;
    
    if (attCountAllTrials% > 0) then
        num := attCountAllTrialsCorrect%;
        den := attCountAllTrials%;
        pct := num/den*100;
		allPct$ := print$("%2.0f", pct);
	endif
	if (attCountTowardTrials% > 0) then
        num := attCountTowardTrialsCorrect%;
        den := attCountTowardTrials%;
        pct := num/den*100;
		towardPct$ := print$("%2.0f", pct);
	endif
	if (attCountAwayTrials% > 0) then
        num := attCountAwayTrialsCorrect%;
        den := attCountAwayTrials%;
        pct := num/den*100;
		awayPct$ := print$("%2.0f", pct);
	endif
    if (attCountNoChangeTrials% > 0) then
        num := attCountNoChangeTrialsCorrect%;
        den := attCountNoChangeTrials%;
        pct := num/den*100;
		noChangePct$ := print$("%2.0f", pct);
	endif
    

    'only print stats for conditions that have occurred
    s$ := "Tallies count/correct/incorrect/aborted (correct%%):";
    if attCountAllTrials% > 0 or attCountAllTrialsAbort% > 0 then  
        s$ := s$ + Print$(" ALL %d/%d/%d/%d (%s%%)",attCountAllTrials%, attCountAllTrialsCorrect%, attCountAllTrialsIncorrect%, attCountAllTrialsAbort%, allPct$);
    endif
    if attCountTowardTrials% > 0 or attCountTowardTrialsAbort% > 0 then
        s$ := s$ + Print$(" TOWARD %d/%d/%d/%d (%s%%)",attCountTowardTrials%, attCountTowardTrialsCorrect%, attCountTowardTrialsIncorrect%, attCountTowardTrialsAbort%, towardPct$);
    endif;
    if attCountAwayTrials% > 0 or attCountAwayTrialsAbort% > 0 then
        s$ := s$ + Print$(" AWAY %d/%d/%d/%d (%s%%)",attCountAwayTrials%, attCountAwayTrialsCorrect%, attCountAwayTrialsIncorrect%, attCountAwayTrialsAbort%, awayPct$);
    endif
    if attCountNoChangeTrials% > 0 or attCountNoChangeTrialsAbort% > 0 then
        s$ := s$ + Print$(" NOCHANGE %d/%d/%d/%d (%s%%)",attCountNoChangeTrials%, attCountNoChangeTrialsCorrect%, attCountNoChangeTrialsIncorrect%, attCountNoChangeTrialsAbort%, noChangePct$);
    endif

    
	ToolbarText(s$);
    
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' InitilizeToolbar - prepare toolbar buttons. Note that the idle processing function (ToolbarSet(0, blah, blah)) is 
' not set here. That's done when the user hits the start button.
'
proc InitializeToolbar()
    
    
	View(App(8)).WindowVisible(0);	'Hide the standard sample bar
	ToolbarVisible(1);
	UpdateToolbarText();
    if UsePlexon% = 1 then
        ToolbarSet(1,"StartPlexon",StartPlexon%);
    else
        ToolbarSet(1,"Sample start",Start%);
    endif;
	ToolbarSet(2,"Sample stop", Stop%);
	ToolbarSet(3,"Juice", Reward%);
	ToolbarSet(4,"Pause stimuli",PauseStimuli%);
	ToolbarSet(5,"Resume stimuli",ResumeStimuli%);
    '	ToolbarSet(6,"Exp Parameters",%);
	ToolbarSet(7,"Quit",Quit%);
	ToolbarEnable(2,0);
	ToolbarEnable(4,0);
	ToolbarEnable(5,0);
	Toolbar("Go",0x3ff);
    
end;




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Looking%(EyePosX,EyePosY)
	'Determine if the eye position is within the fixation window
	if (Pow(EyePosX-FixationX,2) + Pow(EyePosY-FixationY,2)) <= Pow(WindowRadius,2) then return 1; else return 0; endif
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Answer%(EyePosX, EyePosY)
    var ans% := 0;
    var ansptRadius;
    'ansptRadius := Pow(attAnswerPointWindowRadius,2);  'answer point radius is now the size of the grating
    
    'note that in the case statement, we will not consider grating patches that don't exist - see how smart we are!
    docase
    case (Pow(EyePosX-mainX,2) + Pow(EyePosY-(mainY),2)) <= mainW then 'Looking at main grating location, just assuming mainW = mainH!
        ans% := 1;
    case (Pow(EyePosX-dist1X,2) + Pow(EyePosY-(dist1Y),2)) <= dist1W and attNumPatches% > 1 then 'Looking at distracter 1 location, just assuming dist1W = dist1H!
        ans% := -1;
    case (Pow(EyePosX-dist2X,2) + Pow(EyePosY-(dist2Y),2)) <= dist2W and attNumPatches% > 2 then 'Looking at distracter 2 location, just assuming dist2W = dist2H!
        ans% := -2;
    case (Pow(EyePosX-dist3X,2) + Pow(EyePosY-(dist3Y),2)) <= dist3W and attNumPatches% > 3 then 'Looking at distracter 3 location, just assuming dist3W = dist3H!
        ans% := -3;
    case (Pow(EyePosX-dist4X,2) + Pow(EyePosY-(dist4Y),2)) <= dist4W and attNumPatches% > 4 then 'Looking at distracter 4 location, just assuming dist4W = dist4H!
        ans% := -4;
    endcase;
    
	return ans%;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Reward%()
    DefaultReward();
    'No sample text, just use 'R' from keyboard channel
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



var tNow:=0;		' latest time for which there are values recorded. Used in IdleProcessing
var tLast:=-1;		' last time we checked for a trigger. 
var xEye, yEye;		' eye positions
var tLastUpdate:=-1;	' last time view was updated
var vTrigger;		' set by NextTime to indicate trigger transition
var tStateStart:=-1;	' time that present state started. Used to measure wait time, fixation time, etc. 
var tLastTrigger:=-1;	' last trigger time. New triggers have to be greater than this
var tTrigger:=-1;	' temp var for newly discovered trigger times
var tStimOn:=-1;	' time that stim was turned on. Used to measure spike rates 

' Constants for states
const stateStartTrial%:=0;		        ' Start trial state
const stateWaitForFixPtOn%:=1;		    ' Waiting for fixation/cue point return trigger (on)
const stateHoldFixationToStimOn%:=2;		    ' Maintaining fixation with cue color point and lollipops up
const stateWaitForStimOn%:=3;		    ' Wait for stimulus return trigger (on)
const stateWaitForContrastChange%:=4;	' Wait for indication that contrast change has happened
const stateWaitForAcquisition%:=5;	    ' Waiting for subject to acquire fixation point
const stateHoldFixationToCC%:=6;		    ' Holding fixation point
const stateAbort%:=7;			        ' Failed trial state
const stateWaitForAnswer%:=8;			' waiting for answer
const stateAbortWait%:=9;	            ' time out after failed trial
const stateVSGWait%:=10;		        ' wait for vsg to send ready signal #1
const stateVSGWaitConfirm%:=11;		    ' waif for vsg to send ready signal #2
const stateTrialCompleted%:=12;		    ' trial has been completed successfully
const stateDone%:=13;	
const stateWaitForBlank%:=14;
const stateBlockCompleted%:=16;
const stateStartBlock%:=17;
const stateTrialCompletedWaitForBlank% := 18;
const stateTrialCompletedPause% := 19;
const stateWaitForWhitePointOn%:=20;    ' Waiting for fixation white point  This white point stuff is mostly or wholly excised
const stateWhitePointFixation%:=21;     ' white point up, remain fixation
const stateNoResponse% := 22;
const stateFalseAlarmWait% := 23;
const stateCheckFalseAlarm% := 24;
const stateMiss% := 25;
const stateCorrectRejection% := 26;
var iState% := stateVSGWait%;	' present state

const trialtypeAttendToward% := 100;
const trialtypeAttendAway% := 101;
const trialtypeNoChange% := 102;
var trialType%;
var nTrialsStarted%:=0;
var nTrialsCompleted%:=0;
var nTrialsAborted% :=0;		' 
var nBlocksCompleted%:=0;
var iAnswer%;
var isStimDistractorOff% := 0;
var trialCatch%;
var trialIsTarget%;
var trialAttendLoc%;
var trialHazardFunctionTime;

func IdleProcessing%()
    'var getPreciseTiming := 1;
	var iStatus% := 1;	
    var tempanswer%;
    var temptext$;
    
    'while getPreciseTiming = 1 do 
    
    'getPreciseTiming := 0;  'don't get precise timing unless we ask to (if 0, return control to windows after each idle loop iteration)
    
    tNow := View(DataWindow%).MaxTime();
    
    'get eye position, but don't check if tNow is small enough that we would give a negative value to ChanMeasure
    if tNow > .006 then
        xEye := View(DataWindow%).ChanMeasure(XChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltX;
        yEye := View(DataWindow%).ChanMeasure(YChannel%,2,tNow-.001,tNow-.006)*DegreesPerVoltY;
    endif;
        
    ' Don't update display every time....
    if tNow-tLastUpdate > .005 then
        View(XYWindow%).XYAddData(1,xEye,yEye);
        tLastUpdate := tNow;
    endif
    
    
    docase 
    case iState% = stateVSGWait% then
        
        ' Waiting for VSG to indicate it is ready. The indication is a pulse (up, then down, 1 frame apart) on port 6.
        tTrigger := View(DataWindow%).NextTime(ReadyChannel%, tLast, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 0 then
            PrintLog("state stateVSGWait: Got leading edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateVSGWaitConfirm%, tTrigger);
        endif;
        
    case iState% = stateVSGWaitConfirm% then
        
        ' Waiting for VSG to confirm it is ready. The downward side of the pulse is expected...
        tTrigger := View(DataWindow%).NextTime(ReadyChannel%, tLastTrigger, vTrigger);
        if tTrigger > tLastTrigger and vTrigger = 1 then
            PrintLog("state stateVSGWaitConfirm: Got trailing edge of trigger\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateStartBlock%, tTrigger);
        endif;
        
        
    case iState% = stateStartBlock% then
        
        PrepareBlock();
        ChangeStateTo(stateStartTrial%, tNow);
        
    case iState% = stateStartTrial% then
        
        ' Start trial. Put up fixation point.
        UpdateToolbarText();
        PrepareTrial();
        attCountAllTrials% += 1;
        'SafeSampleKey("W");
        docase
        case trialType% = trialtypeAttendToward% then
            attCountTowardTrials% += 1;
        case trialType% = trialtypeAttendAway% then
            attCountAwayTrials% += 1;
        case trialType% = trialtypeNoChange% then
            attCountNoChangeTrials% += 1;
        else
            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
        endcase
        PrintLog("Request Fixation Point\n");
        SafeSampleKey("F");
        ChangeStateTo(stateWaitForFixPtOn%, tNow);
        
        
    case iState% = stateWaitForFixPtOn% then
        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
        if tTrigger > tLast then
            ' Fixation point is up
            PrintLog("stateWaitForFixPtOn: signal received. " + str$(tTrigger) + "\n");
            tLastTrigger := tTrigger;
            ChangeStateTo(stateWaitForAcquisition%, tTrigger);
            docase
            case trialType% = trialtypeAttendToward% then
                SampleText("Fixation point on, Attend Toward",tTrigger);
            case trialType% = trialtypeAttendAway% then
                SampleText("Fixation point on, Attend Away",tTrigger);
            case trialType% = trialtypeNoChange% then 
                SampleText("Fixation point on, No Change",tTrigger);
            endcase;
            DrawStim(1);	' this draws the location of the fixpt.
        endif
        
        
    case iState% = stateWaitForAcquisition% then
        'getPreciseTiming := 1;
        ' Waiting for eye to fall inside of fixation window
        if Looking%(xEye, yEye) = 1 then
            PrintLog("stateWaitForAcquisition: eye in fixation window.\n");
            ChangeStateTo(stateHoldFixationToStimOn%, tNow);
            SampleText("Fixation Acquired",tNow);
            'getPreciseTiming := 0;
        else 
            if tNow - tStateStart > attAcquisitionTime then  'simple abort on failure to acquire
                PrintLog("stateWaitForAcquisition: failed.\n");
                ChangeStateTo(stateAbort%, tNow);
                'getPreciseTiming := 0;
            endif
        endif
        
        
    case iState% = stateHoldFixationToStimOn% then
        
        ' Eye must remain inside of fixation window
        docase
        case Looking%(xEye, yEye) = 1 then
            if tNow - tStateStart > attFixationTime then
                PrintLog("stateHoldFixationToStimOn: Success. Gratings up...\n");
                SafeSampleKey("S");
                ChangeStateTo(stateWaitForStimOn%, tNow);
            endif
        else 'if fixation fails before stim on, begin abort, check to see if it is a FA
            tempanswer% := Answer%(xEye, yEye);
            if tempanswer% < 0 then  'adjust tempanswer to correspond to trialAttendLoc syntax
                tempanswer% := -tempanswer%+1;
            endif;
            if tempanswer% <> 0 then  'if it's in a response window, quit while you're ahead
                docase
                case tempanswer% = trialAttendLoc% then 'answer in "attend toward" window
                    PrintLog("stateWaitForStimOn: in attend toward response window, aborting trial.\n");
                    FAIsResponse% := 1;
                    ChangeStateTo(stateAbort%, tNow);
                    SampleText(Print$("Fixation broken, False Alarm to location %d (attend toward window) before stimulus on, trial aborted",tempanswer%),tNow);
                case tempanswer% = -1 then 'answer in "attend away" = "down" window
                    PrintLog("stateWaitForStimOn: in attend away response window, aborting trial.\n");
                    FAIsResponse% := 1;
                    ChangeStateTo(stateAbort%, tNow);
                    SampleText(Print$("Fixation broken, False Alarm to location %d (attend away window) before stimulus on, trial aborted",tempanswer%),tNow);    
                endcase;
            else  'keep checking until false alarm check window is closed
                ChangeStateTo(stateCheckFalseAlarm%, tNow);
                temptext$ := "before stimulus on";
            endif;
        endcase
        
    case iState% = stateWaitForStimOn% then
        tTrigger := View(DataWindow%).NextTime(StimChannel%, tLast, vTrigger);
        if tTrigger > tLast and vTrigger = 0 then
            ' gratings et al are up
            PrintLog("stateWaitForStimOn: stim is up.\n");
            tStimOn := tTrigger;
            tLastTrigger := tTrigger;
            ChangeStateTo(stateHoldFixationToCC%, tTrigger);
            SampleText("Stimulus on, Fixation color " + fixColor$ + ", Base contrast " + Str$(attContrastBase%) + ", hazard dur " + Str$(trialHazardFunctionTime)
            + ", attend location " + Str$(trialAttendLoc%) + ", change location " + Str$(trialIsTarget%) + ", change contrast " + Str$(thisContrast%),tTrigger);
        endif
        
        
    case iState% = stateAbort% then
        
        ' Signal "X" turns off fixpt and stimulus. The next state 'stateWaitForBlank' only checks for 
        ' fixpt off. 
        PrintLog("stateAbort: send X key.\n");
        SafeSampleKey("X");
        
        view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Force fixation window to blue
        view(XYWindow%).XYColour(iAnswerWindowChannelMain%,13);  'Force main stimulus answer window to blue
        if attNumPatches% > 1 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,13);  'Force distracter1 answer window to blue
        endif;
        if attNumPatches% > 2 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,13);  'Force distracter2 answer window to blue
        endif;
        if attNumPatches% > 3 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,13);  'Force distracter3 answer window to blue
        endif;
        if attNumPatches% > 4 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,13);  'Force distracter4 answer window to blue
        endif;
        
        
        ' tally up aborted trials, right now not distinguishing between response aborts and regular aborts
        ' but we also have to decrement "all trials" because this messes with the percentages
        attCountAllTrialsAbort% += 1;
        attCountAllTrials% -= 1;
        docase
        case trialType% = trialtypeAttendToward% then
            attCountTowardTrialsAbort% += 1;
            attCountTowardTrials% -= 1;
        case trialType% = trialtypeAttendAway% then
            attCountAwayTrialsAbort% += 1;
            attCountAwayTrials% -= 1;
        case trialType% = trialtypeNoChange% then
            attCountNoChangeTrialsAbort% += 1;
            attCountNoChangeTrials% -= 1;
        else 
            PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
        endcase
        
        ' move on
        'ChangeStateTo(stateWaitForBlank%, tNow);
        ChangeStateTo(stateWaitForBlank%, tStateStart);  'don't update time, carry forward
        
    case iState% = stateWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
        if tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            if FAIsResponse% = 1 then
                FAIsResponse% := 0;
                ChangeStateTo(stateFalseAlarmWait%, tTrigger);
                'advance on false alarm
                SafeSampleKey("a");  'this is the only place to get into stateFalseAlarmWait, so advance here is fine
            else                
                ChangeStateTo(stateAbortWait%, tStateStart);  'don't update time, "credits" for time served
            endif;
            DrawStim(0);	' this undraws the location of the fixpt.
        endif
        
    case iState% = stateAbortWait% then
        
        if tNow - tStateStart > attAbortWaitTime then
            PrintLog("stateAbortWait: time out is done.\n");
            ChangeStateTo(stateStartTrial%, tNow);
        endif
        
       
        
    case iState% = stateCheckFalseAlarm% then
        
        if tNow - tStateStart < attFalseAlarmCheckWindow then
            tempanswer% := Answer% (xEye, yEye);
            if tempanswer% < 0 then  'adjust tempanswer to correspond to trialAttendLoc syntax
                tempanswer% := -tempanswer%+1;
            endif;
            docase
            case tempanswer% = trialAttendLoc% then 'answer in "attend toward" window
                PrintLog("stateCheckFalseAlarm: in attend toward response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText(Print$("Fixation broken, False Alarm to location %d (attend toward window) %s, trial aborted",tempanswer%,temptext$),tNow);
            case tempanswer% = -1 then 'answer in "attend away" = "down" window
                PrintLog("stateCheckFalseAlarm: in attend away response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText(Print$("Fixation broken, False Alarm to location %d (attend away window) %s, trial aborted",tempanswer%,temptext$),tNow);    
            endcase;
        else 'credit the animal for time served on the abort if it's not a response
            PrintLog("stateCheckFalseAlarm: no response in window, aborting trial.\n");
            ChangeStateTo(stateAbort%, tNow-attFalseAlarmCheckWindow); 
            SampleText("Fixation broken, no response, trial aborted");
        endif;
        
         
    case iState% = stateFalseAlarmWait% then
        
        if tNow - tStateStart > attFalseAlarmWaitTime then
            PrintLog("stateFalseAlarmWait: time out is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
        endif        
        
        '?!?!?! note major changes necessary here because we are no longer using a trigger to implement contrast change - now is animation!
    case iState% = stateHoldFixationToCC% then
        
        docase            
        case Looking%(xEye, yEye) = 0 then  'begin abort procedure, check to see if it's a FA
            tempanswer% := Answer% (xEye, yEye);
            if tempanswer% < 0 then  'adjust tempanswer to correspond to trialAttendLoc syntax
                tempanswer% := -tempanswer%+1;
            endif;
            docase
            case tempanswer% = trialAttendLoc% then 'answer in "attend toward" window
                PrintLog("stateHoldFixationToCC: in attend toward response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText(Print$("Fixation broken, False Alarm to location %d (attend toward window) during stimulus, trial aborted",tempanswer%),tNow);
            case tempanswer% = -1 then 'answer in "attend away" = "down" window
                PrintLog("stateHoldFixationToCC: in attend away response window, aborting trial.\n");
                FAIsResponse% := 1;
                ChangeStateTo(stateAbort%, tNow);
                SampleText(Print$("Fixation broken, False Alarm to location %d (attend away window) during stimulus, trial aborted",tempanswer%),tNow);           
            else  'keep checking
                ChangeStateTo(stateCheckFalseAlarm%, tNow);
                temptext$ := "during stimulus";
            endcase;
            
        else 
            if (tNow - tStateStart) > (trialHazardFunctionTime) then
                ' we no longer turn off stimulus and advance it, but we DO allow response now
                isStimDistractorOff% := 0;
                ChangeStateTo(stateWaitForAnswer%, tNow);
                'This docase sets the color of the changed location to red on the "monitor screen"
                docase
                case trialIsTarget% = 0 then
                    view(XYWindow%).XYColour(iFixationWindowChannel%,16);  'Change fixation window to red
                case trialIsTarget% = 1 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelMain%,16);  'Change main window to red
                case trialIsTarget% = 2 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,16);  'Change dist1 window to red
                case trialIsTarget% = 3 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,16);  'Change dist2 window to red
                case trialIsTarget% = 4 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,16);  'Change dist3 window to red
                case trialIsTarget% = 5 then
                    view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,16);  'Change dist4 window to red
                endcase
                'This docase does the appropriate SampleTexting
                docase
                case trialType% = trialtypeAttendToward% then
                    if trialIsTarget% > 0 then
                        if trialCatch% = 0 then
                            Sampletext("Contrast Change, Level " + Str$(thisContrast%) + ", Attend Toward",tTrigger+trialHazardFunctionTime);
                        else
                            Sampletext("Contrast Change, Level " + Str$(thisContrast%) + ", Attend Toward (catch)",tTrigger+trialHazardFunctionTime);
                        endif
                    else
                        Sampletext("Attend Toward, No Contrast Change",tTrigger+trialHazardFunctionTime);
                    endif
                case trialType% = trialtypeAttendAway% then
                    if trialIsTarget% > 0 then
                        if trialCatch% = 0 then
                            Sampletext("Contrast Change, Level " + Str$(thisContrast%) + ", Attend Away",tTrigger+trialHazardFunctionTime);
                        else
                            Sampletext("Contrast Change, Level " + Str$(thisContrast%) + ", Attend Away (catch)",tTrigger+trialHazardFunctionTime);
                        endif
                    else
                        Sampletext("Attend Away, No Contrast Change",tTrigger+trialHazardFunctionTime);
                    endif
                case trialType% = trialtypeNoChange% then  
                    Sampletext("No Change, No Contrast Change",tTrigger+trialHazardFunctionTime);
                else
                    PrintLog("ERROR! Unknown blocktype!!!\n");    
                endcase
            endif
            
        endcase
        
'    case iState% = stateWaitForContrastChange% then
'        tTrigger := NextTime(StimChangeChannel%, tLast, vTrigger);
'        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
'        docase
'        case tTrigger > tLast and vTrigger = 0 then
'            PrintLog("stateWaitForContrastChange: got it.\n");
'            tLastTrigger := tTrigger;
'            isStimDistractorOff% := 0;
'            ChangeStateTo(stateWaitForAnswer%, tNow);
'            docase
'            case trialType% = trialtypeAttendToward% then
'                if trialIsTarget% > 0 then
'                    if trialCatch% = 0 then
'                        view(XYWindow%).XYColour(iAnswerWindowChannel1%,16);  'Change up answer window to red
'                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Toward",tTrigger);
'                    else
'                        view(XYWindow%).XYColour(iAnswerWindowChannel2%,16);  'Change down answer window to red
'                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Toward (catch)",tTrigger);
'                    endif
'                else
'                    view(XYWindow%).XYColour(iFixationWindowChannel%,16);  'Change fixation window to red
'                    Sampletext("No Contrast Change",tTrigger);
'                endif
'            case trialType% = trialtypeAttendAway% then
'                if trialIsTarget% > 0 then
'                    if trialCatch% = 0 then
'                        view(XYWindow%).XYColour(iAnswerWindowChannel2%,16);  'Change down answer window to red
'                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Away",tTrigger);
'                    else
'                        view(XYWindow%).XYColour(iAnswerWindowChannel1%,16);  'Change up answer window to red
'                        Sampletext("Contrast Change Up, Level " + Str$(thisContrast%) + ", Attend Away (catch)",tTrigger);
'                    endif
'                else
'                    view(XYWindow%).XYColour(iFixationWindowChannel%,16);  'Change fixation window to red
'                    Sampletext("No Contrast Change",tTrigger);
'                endif
'            else
'                PrintLog("ERROR! Unknown blocktype!!!\n");
'            endcase;
'            
'        case Looking%(xEye, yEye) = 0 then  'begin abort procedure, check to see if it is a FA
'            docase
'            case Answer% (xEye, yEye) = 1 then 'answer in "attend toward" = "up" window
'                PrintLog("stateWaitForContrastChange: in attend toward response window, aborting trial.\n");
'                FAIsResponse% := 1;
'                ChangeStateTo(stateAbort%, tNow);
'                SampleText("Fixation broken, False Alarm in attend toward window, trial aborted");
'            case Answer% (xEye, yEye) = -1 then 'answer in "attend away" = "down" window
'                PrintLog("stateWaitForContrastChange: in attend away response window, aborting trial.\n");
'                FAIsResponse% := 1;
'                ChangeStateTo(stateAbort%, tNow);
'                SampleText("Fixation broken, False Alarm in attend away window, trial aborted");        
'            'if Answer%(xEye, yEye) <> 0 then  'if it's in response window, quit while you're ahead
'            '    PrintLog("stateHoldFixationToCC: in response window, aborting trial.\n");
'            '    FAIsResponse% := 1;
'            '    ChangeStateTo(stateAbort%,tNow);
'            '    SampleText("Fixation broken, False Alarm, trial aborted");
'            else  'keep checking
'                ChangeStateTo(stateCheckFalseAlarm%, tNow);
'            endcase;
'            
'        endcase;
        
    case iState% = stateWaitForAnswer% then
        'getPreciseTiming := 1;  'we need precise timing here, stay in while loop until we get eye movements we expect
        if tNow - tStateStart > attTimeToAnswerPerTrial then  'no response
            if trialIsTarget% > 0 then 'GO trial, expected response
                SafeSampleKey("X");  'turn off animation
                PrintLog("stateWaitForAnswer: no response on go trial, miss\n");
                docase
                case trialType% = trialtypeAttendToward% then
                    attCountTowardTrialsIncorrect% += 1;
                    SampleText("Miss, Attend Toward",tNow);
                case trialType% = trialtypeAttendAway% then
                    attCountAwayTrialsIncorrect% += 1;
                    SampleText("Miss, Attend Away",tNow);
                endcase;
                ChangeStateTo(stateMiss%, tNow); 'go to miss penalty
                SafeSampleKey("a");
            else
                SafeSampleKey("X");  'turn off animation
                PrintLog("stateWaitForAnswer: no response on no-go trial, correct rejection\n");
                docase
                case trialType% = trialtypeAttendToward% then
                    attCountTowardTrialsCorrect% += 1;
                    SampleText("Correct Rejection, Attend Toward",tNow);
                case trialType% = trialtypeAttendAway% then
                    attCountAwayTrialsCorrect% += 1;
                    SampleText("Correct Rejection, Attend Away",tNow);
                case trialType% = trialtypeNoChange% then
                    attCountNoChangeTrialsCorrect% += 1;
                    SampleText("Correct Rejection, No Change",tNow);
                endcase;
                attInterTrialTime2 := attInterTrialTime;
                Reward%();
                ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
            endif;
        else
            ' When fixation is first broken we turn off the stim and distractor. 
            ' That test is done separately from the test for an answer. Also set up 
            ' a var to tell us whether the stim has been turned off. 
            if isStimDistractorOff% = 0 then
                if Looking%(xEye, yEye) = 0 then
                    SafeSampleKey("s");
                    'SampleText("Fixation broken during response window",tNow);
                    PrintLog("stateWaitForAnswer: fix broken - turn off stim\n");
                    isStimDistractorOff% := 1;
                endif
            endif
            
            iAnswer% := Answer%(xEye, yEye);
            if iAnswer% <> 0 then
                ' Got an answer. Record marker for correct/incorrect answer
                printlog("Got answer %d with expected answer %d\n",iAnswer%,expectedAnswer%);
                docase
                case iAnswer% = expectedAnswer% then
                'if trialIsTarget% = 1 then 'it's a GO trial
                    ' Hit                    
                    attCountAllTrialsCorrect% += 1;
                    attInterTrialTime2 := attInterTrialTime;
                    'SampleText("+");
                    docase
                    case trialType% = trialtypeAttendToward% then
                        attCountTowardTrialsCorrect% += 1;
                        SampleText("Hit, Attend Toward, Contrast Up",tNow);
                    case trialType% = trialtypeAttendAway% then
                        attCountAwayTrialsCorrect% += 1;
                        SampleText("Hit, Attend Away, Contrast Up",tNow);
                    case trialType% = trialtypeNoChange% then
                        PrintLog("ERROR: No-Change trial, expectedAnswer should be zero but was " + str$(expectedAnswer%) + "\n");
                    else
                        PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                    endcase
                    'getPreciseTiming := 0;
                    Reward%();
                    ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
                    SafeSampleKey("X");
                case iAnswer% <> expectedAnswer% and expectedAnswer% <> 0 then
                    'it's a GO trial
                    ' Saccade to wrong grating                    
                    attCountAllTrialsIncorrect% += 1;
                    attInterTrialTime2 := attInterTrialTime + attMissPenalty;
                    'SampleText("+");
                    docase
                    case trialType% = trialtypeAttendToward% then
                        attCountTowardTrialsIncorrect% += 1;
                        SampleText("Miss, Attend Toward, Moved To Wrong Grating, Contrast Up",tNow);
                    case trialType% = trialtypeAttendAway% then
                        attCountAwayTrialsIncorrect% += 1;
                        SampleText("Miss, Attend Away, Moved To Wrong Grating, Contrast Up",tNow);
                    case trialType% = trialtypeNoChange% then
                        PrintLog("ERROR: No-Change trial, expectedAnswer should be zero but was " + str$(expectedAnswer%) + "\n");
                    else
                        PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                    endcase
                    'getPreciseTiming := 0;
                    ChangeStateTo(stateTrialCompletedWaitForBlank%, tNow);
                    SafeSampleKey("X");
                else  'it's a NO-GO trial, and we got an answer
                    'SampleText("-");
                    attCountAllTrialsIncorrect% += 1;
                    attInterTrialTime2 := attInterTrialTime + attMissPenalty;
                    docase
                    case trialType% = trialtypeAttendToward% then
                        attCountTowardTrialsIncorrect% += 1;
                        SampleText("False Alarm, Attend Toward",tNow);
                    case trialType% = trialtypeAttendAway% then
                        attCountAwayTrialsIncorrect% += 1;
                        SampleText("False Alarm, Attend Away",tNow);
                    case trialType% = trialtypeNoChange% then
                        attCountNoChangeTrialsIncorrect% += 1;
                        SampleText("False Alarm, No Change",tNow);
                    else
                        PrintLog("ERROR: Unknown trial type (" + str$(trialType%) + "\n");
                    endcase
                    'getPreciseTiming := 0;
                    Yield(.01);    ' necessary so that the SampleText and SafeSampleKey below don't land on the same time (makes extraction difficult)
                    FAIsResponse% := 1;
                    ChangeStateTo(stateAbort%,tNow);
                    'SafeSampleKey("X");
                endcase
            endif
        endif
        
    case iState% = stateTrialCompletedWaitForBlank% then
        
        ' we just wait for fix point off signal in this case. 
        tTrigger := View(DataWindow%).NextTime(FixationPointChannel%, tLast, vTrigger);
        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
        'if tTrigger > tLast and vTrigger = 1 then
        if tTrigger > tLast then
            ' Fixation point is off
            PrintLog("stateTrialCompleteWaitForBlank: Fix pt is off.\n");
            tLastTrigger := tTrigger;
            'advance
            SafeSampleKey("a");
            ChangeStateTo(stateTrialCompletedPause%, tTrigger);
            DrawStim(0);	' actually this draws the location of the fixpt.
        endif
        
'    case iState% = stateNoResponse% then
'        
'        ' we just wait for fix point off signal in this case. 
'        tTrigger := NextTime(FixationPointChannel%, tLast, vTrigger);
'        'tTrigger := NextTime(FrameTriggerChannel%, tLast, vTrigger);
'        'if tTrigger > tLast and vTrigger = 1 then
'        if tTrigger > tLast then
'            ' Fixation point is off
'            PrintLog("stateTrialNoResponse: Fix pt is off.\n");
'            tLastTrigger := tTrigger;
'            'advance
'            'SafeSampleKey("a");  'maybe don't advance
'            ChangeStateTo(stateTrialCompletedPause%, tTrigger);
'            DrawStim(0);	' actually this draws the location of the fixpt.
'        endif        
        
    case iState% = stateTrialCompletedPause% then
        
        if tNow - tStateStart > attInterTrialTime2 then
            
            PrintLog("stateTrialCompletedPause: inter-trial time is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
            
        endif
        
    case iState% = stateMiss% then
        
        if tNow - tStateStart > attMissPenalty then
            
            PrintLog("stateMiss: penalty time is done.\n");
            ChangeStateTo(stateTrialCompleted%, tNow);
            
        endif
        
        
    case iState% = stateTrialCompleted% then
        view(XYWindow%).XYColour(iAnswerWindowChannelMain%,13);  'Force main answer window to blue
        if attNumPatches% > 1 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist1%,13);  'Force distracter1 answer window to blue
        endif;
        if attNumPatches% > 2 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist2%,13);  'Force distracter2 answer window to blue
        endif;
        if attNumPatches% > 3 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist3%,13);  'Force distracter3 answer window to blue
        endif;
        if attNumPatches% > 4 then
            view(XYWindow%).XYColour(iAnswerWindowChannelDist4%,13);  'Force distracter4 answer window to blue
        endif;
        view(XYWindow%).XYColour(iFixationWindowChannel%,13);  'Force fixation window to blue
        PrintLog("Trial completed.\n");
        nTrialsCompleted% += 1;
        attCurrTrialIndex% += 1;
        if nTrialsCompleted% = attTrialsPerBlock%+attEasyTrialsPerBlock% then
            ChangeStateTo(stateBlockCompleted%, tNow);
        else
            ChangeStateTo(stateStartTrial%, tNow);
        endif
        
    case iState% = stateBlockCompleted% then
        
        PrintLog("Block completed.\n");
        nBlocksCompleted% := nBlocksCompleted% + 1;
        if nBlocksCompleted% = attNumberOfBlocks% then
            ChangeStateTo(stateDone%, tNow);
            Stop%();
            iStatus% := 0;
        else
            ChangeStateTo(stateStartBlock%, tNow);
        endif
        
    else
        
        ' Unknown state!
        Message("Unknown state=" + str$(iState%));
        halt;
        
    endcase;
    
    tLast := tNow;
    'wend;
    
	return iStatus%;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc ChangeStateTo(stateTo%, tStart)
	iState% := stateTo%;
	if tStart > 0 then tStateStart := tStart; endif;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareTrial()
    
	PrintLog("Prepare trial: ");
    
	if attBlockAlternate% = 0 then
        docase
		case attAttendList%[attCurrTrialIndex%] = 1 then
			trialType% := trialtypeAttendToward%;
			PrintLog("Trial type: attend-toward\n");
            JuiceRewardMS% := origRewardMS%; 'set reward at trial prep, this will then be good for the reward on this trial, if any.
        case attAttendList%[attCurrTrialIndex%] = 6 then  
            trialType% := trialtypeNoChange%;
            JuiceRewardMS% := lowRewardMS%;  'use low reward for no-change trials
			PrintLog("Trial type: no-change\n");    
		else
			trialType% := trialtypeAttendAway%;
            JuiceRewardMS% := origRewardMS%;
			PrintLog("Trial type: attend-away\n");
		endcase
	else
        docase
		case attAttendList%[attCurrTrialIndex%] = 1 then
            trialType% := trialtypeAttendToward%;
            JuiceRewardMS% := origRewardMS%;
			PrintLog("Trial type: attend-toward (for this entire block)\n");
        case attAttendList%[attCurrTrialIndex%] = 6 then  
            trialType% := trialtypeNoChange%;
            JuiceRewardMS% := lowRewardMS%;  'use low reward for no-change trials
			PrintLog("Trial type: no-change (for this entire block)\n");     
		else
            trialType% := trialtypeAttendAway%;
            JuiceRewardMS% := origRewardMS%;
			PrintLog("Trial type: attend-away (for this entire block)\n");
		endcase
	endif
       
    
    ' Fixation time is a random number between attFixationMinTime and attFixationMaxTime. 
    attFixationTime := Rand(attFixationCueMaxTime - attFixationCueMinTime, attFixationCueMinTime);
    PrintLog("Fixation time " + str$(attFixationTime) + "\n");
    
    ' Set hazard function time and time to answer per trial
    if trialType% = trialTypeNoChange% then
        trialHazardFunctionTime := 0.1;  'for no-change trials, set hazard time to 0.1, this is hard coded
        attTimeToAnswerPerTrial := attNoChangeDuration - 0.1;  'the 0.1 is the hardcoded hazard time, the remainder is answer window
    else
        trialHazardFunctionTime := attHazardList[attCurrTrialIndex%];  'hazard time has been pre-calculated for regular trials
        attTimeToAnswerPerTrial := attTimeToAnswer;  'Use the standard time to answer
    endif
    

    'Determine if trial is catch trial
    trialCatch% := 1-attValidList%[attCurrTrialIndex%];
    if trialCatch% = 1 then
        PrintLog("CATCH\n");
    endif;
    
    'Determine if contrast is changing (target) or not (nontarget)
'    if attContrastList%[attCurrTrialIndex%] = attContrastBase% then
'        trialIsTarget% := 0; 
'    else
'        trialIsTarget% := 1;
'    endif;
    trialIsTarget% := attChangeList%[attCurrTrialIndex%];  'this tells me not only whether the contrast is changing, but WHICH patch
    trialAttendLoc% := attAttendList%[attCurrTrialIndex%];  'this is the attend location
    fixColor$ := masterColorList$[attFixColor%[attCurrTrialIndex%]-1];
    
    'Record actual contrast level on this trial
    thisContrast% := attContrastList%[attCurrTrialIndex%];
    
    'Calculate expected answer
    if trialIsTarget% < 2 then
        expectedAnswer% := trialIsTarget%;
    else
        expectedAnswer% := -trialIsTarget%+1;
    endif;
    
    'printlog("Trial is target value is %d and expected answer is %d\n",trialisTarget%,expectedAnswer%);
    
'    docase
'    case trialType% = trialtypeAttendToward% then
'        if trialIsTarget% > 0 then
'            if trialCatch% = 0 then
'                expectedAnswer% := 1;
'            else
'                expectedAnswer% := -1;
'            endif
'        else
'            expectedAnswer% := 0;
'        endif
'    case trialType% = trialtypeAttendAway% then
'        if trialIsTarget% > 0 then
'            if trialCatch% = 0 then
'                expectedAnswer% := -1;
'            else
'                expectedAnswer% := 1;
'            endif
'        else
'            expectedAnswer% := 0;
'        endif
'    else
'        PrintLog("ERROR! Unknown blocktype!!!\n");
'    endcase;
    
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc PrepareBlock()
    'This function used to do more, but now that all stimuli are determined in advance, it just kinda does some printlogging now
	PrintLog("Block starting: "); 
	if attBlockAlternate% <> 0 then
		if attAttendList%[attCurrTrialIndex%] = 1 then
			PrintLog("Attend-toward ");
		else
			PrintLog("Attend-away ");
		endif
	else
		PrintLog("Attend-toward/away done on a trial-by-trial basis.");
	endif
	PrintLog("\n");
    'reset block-specific variables
	ntrialsCompleted% := 0;
	nTrialsStarted% := 0;
	nTrialsAborted% :=0; 
end

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func PauseStimuli%();
    Pause% :=1;
    ToolbarEnable(4,0);
    ToolbarEnable(5,1);
    return 1;
end
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func ResumeStimuli%();
    Pause% :=0;
    ToolbarEnable(4,1);
    ToolbarEnable(5,0);
    return 1;
end





proc InitializeWindows()
    'CreateContrastList(Contrast$,attContrastList%,attChangeList%,attValidList%,attAttendList%,attHazardList,attOffBitsList%,attRotationList%,attFixColor%);
	'Open the data sampling window
	DataWindow% := FileNew(0,4);  'show spike shape setup dialog
    printlog("datawindow is %d\n",dataWindow%);
	Window(0,48,100,95);
	View(DataWindow%).WindowVisible(1);
    
    if UsePlexon% = 1 then
        'Get the name of the most recent .s2r resource file, if any
        var key$;
        var fn$;
        key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
        Profile(key$, "microS2Rfile", "x", fn$);
        printlog("S2R file name %s was retrieved from registry\n",fn$);
        
        'Apply the ,s2r resource file to the current data window, which will apply the spike shape templates
        'if useSpikeTemplate% = 1 and fn$ <> "x" then
        if fn$ <> "x" then  'OK, Henry says no checkbox necessary, just load up every time 
            FileApplyResource(fn$);
            printlog("S2R file name %s was loaded using FileApplyResource\n",fn$);
        endif
    endif;
    

    
	'Open an XY view to display eye position
	XYWindow% := FileNew(12);
	XRange(-30,30);
	YRange(-2,-30,30);
	XYDrawMode(0,5,0);
	WindowVisible(1);
	Window(0, 0, 100, 47);
	XYColour(1,16);
	XYSize(1,-1);
    
    
	'Calcuate the fixation window
	var index%;
	var twopi;
	twopi := 2.0*4.0*ATan(1.0);
	
	for index% := 0 to 35 do
		FixWindowX[index%] := FixationX + WindowRadius * Cos(index% * twopi/36.0);
		FixWindowY[index%] := FixationY + WindowRadius * Sin(index% * twopi/36.0);
	next;
    
	'Create a new channel in the XY view to display the fixation window
	iFixationWindowChannel% := XYSetChan(0);
	XYColour(iFixationWindowChannel%,13);
	XYDrawMode(iFixationWindowChannel%,2,1);
	XYJoin(iFixationWindowChannel%,1);
	'Draw the fixation window
	XYAddData(iFixationWindowChannel%, FixWindowX[], FixWindowY[]);
    
    
    'get locations of stimuli so that answer windows overlap them
    ParseGratingParametersBrief%(GetGratingParameters$("Stimulus"),mainX,mainY,mainW,mainH); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor1"),dist1X,dist1Y,dist1W,dist1H);
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor2"),dist2X,dist2Y,dist2W,dist2H); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor3"),dist3X,dist3Y,dist3W,dist3H); 
    ParseGratingParametersBrief%(GetGratingParameters$("Distractor4"),dist4X,dist4Y,dist4W,dist4H);     
    
    'Not sure if Henry wants this feature
    'If we are getting our grating parameters from the main stimulus, get ONLY the X and Y position and NOT the width/height, match W/H to main grating
    if attGetGPFromMainStim% = 1 then
        dist1W := mainW;
        dist1H := mainH;
        dist2W := mainW;
        dist2H := mainH;
        dist3W := mainW;
        dist3H := mainH;
        dist4W := mainW;
        dist4H := mainH;
    endif;
    
    
    'Create new channels in the XY view to display the answer windows
    'reuse FixationX, FixationY
    'Main stimulus window
    for index% := 0 to 35 do
        FixWindowX[index%] := mainX + mainW * Cos(index% * twopi/36.0);
		FixWindowY[index%] := mainY + mainH * Sin(index% * twopi/36.0);
	next;
    iAnswerWindowChannelMain% := XYSetChan(0);
    XYColour(iAnswerWindowChannelMain%,13);
	XYDrawMode(iAnswerWindowChannelMain%,2,1);
	XYJoin(iAnswerWindowChannelMain%,1);
	'Draw the answer window
	XYAddData(iAnswerWindowChannelMain%, FixWindowX[], FixWindowY[]);
    

    'Distracter1 window
    if attNumPatches% > 1 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist1X + dist1W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist1Y + dist1H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist1% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist1%,13);
        XYDrawMode(iAnswerWindowChannelDist1%,2,1);
        XYJoin(iAnswerWindowChannelDist1%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist1%, FixWindowX[], FixWindowY[]);
    endif;
       
    'Distracter2 window
    if attNumPatches% > 2 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist2X + dist2W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist2Y + dist2H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist2% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist2%,13);
        XYDrawMode(iAnswerWindowChannelDist2%,2,1);
        XYJoin(iAnswerWindowChannelDist2%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist2%, FixWindowX[], FixWindowY[]);
    endif;    
    
    'Distracter3 window
    if attNumPatches% > 3 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist3X + dist3W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist3Y + dist3H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist3% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist3%,13);
        XYDrawMode(iAnswerWindowChannelDist3%,2,1);
        XYJoin(iAnswerWindowChannelDist3%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist3%, FixWindowX[], FixWindowY[]);
    endif;
    
    'Distracter4 window
    if attNumPatches% > 4 then
        for index% := 0 to 35 do
            FixWindowX[index%] := dist4X + dist4W * Cos(index% * twopi/36.0);
            FixWindowY[index%] := dist4Y + dist4H * Sin(index% * twopi/36.0);
        next;
        iAnswerWindowChannelDist4% := XYSetChan(0);
        XYColour(iAnswerWindowChannelDist4%,13);
        XYDrawMode(iAnswerWindowChannelDist4%,2,1);
        XYJoin(iAnswerWindowChannelDist4%,1);
        'Draw the answer window
        XYAddData(iAnswerWindowChannelDist4%, FixWindowX[], FixWindowY[]);
    endif;    
    
    
    
    
	'Create a new channel in the XY view to display the fixation point
	iStimChannel% := XYSetChan(0);
    
	'Create a new channel in the XY view to show the monitor's location
	iMonitorChannel% := XYSetChan(0);
	XYColour(iMonitorChannel%,13);
	XYDrawMode(iMonitorChannel%,3,1);
	XYJoin(iMonitorChannel%,2);
	XYAddData(iMonitorChannel%,-9,-7);
	XYAddData(iMonitorChannel%,9,-7);
	XYAddData(iMonitorChannel%,9,7);
	XYAddData(iMonitorChannel%,-9,7);
    
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
	var index;
    var key$;
    key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Temp\\Filepref";
    SampleClear(); 'Set standard sampling state

    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 3);
    FilePathSet(dataPathRoot$ + "\\" + dataDataSet$, 1);
    if UsePlexon% = 0 then
        SampleAutoName$(dataCellName$ + "_atn_000");  'NOTE: maximum of 13 characters!!!
    else
        EqualizeSMRFilenumbers(dataPathRoot$ + "\\" + dataDataSet$,dataCellName$+"_atnMICRO_",dataCellName$+"_atnPOWER_");
        SampleAutoName$(dataCellName$ + "_atnMICRO_000");  'NOTE: maximum of 13 characters!!!
        SetStringRegistryValue(key$, "pref", "atn");
    endif;
    'autoNameTemplate$ := SampleAutoName$();  'to retrieve sample name, this must be called AFTER setting ::rolls eyes::
    SampleAutoFile(1);  'Enable automatic file naming
    
	SampleAutoComment(0); 'Prompt for comment after sampling
	SampleAutoCommit(60); 'Seconds between each file commit
    
	'Channel recording definitions
	SampleEvent(FrameTriggerChannel%,0,2,3600); 'Trigger channel, level
	SampleComment$(FrameTriggerChannel%,"Frame");
	SampleTitle$(FrameTriggerChannel%,"Frame");
    
    ' Synch channel for checking synchronization.  Synch is good down to the microsecond.  Have to change 
' Edit->Edit Preferences->Sampling->Event Ports 0 and 1 on rear digital... to unchecked or it won't work    
'   SampleEvent(SynchChannel%,1,2,3600); 'Synch channel, level
'	SampleComment$(SynchChannel%,"Synch");
'	SampleTitle$(SynchChannel%,"Synch");
    
 	SampleEvent(FixationPointChannel%,2,2,3600); 'Trigger channel, level
	SampleComment$(FixationPointChannel%,"Fixation");
	SampleTitle$(FixationPointChannel%,"Fixation");
	
	SampleEvent(StimChannel%,3,2,3600); 'Trigger channel, level
	SampleComment$(StimChannel%,"Stim");
	SampleTitle$(StimChannel%,"Stim");
	
	SampleEvent(StimChangeChannel%,4,2,3600); 'Trigger channel, level
	SampleComment$(StimChangeChannel%,"Stim Chg.");
	SampleTitle$(StimChangeChannel%,"Stim Chg.");
	
	SampleEvent(ReadyChannel%,6,2,3600); 'Trigger channel, level
	SampleComment$(ReadyChannel%,"VSG Ready");
	SampleTitle$(ReadyChannel%,"VSG Ready");
    
    ' Set up channels for sampling electrodes.
    docase
    case UsePlexon% = 1 then  'call Plexon setup function, this will ONLY set up the sampling configuration for the Micro1401 mark II.  The Power1401 will be set up from its own dedicated script in its dedicated Spike2 instance
        CreatePlexonSamplingConfiguration1824Micro(); 'Note that for right now the ONLY Plexon configuration is 18 WaveMark/24 LFP (maximal WMs for 24 LFPs, trust me)
    case UsePlexon7WM15CN% = 1 then  'call 7 wavemark, 15 continuous setup
        CreateElectrodeSamplingConfiguration7WM15CN();
    else  'just set up the channels as expected
        CreateElectrodeSamplingConfiguration(1, 11);
    endcase;
	
    ' Set up eye channels whether using Plexon or not
	SampleWaveform(XChannel%,14,1000);
	SampleTitle$(XChannel%,"Eye X");
	SampleWaveform(YChannel%,15,1000);
	SampleTitle$(YChannel%,"Eye Y");
    
    'I don't know what this is, but it's a problem for Plexon configs
'    if UsePlexon% = 0 and UsePlexon7WM15CN% = 0 then  'Kill it if we're using the Plexon
'        SampleWaveform(NumberOfElectrodes%+10, 6, 1000);
'        SampleTitle$(NumberOfElectrodes%+10, "PD");
'    endif;
    
    
	SampleTextMark(200);  'increase number of allowed characters, 1 is so stingy!
    
	'SampleSequencer(script$ + "Attention.pls");
    SampleSequencer(script$ + "Tuning.pls");
    if UsePlexon% = 1 then  'Set optimise mode (do this last, so it's outside of the CreatePlexonSamplingConfiguration... functions)
        SampleOptimise(0,1,4,0,0,0,0);  'for the Micro 1401 mk II: manually set sampling timing, group channels with same ideal rate, micro1401, unused, unused, do not disable for compatibility, no burst mode
    else
        SampleOptimise(2,2,2,2,50);  'otherwise: full optimize timing, channels may have different rates, Power1401 (lowest common denominator, so eh), low usPerTime of 2, high usPerTime of 50
    endif;
	SampleMode(1); 'Continuous sampling
end;



' Get grating parameters from registry AlertRig\\(config)\\Gratings\\type$
func GetGratingParameters$(type$)
	var key$;
	var stmp$;
	key$ := "AlertRig\\" + GetCurrentConfiguration$() + "\\Gratings";
	Profile(key$, type$, "", stmp$);
	return stmp$;
end;

' Replace the color vector spec in a grating with the specified value
func ReplaceGratingColorVector$(gspec$, cvspec$)
    var s$;
    var i1%, i2%;
    var index%:=0;
    var i%;
    ' i1% and i2% are the index positions of the 8th and 9th commas
    PrintLog(gspec$ + "\n");
    for i% := 1 to 7 do
        index% := InStr(gspec$, ",", index%+1);
        PrintLog("%d index %d\n", i%, index%);
    next;
    i1% := InStr(gspec$, ",", index%+1);
    i2% := InStr(gspec$, ",", i1%+1);
    s$ := Mid$(gspec$, 1, i1%) + cvspec$ + Mid$(gspec$, i2%);
    PrintLog(s$ + "\n");
    return s$;
end

' Replace the X and Y positions in the grating spec with new XY positions but leave the rest (including W/H) the same
func ReplaceGratingXY$(sSpec$,x,y);
    var s$;
    var i1%, i2%;
    i1% := InStr(sSpec$, ",");  'get first comma position
    i2% := InStr(sSpec$, ",", i1%+1);  'get second comma position
    s$ := Str$(x) + "," + Str$(y) + "," + Right$(sSpec$,Len(sSpec$)-i2%);  'and put the X and Y values in front
    return s$;
end    
    
' Used to hard-quit from toolbar. This will close data files without saving!!! 
' It is important that this function be disabled once sampling is started!!!

func Quit%()
	FileClose(-1,-1);
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Stop%()
    var i%, mylen%;
    var fn$;
    var chanToExport%[30];
    
	' Disable idle process func
	ToolbarSet(0,"");
    
    ' Save the current resource file - might be causing problems
    'FileSaveResource(1);   
    
	' Tell stim app to shut down
	SafeSampleKey("Q");
	Yield(.1);
	SampleStop();
    
	ProgKill(StimHandle%);
	while ProgStatus(StimHandle%) > 0 do
		Yield();
	wend
    
    View(DataWindow%);
    ExportChanList(); 
    chanToExport%[1] := 30;  'channels to export go in elements 1:...'30 is the textmark channel
    chanToExport%[2] := 31;  '31 is the keyboard channel
    chanToExport%[3] := StimChannel%;  'stim channel
    docase
    case UsePlexon% = 1 then  'use hardcoded Plexon values - 18 WaveMarks and 24 LFPs for now, on the micro it's 
        for i% := 0 to 12 do
            chanToExport%[i%+4] := i%+1;  'wavemark channels are in order
        next;
        chanToExport%[0] := 3+i%;  'total number of channels goes in element 0
    case UsePlexon7WM15CN% = 1 then  'use hardcoded Plexon values - 7 WaveMarks and 15 LFPs
        for i% := 0 to 13 do
            chanToExport%[i%+4] := i%+1;  'wavemark channels are in order
        next;
        for i% := 14 to 21 do
            chanToExport%[i%+4] := i%+3;  'wavemark channels are in order, but we're skipping eye channels
        next;
        chanToExport%[0] := 3+i%;  'total number of channels goes in element 0
    else
        for i% := 0 to NumWavemarkPorts% do
            chanToExport%[i%+4] := i%+1;  'wavemark channels are in order
        next;
        chanToExport%[0] := 3+i%;  'total number of channels goes in element 0
    endcase;
    
    ExportChanList(0,view(datawindow%).maxtime(),chanToExport%[]);
    
    'Code for putting other various channels into the Matlab extraction, Ben doesn't want them but they will be useful for other code    
    ExportChanList(0,maxtime(),XChannel%);  'Eye position channel, X
    ExportChanList(0,maxtime(),YChannel%);  'Eye position channel, Y
    'for i% := 0 to NumWavemarkPorts%-1 do
    '    ExportChanList(0,maxtime(),i%+1);  'Wavemark channel(s)
    'next;
    
    
    fn$ := FileName$();  'get current file name
    printlog("file name is %s\n",fn$);
    mylen% := Len(fn$);
    fn$ := Left$(fn$,mylen%-4);
    fn$ := fn$ + ".mat";
    FileSaveAs(fn$,100,0,"",0,"UseSName=0"); 'Do not overwrite the .mat file - should have a different name and if it doesn't that is a red flag    
    
    ' Write parameter file
	WriteParameterFile();
    
    if UsePlexon% = 1 then
        ' Save most recent .s2r file name to registry
        fn$ := Left$(fn$,mylen%-4);
        fn$ := fn$ + ".s2r";
        var key$;
        key$:="AlertRig\\" + GetCurrentConfiguration$() + "\\Scripts\\AttentionGNG";
        Profile(key$, "microS2Rfile", fn$);
        printlog("S2R file name %s was saved to registry\n",fn$);
    endif;
    
    
    ' update statistics
    'AttentionExtract%(-1, -1);
    
	'ProgRun(bin$ + "\\ClearTrigger",0);
    
end;



func StartPlexon%()
    
    
    'Start the Power1401!  This is a bit cumbersome, and I'm not sure it's transferable, but it's a start, perhaps.
    var fp$;  'to hold current file path
    var fp2$;  'to hold destination file path
    fp$ := FilePath$();  'get current file path
    printlog("%s\n",fp$);  'and tell the world what it was
    FilePathSet("F:/work/AlertRig/Spike2Scripts");  'change the file path
    fp2$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp2$);  'by telling the world about it (hint: it works)
    
    'These two functions are not done before initializing the toolbar in dual-1401 mode
    'Must run this BEFORE the PROGRUN command, because both this sequence AND SetPlexon...
    'access the same directory, and this was causing conflicts because they were running
    'simultaneously.  Here, CreateSampleConfiguration is done accessing the directory before
    'SetPlexon... is started, and everything is kosher.
    CreateSampleConfiguration();
    
    progrun("sonview.exe /M /u2 SetPlexonRecording1824OnPower1401.s2s");  'run the program, .s2s file is now on default path by design
    
    FilePathSet(fp$);  'change the file path back to what it was
    fp$ := FilePath$();  'read out to allow verification
    printlog("%s\n",fp$); 'and tell the world to verify
    
    ToolbarSet(1,"Start SECOND",Start%);  'change button 1 on the toolbar, this may not work

    ' Get display windows ready
    InitializeWindows();    
    
    return 1; 'stay in toolbar
    
end


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
func Start%()
	var CommandLine$;
	var Extras$;
	var Tune$;
	var Stim$:="";
	'var Contrast$;  'made global so that WriteParameterFile can use it
    var ttemp;
    var stimSpec$;
    var dist1Spec$;
    var dist2Spec$;
    var dist3Spec$;
    var dist4Spec$;
    var xTemp;
    var yTemp;
    var wTemp;
    var hTemp;
    var lolSpec$;  'LOLlerskates!  ROFLcopter!
    var x;
    var i%;
    var specFileName$:="F:\\work\\AttentionSpecFile.txt";
    var specHandle%;
    var CueCirc$;  'this begins blank, if we don't use cue circles then it won't get filled
    
	
    'hard code pReward to 1, per Henry
    pReward := 1;
    

    'start sampling
    if UsePlexon% = 1 then
        SampleStart(1);  'set sampling to start on a trigger     
    else
    	SampleStart(0); 'Start sampling now
    endif;
    
	' Set Sequencer Variable #3 based on juicer type 
    SetJuicerSequencerVariable%();
    ' Clear any trigger bits on digout lines.
    SafeSampleKey("0");
    ttemp := View(DataWindow%).MaxTime();
    Yield();
    tLast := View(DataWindow%).MaxTime();
    PrintLog("ttemp " + str$(ttemp) + " tlast " + str$(tLast) + "\n");
    
    
    if attUseCueCircles% = 1 then
        CueCirc$ := CreateCueCircleColorSets$();
    endif;
    
    'get all these grating parameters
    stimSpec$ := GetGratingParameters$("Stimulus");
    ParseGratingParametersBrief%(stimSpec$, xTemp, yTemp, wTemp, hTemp);  'we may as well just do this every time - 90+% of the time we will anyway, and why put it in the if statements four times?
    if attNumPatches% > 1 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor1"), xTemp, yTemp, wTemp, hTemp);
            dist1Spec$ := ReplaceGratingXY$(stimSpec$,xTemp,yTemp);
        else
            dist1Spec$ := GetGratingParameters$("Distractor1");
        endif;
    endif;
    if attNumPatches% > 2 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor2"), xTemp, yTemp, wTemp, hTemp);
            dist2Spec$ := ReplaceGratingXY$(stimSpec$,xTemp,yTemp);
        else
            dist2Spec$ := GetGratingParameters$("Distractor2");
        endif;
    endif;
    if attNumPatches% > 3 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor3"), xTemp, yTemp, wTemp, hTemp);
            dist3Spec$ := ReplaceGratingXY$(stimSpec$,xTemp,yTemp);
        else
            dist3Spec$ := GetGratingParameters$("Distractor3");
        endif;
    endif;
    if attNumPatches% > 4 then
        if attGetGPFromMainStim% = 1 then
            ParseGratingParametersBrief%(GetGratingParameters$("Distractor4"), xTemp, yTemp, wTemp, hTemp);
            dist4Spec$ := ReplaceGratingXY$(stimSpec$,xTemp,yTemp);
        else
            dist4Spec$ := GetGratingParameters$("Distractor4");
        endif;
    endif;

    
    
    if attCustomGratingColorCheck% = 1 then
        var f$, t$;
        f$ := EncodeColor$(attCustomGratingColorStimFrom%[0], attCustomGratingColorStimFrom%[1], attCustomGratingColorStimFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorStimTo%[0], attCustomGratingColorStimTo%[1], attCustomGratingColorStimTo%[2]);
        stimSpec$ := ReplaceGratingColorVector$(stimSpec$, f$ + "-" + t$);
        f$ := EncodeColor$(attCustomGratingColorDistractorFrom%[0], attCustomGratingColorDistractorFrom%[1], attCustomGratingColorDistractorFrom%[2]);
        t$ := EncodeColor$(attCustomGratingColorDistractorTo%[0], attCustomGratingColorDistractorTo%[1], attCustomGratingColorDistractorTo%[2]);
        if attNumPatches% > 1 then
            dist1Spec$ := ReplaceGratingColorVector$(dist1Spec$, f$ + "-" + t$);
        endif;
        if attNumPatches% > 2 then
            dist2Spec$ := ReplaceGratingColorVector$(dist2Spec$, f$ + "-" + t$);
        endif;
        if attNumPatches% > 3 then
            dist3Spec$ := ReplaceGratingColorVector$(dist3Spec$, f$ + "-" + t$);
        endif;
        if attNumPatches% > 4 then
            dist4Spec$ := ReplaceGratingColorVector$(dist4Spec$, f$ + "-" + t$);
        endif;
    endif

    
	Stim$ := " -s " + stimSpec$;  
    if attNumPatches% > 1 then
            Stim$ := Stim$ + " -s " + dist1Spec$;
    endif;
    if attNumPatches% > 2 then
            Stim$ := Stim$ + " -s " + dist2Spec$;
    endif;
    if attNumPatches% > 3 then
            Stim$ := Stim$ + " -s " + dist3Spec$;
    endif;
    if attNumPatches% > 4 then
            Stim$ := Stim$ + " -s " + dist4Spec$;
    endif;
	CreateContrastList(Contrast$,attContrastList%,attChangeList%,attValidList%,attAttendList%,attHazardList,attOffBitsList%,attRotationList%,attFixColor%);  'Fills Contrast$ with the big ol' list, plus some vars to make it easier on us all   
    'Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$() + " -A " + str$(attAnswerPointOffset) + " -D " + str$(attAnswerPointDiameter) + lolSpec$;  'answer points on
    Extras$ := " -b " + attBackgroundColor$ + " -d " + GetDistanceToScreenMM$(); '+ " -N ";' + lolSpec$;  'answer points off, lollipop spec off as well
    'if attTrainingContrastCheck% = 1 then
    '    Extras$ := Extras$ + " -T " + str$(attTrainingContrastPct%);
    'endif
    
    'Hardcode the choice points to be red no matter what
    'Turns out that for the attention program the color in the fixation argument sets the color of the choice
    'points but that the actual fixation point is set differently.  FixationArg$ is created at the outset of
    'the script, but here I'm overriding the value to make the choice points always red.
    FixationArg$ := " -f " + str$(FixationX) + "," + str$(FixationY) + "," + str$(FixationDiameter) + ",red";
	
	'CommandLine$ := "cmd /c " + bin$ + "\\dAttention " + FixationArg$ + Extras$ + Distractors$;
	'CommandLine$ := "cmd /k " + bin$ + "\\Attention " + FixationArg$ + Extras$ + Stim$ + Contrast$;
    'CommandLine$ := "cmd /k " + bin$ + "\\Attention -F " + specFileName$;
    CommandLine$ := "cmd /k " + bin$ + "\\fixstim -F " + specFileName$;
    
    'open a file to write the trial-by-trial specs for the VSG
    specHandle% := FileOpen(specFileName$, 8, 1);
    'print to spec file
    Print("%s %s %s %s %s",FixationArg$,Extras$,Stim$,CueCirc$,Contrast$);  'file should be everything starting from FixationArg$ on
    'close spec file
	FileClose(0);
    
    'Print the parameters
    for i% := 1 to Len(CommandLine$) step 100 do
        SampleText(Mid$(CommandLine$, i%, 100));
    next
    
    
	'Begin the stimulus program. It will take a few seconds for the VSG to initialize.
	PrintLog(CommandLine$+"\n");
	StimHandle% := ProgRun(CommandLine$,1);
	if StimHandle% <0 then Message("Could not start stimulus."); halt; endif
	'Yield(5);	'Wait a few seconds to make sure the VSG has time to initialize.
	
	ToolbarSet(0,"",IdleProcessing%);	'Enable the IdleProcessing function
	ToolbarEnable(2,1);
	ToolbarEnable(1,0);
	ToolbarEnable(6,0);
	ToolbarEnable(7,0);
	View(DataWindow%);
	Yield(.1);
    return 1;
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' DrawStim
' 
' Draws stimulus in xy window (iDraw%==1) or blanks it (0). 
proc DrawStim(iDraw%)
    
	if iDraw% > 0 then
		var xstim, ystim;
		xstim := FixationX;
		ystim := FixationY;
        
		' Draw stimulus in xy window
		View(XYWindow%).XYAddData(iStimChannel%, xstim, ystim);
	else 
		' erase the stim and the window from xy view
		View(XYWindow%).XYDelete(iStimChannel%);
	endif
    
end;




'
'
'===== GetLogProgression =====

' Get a log progression from xmin to xmax, through nsteps%. Assumed that vec[] has enough room!
' There will be a total of nsteps%+1 values entered into vec[], vec[0] will be xmin, vec[nsteps%] will be xmax
Proc GetLogProgression(xmin, xmax, nsteps%, &vec[])
	var stepsize;
	var v;
	var i%:= 0;
	stepsize := (Ln(xmax) - Ln(xmin))/nsteps%;
	for v := Ln(xmin) to Ln(xmax)+stepsize/2 step stepsize do
		'PrintLog("Value[" + str$(i%) + "]=" + str$(Exp(v)) + "\n");
		vec[i%] := Exp(v);
		i% := i% + 1;
	next;
end;

'
'
'======= CreateContrastList =======
'Fill input variable c$ with the long-form contrast specifier for the Attention experiment
'and cList%[] with the actual contrast (at change) to be used on each trial - note that if this is equal to attContrastBase% then the trial is a non-target trial
'and chgList%[] with the stimulus location that is changed (new)
'and vList%[] with ones if valid and zeros for invalid trials
'and attList%[] for which stimulus is being attended (new)
'and hazList[] with the required hazard time (time to contrast change) for each trial (new)
'and offList%[] with a series of off-bits (1=stim 1 off, 2 = dist1 off, 4 = dist2 off, etc.) (new, probably not used later but nice to have in case)
'and rotList%[] with a series of rotation values
'and fixColor%[] with the current fixation color
'Creating all of these here (including easy trials) allows us to just blast through once we get to the actual experiment
'without too much counting going on.
Proc CreateContrastList(&c$,&cList%[],&chgList%[],&vList%[],&attList%[],&hazList[],&offList%[],&rotList%[],&fixColor%[])
    var i%;
    var j%;
    var k%;
    var tempInvalid%;  'holds number of invalid stimulus patch 
    var stdCount%;  'a counter for standard (i.e. "valid") trials, index into attTrialOrder%[]
    var catchCount%;  'a counter for catch trials
    var totalCount%;  'the current index of the xList% variables
    var blockCount%;
    var attDirection%;
    var attColor%;
    var alloff%;  'this is for the bitwise "off" indicator
    var cueCircleRotation% := 0;
    
    var blockTypes%[6];  'These are only used if we are "alternating" blocks and simultaneously using a no-change condition
    var btIndices%[6];  'index, for the shuffle
    var nBlockTypes%;
    var blockTypeIndex% := 0;
    
    
    'preliminaries for no-change condition, which messes with numbering because the number of distractors is variable
    if attNoChangeCondition% = 1 then    
        'If we are asked to "alternate" blocks and to use a No-Change condition, here's the protocol:
        'Create a list of legal block numbers (1 = on-RF, 2-5 = existing distractors, 6 = no-change)
        for i% := 0 to attNumPatches%-1 do
            blockTypes%[i%] := i%+1;
        next
        blockTypes%[attNumPatches%] := 6;  'no change value is hardcoded
        'printlog("original blocktype is %d\n",blockTypes%[]);
        'and shuffle the list
        Shuffle%(attNumPatches%+1,btIndices%[]);
        'printlog("shuffled blocktype is %d\n",blockTypes%[]);
    endif
    
    
    'calculate the value of alloff%, this is bitwise indicator if all stimuli are shut off
    'this is simply 2^0 + 2^1 + 2^2 ... + 2^(n-1), which is (2^n)-1
    alloff% := pow(2,attNumPatches%)-1;
    
    
    c$ := " -J " + Str$(attTimeToAnswer) + ",";  'put in the first two elements of the specifier string, the -J and the post-CC time
       
    for i% := 1 to attNumberOfBlocks% do
        
        'If we are alternating by block or randomizing by block, set attDirection% here, otherwise we set it on a trial-by-trial basis
        docase 
        'if randomizing by trial do nothing, this is dealt with later
        case attBlockAlternate% = 0 then
        'if a start block is specified and it is the first block, use that start block
        case i% = 1 and attStartBlock% > 0 then
            attColor% := attStartBlock%; 
            'Also, for the alternate+no change condition, get starting block index, because this cycles
            if attBlockAlternate% = 2 and attNoChangeCondition% = 1 then 
                for k% := 0 to len(btIndices%[])-1 do
                    if attStartBlock% = blockTypes%[btIndices%[k%]] then
                        blockTypeIndex% := k%+1;
                        'and cycle back to index zero if we go past the end
                        if blockTypeIndex% > attNumPatches% then  'attNumPatches% is right because there are attNumPatches%+1 total legal indices
                            blockTypeIndex% := 0;
                        endif;
                    endif
                next
            endif
        'if randomizing by block without a no-change, select random stim to attend (block > 1 or start block not specified)
        case attBlockAlternate% = 1 and attNoChangeCondition% = 0 then  'randomize by block, choose a random stimulus to attend for each block, all stims have equal probability
            attColor% := Floor(Rand(attNumPatches%,1));  'offset by 1 so the value comes out 1:N instead of 0:N-1    
        'if randomizing by block with a no-change, select random stim to attend (block > 1 or start block not specified)    
        case attBlockAlternate% = 1 and attNoChangeCondition% = 1 then  'randomize by block, choose a random stimulus to attend for each block, all stims including no-change have equal probability 
            attColor% := blockTypes%[btIndices%[Floor(Rand(attNumPatches%+1,0))]];  'do not offset by one, we are shuffling indices
        'if alternating without a no-change condition, every other block is on RF...note that randBlockOrderVar is appropriately changed above (in dialog code) if attStartOrder is set  
        case attBlockAlternate% = 2 and attNoChangeCondition% = 0 then  'alternate by block, every other block is on receptive field, blocks off RF are randomly selected
            if ((blockCount%+randBlockOrderVar%) mod 2) = 1 then
                attColor% := 1;  'Attend main stimulus
            else
                attColor% := Floor(Rand(attNumPatches%-1,2));  'choose a random stim to attend that is not the main
            endif
        'if alternating with a no-change condition, Henry wants to cycle through blocks, starting with attend-toward unless otherwise specified
        case attBlockAlternate% = 2 and attNoChangeCondition% = 1 then 
            'select a starting block from the list of legal starting blocks using an index
            attColor% := blockTypes%[btIndices%[blockTypeIndex%]]; 'this should put the randomization back in
            'update blockTypeIndex%
            blockTypeIndex% += 1;
            'and cycle back to index zero if we go past the end
            if blockTypeIndex% > attNumPatches% then  'attNumPatches% is right because there are attNumPatches%+1 total legal indices
                blockTypeIndex% := 0;
            endif;
        endcase
        
        
        for j% := 1 to attTrialsPerBlock%+attEasyTrialsPerBlock% do
            'if we are NOT alternating by block, choose a direction on each trial
            docase
            case attBlockAlternate% = 0 and attNoChangeCondition% = 0 then
                if (Rand(0.0) < 0.5) then
                    attColor% := 1;  'Attend main stimulus, this happens half the time
                else
                    attColor% := Floor(Rand(attNumPatches%-1,2));  'choose a random stim to attend that is not the main
                endif
            case attBlockAlternate% = 0 and attNoChangeCondition% = 1 then
                attColor% := blockTypes%[btIndices%[Floor(Rand(attNumPatches%+1,0))]];  'choose a straight-up random color, unless Hank sez otherwise
            endcase;
            
            fixColor%[totalCount%] := attColor%;  'this is the color of the fixation point, which is the same regardless of attention/valid/etc.  It's kind of ground truth and everything builds from there.            
            
            if j% <= attEasyTrialsPerBlock% then  'Note that Easy trials will now only happen if the attend directions are blocked
                attDirection% := attColor%;  'no tricks here, we won't rotate cue circles on "easy" trials
                vList%[totalCount%] := 1;  'all easy trials are valid
                hazList[totalCount%] := attHazardMinTime;  'don't calculate a hazard time, just use the minimum
                rotList%[totalCount%] := 0;  'no rotation on easy trials
                'rotList%[totalCount%] := attNumPatches%*(attColor%-1);  'no rotation on easy trials, but get cue circle contrast correct 
                if attDirection% <> 6 then 'for all blocks that are not no-change blocks, do this
                    chgList%[totalCount%] := attDirection%;  'set stimulus that changes
                    attList%[totalCount%] := attDirection%;  'set direction of attention
                    cList%[totalCount%] := 100;  'change easy trials to 100% contrast            
                    if distracterOffForEasy% = 1 then
                        offList%[totalCount%] := alloff% - Pow(2,attDirection%-1);  'turn off all stimuli but the attended one
                        'insert easy trial with 100% contrast
                        'note that for easy trials cueCircleRotation is 0 by definition, but just keeping this so the logic is consistent
                        'UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,100,attHazardMinTime,attPhaseDeg%,alloff%-Pow(2,attDirection%-1)+(256*cueCircleRotation%),masterColorListVSG$);  
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,100,attHazardMinTime,attPhaseDeg%,alloff%-Pow(2,attDirection%-1)+(256*rotList%[totalCount%]),masterColorListVSG$);  
                    else
                        offList%[totalCount%] := 0;  'show all grating patches                
                        'insert easy trial with 100% contrast
                        'UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,100,attHazardMinTime,attPhaseDeg%,0+(256*cueCircleRotation%),masterColorListVSG$);
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,100,attHazardMinTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                    endif;
                else
                    chgList%[totalCount%] := 0;  'no stimulus changes
                    cList%[totalCount%] := attContrastBase%;  'fill cList%[] with the base contrast
                    attList%[totalCount%] := attDirection%;  'set direction of attention, we still need to do this
                    offList%[totalCount%] := 0;  'show all grating patches
                    'insert no-go trial
                    'UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,attContrastBase%,trialHazardFunctionTime,attPhaseDeg%,0+(256*cueCircleRotation%),masterColorListVSG$);
                    UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,attContrastBase%,trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                endif;
                
              
            else 'regular trial
                'if we are cue-swapping, select set of cue circles
                if attSwapCueCircle% = 1 then
                    cueCircleRotation% := Floor(Rand(attNumPatches%,0));  '0 for no rotation, 1 for cycle forward 1, etc.
                endif
                rotList%[totalCount%] := cueCircleRotation%;
                'rotList%[totalCount%] := cueCircleRotation% + (attNumPatches%*(attColor%-1));  'set which rotation is being used, will be 0 if swapping is off               
                'determine stimulus being attended (i.e., which stimulus has the same cue circle color as the fixation point)
                if attColor% = 6 then 'on a no-change trial, just set direction to the arbitrary 6
                    attDirection% := 6;  
                else 'on a regular trial, add rotation
                    attDirection% := attColor% + cueCircleRotation%;  'add in the rotation
                    if attDirection% > attNumPatches% then  'get the modulus if necessary
                        attDirection% := attDirection% mod attNumPatches%; 
                    endif
                endif;
                
                attList%[totalCount%] := attDirection%;  'set direction of attention, same for regular or no-change trials
                
                if (Rand()*100 < attNoGoTrialPercentage) and attDirection% <> 6 then 'NoGo trial, don't do this on no-change trials, even though I guess it's the same thing
                    vList%[totalCount%] := 1;  'all no-go trials are valid
                    chgList%[totalCount%] := 0;  'no stimulus changes, it's a no-go -- note that we cannot pass 0 to UpdateTrialSpecString, though, so pass the attend direction
                    cList%[totalCount%] := attContrastBase%;  'fill cList%[] with the base contrast
                    trialHazardFunctionTime := RandExp(attHazardExpMeanTime, attHazardMinTime);
                    if trialHazardFunctionTime > attHazardCutoffTime then
                        trialHazardFunctionTime := attHazardCutoffTime;
                    endif;
                    hazList[totalCount%] := trialHazardFunctionTime;  'set hazard function time
                    offList%[totalCount%] := 0;  'show all grating patches
                    'insert no-go trial
                    'UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,attContrastBase%,trialHazardFunctionTime,attPhaseDeg%,0+(256*cueCircleRotation%),masterColorListVSG$);
                    UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,attContrastBase%,trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                else    
                    docase
                    case attDirection% = 6 then  'no-change trial, these are the same as no-go trials, but with a different fix color
                        vList%[totalCount%] := 1;  'all no-go trials are valid
                        chgList%[totalCount%] := 0;  'no stimulus changes, it's a no-go -- note that we cannot pass 0 to UpdateTrialSpecString, though, so pass the attend direction
                        cList%[totalCount%] := attContrastBase%;  'fill cList%[] with the base contrast
                        trialHazardFunctionTime := RandExp(attHazardExpMeanTime, attHazardMinTime);
                        if trialHazardFunctionTime > attHazardCutoffTime then
                            trialHazardFunctionTime := attHazardCutoffTime;
                        endif;
                        hazList[totalCount%] := trialHazardFunctionTime;  'set hazard function time
                        offList%[totalCount%] := 0;  'show all grating patches
                        'insert no-go trial
                        'UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,attContrastBase%,trialHazardFunctionTime,attPhaseDeg%,0+(256*cueCircleRotation%),masterColorListVSG$);
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,attContrastBase%,trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                    case (Rand()*100 < attCatchTrialPercentage) then 'catch trial
                        vList%[totalCount%] := 0;  'catch = invalid
                        trialHazardFunctionTime := RandExp(attHazardExpMeanTime, attHazardMinTime);
                        if trialHazardFunctionTime > attHazardCutoffTime then
                            trialHazardFunctionTime := attHazardCutoffTime;
                        endif;
                        hazList[totalCount%] := trialHazardFunctionTime;  'set hazard function time
                        offList%[totalCount%] := 0;  'show all grating patches
                        'select a random patch that is not the attended direction
                        tempInvalid% := ceil(rand(attNumPatches%,0));  'select a random patch for invalid stimuli
                        while tempInvalid% = attDirection% do  'it's not catch if it's the attended patch, try again
                            tempInvalid% := ceil(rand(attNumPatches%,0));  'yes, this is technically ugly but much easier to code than a method guaranteed to get a result in one shot
                        wend;
                        chgList%[totalCount%] := tempInvalid%;  'set stimulus that changes
                        if attOnlyOneCatch% = 0 then  'if we are doing a tuning curve over catch trials
                            cList%[totalCount%] := attContrastList[attCatchTrialOrder%[catchCount%]];
                        else  'if we are doing only one catch trial (note the commented stuff above is not re-included)
                            cList%[totalCount%] := attOneCatchContrast%;  'there is only one contrast
                        endif;
                        'insert catch trial
                        'UpdateTrialSpecString(c$,attColor%,tempInvalid%,attContrastBase%,cList%[totalCount%],trialHazardFunctionTime,attPhaseDeg%,0+(256*cueCircleRotation%),masterColorListVSG$);
                        UpdateTrialSpecString(c$,attColor%,tempInvalid%,attContrastBase%,cList%[totalCount%],trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                        catchCount% += 1;  
                    case (Rand()*100 < attUncatchTrialPercentage) then 'uncatch trial
                        'this is guaranteed to go along with attOnlyOneCatch% = 1
                        vList%[totalCount%] := 1;  'uncatch = valid
                        cList%[totalCount%] := attOneCatchContrast%;  'there is only one contrast
                        trialHazardFunctionTime := RandExp(attHazardExpMeanTime, attHazardMinTime);
                        if trialHazardFunctionTime > attHazardCutoffTime then
                            trialHazardFunctionTime := attHazardCutoffTime;
                        endif;
                        hazList[totalCount%] := trialHazardFunctionTime;  'set hazard function time
                        offList%[totalCount%] := 0;  'show all grating patches
                        chgList%[totalCount%] := attDirection%;  'set stimulus that changes
                        'insert uncatch trial
                        'UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,cList%[totalCount%],trialHazardFunctionTime,attPhaseDeg%,0+(256*cueCircleRotation%),masterColorListVSG$);
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,cList%[totalCount%],trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                    else  'valid trial
                        vList%[totalCount%] := 1;  'valid
                        cList%[totalCount%] := attContrastList[attTrialOrder%[stdCount%]];
                        trialHazardFunctionTime := RandExp(attHazardExpMeanTime, attHazardMinTime);
                        if trialHazardFunctionTime > attHazardCutoffTime then
                            trialHazardFunctionTime := attHazardCutoffTime;
                        endif;
                        hazList[totalCount%] := trialHazardFunctionTime;  'set hazard function time
                        offList%[totalCount%] := 0;  'show all grating patches
                        chgList%[totalCount%] := attDirection%;  'set stimulus that changes
                        'insert uncatch trial
                        'UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,cList%[totalCount%],trialHazardFunctionTime,attPhaseDeg%,0+(256*cueCircleRotation%),masterColorListVSG$);
                        UpdateTrialSpecString(c$,attColor%,attDirection%,attContrastBase%,cList%[totalCount%],trialHazardFunctionTime,attPhaseDeg%,0+(256*rotList%[totalCount%]),masterColorListVSG$);
                        stdCount% += 1;
                    endcase;
                endif;
            endif;
            totalCount% += 1;
        next; 
        blockCount% += 1;
    next;
    c$ := Left$(c$,len(c$)-1); 'remove trailing comma from the list
end;


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ParseGratingParametersBrief%(gr$, &x, &y, &w, &h);
' 
' Given a grating parameter list, parse the individual values in to the given variable list. 
' Simpler version than the full-blown one, as it doesn't return all values. 
' This version will work for all possible variable list lengths - with/without phase/cv/pattern/aperture/inner/outer
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func ParseGratingParametersBrief%(gr$, &x, &y, &w, &h)
    var status% := 0;
    var n%;
	ReadSetup("", "", "", "", ",");
	n% := ReadStr(gr$, x, y, w, h);
    ReadSetup();
    if n% <> 4 then status% := -1; endif;
    return n%;
end


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc WriteParameterFile()
	var parFileName$;
	var parFileBase$;
	var parHandle%;
    var tempPrimary$;
    var tempSecondary$;

	' get filename for parfile (data file + "par" extension) and open it
	View(DataWindow%);
	parFileBase$ := FileName$(1) + FileName$(2) + FileName$(3) + FileName$(4);
	parFileName$ := parFileBase$ + ".par";
	PrintLog("par filename is " + parFileName$ + "\n");
	parHandle% := FileOpen(parFileName$, 8, 1);

	' write general info - eye coil gains, dist to screen
	Print("Tuning parameters for %s\n\n", parFileBase$);

	Print("General information\n");
	Print("-------------------\n\n");
	Print("Distance to screen (MM)    : %s\n", GetDistanceToScreenMM$());
	Print("Eye coil software gain (X) : %f\n", DegreesPerVoltX);
	Print("Eye coil software gain (Y) : %f\n", DegreesPerVoltY);
	Print("Eye coil sampling freq (Hz): %d\n", EyeCoilSamplingFrequency%);
    Print("Wavemark ports             : %s\n", GetWavemarkPorts$());
    Print("Continuous ports           : %s\n", GetContinuousPorts$());
	Print("Reward size (ms)           : %d\n", GetJuiceRewardMS%());
	'Print("Background color           : %s\n", tunBackgroundColor$);

	' write fixpoint parameters
	Print("\nFixation point\n");
	Print("-------------------\n\n");
	Print("Window radius              : %f\n", WindowRadius);
	Print("Position (x, degrees)      : %f\n", FixationX);
	Print("Position (y, degrees)      : %f\n", FixationY);
	Print("Diameter (degrees)         : %f\n", FixationDiameter);
	Print("Color                      : %s\n", FixationColor$);

	' write stimulus parameters
	var Tstimstr$;
	var Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$;
	var i%;
	var Tstepsize;
    var phase;
    Print("\nStimulus\n");  'Master grating
	Print("-------------------\n\n");
	Tstimstr$ := GetGratingParameters$("Stimulus");
	ReadSetup(",",",",",",",",",");
	i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
	Print("Position (x, degrees)           : %s\n", Tstimx$);
	Print("Position (y, degrees)           : %s\n", Tstimy$);
	Print("Width (degrees)                 : %s\n", Tstimw$);
	Print("Height (degrees)                : %s\n", Tstimh$);
    Print("Inner Width (degrees)           : %s\n", Tstimiw$);
	Print("Inner Height (degrees)          : %s\n", Tstimih$);
	Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
    Print("Temporal frequency              : %s\n", Tstimtf$);
	Print("Spatial frequency               : %s\n", Tstimsf$);
	Print("Orientation (degrees)           : %s\n", Tstimorientation$);
    Print("Initial Phase (degrees)         : %f\n", phase);
	Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
	Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
	Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        
    ' write distractor parameters
    if attNumPatches% > 1 then
        Print("\nDistractor1\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor1");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            Print("Initial Phase (degrees)         : %f\n", phase);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
    endif;
    if attNumPatches% > 2 then
        Print("\nDistractor2\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor2");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            Print("Initial Phase (degrees)         : %f\n", phase);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
    endif;
    if attNumPatches% > 3 then
        Print("\nDistractor3\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor3");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            Print("Initial Phase (degrees)         : %f\n", phase);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
    endif;
    if attNumPatches% > 4 then
        Print("\nDistractor4\n");  'Distractor grating
        Print("-------------------\n\n");
        Tstimstr$ := GetGratingParameters$("Distractor4");
        ReadSetup(",",",",",",",",",");
        i% := ReadStr(Tstimstr$, Tstimx$, Tstimy$, Tstimw$, Tstimh$, Tstimiw$, Tstimih$, Tstimcontrast$, Tstimsf$, Tstimtf$, Tstimorientation$, Tstimphase$, Tstimcv$, Tstimp$, Tstimap$);
        Print("Position (x, degrees)           : %s\n", Tstimx$);
        Print("Position (y, degrees)           : %s\n", Tstimy$);
        if attGetGPFromMainStim% = 0 then
            Print("Width (degrees)                 : %s\n", Tstimw$);
            Print("Height (degrees)                : %s\n", Tstimh$);
            Print("Inner Width (degrees)           : %s\n", Tstimiw$);
            Print("Inner Height (degrees)          : %s\n", Tstimih$);
            Print("Color: b/w(b),lms-cone(l,m,s)   : %s\n", Tstimcv$);
            Print("Temporal frequency              : %s\n", Tstimtf$);
            Print("Spatial frequency               : %s\n", Tstimsf$);
            Print("Orientation (degrees)           : %s\n", Tstimorientation$);
            Print("Initial Phase (degrees)         : %f\n", phase);
            Print("Contrast (%%)                    : %s\n", Tstimcontrast$);
            Print("Aperture: ellipse(e)/square(q)  : %s\n", Tstimap$);
            Print("Type: sine (s)/square (q)       : %s\n", Tstimp$);
        endif;
    endif;
    
    
	Print("\nExperimental parameters\n");
	Print("-------------------------\n\n");

	Print("Acquisition time (s)   : %f\n", attAcquisitionTime);
    Print("Min fixation cue time (s)   : %f\n", attFixationCueMinTime);
    Print("Max fixation cue time (s)   : %f\n", attFixationCueMaxTime);
    Print("Min Hazard time (s)   : %f\n", attHazardMinTime);
    Print("Mean Hazard time (s)   : %f\n", attHazardExpMeanTime);
    Print("Hazard Cutoff time (s)   : %f\n", attHazardCutoffTime);
    Print("Time to answer (s)   : %f\n", attTimeToAnswer);
    Print("No Change Duration (s)   : %f\n", attNoChangeDuration);
    Print("Intertrial time (s)   : %f\n", attInterTrialTime);
    Print("Abort penalty time (s)   : %f\n", attAbortWaitTime);
    Print("False Alarm penalty time (s)   : %f\n", attFalseAlarmWaitTime);
    Print("False Alarm check window (s)   : %f\n", attFalseAlarmCheckWindow);
    Print("Miss penalty time (s)   : %f\n", attMissPenalty);
    
    
	Print("\nTuning parameters\n");
	Print("-------------------\n\n");    
    'Print("Min,Max,#Steps,#Repeats: %f,%f,%d,%d\n", tunContrastMinContrast, tunContrastMaxContrast, tunContrastNSteps%, tunContrastNRepeats%);
    
    Print("Number of blocks   : %d\n", attNumberOfBlocks%);
    Print("Trials per block   : %d\n", attTrialsPerBlock%);
    Print("Easy trials per block   : %d\n", attEasyTrialsPerBlock%);
    Print("Distracter off for easy trials?   : %d\n", distracterOffForEasy%);
    Print("Catch trial percentage   : %f\n", attCatchTrialPercentage);
    Print("No-go trial percentage   : %f\n", attNoGoTrialPercentage);
    Print("Alternate Cue Type by block?   : %d\n", attBlockAlternate%);
    Print("Do NOT randomize by block?   : %d\n", attSelectRandomContrastEachTrial%);
    Print("Base Contrast   : %d\n", attContrastBase%);
    Print("Max contrast change   : %f\n", attMaxContChange);
    Print("Min contrast change   : %f\n", attMinContChange);
    Print("N Contrast levels   : %d\n", attNContLevels%);
    'Print("Answer point window radius   : %f\n", attAnswerPointWindowRadius);  'currently not used
    Print("Use Training Contrast?   : %d\n", attTrainingContrastCheck%);
    Print("Training contrast   : %d\n", attTrainingContrastPct%);
    Print("Set phase at contrast change?   : %d\n", attPhaseCheck%);
    Print("Phase at contrast change   : %d\n", attPhaseDeg% );
    Print("Number of Distractors     : %d\n", attNumPatches%);
    Print("Get distractor params from main stim?     : %d\n", attGetGPFromMainStim%);
    Print("Use only one catch contrast?     : %d\n", attOnlyOneCatch%);
    Print("Value of only catch contrast   : %d\n", attOneCatchContrast%);
    Print("Do 'uncatch'     : %d\n", attDoUncatch%);
    Print("Use cue circles?    : %d\n", attUseCueCircles%);
    Print("Cue Circle extra radius    : %f\n", attCueCircleExtraRadius);
    Print("Start Block     : %d\n", attStartBlock%);
    Print("No Change Condition    : %d\n", attNoChangeCondition%);
    Print("Swap Cue Circle    : %d\n", attSwapCueCircle%);  
            

    
    Print("Values: " + Contrast$ + "\n");
    Print("\n");

	' close parfile
	FileClose(0);

end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Calculates initial phase given params
func GetInitialPhase%(phaseAtCC%,tempFreq,dur)
    'phases in degrees (integer)
    'temporal frequency in Hz
    'duration in seconds
    var Po%;
    var deg;
    var deg%;
    
    deg := (360*((tempFreq*dur)mod 1));
    deg% := round(deg);  'this corrects to nearest degree, non-explicit conversion of real to int results in a floor operation
    
    'This is the way you would THINK it would work
    'Po% := phaseAtCC% - deg%;
    'Po% := phaseAtCC% - (360*((tempFreq*dur)mod 1));
    'if Po% < 0 then
    '    Po% := Po% + 360;
    'endif;
    
    'This is the way it actually works, because the grating drifts "backwards" - that is to say that if the grating
    'starts at 150 degrees and drifts through 30 degrees, the final grating position is 120 degrees, not 180 degrees.  
    Po% := phaseAtCC% + deg%;
    if Po% <= 360 then
        Po% := Po% - 360;
    endif;
        
    'printlog("Requested initial phase is %d\n",Po%);
    return Po%;
    
end


func GetStimulusTF(stim%)
    var gr$;
    var x, y, w, h, iw, ih, sf, tf, ori, phase;
    var contrast%;
    var cv$, pattern$, aperture$;
    docase
    case stim% = 1 then
        gr$ := GetGratingParameters$("Stimulus");
    case stim% = 2 then
        gr$ := GetGratingParameters$("Distractor1");
    case stim% = 3 then
        gr$ := GetGratingParameters$("Distractor2");
    case stim% = 4 then
        gr$ := GetGratingParameters$("Distractor3");
    case stim% = 5 then
        gr$ := GetGratingParameters$("Distractor4");  
    endcase;    
    ParseGratingParameters%(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    LogStatus("GetStimulusTF", "TF=" + str$(tf));
    return tf;
end


proc UpdateTrialSpecString(&c$,attdir%,chgdir%,base%,chg%,haz,phase%,off%,colListVSG$[])
    var col$;
    var trainbase%;
    
    'if we are using training contrast, set non-changing gratings to different base contrast
    if attTrainingContrastCheck% = 1 then
        trainbase% := attTrainingContrastPct%;
    else
        trainbase% := base%;  'by default we will use the same base
    endif;
    
    
    'order of colors is red, [green, cyan, yellow, magenta], (blue) ... [distractors] (no-change)
    'This comes form the same color list, so they do correspond
    'printlog("attdir is %d\n",attdir%);
    col$ := colListVSG$[attdir%-1]; 
    c$ := c$ + col$ + ",";  'add color spec
    
    'get temporal frequency of the changing grating
    var tf;
    var initphase%;
    if attGetGPFromMainStim% = 1 then  'use main value if we're getting values from main
        tf := GetStimulusTF(1);  '1 is Stimulus1 
    else
        tf := GetStimulusTF(chgdir%);  'or actual changing value if not
                                       '2 is Distracter1, 3 is Distracter2, etc.
    endif;
    
    'set phase
    if phase% < 0 then
        initphase% := 0;
    else
        initphase% := GetInitialPhase%(phase%,tf,haz);
    endif;

    c$ := c$ + Str$(initphase%) + ",";  'add initial phase
    
    c$ := c$ + Str$(haz) + ",";  'add hazard time
    
    c$ := c$ + Str$(off%) + ",";  'add offbits, these are already updated based on the rotation of the cue circles
    
    'now go through the base and change contrasts
    var k%;
   for k% := 1 to attNumPatches% do
        if k% = chgdir% then  'do base and change
            c$ := c$ + Str$(base%) + "," + Str$(chg%) + ",";
        else 'change is identical to original, typically trainbase% = base% but if training contrast is on that is not necessarily true
            c$ := c$ + Str$(trainbase%) + "," + Str$(trainbase%) + ",";
        endif;
    next;  
    
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' ParseGratingParameters%(gr$, &x, &y, &w, &h, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
' 
' Given a grating parameter list, parse the individual values in to the given variable list. 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func ParseGratingParameters%(gr$, &x, &y, &w, &h, &iw, &ih, &contrast%, &sf, &tf, &ori, &phase, &cv$, &pattern$, &aperture$)
    var status% := 0;
    var n%;
    var str1$, str2$, str3$, str4$, str5$, str6$, str7$, str8$;
    var str9$, str10$, str11$, str12$, str13$, str14$;
	ReadSetup("", "", "", "", ",");
    'Do initial read to determine how many variables are present
    n% := ReadStr(gr$, str1$, str2$, str3$, str4$, str5$, str6$, str7$, str8$, str9$, str10$, str11$, str12$, str13$, str14$);
    
    docase
    case n% = 8 or n% = 9 or n% = 12 then
        'If the read gets 8 (no phase or strings), 9 (no strings) or 12 (everything) variables this is the correct read
        n% := ReadStr(gr$, x, y, w, h, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    case n% = 11 then
        'If there are 11 variables read (strings, no phase) the correct read omits phase
        n% := ReadStr(gr$, x, y, w, h, contrast%, sf, tf, ori, cv$, pattern$, aperture$); 
    case n% = 14 then
        'If 14 parameters are present, inner width and outer width are set
        n% := ReadStr(gr$, x, y, w, h, iw, ih, contrast%, sf, tf, ori, phase, cv$, pattern$, aperture$);
    else
        
    endcase; 
    ReadSetup();
    if n% < 11 then 'Return -1 as status if there is no cv$/pattern$/aperture$
        status% := -1; 'otherwise return 0 if cv$/pattern$/aperture$ are present
                       'there is currently no return scheme to indicate that phase is present
    endif;
    return status%;
end




''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'
' FadeColorToGray$(rgb[]%,contrast%)
' 
' Takes an RGB direction and applies the value from CONTRAST to fade the color towards gray.  Gray
' is taken to be 128,128,128 in RGB.  Returns a string in the format (255/255/0) which is placed
' directly into the command line.
' Valid contrast values are integers between 0 (will return 128,128,128 for any value) and 128 (will
' return 256*the input RGB value (e.g. for green 0,1,0 will return 0,256,0)
' Valid RGB directions are:
' Red     - 1,0,0
' Green   - 0,1,0
' Blue    - 0,0,1
' Yellow  - 1,1,0
' Cyan    - 0,1,1
' Magenta - 1,0,1
' Black   - 0,0,0
' White   - 1,1,1
' For super convenience have changed this so that rgb% is 1x3 vector to split into r% g% b%
' No other direction is legal; r%, g%, and b% must have a value of 0 or 1.
' 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''


func FadeColorToGray$(rgb%[],contrast%)
    var r$;
    var g$;
    var b$;
    var r%;
    var g%;
    var b%;
    var r2%;
    var g2%;
    var b2%;
    var out$;
    
    r% := rgb%[0];
    g% := rgb%[1];
    b% := rgb%[2];
    
    'Don't let the programmer mess this up
    var error$ := "Error!";
    if r% <> 0 and r% <> 1 then
        return error$;
    endif
    if g% <> 0 and g% <> 1 then
        return error$;
    endif
    if b% <> 0 and b% <> 1 then
        return error$;
    endif
    'Calculate RGB colors
    if r% = 1 then
        r2% := 128 + contrast%;
    else
        r2% := 128 - contrast%;
    endif
    if g% = 1 then
        g2% := 128 + contrast%;
    else
        g2% := 128 - contrast%;
    endif
    if b% = 1 then
        b2% := 128 + contrast%;
    else
        b2% := 128 - contrast%;
    endif
    'don't allow 256, VSG (presumably) doesn't allow this value
    if r2% = 256 then
        r2% := 255;
    endif
    if g2% = 256 then
        g2% := 255;
    endif
    if b2% = 256 then
        b2% := 255;
    endif
    'set output string
    out$ := "(" + Str$(r2%) + "/" + Str$(g2%) + "/" + Str$(b2%) + ")";
    return out$;
end



'
'
'======= CreateCueCircleColorSets =======
'This function creates the cue circle color sets which are the basis of Cue Circle Swapping and
'Start%() places in CueCirc$ for inclusion in the long spec file.

func CreateCueCircleColorSets$()
    
    var CueCirc$;
    var stimRGB%[3];
    var D1RGB%[3];
    var D2RGB%[3];
    var D3RGB%[3];
    var D4RGB%[3];
    
    var RGBColors%[5][3];
    var ContrastList%[5];    
    var i%;
    var j%;
    var k%;
    var x%;
    var y%;
    
    'assign RGB colors for cue circles
    'These colors have to be in the same order as the ones specified in UpdateTrialSpecString!
    'Stim over receptive field cue color is red
    stimRGB%[0] := 1;
    stimRGB%[1] := 0;
    stimRGB%[2] := 0;
    'Distractor1 cue color is green
    D1RGB%[0] := 0;
    D1RGB%[1] := 1;
    D1RGB%[2] := 0;
    'Distractor2 cue color is cyan, DO NOT USE BLUE as this conflicts with blue fixation point (which means no contrast change)
    D2RGB%[0] := 0;
    D2RGB%[1] := 1;
    D2RGB%[2] := 1;
    'Distractor3 cue color is yellow
    D3RGB%[0] := 1;
    D3RGB%[1] := 1;
    D3RGB%[2] := 0;
    'Distractor4 cue color is magenta
    D4RGB%[0] := 1;
    D4RGB%[1] := 0;
    D4RGB%[2] := 1;
    
    'assign RGB colors for cue circles
    'These colors have to be in the same order as the ones specified in UpdateTrialSpecString!
    'Stim over receptive field cue color is red
    RGBColors%[0][0] := 1;
    RGBColors%[0][1] := 0;
    RGBColors%[0][2] := 0;
    'Distractor1 cue color is green
    RGBColors%[1][0] := 0;
    RGBColors%[1][1] := 1;
    RGBColors%[1][2] := 0;
    'Distractor2 cue color is cyan, DO NOT USE BLUE as this conflicts with blue fixation point (which means no contrast change)
    RGBColors%[2][0] := 0;
    RGBColors%[2][1] := 1;
    RGBColors%[2][2] := 1;
    'Distractor3 cue color is yellow
    RGBColors%[3][0] := 1;
    RGBColors%[3][1] := 1;
    RGBColors%[3][2] := 0;
    'Distractor4 cue color is magenta
    RGBColors%[4][0] := 1;
    RGBColors%[4][1] := 0;
    RGBColors%[4][2] := 1;
    
    'assign contrasts
    ContrastList%[0] := attCueCircleContrastStim%;
    ContrastList%[1] := attCueCircleContrastD1%;
    ContrastList%[2] := attCueCircleContrastD2%;
    ContrastList%[3] := attCueCircleContrastD3%;
    ContrastList%[4] := attCueCircleContrastD4%;
    
'    'This is crazy-ass code that I can't even explain but it works.
'    'Actually, NO, IT DOESN'T WORK.  So there.
'    'What you get is Cue Circles for red valid (followed by rotations of red-valid if applicable), then Cue Circles for green valid (followed by rotations of green-valid if applicable)...
'    CueCirc$ := "-Q ";  'starter
'    for i% := 0 to attNumPatches%-1 do
' 
'        if i% > 0 then  'this puts the comma in, but not in front of the very first entry where it would be a syntax error
'            CueCirc$ := CueCirc$ + ",";
'        endif;
'        'This section determines the correct index into the contrast list.  Contrasts are rotated
''        x% := j% - i%;
''        if x% < 0 then
''            x% := attNumPatches% + x%;
''        endif
'        'This section writes the radius (always the same) and the color, based on the color list and the requested, rotated contrast
'        'This means that contrast 0 (the "valid" contrast) is always paired with the color that is the same color as the fixation point
'        CueCirc$ := CueCirc$ + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(RGBColors%[i%][0:3],ContrastList%[i%]);     
'    next
'        'NOW, if we are ALSO doing swap cue circle, we have to create a series of rotations where the valid contrast remains
'        'paired with the valid color, but the valid color moves position
'        for j% := 1 to attNumPatches%-1 do
'            if attSwapCueCircle% = 1 then
'                for k% := 0 to attNumPatches%-1 do  'robust to 0, does not execute
'                    y% := k% - j%;
'                    if y% < 0 then
'                        y% := attNumPatches% + y%;
'                    endif
'                    'This section determines the correct index into the contrast list.  Contrasts are rotated
'                    x% := y% - i%;
'                    if x% < 0 then
'                        x% := attNumPatches% + x%;
'                    endif
'                    CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(RGBColors%[y%][0:3],ContrastList%[x%]);
'                next
'            endif
'        next        
'    'next
'    
'    'put in closing space
'    CueCirc$ := CueCirc$ + " ";
    
    
    
    'Put in cue circle opener and first cue circle, which always happens
    CueCirc$ := "-Q " + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);
    
    docase
    case attNumPatches% = 2 then
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
        'end of first cue color circle set, rotate if attSwapCueCircle is 1
        if attSwapCueCircle% = 1 then
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
        endif
        
    case attNumPatches% = 3 then
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
        'end of first cue color circle set, rotate if attSwapCueCircle is 1
        if attSwapCueCircle% = 1 then
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            'end of second cue color circle set, rotate
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
        endif
        
    case attNumPatches% = 4 then
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D3RGB%[],attCueCircleContrastD3%);  'Add D3
        'end of first cue color circle set, rotate if attSwapCueCircle is 1
        if attSwapCueCircle% = 1 then
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D3RGB%[],attCueCircleContrastD3%);  'Add D3
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
            'end of second cue color circle set, rotate
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D3RGB%[],attCueCircleContrastD3%);  'Add D3
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            'end of third cue color circle set, rotate
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D3RGB%[],attCueCircleContrastD3%);  'Add D3
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
        endif
        
    case attNumPatches% = 5 then   
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D3RGB%[],attCueCircleContrastD3%);  'Add D3
        CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D4RGB%[],attCueCircleContrastD4%);  'Add D4
        'end of first cue color circle set, rotate if attSwapCueCircle is 1
        if attSwapCueCircle% = 1 then
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D4RGB%[],attCueCircleContrastD4%);  'Add D4
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D3RGB%[],attCueCircleContrastD3%);  'Add D3
            'end of second cue color circle set, rotate
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D3RGB%[],attCueCircleContrastD3%);  'Add D3
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D4RGB%[],attCueCircleContrastD4%);  'Add D4
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
            'end of third cue color circle set, rotate
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D3RGB%[],attCueCircleContrastD3%);  'Add D3
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D4RGB%[],attCueCircleContrastD4%);  'Add D4
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            'end of fourth cue color circle set, rotate
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D1RGB%[],attCueCircleContrastD1%);  'Add D1
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D2RGB%[],attCueCircleContrastD2%);  'Add D2
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D3RGB%[],attCueCircleContrastD3%);  'Add D3
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(D4RGB%[],attCueCircleContrastD4%);  'Add D4
            CueCirc$ := CueCirc$ + "," + Str$(attCueCircleExtraRadius) + "," + FadeColorToGray$(stimRGB%[],attCueCircleContrastStim%);  'Add Stim
        endif
    endcase;

    
    'put in closing space
    CueCirc$ := CueCirc$ + " ";
    
    return CueCirc$;
end
