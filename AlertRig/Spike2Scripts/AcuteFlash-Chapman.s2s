' $Id: AcuteFlash-Chapman.s2s,v 1.1 2012-10-23 17:56:56 devel Exp $


var hView,hExperiment;
var hDataWindow%;
var hHistWindow%;
var hHistCursor%;
var hStimulus%;
var bgTotalCounts:=0;
var bgTotalTime:=0;
var bin$;
var nRead%;
var iScreenDistanceMM%;
var nChannels% := 1;
var nRepeats% := 1;
var TriggerChannel%;
var colorSel%[4];
var times[4];
var nFlash% := 0;

var tPeriod;
var dDiameter;
var sFilePathRoot$;	' dir for current experiment. 
var sFileNameRoot$;	' base name for data files
var sParameterFilePath$;
var sParameterFileName$;
bin$ := View(App(3)).FileName$(1) + View(App(3)).FileName$(2) + "..\\bin";	' Location of executables is ..\bin, relative to script dir

' jump through a couple of hoops to determine what folder to store the data files in. 
'View(App(0)).Window(0,0,50,100);
hView := FileOpen("C:\\AcuteRig\\Experiments\\CurrentExperiment.par",8,0);
nRead% := Read(sFilePathRoot$);
FileClose();
if nRead% >0 then
	hExperiment := FileOpen(sFilePathRoot$+"\\Experiment.par",8,0);
	nRead% := Read(iScreenDistanceMM%);
	nRead% := Read(sFileNameRoot$);
	PrintLog("Data file path %s filename base %s\n", sFilePathRoot$, sFileNameRoot$);
	FileClose();
endif
View(SampleHandle(1)).WindowVisible(0);

' location for data files
sParameterFilePath$ := sFilePathRoot$ + "\\DataFiles\\";
PrintLog("Parameter file path is " + sParameterFilePath$ + "\n");

if AFDialog%() = 0 then
	halt;
endif


TriggerChannel% := nChannels% + 1;

' sampling config
CreateSampleConfiguration();


' open data window
hDataWindow%:=FileNew(0,4);
View(hDataWindow%).WindowVisible(1);
View(hDataWindow%).Window(0,0,100,50);
View(hDataWindow%).XRange(0, 30);
View(hDataWindow%);
sParameterFilePath$ := FileName$(1) + FileName$(2);
sParameterFileName$ := FileName$(3) + FileName$(4) + ".par";

' Set toolbar and wait for the "go" signal
ToolbarSet(1,"Quit",Quit%);
ToolbarSet(2,"Sample start",Start%);
ToolbarSet(3,"Sample stop", Stop%);
ToolbarEnable(1, 0);
ToolbarEnable(2, 1);
ToolbarEnable(3, 0);
Toolbar("Go",1234);



'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func AFDialog%()
	times[0] := 1;
	times[1] := 1;
	times[2] := 1;
	times[3] := 1;
	DlgCreate("Stimulus Parameters");
	DlgInteger(1, "Number of channels: ",1,8);
	DlgInteger(2, "Number of repeats: ",1,100);
	DlgList(3, "Color 1", "NONE|Black|Gray|White", 4);   ' WARNING!!! HARD-CODED See WriteParameterFile()
	DlgReal(4, "Time(s) 1", 0.01, 100.0);                ' and values for const stateBlack% et al. 
	DlgList(5, "Color 2", "NONE|Black|Gray|White", 4);
	DlgReal(6, "Time(s) 2", 0.01, 100.0);
	DlgList(7, "Color 3", "NONE|Black|Gray|White", 4);
	DlgReal(8, "Time(s) 3", 0.01, 100.0);
	DlgList(9, "Color 4", "NONE|Black|Gray|White", 4);
	DlgReal(10, "Time(s) 4", 0.01, 100.0);
	return DlgShow(nChannels%, nRepeats%,  colorSel%[0], times[0], colorSel%[1], times[1], colorSel%[2], times[2], colorSel%[3], times[3]);
end

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func Quit%()
	return 0;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func Start%()
	var sCommand$;
	var sFlashArg$ := " -p ";
	var sPattern$;
	var i%;
	var iStop% := 0;

	while i% < 4 and iStop% = 0 do
		if colorSel%[i%] = 0 then
			iStop% := 1;
		else
			nFlash% += 1;
			if i% > 0 then 
				sFlashArg$ += ",";
			endif
			docase 
			case colorSel%[i%] = 1 then
				sFlashArg$ += "0,0,0," + str$(times[i%]);
				sPattern$ += "B";
			case colorSel%[i%] = 2 then
				sFlashArg$ += "0.5,0.5,0.5," + str$(times[i%]);
				sPattern$ += "G";
			case colorSel%[i%] = 3 then
				sFlashArg$ += "1,1,1," + str$(times[i%]);
				sPattern$ += "W";
			endcase
		   i% += 1;
		endif
	wend

	sCommand$ := bin$ + "\\colorflash -n -A -r " + str$(nRepeats%) + sFlashArg$;
	PrintLog("Command line: " + sCommand$ + "\n");
	SampleStart(0);
	SampleText(sPattern$);
	hStimulus% := ProgRun(sCommand$ , 1);
	Yield(5);
	ToolbarEnable(2, 0);
	ToolbarEnable(3, 1);
	ToolbarSet(0,"",IdleProcessing%);
	return 1;
end;

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

func Stop%()
	if ProgStatus(hStimulus%) = 1 then ProgKill(hStimulus%); endif
	ProgRun(bin$ + "\\cleartrigger",0);
	ToolbarSet(0,"");
	SampleStop();

	' Write parameters to file for posterity
	WriteParameterFile();


	ToolbarEnable(3, 0);
	ToolbarEnable(1, 1);

	return 1; 
end; 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''







proc WriteParameterFile()
	var ParViewHandle;
	var i%;
	var stmp$[4];
	stmp$[0] := "NONE";
	stmp$[1] := "Black";
	stmp$[2] := "Gray";
	stmp$[3] := "White";
	FilePathSet(sParameterFilePath$);

	ParViewHandle := FileOpen(sParameterFilePath$ + sParameterFileName$,8,1);
	if ParViewHandle <0 then Message("Could not create parameter file "+sParameterFilePath$+sParameterFileName$);
	else
		Print("[stimulus]\n");
		Print("\"Number Of Channels\" %d\n",nChannels%);
		Print("\"Number of repeats\" %d\n",nRepeats%);
		for i% := 0 to 3 do
			Print("\"Color/Time %d: \" %s/%f\n", i%, stmp$[colorSel%[i%]], times[i%]);
	   next
	endif
end



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
proc CreateSampleConfiguration()
var index;
var TimeLimit;
SampleClear(); 'Set standard sampling state
SampleAutoFile(1); 'Enable automatic file naming
SampleAutoName$(sFileNameRoot$ + "_chap_00");
' location for data files
FilePathSet(sFilePathRoot$+"\\DataFiles\\", 3);

'SampleAutoComment(1); 'Prompt for comment after sampling
SampleAutoCommit(60); 'Seconds between each file commit

'Channel recording definitions

for index := 1 to nChannels% do
	SampleWaveMark(index,index-1,2000,34,15,28000); ' chan, port, event rate, points, pre-trigger, rate
	SampleTitle$(index, "Chan " + str$(index));
next

SampleEvent(nChannels%+1,1,1,1000); 
SampleTitle$(nChannels%+1, "Trigger");

' text mark for recording pattern
SampleTextMark(16);

SampleOptimise(2,2,2,2,50);  'Set optimise mode (do this last)
SampleMode(1); 'Continuous sampling
end;


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

var tTrigger := 0;
var tTriggerLast := 0;
var nCountBlocks% := 0;		' this is the number of blocks COMPLETED
var nCountRepeats% := 0;	' this is the number of  b/w cycles COMPLETED
var iCycle% := -1;				' keep track of where in cycle we are; increment each trigger
const stateStim% := 10;
const stateBlack% := 1;
const stateGray% := 2;
const stateWhite% := 3;
const stateRepeatDone% := 4;
const stateBlockDone% := 5;
const stateStimDone% := 6;
var state% := stateStim%;
' When nCountBlocks% = nBlocks%  and nCountRepeats% = nRepeats% then the stimulus has run its course. 

func IdleProcessing%()
	var istatus% := 1;
	var loopDone% := 0;
	var iNextState% := 0;

	' Look for trigger. Each trigger leads to a transition FROM the current state. The state% indicates what state the stim was in prior to the trigger. 
	tTrigger := View(hDataWindow%).NextTime(TriggerChannel%, tTriggerLast);
	if tTrigger > 0 then
		iCycle% += 1;
		iNextState% := iCycle% mod nFlash%;

		docase
			case state% = stateStim% then
				PrintLog("iCycle %d nFlash %d iNextState %d\n", iCycle%, nFlash%, iNextState%);
			case state% = stateGray% then

				PrintLog("exiting stateGray\n");
				HandleBackgroundSpikes(tTriggerLast, tTrigger);
				state% := iNextState%;
				loopDone% := 1;

			case state% = stateWhite% then

				PrintLog("exiting stateWhite\n");
				'HandleWhiteSpikes(tTriggerLast, tTrigger);
				state% := iNextState%;
				loopDone% := 1;

			case state% = stateBlack% then

				PrintLog("exiting stateBlack\n");
				HandleSpikes(tTriggerLast);
				state% := iNextState%;					

			case state% = stateStimDone% then

				PrintLog("Stopping stim\n");
				Stop%();
				istatus% := 0;
				loopDone% := 1;

			else
				PrintLog("Unknown state (" + str$(state%) + ")!\n");
				loopDone% := 1;

		endcase;		

		tTriggerLast := tTrigger;
	endif 	' if tTrigger > 0
	return istatus%;

end

proc HandleSpikes(trigger)

	View(hHistWindow%).Process(trigger, 0, 0, 1);

end

proc HandleBackgroundSpikes(tstart, tstop)

	var c;
	c := View(hDataWindow%).Count(1, tstart, tstop);

	bgTotalCounts += c;
	bgTotalTime += (tstop - tstart);

	if (bgTotalTime > 0) then
		View(hHistWindow%);
		HCursor(hHistCursor%, bgTotalCounts/bgTotalTime);
	endif
end
